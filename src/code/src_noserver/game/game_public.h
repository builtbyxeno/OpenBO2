#pragma once

#include "types.h"

//t6/code/src_noserver/game/actor.cpp
void TRACK_actor();
void VisCache_Update(vis_cache_t *pCache, bool bVisible);
void SentientInfo_Clear(sentient_info_t *pInfo);
int Actor_droptofloor(unsigned int a1, gentity_t *ent);
void Actor_DropPointToFloor(vec3_t *point);
void G_InitActors();
int G_GetActorIndex(actor_t *actor);
XAnimTree_s *G_GetActorAnimTree(actor_t *actor);
void Actor_FinishSpawning(actor_t *self);
void Actor_InitAnimScript(actor_t *self);
actor_t *Actor_FirstActor(const int iTeamFlags);
actor_t *Actor_NextActor(actor_t *pPrevActor, const int iTeamFlags);
int Actor_NumFreeActors();
int Actor_NumActors(const int iTeamFlags);
void Actor_ClearArrivalPos(actor_t *self);
int Actor_UpdateActorInfo(gentity_t *ent);
void SV_UpdateMoverRecord(gentity_t *self);
void Spawner_Think(gentity_t *ent);
void Actor_Touch(gentity_t *self, gentity_t *other);
bool Actor_InScriptedState(const actor_t *self);
void Actor_Die(gentity_t *self, gentity_t *pInflictor, gentity_t *pAttacker, int iDamage, int iMod, Weapon iWeapon, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset);
bool Actor_IsDying(const actor_t *self);
BOOL usingCodeGoal(actor_t *actor);
void Actor_DebugDrawNodesInVolume(actor_t *self, const char *a2);
gentity_t *Actor_GetTargetEntity(actor_t *self);
sentient_t *Actor_GetTargetSentient(actor_t *self);
char Actor_AllSecondaryTargetsForward(const actor_t *self);
void Actor_GetTargetPosition(actor_t *self, vec3_t *position);
void Actor_GetTargetLookPosition(actor_t *self, vec3_t *position);
gentity_t *Actor_GetScriptTargetEntity(actor_t *self);
BOOL Actor_IsDodgeEntity(actor_t *self, int entnum);
int Actor_Physics_GetLeftOrRightDodge(actor_t *self, bool dodgeRight, float length);
void Actor_PhysicsRestoreInputs(actor_t *self, PhysicsInputs *inputs);
float Actor_CalcultatePlayerPushDelta(const actor_t *self, const gentity_t *pusher, vec2_t *pushDir);
bool Actor_ShouldMoveAwayFromCloseEnt(actor_t *self);
void actor_controller(const gentity_t *self, int *partBits);
bool Actor_PointNear(const vec3_t *vPoint, const vec3_t *vGoalPos);
bool Actor_PointNearNode(const vec3_t *vPoint, const pathnode_t *node);
bool Actor_PointNearClaimNode(const actor_t *self, const vec3_t *vPoint);
bool Actor_PointAtGoal(const vec3_t *vPoint, const actor_goal_s *goal);
bool Actor_PointNearPoint(const vec3_t *vPoint, const vec3_t *vGoalPos, float buffer);
bool Actor_PointNearPointSqDist(const vec3_t *vPoint, const vec3_t *vGoalPos, float bufferSq);
bool Actor_PointAt(const vec3_t *vPoint, const vec3_t *vGoalPos);
bool Actor_ExitingClaimNode(actor_t *self);
void Actor_HandleInvalidPath(actor_t *self, vec3_t goal);
void Actor_GetNodeOffset(actor_t *self, const pathnode_t *node);
bool Actor_ShouldHoldGroundAgainstEnemy(actor_t *self);
bool Actor_EnemyInPathFightDist(actor_t *self, sentient_t *enemy);
gentity_t *Actor_IsKnownEnemyInRegion(const actor_t *self, const gentity_t *volume, const vec3_t *position, float radius);
bool Actor_HasPath(actor_t *self);
BOOL Actor_HadPath(actor_t *self);
void Actor_InitPath(actor_t *self);
void Actor_ClearPath(actor_t *self);
void Actor_GetAnimDeltas(actor_t *self, vec2_t *rotation, char *translation, vec3_t *a4);
BOOL Actor_IsMovingToMeleeAttack(actor_t *self);
bool Actor_SkipPathEndActions(actor_t *self);
void Actor_PathEndActions(actor_t *self);
void Actor_SimulateChildrenPhysics(actor_t *self);
BOOL Actor_AtClaimNode(actor_t *self);
BOOL Actor_AtClaimNodeAndAngle(actor_t *self);
BOOL Actor_NearClaimNode(actor_t *self, float dist);
int Actor_IsValidClaimNode(actor_t *self, const pathnode_t *node);
void Actor_PredictAnim(actor_t *self);
BOOL Actor_UseChokePoints(actor_t *self);
void Actor_CheckCollisions(actor_t *self);
void Actor_ClearPileUp(actor_t *self);
void Actor_ClipPathToGoal(actor_t *self);
void Actor_BeginTrimPath(actor_t *self);
int Actor_TrimPathToAttack(actor_t *self);
BOOL Actor_MayReacquireMove(actor_t *self);
void Actor_ClearMoveHistory(actor_t *self);
void Actor_GetMoveHistoryAverage(actor_t *self, vec3_t *vDir);
void Actor_UpdateMoveHistory(actor_t *self);
void Path_UpdateLeanAmount(actor_t *self, vec2_t *vWishDir);
float Path_UpdateMomentum(actor_t *self, vec2_t *vWishDir, float fMoveDist);
void Path_UpdateMovementDelta(actor_t *self, float fMoveDist);
void Actor_AddStationaryMoveHistory(actor_t *self);
BOOL Actor_IsMoving(actor_t *self);
void Actor_SetFlashed(actor_t *self, int flashed, float strength);
void Actor_SetGoalRadius(actor_goal_s *goal, float radius);
void Actor_SetGoalHeight(actor_goal_s *goal, float height);
bool Actor_IsInsideArc(actor_t *self, const vec3_t *origin, float radius, float angle0, float angle1, float halfHeight);
void SentientInfo_Copy(actor_t *pTo, const actor_t *pFrom, int index);
void Actor_InitActorState(gentity_t *ent);
actor_t *Actor_Alloc();
void Actor_Free(actor_t *actor);
void Actor_FreeExpendable();
void Actor_FinishSpawningAll(bool bRestart);
void Actor_DissociateSentient(actor_t *self, sentient_t *other);
void Actor_NodeClaimRevoked(actor_t *self, int invalidTime);
void Actor_CheckClearNodeClaimCloseEnt(actor_t *selfa);
char Actor_KeepClaimedNode(actor_t *self, const vec3_t *a2);
void Actor_ClearKeepClaimedNode(actor_t *self);
void Actor_CheckNodeClaim(actor_t *self);
void Actor_PreThink(actor_t *self);
void Actor_UpdatePlayerPush(actor_t *self, gentity_t *player);
void Actor_UpdateCloseEnt(actor_t *self);
actor_think_result_t Actor_CallThink(actor_t *self);
void Actor_UpdatePathNodes(actor_t *self);
void Actor_Pain(gentity_t *self, gentity_t *pAttacker, int iDamage, const vec3_t *vPoint, const int iMod, const vec3_t *vDir, const hitLocation_t hitLoc, const Weapon weapon);
void Actor_EntInfo(const char *a1, gentity_t *self, vec3_t *source);
int Actor_MoveAwayNoWorse(actor_t *self);
int Actor_PhysicsCheckMoveAwayNoWorse(actor_t *self, gentity_t *other, int flags, float distanceSqrd, float lengthSqrd, float lengthSqrda);
int Actor_PhysicsMoveAway(actor_t *self);
bool Actor_IsAtScriptGoal(actor_t *self, const vec3_t *a2);
bool Actor_ShouldKeepClaimedNode(actor_t *self);
bool Actor_IsNearClaimedNode(actor_t *self);
void Actor_ResetLookahead(actor_t *self);
pathnode_t *Actor_FindClaimedNode(actor_t *self);
bool Actor_IsAlongPath(actor_t *self, vec2_t *origin, vec2_t *pathPoint);
bool Actor_CheckStopOnGoalChange(actor_t *self, checkStopParams_t *params);
bool Actor_IsFixedNodeUseable(actor_t *self);
bool Actor_FindPath(actor_t *self, vec3_t *vGoalPos, pathnode_t *pGoalNode, int bAllowNegotiationLinks, int ignoreSuppression);
void Actor_RecalcPath(actor_t *self);
bool Actor_FindPathToNode(actor_t *self, pathnode_t *pGoalNode, int bSuppressable, int bIgnoreBadplaces);
bool Actor_FindPathToSentient(actor_t *self, sentient_t *pGoalEnt, int bSuppressable);
void Actor_FindPathInGoalWithLOS(actor_t *self, const vec3_t *vGoalPos, float fWithinDistSqrd, bool ignoreSuppression);
void Actor_BadPlacesChanged();
void Actor_UpdateAnglesAndDelta(actor_t *self);
void Actor_UpdatePileUp(actor_t *self);
void Actor_UpdateGoalPos(actor_t *self);
void Actor_ClearUseEnemyGoal(actor_t *self);
bool Actor_CheckGoalNotify(actor_t *self);
void Actor_CheckNotify(actor_t *self);
void Actor_Think(gentity_t *self);
int Actor_PhysicsAndDodge(actor_t *self, char *a2);
void Actor_DoMove(actor_t *self);
bool Actor_IsAtGoal(actor_t *self, const vec3_t *a2);
bool Actor_FindPathToGoalDirectInternal(actor_t *self);
void Actor_FindPathToGoalDirect(actor_t *self);
bool Actor_FindPathToClaimNode(actor_t *self, pathnode_t *node, int allowNegotiationLinks, int ignoreSuppression);
bool Actor_CheckStop(actor_t *self, int canUseEnemyGoal, pathnode_t *node);
void Actor_TryPathToArrivalPos(actor_t *self);
void Actor_FindPathToFixedNode(actor_t *self);
bool Actor_SetupFindPathToGoal(actor_t *self, int *canUseEnemyGoal);
bool Actor_TryPathToNode(actor_t *self, pathnode_t *node);
void Actor_FindPathToGoal(actor_t *self, char *a2);
void Actor_FixedLinkPhysicsFallback(actor_t *self, vec3_t *targetOrigin);
void Actor_UpdateOriginAndAngles(actor_t *self, char *a2);
void Actor_PredictOriginAndAngles(actor_t *self);
void Actor_PostThink(actor_t *self);
void Actor_InitMove(actor_t *self);
int SP_actor(gentity_t *ent, SpawnVar *spawnVar);

//t6/code/src_noserver/game/actor_aim.cpp
void Actor_FillWeaponParms(actor_t *self, weaponParms *wp);
gentity_t *Actor_Melee(actor_t *self, const vec3_t *direction, const vec3_t *offset);

//t6/code/src_noserver/game/actor_animapi.cpp
void Actor_InitAnim(actor_t *self);
BOOL Actor_IsAnimScriptAlive(actor_t *self);
void Actor_KillAnimScript(actor_t *self);
void Actor_SetMoveMode(actor_t *self, unsigned __int8 moveMode);
void Actor_SetAnimScript(actor_t *self, scr_animscript_t *pAnimScriptFunc, unsigned __int8 moveMode, ai_animmode_t animMode, scriptAnimAIFunctionTypes_t animScript);
void Actor_AnimMoveAway(actor_t *self, scr_animscript_t *pAnimScriptFunc);
void Actor_AnimStop(actor_t *self, scr_animscript_t *pAnimScriptFunc);
void Actor_AnimStopOrCombat(actor_t *self);
scr_animscript_t *Actor_GetStopAnim(actor_t *self);
void Actor_AnimTryWalk(actor_t *self, scr_animscript_t *a2);
void Actor_AnimTryRun(actor_t *self, scr_animscript_t *a2);
void Actor_AnimCombat(actor_t *self);
void Actor_AnimPain(actor_t *self);
void Actor_AnimDeath(actor_t *self);
void Actor_AnimSpecific(actor_t *self, scr_animscript_t *func, ai_animmode_t eAnimMode, bool bUseGoalWeight);
void Actor_AnimScripted(actor_t *self);
void Actor_AnimSetCompleteGoalWeight(XAnimTree_s *tree, unsigned int animIndex, float goalWeight, float goalTime, float rate, unsigned int notifyName, unsigned int notifyType, int bRestart);

//t6/code/src_noserver/game/actor_animscripted.cpp
char Actor_ScriptedAnim_Start(actor_t *self, ai_state_t ePrevState);
void Actor_ScriptedAnim_Finish(actor_t *self, ai_state_t eNextState);
int Actor_ScriptedAnim_Think(actor_t *self);
char Actor_CustomAnim_Start(actor_t *self, ai_state_t ePrevState);
int Actor_CustomAnim_Think(actor_t *self);

//t6/code/src_noserver/game/actor_badplace.cpp
void TRACK_actor_badplace();
void Path_UpdateBadPlaceCount(badplace_t *place, int delta);
badplace_t *Path_AllocBadPlace(unsigned int name, int duration, badplace_parms_t *params);
char Path_CheckLineSegmentIntersectsAnyBadPlaceCylinder(const vec3_t *start, const vec3_t *end, int teamflags);
void Path_MakeBadPlaceEx(unsigned int name, int duration, int teamflags, int type, badplace_parms_t *parms);
void Path_DrawBadPlaces();
void Path_InitBadPlaces();
void Path_ShutdownBadPlaces();
char Actor_IsInAnyBadPlace(actor_t *self);
actor_t *Actor_BadPlace_UpdateFleeingActors(unsigned int a1);
void Actor_BadPlace_GetMaximumFleeRadius();
bool Actor_BadPlace_HasPotentialNodeDuplicates(pathsort_t *potentialNodes, int potentialNodeCount, pathnode_t *checkNode);
int Actor_BadPlace_IsPointInAnyBadPlace(const vec3_t *a1, vec3_t *point);
char Actor_BadPlace_IsNodeInAnyBadPlace(pathnode_t *node);
pathnode_t *Actor_BadPlace_FindSafeNodeAlongPath(actor_t *self);
void __cdecl Path_UpdateBadPlaces();
int Actor_BadPlace_FindSafeNodeOutsideBadPlace(actor_t *self, pathsort_t *potentialNodes, float maxFleeDist);
bool Actor_BadPlace_AttemptEscape(actor_t *self);
bool Actor_BadPlace_Flee_Start(actor_t *self, ai_state_t ePrevState);
int Actor_BadPlace_Flee_Think(actor_t *self);

//t6/code/src_noserver/game/actor_bigdog_exposed.cpp
char Actor_BigDog_Exposed_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Dog_Exposed_Finish(actor_t *self, ai_state_t eNextState);
void Actor_BigDog_Attack(actor_t *self);
actor_think_result_t Actor_BigDog_Exposed_Think(actor_t *self);

//t6/code/src_noserver/game/actor_corpse.cpp
int G_GetActorCorpseIndex(gentity_t *ent);
int G_GetFreeActorCorpseIndex(int reuse);
void G_RemoveOneActorCorpse();
void G_RemoveAllActorCorpses();
void G_RemoveActorCorpses(int allowedCorpseCount);
void G_UpdateActorCorpses(int a1);
void ActorCorpse_Free(gentity_t *ent);
float Actor_SetBodyPlantAngle(const int iEntNum, const vec3_t *vOrigin);
void Actor_GetBodyPlantAngles(int iEntNum, int iClipMask, const vec3_t *vOrigin, const float fYaw, float *pfPitch, float *pfRoll, float *pfHeight);
void Actor_OrientCorpseToGround(gentity_t *self, int bLerp);
void Actor_OrientPitchToGround(gentity_t *self, int bLerp);
int Actor_BecomeCorpse(gentity_t *self);

//t6/code/src_noserver/game/actor_death.cpp
char Actor_Death_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Death_Cleanup(actor_t *self);
int Actor_Death_Think(actor_t *self, int a2);

//t6/code/src_noserver/game/actor_dog_exposed.cpp
char Actor_Dog_Exposed_Start(actor_t *self, ai_state_t ePrevState);
int Actor_Dog_IsInSyncedMelee(actor_t *self, sentient_t *enemy);
void Actor_Dog_Attack(actor_t *self);
void Actor_FindPathToGoalNearestNode(actor_t *self);
void Actor_UpdateMeleeGoalPos(actor_t *self, const vec3_t *goalPos);
bool Actor_Dog_IsTurnScriptRunning(actor_t *self);
float Actor_Dog_GetEnemyPos(actor_t *self, sentient_t *enemy, vec3_t *enemyPos);
char Actor_Dog_ObstacleInPath(int a1);
double Actor_Dog_GetDeltaTurnYaw(actor_t *self);
bool Actor_Dog_ShouldTurn(actor_t *self);
void Actor_Dog_PredictPosition(const gentity_t *ent, vec3_t *vPos);
bool Actor_Dog_ShouldAttack(const actor_t *self, const sentient_t *enemy);
bool Actor_SetMeleeAttackSpot(actor_t *self, vec3_t *attackPosition);
int Actor_Dog_IsEnemyInAttackRange(actor_t *self, sentient_t *enemy, int *goalPosSet);
actor_think_result_t Actor_Dog_Exposed_Think(actor_t *self);

//t6/code/src_noserver/game/actor_events.cpp
double Actor_EventDefaultRadiusSqrd(ai_event_t eType);
void Actor_DumpEvents(actor_t *self, ai_event_t event, gentity_t *originator);
void Actor_WasAttackedBy(actor_t *self, sentient_t *pOther);
bool Actor_IsOnSameTeam(gentity_t *originator, actor_t *pActor, int teamFlags);
void Actor_EventFootstep(actor_t *self, sentient_t *originator, const vec3_t *vOrigin);
void Actor_EventNewEnemy(actor_t *self, sentient_t *originator);
void Actor_EventPain(actor_t *self, sentient_t *pCasualty, sentient_t *pAttacker);
void Actor_EventDeath(actor_t *self, sentient_t *pCasualty, sentient_t *pAttacker);
void Actor_EventExplosion(actor_t *self, gentity_t *originator, const vec3_t *vOrigin);
void Actor_EventGrenadePing(actor_t *self, gentity_t *originator);
void Actor_EventGunshot(actor_t *self, sentient_t *originator, const vec3_t *vOrigin);
void Actor_EventBullet(actor_t *self, gentity_t *originator, const vec3_t *vStart, const vec3_t *vEnd, const vec3_t *vClosest, float fDistSqrd, float fRadiusSqrd, PARM_SUPPRESSION suppression);
bool Actor_ShouldKnowAboutPainDeathEvent(actor_t *self, gentity_t *originator, const vec3_t *vOrigin);
void Actor_ReceivePointEvent(actor_t *self, gentity_t *originator, ai_event_t eType, const vec3_t *vOrigin, float fDistSqrd, float fRadiusSqrd);
void Actor_ReceiveLineEvent(actor_t *self, gentity_t *originator, gentity_t *hitEnt, ai_event_t eType, const vec3_t *vStart, const vec3_t *vEnd, const vec3_t *vClosest, float fDistSqrd, float fRadiusSqrd);
void Actor_BroadcastPointEvent(gentity_t *originator, ai_event_t eType, int teamFlags, const vec3_t *vOrigin, float fRadiusSqrd);
void Actor_BroadcastLineEvent(gentity_t *originator, gentity_t *hitEnt, ai_event_t eType, int teamFlags, const vec3_t *vStart, const vec3_t *vEnd, float fRadiusSqrd);
void Actor_BroadcastTeamEvent(sentient_t *sentient, ai_event_t eType);

//t6/code/src_noserver/game/actor_event_listeners.cpp
void TRACK_actor_event_listener();
void Actor_EventListener_RemoveEntity(int entIndex);
int Actor_EventListener_Next(int index, ai_event_t event, int teamFlags);
gentity_t *Actor_EventListener_GetEntity(int index);
void Actor_EventListener_NotifyToListener(gentity_t *listener, gentity_t *originator, ai_event_t event, const vec3_t *position);
int Actor_EventListener_First(ai_event_t event, int teamFlags);

//t6/code/src_noserver/game/actor_exposed.cpp
void Actor_Exposed_CheckLockGoal(actor_t *self);
void Actor_Exposed_Combat(actor_t *self);
char Actor_Exposed_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Exposed_Finish(actor_t *self, ai_state_t eNextState);
bool Actor_Exposed_Resume(actor_t *self, ai_state_t ePrevState);
void Actor_Exposed_Reacquire_Move(actor_t *self, AI_MOVE_MODE moveMode);
void Actor_ReacquireDoneBehavior(actor_t *self);
bool Actor_Exposed_CheckStopMovingAndStartCombat(actor_t *self);
void Actor_Exposed_DecideSubState(actor_t *self);
void Actor_Exposed_FindReacquireNode(actor_t *self);
pathnode_t *Actor_Exposed_GetReacquireNode(actor_t *self);
char Actor_Exposed_UseReacquireNode(actor_t *self, pathnode_t *pNode);
BOOL Actor_IsDoingReacquire(actor_t *self);
char Actor_Exposed_ReacquireStepMove(actor_t *self, float fDist);
void Actor_Exposed_FindReacquireDirectPath(actor_t *self, bool ignoreSuppression);
void Actor_Exposed_FindReacquireProximatePath(actor_t *self, bool ignoreSuppression);
char Actor_Exposed_StartReacquireMove(actor_t *self);
void Actor_Exposed_MoveToGoal_Move(actor_t *self);
bool Actor_Exposed_IsShortMove(actor_t *self);
void Actor_Exposed_NonCombat_Anim(actor_t *self);
void Actor_Exposed_NonCombat_Think(actor_t *self);
void Actor_Exposed_FlashBanged(actor_t *self);
void Actor_Exposed_Reaction(actor_t *self);
actor_think_result_t Actor_Exposed_Think(actor_t *self, char *a2);
void Actor_Exposed_Touch(actor_t *self, gentity_t *pOther);

//t6/code/src_noserver/game/actor_fields.cpp
unsigned __int8 *BaseForFields(actor_t *actor, const actor_fields_s *fields);
const actor_fields_s *FindFieldForName(const actor_fields_s *fields, const char *pszFieldName);
void ActorScr_SetSpecies(actor_t *pSelf);
void ActorScr_GetSpecies(actor_t *pSelf);
void ActorScr_GetStairsState(actor_t *pSelf);
void ActorScr_GetIsDog(actor_t *pSelf);
void ActorScr_GetIsBigDog(actor_t *pSelf);
void ActorScr_Clamp_0_1(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_Clamp_0_Positive(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetSqr(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetSqrt(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_ReadOnly(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetGoalRadius(actor_t *pSelf);
void ActorScr_SetGoalHeight(actor_t *pSelf);
void ActorScr_SetTime(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetTime(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetAlertLevel(actor_t *pSelf);
void ActorScr_GetAlertLevel(actor_t *pSelf);
void ActorScr_SetCombatMode(actor_t *pSelf);
void ActorScr_GetCombatMode(actor_t *pSelf);
void ActorScr_GetGroundType(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetIgnoreTriggerBit(actor_t *pSelf);
void ActorScr_GetIgnoreTriggerBit(actor_t *pSelf);
void ActorScr_SetPushableBit(actor_t *pSelf);
void ActorScr_GetPushableBit(actor_t *pSelf);
void ActorScr_SetNoPlayerMeleeBloodBit(actor_t *pSelf);
void ActorScr_GetNoPlayerMeleeBloodBit(actor_t *pSelf);
void ActorScr_SetIkPriorityBit(actor_t *pSelf);
void ActorScr_GetIkPriorityBit(actor_t *pSelf);
void ActorScr_SetLastEnemySightPos(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetLastEnemySightPos(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetPathGoalPos(actor_t *self, const actor_fields_s *field);
void ActorScr_GetPathStartPos(actor_t *self, const actor_fields_s *field);
void ActorScr_SetFixedNode(actor_t *self, const actor_fields_s *field);
void ActorScr_GetMoveMode(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetPathRandomPercent(actor_t *self, const actor_fields_s *field);
void ActorScr_GetLookaheadNextNodePos(actor_t *pSelf);
void PrintFieldUsage(const actor_fields_s *fields);
void Cmd_AI_PrintUsage();
void Cmd_AI_DisplayInfo(actor_t *actor);
void Cmd_AI_Delete(actor_t *actor);
void Cmd_AI_DisplayValue(actor_t *pSelf, unsigned __int8 *pBase, const actor_fields_s *pField);
void Cmd_AI_SetValue(actor_t *pSelf, int argc, unsigned __int8 *pBase, const actor_fields_s *pField);
void Cmd_AI_Dispatch(int argc, actor_t *pSelf, const actor_fields_s *fields, const actor_fields_s *pField);
void Cmd_AI_EntityNumber(int argc, const actor_fields_s *fields, const actor_fields_s *pField, const char *szNum, int bInvertSelection);
void Cmd_AI_Team(int argc, const actor_fields_s *fields, const actor_fields_s *pField, int iTeamFlags, int bInvertSelection);
void Cmd_AI_Name(int argc, const actor_fields_s *fields, const actor_fields_s *pField, const char *szName, int bInvertSelection);
void Cmd_AI_f(char *a1);
void GScr_AddFieldsForActor();
void Scr_SetActorField(const char *a1, actor_t *actor, int offset);
void Scr_GetActorField(actor_t *actor, int offset);

//t6/code/src_noserver/game/actor_generic.cpp
void Actor_Generic_Suspend(actor_t *self, ai_state_t eNextState);
int Actor_Generic_Resume(actor_t *self, ai_state_t ePrevState);
void Actor_Generic_Pain(bdLobbyEventHandler *notthis, unsigned __int64 __formal, const char *vPoint, void *iMod, unsigned int vDir);
void Actor_Generic_Touch(actor_t *self, gentity_t *pOther);

//t6/code/src_noserver/game/actor_lookat.cpp
void Actor_InitLookAt(actor_t *self);
void Actor_SetLookAtAnimNodes(actor_t *self, unsigned __int16 animStraight, unsigned __int16 animLeft, unsigned __int16 animRight);
void Actor_SetLookAt(actor_t *self, const vec3_t *vPosition, float fTurnAccel);
void Actor_SetLookAtYawLimits(actor_t *self, float fAnimYawLimit, float fYawLimit, float fBlendTime);
void Actor_StopLookAt(actor_t *self, float fTurnAccel);
void Actor_UpdateLookAt(actor_t *self);

//t6/code/src_noserver/game/actor_navigation.cpp
float Path_GetPathDir(vec2_t *delta, const vec2_t *vFrom, const vec2_t *vTo);
void Path_IncrementNodeUserCount(path_t *pPath);
void Path_DecrementNodeUserCount(path_t *pPath);
void Path_Backup(const path_t *path);
float Path_GetDistToPathSegment(const vec2_t *vStartPos, const pathpoint_t *pt);
BOOL Path_LookaheadNeedsReset(path_t *pPath);
void Path_AddTrimmedAmount(path_t *pPath, const vec3_t *vStartPos);
void Path_SubtractTrimmedAmount(const vec3_t *vStartPos, float pPath, path_t *pPatha, const vec3_t *vStartPosa);
void Path_SetLookaheadToStart(path_t *pPath, const vec3_t *vStartPos, int bTrimAmount);
bool Path_NearDangerousNode(const pathnode_t *pNode, const team_t team);
void Path_SmoothPath(pathnode_t *pNodeFrom, pathnode_t *pNodeTo, team_t team);
bool Path_NodeOccupiedByOther(int searchEntNum, const pathnode_t *node);
BOOL Path_CheckFromAndToNodesNoHeightCheck(PathFindInput *pathFindInput);
int Path_CheckFromAndToNodes(PathFindInput *pathFindInput, PathBlockPlanes *blockPlanes);
// void CustomSearchInfo_FindPath::CustomSearchInfo_FindPath(CustomSearchInfo_FindPath *notthis, int randomPercent, int useChokePoints);
void Path_InitFindInput(PathFindInput *pathFindInput, actor_t *actor);
int Path_GetPathRandomness(PathFindInput *pathFindInput);
void Path_TrimLastNodes(path_t *pPath, const int iNodeCount, bool bMaintainGoalPos);
int Path_ClipToGoal(path_t *pPath, const actor_goal_s *goal);
void Path_BeginTrim(path_t *pPath, path_trim_t *pTrim);
int Path_TrimToSeePoint(path_t *pPath, path_trim_t *pTrim, actor_t *pActor, float fMaxDistSqrd, int iIgnoreEntityNum, const vec3_t *vPoint);
void Path_Begin(path_t *pPath);
void Path_Clear(path_t *pPath);
BOOL Path_Exists(const path_t *pPath);
int Path_CompleteLookahead(const path_t *pPath);
unsigned int Path_AttemptedCompleteLookahead(const path_t *pPath);
BOOL Path_UsesObstacleNegotiation(const path_t *pPath);
bool Path_HasNegotiationNode(const path_t *path);
unsigned int Path_AllowsObstacleNegotiation(const path_t *pPath);
void Path_GetObstacleNegotiationScript(const path_t *pPath, scr_animscript_t *animscript);
int Path_CurrentLinkDisconnected(const path_t *pPath);
bool Path_NeedsReevaluation(const path_t *pPath);
BOOL Path_GoingDown(const path_t *pPath);
int Path_DistanceGreaterThan(path_t *pPath, float fDist);
void Path_ReduceLookaheadAmount(path_t *pPath, float maxLookaheadAmountIfReduce);
BOOL Path_FailedLookahead(path_t *pPath);
void Path_IncreaseLookaheadAmount(path_t *pPath);
BOOL skip_avoidance_ents(int entnum);
BOOL Path_IsTrimmed(path_t *pPath);
void Path_RemoveCompletedPathPoints(path_t *pPath, int pathPointIndex);
void Path_TrimCompletedPath(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vStartPosa);
void Path_BackTrack(path_t *pPath, int newPathLength, float lookaheadIncreaseAmount);
void Path_BacktrackCompletedPath(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vStartPosa);
void PathCalcLookahead_CheckMinLookaheadNodes(path_t *pPath, const pathpoint_t *pt, int currentNode);
int Path_GetForwardStartPos(path_t *pPath, const vec2_t *vStartPos, vec2_t *vForwardStartPos);
void Path_DebugDraw(path_t *pPath, const vec3_t *vStartPos, clientDebugLineInfo_t *bDrawLookahead, int entId, int a5);
bool Path_WithinApproxDist(path_t *pPath, float checkDist);
ai_stance_e Path_AllowedStancesForPath(path_t *pPath);
void Path_CheckNodeCountForDodge(path_t *pPath, int numNeeded, pathpoint_t **pt, int *startIndex);
void Path_DodgeDrawRaisedLine(const vec3_t *start, const vec3_t *end, const vec4_t *color);
BOOL Path_MayFaceEnemy(path_t *pPath, vec3_t *vEnemyDir, vec3_t *vOrg);
double Path_GetStepHeightForRadius(const float radius);
void Path_TrimToBadPlaceLink(path_t *pPath, team_t eTeam, char *a3);
// double BotSearchInfo::GetNodeCost(BotSearchInfo *notthis, const pathnode_t *pSuccessor, const vec3_t *vGoalPos);
void Path_Restore(path_t *path);
int Path_FindPath(PathFindInput *pathFindInput, char *a2);
char Path_PredictionTrace(const vec3_t *vStartPos, const vec3_t *vEndPos, unsigned int entityIgnore, int mask, int vTraceEndPos, vec3_t *stepheight, float allowStartSolid, int radius, float height, float flying, int usingAvoidance, int a12);
int Path_PredictionTraceCheckForEntities(const vec3_t *vStartPos, const vec3_t *vEndPos, int a3, const int *entities, const int entityCount, int entityIgnore, int mask, vec3_t *vTraceEndPos);
int Path_LookaheadPredictionTrace(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vEndPos);
void Path_UpdateLookaheadAmount(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vLookaheadPos, int bReduceLookaheadAmount, float dist, int lookaheadNextNode, float maxLookaheadAmountIfReduce, int bAllowRestore);
void Path_CalcLookahead_Completed(path_t *pPath, const vec3_t *vStartPos, int bReduceLookaheadAmount, float totalArea, int bAllowRestore);
void Path_CalcLookahead(path_t *pPath, char *a2, int bReduceLookaheadAmount, int bAllowRestore, int bAllowRestorea);
void Path_UpdateLookahead(path_t *pPath, const vec3_t *vStartPos, int bReduceLookaheadAmount, int bTrimAmount, int bAllowBacktrack, int bAllowRestore);
void Path_TransferLookahead(path_t *pPath, const vec3_t *vStartPos);
BOOL Path_GeneratePath(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vGoalPos, pathnode_t *pNodeFrom, pathnode_t *pNodeTo, int bIncludeGoalPos, PathFindInput *pathFindInput);
void Path_UpdateLookahead_NonCodeMove(path_t *pPath, const vec3_t *vPrevPos, const vec3_t *vStartPos);
char Path_AttemptDodge(path_t *pPath, const vec3_t *vOrg, const vec3_t *vDodgeStart, const vec3_t *vDodgeEnd, int startIndex, const int *entities, const int entityCount, int entityIgnore, int mask, int bCheckLookahead);
pathnode_t *Path_FindCloseNode(team_t eTeam, pathnode_t *pNodeFrom, const vec3_t *vGoalPos);
int Path_FindPathWithWidth(PathFindInput *pathFindInput, float width, vec2_t *perp);
int Path_FindPathNotCrossPlanes(PathFindInput *pathFindInput, PathBlockPlanes *blockPlanes);
int Path_FindPathInCylinderWithLOS(PathFindInput *pathFindInput, const actor_goal_s *goal, float fWithinDistSqrd);
pathnode_t *Path_FindFacingNode(pathnode_t *node, sentient_t *pOther, sentient_info_t *pInfo);
int Path_FindPathGetCloseAsPossible(PathFindInput *pathFindInput, char *a2);
int Bot_FindPath(PathFindInput *pathFindInput, char *a2);

//t6/code/src_noserver/game/actor_negotiation.cpp
bool Actor_Negotiation_Start(actor_t *pSelf, ai_state_t ePrevState);
int Actor_Negotiation_Think(actor_t *pSelf);

//t6/code/src_noserver/game/actor_orientation.cpp
void Actor_SetDesiredBodyAngle(ai_orient_t *pOrient, const float fAngle);
void Actor_SetDesiredAngles(ai_orient_t *pOrient, const float fPitch, const float fYaw);
void Actor_SetLookAngles(actor_t *self, const float fPitch, const float fYaw);
void Actor_SetBodyAngle(actor_t *self, const float fAngle);
void Actor_ChangeAngles(actor_t *self, const float fPitch, const float fYaw);
void Actor_UpdateLookAngles(actor_t *self);
void StepYaw(float dt, float *yaw, float *yawVeloc, float targetYaw, float targetVeloc);
void Actor_UpdateBodyAngle(actor_t *self);
bool Actor_CheckGunBlockedByWallWhileMoving(actor_t *self, const vec3_t *predictedMovePos, const vec2_t *dir);
void Actor_FaceVectorSnapToMovementQuadrant(actor_t *self, ai_orient_t *pOrient, const vec3_t *lookAtPos, bool enemyVisible);
void Actor_FaceVector(ai_orient_t *pOrient, const vec3_t *v);
void Actor_FaceMotion(actor_t *self, ai_orient_t *pOrient);
void Actor_SetAnglesToLikelyEnemyPath(actor_t *self);
char Actor_GetAnglesToLikelyEnemyPath(actor_t *self);
void Actor_FaceLikelyEnemyPath(actor_t *self, ai_orient_t *pOrient);
void Actor_FaceEnemy(actor_t *self, ai_orient_t *pOrient);
bool Actor_ShouldFaceMotion(actor_t *self);
void Actor_FaceEnemyOrMotion(actor_t *self, ai_orient_t *pOrient);
void Actor_FaceEnemyOrMotionSidestep(actor_t *self, ai_orient_t *pOrient);
void Actor_DecideOrientation(actor_t *self, char *a2);
void Actor_SetOrientMode(actor_t *self, ai_orient_mode_t eMode);
void Actor_ClearScriptOrient(actor_t *self);

//t6/code/src_noserver/game/actor_pain.cpp
bool Actor_InPain(const actor_t *self);
char Actor_Pain_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Pain_Finish(actor_t *self, ai_state_t eNextState);
int Actor_Pain_Think(actor_t *self);

//t6/code/src_noserver/game/actor_physics.cpp
void TRACK_actor_physics();
void AIPhys_AddTouchEnt(actor_physics_t *pPhys, int entityNum);
void AIPhys_ClipVelocity(const vec3_t *in, const vec3_t *normal, bool isWalkable, vec3_t *out, float overbounce);
void setup_gjkcc_input(actor_physics_t *pPhys, gjkcc_input_t *gjkcc_in);
void AIPhys_Footsteps(actor_physics_t *pPhys);
void ai_physics_trace(trace_t *trace, const vec3_t *start, const vec3_t *mins, const vec3_t *maxs, const vec3_t *end, const int passEntityNum, const int contentmask, actor_physics_t *pPhys);
// void ai_gjk_slide_move_input_t::custom_process(ai_gjk_slide_move_input_t *notthis, int a2, gjk_trace_output_t *gto);
void AIPhys_GroundTrace(actor_physics_t *pPhys);
void AIPhys_FoliageSounds(unsigned int a1, actor_physics_t *pPhys);
void Actor_PostPhysics(actor_physics_t *pPhys);
SlideMoveResult AIPhys_SlideMove(actor_physics_t *pPhys);
void AdjustBigDog(int a1, actor_physics_t *pPhys);
int AIPhys_StepSlideMove(actor_physics_t *pPhys);
int AIPhys_AirMove(actor_physics_t *pPhys);
int AIPhys_WalkMove(actor_physics_t *pPhys);
int Actor_Physics_1(actor_physics_t *pPhys);
int Actor_Physics(actor_physics_t *pPhys);
int Actor_Physics_z(actor_physics_t *pPhys);
void setup_gjkcc_input(pmove_t *pm, gjkcc_input_t *gjkcc_in);
void setup_gjkcc_input(pmove_t *pm, const VehicleDef *vehDef, VehicleState *vehicleState, gjkcc_input_t *gjkcc_in, gjccc_create_t *gjkcc_create);

//t6/code/src_noserver/game/actor_script_cmd.cpp
actor_t *Actor_Get(scr_entref_t entref);
void Actor_SetScriptGoalPos(actor_t *self, vec3_t *vGoalPos, pathnode_t *node, vec3_t *ang);
void Actor_StartArrivalState(actor_t *self, ai_state_t newState);
void ActorCmd_StartCoverArrival(scr_entref_t entref);
void ActorCmd_StartTraverseArrival(scr_entref_t entref);
void ActorCmd_Melee(scr_entref_t entref);
void ActorCmd_MeleeWithOffset(scr_entref_t entref);
void ActorCmd_ReacquireStep(scr_entref_t entref);
void ActorCmd_FindReacquireNode(scr_entref_t entref);
void ActorCmd_GetReacquireNode(scr_entref_t entref);
void ActorCmd_UseReacquireNode(scr_entref_t entref);
void ActorCmd_FindReacquireDirectPath(scr_entref_t entref);
void ActorCmd_FindReacquireProximatePath(scr_entref_t entref);
void ActorCmd_TrimPathToAttack(scr_entref_t entref);
void ActorCmd_ReacquireMove(scr_entref_t entref);
void ActorCmd_FlagEnemyUnattackable(scr_entref_t entref);
void ActorCmd_ClearPitchOrient(scr_entref_t entref);
void ActorCmd_SetPitchOrient(scr_entref_t entref);
void ActorCmd_SetLookAtAnimNodes(scr_entref_t entref);
void ActorCmd_SetLookAt(scr_entref_t entref);
void ActorCmd_SetLookAtYawLimits(scr_entref_t entref);
void ActorCmd_StopLookAt(scr_entref_t entref);
void ActorCmd_CanSee(scr_entref_t entref);
void ActorCmd_SeeRecently(scr_entref_t entref);
void ActorCmd_LastKnownTime(scr_entref_t entref);
void ActorCmd_LastKnownPos(scr_entref_t entref);
void ActorCmd_Teleport(scr_entref_t entref);
void ActorCmd_ForceTeleport(scr_entref_t entref);
void ActorCmd_WithinApproxPathDist(scr_entref_t entref);
void ActorCmd_IsPathDirect(scr_entref_t entref);
void ActorCmd_AllowedStances(scr_entref_t entref);
void ActorCmd_IsStanceAllowed(scr_entref_t entref);
void ActorCmd_Knockback(scr_entref_t entref);
void ActorCmd_TraverseMode(scr_entref_t entref);
void ActorCmd_AnimMode(scr_entref_t entref);
void ActorCmd_OrientMode(scr_entref_t entref);
void ActorCmd_GetOrientMode(scr_entref_t entref);
void ActorCmd_GetMotionAngle(scr_entref_t entref);
void ActorCmd_ShouldFaceMotion(scr_entref_t entref);
void ActorCmd_ClearMoveHistory(scr_entref_t entref);
void ActorCmd_GetMoveHistoryAverage(scr_entref_t entref);
void ActorCmd_GetAnglesToLikelyEnemyPath(scr_entref_t entref);
void ActorCmd_LerpPosition(scr_entref_t entref);
void ActorCmd_PredictOriginAndAngles(scr_entref_t entref);
void ActorCmd_PredictAnim(scr_entref_t entref);
void ActorCmd_GetHitEntType(scr_entref_t entref);
void ActorCmd_GetHitYaw(scr_entref_t entref);
void ActorCmd_GetGroundEntType(scr_entref_t entref);
void ActorCmd_IsDeflected(scr_entref_t entref);
void ScrCmd_animcustom(scr_entref_t entref);
void ScrCmd_CanAttackEnemyNode(scr_entref_t entref);
void ScrCmd_CanSeePathGoal(scr_entref_t entref);
void ScrCmd_GetPathLength(scr_entref_t entref);
void ScrCmd_CalcPathLength(scr_entref_t entref);
void ScrCmd_GetNegotiationStartNode(scr_entref_t entref);
void ScrCmd_GetNegotiationEndNode(scr_entref_t entref);
void ActorCmd_CheckProne(scr_entref_t entref);
void ActorCmd_PushPlayer(scr_entref_t entref);
void Actor_SetScriptGoalVolume(actor_t *self, gentity_t *volume);
void ActorCmd_SetGoalNode(scr_entref_t entref);
void Actor_SetScriptGoalEntity(actor_t *self, gentity_t *pGoalEnt);
void ActorCmd_SetGoalPos(scr_entref_t entref);
void ActorCmd_SetGoalEntity(scr_entref_t entref);
void ActorCmd_SetGoalVolume(scr_entref_t entref);
void ActorCmd_SetGoalVolumeAuto(scr_entref_t entref);
void ActorCmd_GetGoalVolume(scr_entref_t entref);
void ActorCmd_ClearGoalVolume(scr_entref_t entref);
void ActorCmd_SetFixedNodeSafeVolume(scr_entref_t entref);
void ActorCmd_GetFixedNodeSafeVolume(scr_entref_t entref);
void ActorCmd_ClearFixedNodeSafeVolume(scr_entref_t entref);
void ActorCmd_IsInGoal(scr_entref_t entref);
void ActorCmd_SetOverrideRunToPos(scr_entref_t entref);
void ActorCmd_ClearOverrideRunToPos(scr_entref_t entref);
void ActorCmd_NearNode(scr_entref_t entref);
void ActorCmd_NearClaimNode(scr_entref_t entref);
void ActorCmd_NearClaimNodeAndAngle(scr_entref_t entref);
void ActorCmd_AtDangerousNode(scr_entref_t entref);
void ActorCmd_GetEnemyInfo(scr_entref_t entref);
void ActorCmd_ClearEnemy(scr_entref_t entref);
void ActorCmd_SetEntityTarget(scr_entref_t entref);
void ActorCmd_ClearEntityTarget(scr_entref_t entref);
void ActorCmd_SetPotentialThreat(scr_entref_t entref);
void ActorCmd_ClearPotentialThreat(scr_entref_t entref);
void ActorCmd_GetPerfectInfo(scr_entref_t entref);
void ActorCmd_SetFlashBanged(scr_entref_t entref);
void ActorCmd_SetFlashbangImmunity(scr_entref_t entref);
void ActorCmd_GetFlashBangedStrength(scr_entref_t entref);
void ActorCmd_IsKnownEnemyInRadius(scr_entref_t entref);
void ActorCmd_IsKnownEnemyInVolume(scr_entref_t entref);
void ActorCmd_SetTalkToSpecies(scr_entref_t entref);
void ActorCmd_AllowPitchAngle(scr_entref_t entref);
void ActorCmd_GetDeltaTurnYaw(scr_entref_t entref);
void ActorCmd_SetAnimState(scr_entref_t entref);
void ActorCmd_StartScriptedAnim(scr_entref_t entref);
void ActorCmd_PopAIState(scr_entref_t entref);
void ActorCmd_SetAimAnimWeights(scr_entref_t entref);
void ActorCmd_CalcLookaheadPos(scr_entref_t entref);
void ActorCmd_IsInScriptedState(scr_entref_t entref);
void ActorCmd_SetAnimStateFromASD(scr_entref_t entref);
void ActorCmd_HasAnimStateFromASD(scr_entref_t entref);
void ActorCmd_GetAnimStateFromASD(scr_entref_t entref);
void ActorCmd_GetAnimSubStateFromASD(scr_entref_t entref);
void ActorCmd_GetAnimSubStateCountFromASD(scr_entref_t entref);
void ActorCmd_GetAnimFromASD(scr_entref_t entref);
void ActorCmd_GetAnimLengthFromASD(scr_entref_t entref);
void ActorCmd_GetAnimHasNotetrackFromASD(scr_entref_t entref);
void ActorCmd_SetFreeCameraLockOnAllowed(scr_entref_t entref);
void (*Actor_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
int MayMove_TraceCheck(actor_t *self, const vec3_t *vEnd);
void ActorCmd_MayMoveToPoint(scr_entref_t entref);
void ActorCmd_MayMoveFromPointToPoint(scr_entref_t entref);
void ActorCmd_ClearEntityOwner(scr_entref_t entref);
void ActorCmd_SetEntityOwner(scr_entref_t entref);
void ActorCmd_finishActorDamage(scr_entref_t entref);

//t6/code/src_noserver/game/actor_senses.cpp
bool Actor_SightTrace(actor_t *self, const vec3_t *start, const vec3_t *end, int passEntNum);
bool Actor_CanSeePointFrom(actor_t *self, const vec3_t *vStart, const vec3_t *vEnd, float fMaxDistSqrd, int ignoreEntityNum);
void Actor_UpdateVisCache(actor_t *self, const gentity_t *ent, sentient_info_t *pInfo, bool bVisible);
bool Actor_ShouldDoFOVCheck(actor_t *self, sentient_t *sentient);
bool Actor_KnowAboutEnemy(actor_t *self);
int compare_sentient_sort(const void *pe1, const void *pe2);
void Actor_UpdateLastKnownPos(actor_t *self, sentient_t *other, const vec3_t *pos);
void Actor_UpdateLastEnemySightPos(actor_t *self);
void Actor_GetLastKnownEnemyPosWithDuration(actor_t *self, const gentity_t *enemy, int cheatDuration, vec3_t *lastKnownPos);
void Actor_GetLastKnownEnemyPos(actor_t *self, const gentity_t *enemy, vec3_t *lastKnownPos);
void Actor_UpdateEyeInformation(actor_t *self);
void Actor_GetEyePosition(actor_t *self, vec3_t *vEyePosOut);
void Actor_GetDebugEyePosition(actor_t *self, vec3_t *vEyePosOut);
void Actor_GetEyeDirection(actor_t *self, vec3_t *vEyeDir);
void Actor_GetEyeOffset(actor_t *self, vec3_t *vEyePosOut);
BOOL Actor_PointInFov(actor_t *self, const vec3_t *vPoint);
int Actor_GetMuzzleInfo(actor_t *self, vec3_t *vOrigin, vec3_t *vForward);
bool Actor_CanSeePointExInternal(actor_t *self, const vec3_t *vPoint, float fovDot, float fMaxDistSqrd, int ignoreEntityNum, vec3_t *vViewPos);
bool Actor_CanSeePointEx(actor_t *self, const vec3_t *vPoint, float fovDot, float fMaxDistSqrd, int ignoreEntityNum);
char Actor_CanSeeEntityEx(actor_t *self, const gentity_t *ent, float fovDot, float fMaxDistSqrd);
bool Actor_CanShootFrom(actor_t *self, const vec3_t *vTarget, int vFrom, const vec3_t *a4);
bool Actor_CanShootEnemy(actor_t *self, const int cacheDuration, const char *a3);
char Actor_CanSeeEntity(actor_t *self, const gentity_t *ent);
char Actor_RecentlySeeSentient(actor_t *self, sentient_t *sentient, int latency);
char Actor_CanSeeSentient(actor_t *self, sentient_t *sentient, int iMaxLatency);
char Actor_CanSeeEnemy(actor_t *self);
char Actor_CanSeeEnemyExtended(actor_t *self);
void Actor_CheckSurprisedBySentient(actor_t *self, sentient_t *other);
void Actor_GetPerfectInfo(actor_t *self, sentient_t *other);
char Actor_RecentlySeeEnemy(actor_t *self);
void Actor_UpdateNearbyEnemyInfo(actor_t *self, sentient_sort_t *enemyList, int enemyCount);
void Actor_UpdateSight(actor_t *self);

//t6/code/src_noserver/game/actor_spawner.cpp
int SpotWouldTelefrag(gentity_t *spot);
int PointCouldSeeSpawn(const vec3_t *vEyePos, const vec3_t *vSpawnPos, int iIgnoreEnt1, int iIgnoreEnt2);
gentity_t *SpawnActor(gentity_t *ent, const unsigned int targetname, enumForceSpawn forceSpawn, int getEnemyInfo, int updateThreats);
void G_DropActorSpawnersToFloor();
int SP_actor_spawner(gentity_t *pEnt, SpawnVar *spawnVar);

//t6/code/src_noserver/game/actor_state.cpp
void Actor_SetDefaultState(actor_t *actor);
bool Actor_StartState(actor_t *self, ai_state_t eStartedState);
bool Actor_ResumeState(actor_t *self, ai_state_t ePrevState);
void Actor_ResumePopedState(actor_t *self, ai_state_t state);
void Actor_ThinkStateTransitions(actor_t *self, char *a2);
void Actor_SetSubState(actor_t *self, ai_substate_t eSubState);
int Actor_IsStateOnStack(const actor_t *self, ai_state_t eState);
void Actor_SimplifyStateTransitions(actor_t *self);
int Actor_AllowedToPushState(actor_t *self, ai_state_t eState);
void Actor_SetState(actor_t *self, ai_state_t eState);
void Actor_PopState(actor_t *self);
void Actor_ForceState(actor_t *self, ai_state_t eState);
void Actor_PrepareToPushState(actor_t *self, ai_state_t eState);
int Actor_PushState(actor_t *self, ai_state_t eState);

//t6/code/src_noserver/game/actor_team_move.cpp
void Actor_TeamMoveBlocked(actor_t *self);
void Actor_TeamMoveBlockedClear(actor_t *self);
bool Actor_TeamMoveCheckWaitTimer(actor_t *self);
bool Actor_TeamMoveNeedToCheckWait(unsigned __int8 moveMode, path_t *pPath);
char Actor_TeamMoveCalcMovementDir(team_move_context_t *context, ai_teammove_t *result);
void Actor_AddToList(int *dodgeEntities, int *dodgeEntityCount, int arraysz, actor_t *pOtherActor);
void Actor_TeamMoveGetEntVelocity(gentity_t *other, vec2_t *velocity);
bool Actor_TeamMoveCheckDontDodgeSentient(actor_t *self, sentient_t *other);
char Actor_TeamMoveShouldTryDodgeSentient(sentient_t *a1, actor_t *a2, team_move_context_t *context, team_move_other_context_t *context_other);
bool Actor_TeamMoveTryDodge(team_move_context_t *context, team_move_other_context_t *context_other);
bool Actor_TeamMoveConsiderSlowDown(team_move_context_t *context, ai_teammove_t *eResult);
ai_teammove_t Actor_TeamMoveNoDodge(team_move_context_t *context, ai_teammove_t eResult);
void Actor_TeamMoveInitializeContext(actor_t *self, bool bUseInterval, bool bAllowGoalPileUp, team_move_context_t *context);
int Actor_TeamMoveTrimPath(path_t *pPath, const team_move_context_t *context);
void Actor_TeamMoveTooCloseMoveAway(const actor_t *self, int mask, team_move_context_t *context);
bool Actor_TeamMoveCheckPileup(actor_t *self, actor_t *pOtherActor);
BOOL Actor_WaitBeforeMoveStart(actor_t *self, team_move_context_t *context, vec2_t *velOther);
ai_teammove_t Actor_GetTeamMoveStatus(char *a1, actor_t *bAllowGoalPileUp, bool wasMoving, team_move_context_t *bAllowGoalPileUpa, bool wasMovinga);
void Actor_MoveAlongPathWithTeam(actor_t *self, AI_MOVE_MODE moveMode, actor_t *bUseInterval, team_move_context_t *bAllowGoalPileUp);

//t6/code/src_noserver/game/actor_threat.cpp
void Actor_InitThreatBiasGroups();
int Actor_GetThreatBias(int groupSelf, int groupEnemy);
void Actor_FlagEnemyUnattackable(actor_t *self);
BOOL Actor_CaresAboutInfo(actor_t *self, sentient_t *pOther);
int Actor_ThreatFromScariness(float a1);
int Actor_ThreatFromCover(actor_t *self, sentient_t *enemy, float distance);
int Actor_ThreatFromDistance(const float fDistance);
double Sentient_GetScarinessForDistance(sentient_t *self, sentient_t *enemy, float fDist);
bool Actor_CanBePathedTo(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
bool Actor_ShouldIgnoreFromAttackerCount(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
int Actor_IsFullyAware(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
int Actor_ThreatFromVisibilityAndAwareness(int friendlyTimingOut, int isFullyAwarea, int friendlyTimingOuta);
int Actor_ThreatFromAttackerCount(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
int Actor_ThreatBonusForCurrentEnemy(int isCurrentEnemy, int isFullyAware, int friendlyTimingOut, int isPlayer, int isDamaged);
int Actor_ThreatCoveringFire(actor_t *self, sentient_t *enemy);
int Actor_ThreatFlashed(sentient_t *enemy);
int Actor_UpdateSingleThreat(char *a1, float enemyDist, sentient_t *enemya, float enemyDista);
void Actor_InitThreatUpdateInterval(actor_t *self);
void Actor_IncrementThreatTime(actor_t *self);
void Actor_InitPotentialTarget(PotentialTargetData *potentialTarget, gentity_t *entity, float dist, const vec3_t *dirToEnemy);
void Actor_InitSecondaryTarget(actor_t *self, ActorSecondaryTarget *secondary, const PotentialTargetData *potentialTarget);
bool Actor_IsSimilarTarget(const vec2_t *dirToFirst, const vec2_t *dirToSecond, float distToFirst, float distToSecond);
int Actor_GetClosestDirectionSecondary(const actor_t *self, const PotentialTargetData *potential);
void Actor_UpdateSecondaryTargets(actor_t *self, PotentialTargetData *potentialTargets, int numPotentialTargets);
BOOL Actor_FullyAwareOfEnemy(actor_t *self);
void Actor_SetPotentialThreat(potential_threat_t *self, float yaw, float a3);
void Actor_ClearPotentialThreat(potential_threat_t *self);
void Actor_PotentialThreat_Debug(actor_t *self);
void Actor_EnterAlertState(actor_t *self);
void Actor_EnterCombatState(actor_t *self);
BOOL Actor_CheckIgnore(sentient_t *self, sentient_t *enemy);
void Actor_UpdateThreat(actor_t *self);

//t6/code/src_noserver/game/actor_zombie.cpp
char Actor_Zombie_Scripted_Start(actor_t *pSelf, ai_state_t ePrevState);
void Actor_Zombie_Scripted_Finish(actor_t *pSelf, ai_state_t eNextState);
int Actor_Zombie_Scripted_Think(actor_t *pSelf);
char Actor_Zombie_Custom_Start(actor_t *pSelf, ai_state_t ePrevState);
int Actor_Zombie_Custom_Think(actor_t *pSelf);

//t6/code/src_noserver/game/avoid.cpp
void Avoid_Init();
void Avoid_Init(int index, vec3_t origin, float radius, float timeHorizon, float maxSpeed, bool stubborn);
unsigned __int8 Avoid_Allocate(char *a1, int entnum, vec3_t origin, float radius, float timeHorizon, float maxSpeed);
void Avoid_Free(int index);
int Avoid_GetNeighbors(Avoid *avoid, Avoid **neighbors, int team);
void Avoid_UpdateNoGoal(int index, vec3_t origin, vec3_t vel);
void Avoid_Disable(int index);
void Avoid_SetRadius(int index, const float radius);
void Avoid_SetPriority(int index, const int priority);
void Avoidance_DebugRender();
void CalcStaticORCAs(int a1, Avoid *curr, float invT, OrcaPlane *orcas, int *orcaCount);
void AvoidUpdateOne(float curr, Avoid *a2, Avoid **inRange, int inRangeCount);
void Avoid_UpdateGoal(char *a1, int index, const float dt, const vec3_t *position, const vec3_t *vel, vec3_t *goalPos, float *speed, int team);

//t6/code/src_noserver/game/bullet.cpp
void Bullet_RandomDir(unsigned int *randSeed, float *x, float *y);
void Bullet_Endpos(float randSeed, char *a2, unsigned int *a3, float spread, vec3_t *end, vec3_t *dir, const weaponParms *wp, float maxRange, int shotIndex, int maxShotIndex);
int Bullet_GetDamage(const BulletFireParams *bp, const BulletTraceResults *br, const Weapon weapon, gentity_t *attacker);
void Bullet_NofifyActor(const BulletFireParams *bp, gentity_t *attacker, const vec3_t *start, const vec3_t *end, gentity_t *hitEnt, Weapon weapon);
void SetTempEventEntNormal(gentity_t *ent, const vec3_t *normal);
unsigned __int8 EncodeShieldHitPos(int entNum, const vec3_t *hitPos, const vec3_t *startPos);
bool Bullet_IgnoreHitEntity(const BulletFireParams *bp, const BulletTraceResults *br, gentity_t *attacker);
bool Bullet_Trace(const BulletFireParams *bp, const WeaponVariantDef *weapVariantDef, gentity_t *attacker, BulletTraceResults *br, int lastSurfaceType);
void CalcRicochet(const vec3_t *incoming, const vec3_t *normal, vec3_t *result);
char BG_BulletCalcBounce(const vec3_t *incoming, const vec3_t *normal, vec3_t *result);
bool BG_WeaponBulletFire_ShouldBounce(const Weapon weapon);
bool BG_WeaponBulletFire_ShouldPenetrate(const Weapon weapon);
void Bullet_AddBBInfo(BulletTraceResults *br);
void Bullet_ReportBBInfo(int time);
void BroadcastShieldHitEvent(const vec3_t *hitPos, const vec3_t *hitNormal, const vec3_t *startPos, int surfType, const Weapon weapon, int attackerEntNum, int victimEntNum);
void BroadcastShieldHitEventToVictim(unsigned int *randSeed, const vec3_t *hitPos, const vec3_t *hitNormal, const vec3_t *startPos, const Weapon weapon, int attackerEntNum, int victimEntNum);
void Bullet_ImpactEffect(unsigned int *randSeed, const BulletFireParams *bp, const BulletTraceResults *br, const vec3_t *normal, const Weapon weapon, gentity_t *attacker, int impactEffectFlags, gentity_t **outTempEnt);
void BulletRicochet(unsigned int *randSeed, gentity_t *hitEnt, gentity_t *attacker, const Weapon weapon, const vec3_t *contactPoint, const vec3_t *surfaceNormal, const vec3_t *incomingNormal, int gameTime);
bool Bullet_ProcessShieldHit(unsigned int *randSeed, BulletFireParams *bp, BulletTraceResults *br, const Weapon weapon, gentity_t *attacker, int gameTime);
bool Bullet_Process(unsigned int *randSeed, BulletFireParams *bp, BulletTraceResults *br, const Weapon weapon, gentity_t *attacker, int dFlags, int gameTime, int *outImpactFlags, bool processFx);
void Bullet_HitNothing(unsigned int *randSeed, BulletFireParams *bp, BulletTraceResults *br, const Weapon weapon, gentity_t *attacker);
bool G_WeaponBounceShot(Weapon weapon, BulletFireParams *incomingbp, BulletTraceResults *br, gentity_t *attacker, unsigned int *randSeed, int gameTime);
void Bullet_FirePenetrate(BulletFireParams *bp, gentity_t *attacker);
void Bullet_FireExtended(BulletFireParams *bp, gentity_t *attacker);
void Bullet_Fire(gentity_t *attacker, float spread, const weaponParms *wp, const gentity_t *weaponEnt, int gameTime);

//t6/code/src_noserver/game/enthandle.cpp
void TRACK_enthandle();
void Cmd_EntHandle_PrintInfo_f();
// void EntHandle::Init();
// void EntHandle::Shutdown();
// void SentientHandle::Init();
void EntHandleDissociateInternal(EntHandleList *entHandleList);
void EntHandleDissociate(gentity_t *ent);
void SentientHandleDissociate(sentient_t *sentient);
void RemoveEntHandleInfo(EntHandleList *entHandleList, unsigned int oldInfoIndex);
unsigned int AddEntHandleInfo(EntHandleList *entHandleList, void *handle);
// void EntHandle::setEnt(EntHandle *notthis, gentity_t *ent);
// void SentientHandle::setSentient(SentientHandle *notthis, sentient_t *sentient);

//t6/code/src_noserver/game/gamerprofile.cpp
int GamerProfile_GetSettingByName(const char *settingName);
bool GamerProfile_LookupKey(profile_setting setting, ControllerIndex_t controllerIndex, ddlState_t *outState, unsigned __int8 **outBuffer);
void GamerProfile_Get_f();
bool GamerProfile_IsValidProfileVariable(const char *settingName);
unsigned int GamerProfile_GetInt(ControllerIndex_t a1, profile_setting setting);
BOOL GamerProfile_GetBool(ControllerIndex_t a1, profile_setting setting);
double GamerProfile_GetFloat(ControllerIndex_t a1, profile_setting setting);
const GfxViewParms *GamerProfile_GetString(ControllerIndex_t a1, char *a2, profile_setting setting);
unsigned int GamerProfile_GetInt(const char *settingName);
double GamerProfile_GetFloat(const char *setting);
const GfxViewParms *GamerProfile_GetString(const char *settingName);
const GfxViewParms *GamerProfile_GetArrayString(const char *settingName, ControllerIndex_t controllerIndex, int index);
unsigned int GamerProfile_GetArrayInt(const char *settingName, ControllerIndex_t controllerIndex, int index);
bool GamerProfile_GetGlobalProfileBool(profile_setting setting);
unsigned int GamerProfile_GetTeamIndicator(int a1, ControllerIndex_t a2);
char GamerProfile_GetColorBlindAssist(int a1, ControllerIndex_t a2);
void GamerProfile_UpdateButtonConfig(ControllerIndex_t controllerIndex, int gpadButtonsConfig);
void GamerProfile_UpdateStickConfig(ControllerIndex_t controllerIndex, int gpadSticksConfig);
void GamerProfile_ExecuteFloatCallback(profile_setting setting, ControllerIndex_t controllerIndex, float newValue);
bool GamerProfile_SetFloat_Internal(ControllerIndex_t controllerIndex, ddlState_t *profileItemState, float newValue, unsigned __int8 *buffer);
bool GamerProfile_SetString_Internal(ControllerIndex_t controllerIndex, ddlState_t *profileItemState, const char *newValue, unsigned __int8 *buffer);
void GamerProfile_SetString(ControllerIndex_t a1, char *a2, profile_setting setting, ControllerIndex_t controllerIndex, const char *newValue);
void GamerProfile_CopyProfileEntry(ControllerIndex_t a1, char *a2, profile_setting setting);
char *GamerProfile_GetVariableAsString(char *a1, const char *settingName, ControllerIndex_t controllerIndex);
void TRACK_gamerprofile();
bool GamerProfile_IsProfileLoggedIn(ControllerIndex_t controllerIndex);
bool GamerProfile_IsProfileInitialized(ControllerIndex_t controllerIndex);
bool GamerProfile_WasErrorOnRead(ControllerIndex_t controllerIndex);
void DebugReportProfileVars(ControllerIndex_t controllerIndex, const char *headerMsg);
void GamerProfile_SetLocClassCmd();
void GamerProfile_SetClassVersion(const ControllerIndex_t controllerIndex);
void GamerProfile_SetupInitialClasses(const ControllerIndex_t controllerIndex);
void GamerProfile_ExecControllerBindings(ControllerIndex_t a1, ControllerIndex_t controllerIndex);
bool GamerProfile_AreBothBuffersInitialized(const ControllerIndex_t controllerIndex);
void GamerProfile_InitAllProfiles();
const CACRoot *GamerProfile_GetCACRoot(const CACRoot *result, const ControllerIndex_t controllerIndex);
const CACRoot *GamerProfile_GetCACRoot(const CACRoot *result, unsigned __int8 *buffer);
int GamerProfile_GetExeSettingsSize();
unsigned __int8 *GamerProfile_GetExeSettingsBuffer(const ControllerIndex_t controllerIndex);
void GamerProfile_ExecuteIntCallback(profile_setting setting, ControllerIndex_t controllerIndex, int newValue);
bool GamerProfile_SetInt_Internal(ControllerIndex_t controllerIndex, ddlState_t *profileItemState, int newValue, unsigned __int8 *buffer);
void GamerProfile_SetInt(ControllerIndex_t a1, profile_setting setting, ControllerIndex_t controllerIndex, int newValue);
void GamerProfile_SetBool(profile_setting setting, ControllerIndex_t controllerIndex);
bool GamerProfile_SetVariableFromString_Internal(const char *settingName, ControllerIndex_t controllerIndex, int index, const char *settingValue);
bool GamerProfile_SetVariableFromString(ControllerIndex_t a1, const char *settingKey, ControllerIndex_t controllerIndex);
bool GamerProfile_SetArrayVariableFromString(ControllerIndex_t a1, const char *settingKey, ControllerIndex_t controllerIndex, int index);
void __cdecl GamerProfile_ResetCommonVarsToDefault(ControllerIndex_t controllerIndex);
void __cdecl GamerProfile_ResetExeVarsToDefault(ControllerIndex_t controllerIndex);
void __cdecl GamerProfile_SaveChanges(ControllerIndex_t controllerIndex);
void GamerProfile_SaveChangesCmd();
void GamerProfile_RunCallbacks(int a1, ControllerIndex_t controllerIndex);
void GamerProfile_ResetProfile(ControllerIndex_t controllerIndex);
void GamerProfile_InitProfileWithoutSignin(int a1, ControllerIndex_t controllerIndex);
void __cdecl GamerProfile_Set_f();
void __cdecl GamerProfile_Reset_f();
void GamerProfile_InitOnce();

//t6/code/src_noserver/game/gamerprofile_pc.cpp
bool GamerProfile_CheckForErrors(int error, ControllerIndex_t controllerIndex, char *ioMode);
DWORD GamerProfile_WriteExeProfile();
DWORD GamerProfile_WriteCommonProfile();
void __cdecl GamerProfile_WriteSettings(ControllerIndex_t controllerIndex, GamerProfileBuffer *profileBuffer);

//t6/code/src_noserver/game/g_active.cpp
int GetFollowPlayerState(ClientNum_t clientNum, playerState_s *ps, bool allowLastActive);
int StuckInClient(gentity_t *self);
void G_PlayerEvent(int clientNum, int event);
void P_DamageFeedback(gentity_t *player);
void Player_WaterUpdate(gentity_t *ent);
void G_TouchEnts(gentity_t *ent, int numtouch, int *touchents);
void ClientImpacts(gentity_t *ent, pmove_t *pm);
void G_DoTouchTriggers(gentity_t *ent);
BOOL G_ClientCanSpectateTeam(gclient_t *client, team_t team);
int G_ClientCanSpectateAnyTeams(gclient_t *client, int teamsMask);
BOOL G_ClientCanSpectateDead(gclient_t *client);
void NotifyGrenadePullback(gentity_t *ent, Weapon weapon);
bool IsLiveGrenade(gentity_t *ent);
void AttemptLiveGrenadePickup(gentity_t *clientEnt);
void NotifyWeaponSwitchStarted(gentity_t *ent, const Weapon weapon);
void G_SetLastServerTime(ClientNum_t clientNum, int lastServerTime);
void G_SetClientContents(gentity_t *pEnt);
void SpectatorClientEndFrame(gentity_t *ent);
void ClientThink(ClientNum_t clientNum);
void G_PlayerController(const gentity_t *self, int *partBits);
gentity_t *G_GetPlayer(ClientNum_t clientNum);
int ClientInactivityTimer(gclient_t *client);
void ClientEvents(gentity_t *ent, int oldEventSequence);
void SpectatorThink(gentity_t *ent, usercmd_s *ucmd);
void ClientIntermissionThink(gentity_t *ent);

//t6/code/src_noserver/game/g_actor_prone.cpp
void G_InitActorProneInfo(actor_t *actor);

//t6/code/src_noserver/game/g_animscripted.cpp
void CalcDeltaOriginAndAngles(DObj *obj, unsigned int anim, const vec3_t *matrix, vec3_t *origin, vec3_t *angles);
void G_AnimScripted_ClearAnimWeights(gentity_t *ent, DObj *obj, XAnimTree_s *pAnimTree, unsigned int root, actor_t *pActor, float blendTime);
char G_ReduceOriginError(vec3_t *origin, vec3_t *originError, const vec3_t *originErrorReduction, const int lerpTime, const int startTime);
void G_ReduceAnglesError(vec3_t *angles, vec3_t *anglesError, const vec3_t *anglesErrorReduction);
void G_AnimScripted_Think_DeathPlant(XAnimTree_s *tree, vec3_t *origin, vec3_t *angles);
void G_AnimScripted_UpdateEntityOriginAndAngles(gentity_t *ent, const vec3_t *origin, const vec3_t *angles);
void G_Animscripted_Think(gentity_t *ent);
void G_Animscripted_DeathPlant(gentity_t *ent);
void G_Animscripted(gentity_t *ent, const vec3_t *origin, const vec3_t *angles, unsigned int anim, unsigned int root, unsigned int notifyName, unsigned __int8 animMode, const float animRate, bool skipRestart, float goalTime, float lerpTime);

//#include "game/g_bsp_load_db.h"

//t6/code/src_noserver/game/g_client_common.cpp
void InitClientDeltaAngles(gclient_t *client);
void SetClientViewAngle(gentity_t *ent, const vec3_t *angle);
void ClientCleanName(const char *in, char *out, int outSize);
void ClientUserinfoChanged(char *name, ClientNum_t clientNum);
void ClientBegin(ClientNum_t clientNum);
void ClientDisconnect(ClientNum_t clientNum);
unsigned int G_GetNonPVSPlayerInfo(gentity_t *pSelf, vec3_t *vPosition, int iLastUpdateEnt);
BOOL OnSameTeam(gentity_t *ent1, gentity_t *ent2);
void G_GetViewOriginMissingTag(const playerState_s *ps, vec3_t *origin, const char *type);
float G_Player3rdPersonVehicle_GetDampedSpringDistance(const gentity_t *vehicle, const VehicleDef *info, float camDefaultDist);
void G_GetPlayerVehicleViewOrigin_Internal(const playerState_s *ps, vec3_t *origin);
void G_Player3rdPersonVehicle_GetViewAngles(const playerState_s *ps, const gentity_t *vehicle, const VehicleDef *info, vec3_t *angles);
void G_Player3rdPersonVehicle_GetLookAtPosition(const gentity_t *vehicle, const VehicleDef *info, vec3_t *origin);
const char *ClientConnect(char *a1, ClientNum_t clientNum, unsigned __int16 scriptPersId);
void G_GetPlayer3rdPersonVehicleViewOrigin(unsigned int a1, const playerState_s *ps, vec3_t *origin);
void G_GetPlayerVehicleViewOrigin(const playerState_s *ps, vec3_t *origin);
void ClientSpawn(gentity_t *ent, const vec3_t *spawn_origin, const vec3_t *spawn_angles);

//t6/code/src_noserver/game/g_client_fields.cpp
void ClientScr_ReadOnly(gclient_t *pSelf, const client_fields_s *pField);
void ClientScr_SetSessionTeam(gclient_t *pSelf);
void ClientScr_SetFFATeam(gclient_t *pSelf);
void ClientScr_GetFFATeam(gclient_t *pSelf);
void ClientScr_GetName(gclient_t *pSelf);
void ClientScr_GetGroundType(gclient_t *pSelf);
void ClientScr_GetSessionTeam(gclient_t *pSelf);
scoreboardColumnType_t CScr_GetColumnTypeByName(const char *typeName);
const char *CScr_GetColumnNameByType(scoreboardColumnType_t columnType);
void ClientScr_SetSessionState(gclient_t *pSelf);
void ClientScr_GetSessionState(gclient_t *pSelf);
void ClientScr_SetMaxHealth(gclient_t *pSelf);
void ClientScr_SetScore(gclient_t *pSelf);
void ClientScr_SetKills(gclient_t *pSelf);
void ClientScr_SetDeaths(gclient_t *pSelf);
void ClientScr_SetAssists(gclient_t *pSelf);
void ClientScr_SetDowns(gclient_t *pSelf);
void ClientScr_SetRevives(gclient_t *pSelf);
void ClientScr_SetDefends(gclient_t *pSelf);
void ClientScr_SetPlants(gclient_t *pSelf);
void ClientScr_SetDefuses(gclient_t *pSelf);
void ClientScr_SetReturns(gclient_t *pSelf);
void ClientScr_SetCaptures(gclient_t *pSelf);
void ClientScr_SetDestructions(gclient_t *pSelf);
void ClientScr_SetSurvived(gclient_t *pSelf);
void ClientScr_SetStabs(gclient_t *pSelf);
void ClientScr_SetTomahawks(gclient_t *pSelf);
void ClientScr_SetHumiliated(gclient_t *pSelf);
void ClientScr_SetX2Score(gclient_t *pSelf);
void ClientScr_SetHeadshots(gclient_t *pSelf);
void ClientScr_SetAGRKills(gclient_t *pSelf);
void ClientScr_SetHacks(gclient_t *pSelf);
void ClientScr_SetPointsToWin(gclient_t *pSelf);
void ClientScr_SetKillsConfirmed(gclient_t *pSelf);
void ClientScr_SetKillsDenied(gclient_t *pSelf);
void ClientScr_SetForceSpectatorClient(gclient_t *pSelf);
void ClientScr_GetSpectatorClient(gclient_t *pSelf);
void ClientScr_SetKillCamEntity(gclient_t *pSelf);
void ClientScr_SetKillCamTargetEntity(gclient_t *pSelf);
void ClientScr_SetStatusIcon(gclient_t *pSelf);
void ClientScr_GetStatusIcon(gclient_t *pSelf);
void ClientScr_SetHeadIcon(gclient_t *pSelf);
void ClientScr_GetHeadIcon(gclient_t *pSelf);
void ClientScr_GetHeadIconTeam(gclient_t *pSelf);
void ClientScr_SetArchiveTime(gclient_t *pSelf);
void ClientScr_GetArchiveTime(gclient_t *pSelf);
void ClientScr_SetPSOffsetTime(gclient_t *pSelf);
void ClientScr_GetEntityFromIndex(gclient_t *pSelf, const client_fields_s *pField);
void ClientScr_GetPSOffsetTime(gclient_t *pSelf);
void GScr_AddFieldsForClient();
void Scr_SetClientField(gclient_t *client, int offset);
void Scr_GetClientField(gclient_t *client, int offset);
void ClientScr_SetHeadIconTeam(gclient_t *pSelf);

//t6/code/src_noserver/game/g_cmds.cpp
int CheatsOkInternal(gentity_t *ent);
char *ConcatArgs(int start);
void G_setfog(ClientNum_t clientNum, const char *fogstring);
void Cmd_SetSoundLength_f();
void Cmd_Take_f(gentity_t *ent);
void Cmd_God_f(gentity_t *ent);
void Cmd_DemiGod_f(gentity_t *ent);
void Cmd_UFO_f(gentity_t *ent);
void Cmd_Kill_f(gentity_t *ent);
void Cmd_Notarget_f(gentity_t *ent);
void Cmd_Noclip_f(gentity_t *ent);
int CompareClient(const void *_a, const void *_b);
void UpdateTeamSortedClients();
ClientNum_t CycleClient(ClientNum_t current, int dir);
int Cmd_FollowCycle_f(gentity_t *ent, int dir);
void Cmd_Where_f(gentity_t *ent);
void Cmd_PrintClientFields_f();
void Cmd_CallVote_f(gentity_t *ent);
void Cmd_Vote_f(gentity_t *ent);
void Cmd_SetViewpos_f(gentity_t *ent);
void Cmd_EntityCount_f();
void Cmd_MenuResponse_f(gentity_t *pEnt);
void Cmd_VisionSetNaked_f();
void Cmd_VisionSetNight_f();
BOOL G_IsPlaying(gentity_t *ent);
void G_SpectatorsSendServerCommand(ClientNum_t clientNum, svscmd_type type, const char *text);
void G_SayTo(gentity_t *ent, gentity_t *other, int mode, int color, const char *teamString, const char *cleanname, const char *message);
void G_Say(gentity_t *ent, gentity_t *target, int mode, const char *chatText);
void Cmd_Give_f(gentity_t *ent);
void StopFollowing(unsigned int a1, gentity_t *ent);
void ClientCommand(ClientNum_t clientNum);

//t6/code/src_noserver/game/g_debug.cpp
void G_DebugLine(clientDebugLineInfo_t *a1, const vec3_t *start, const vec3_t *end, const vec4_t *color, int depthTest);
void CG_DebugLine(clientDebugLineInfo_t *a1, const vec3_t *start, const vec3_t *end, const vec4_t *color, int depthTest, int duration);
void CG_DebugStar(clientDebugLineInfo_t *a1, const vec3_t *point, const vec4_t *color, int duration);
void G_DebugStarWithText(clientDebugLineInfo_t *a1, const vec3_t *point, const vec4_t *starColor, const vec4_t *textColor, const char *string, float fontsize);
void G_DebugSphere(const vec3_t *center, float radius, const vec4_t *floatColor, int sideCount, int depthTest, int duration);
void CG_DebugCircle(const vec3_t *center, float radius, const vec3_t *dir, const vec4_t *color, int depthTest);
void G_DebugArc(const vec3_t *center, float radius, float angle0, float angle1, const vec4_t *color, int depthTest);
void DrawBrushPoly(int numPoints, vec3_t *points, const vec4_t *color);
void G_DebugDrawBrush_r(cLeafBrushNode_s *node, const vec4_t *color);
void G_DebugDrawBrushModel(gentity_t *entity, const vec4_t *color, int depthTest, int duration);
void G_DebugCircle(const vec3_t *center, float radius, const vec4_t *color, int depthTest, int onGround, int duration);

//t6/code/src_noserver/game/g_helicopter.cpp
void Helicopter_RegisterDvars();
void HELI_CmdScale(const char *move, vec4_t *outFracs);
void HELI_UpdateJitter(VehicleJitter *jitter);
void HELI_CalcAccel(gentity_t *ent, char *move, vec3_t *bodyAccel, vec3_t *rotAccel, vec3_t *viewangles);
void HELI_CancelAIMove(gentity_t *ent);
void HELI_SoftenCollisions(gentity_t *ent, vec3_t *worldAccel);
void VEH_CheckForCrash(int a1, gentity_t *ent, vec3_t *newPosition);
int VEH_HandleHeliLockHeight(gentity_t *ent);
double Vehicle_AdjustRollForInputDeadZone(float rollPercent);
void Vehicle_AddRotate(vehicle_physic_t *phys, float fRoll, float fPitch, float fYaw);
void VEH_CheckForPredictedCrash(unsigned int a1, gentity_t *ent);
void VEH_UpdateClientChopper(char *a1, gentity_t *ent);
void VEH_UpdateClientPlane(char *a1, gentity_t *ent);

//t6/code/src_noserver/game/g_hudelem.cpp
int GetField(const void *i, int size);
void TRACK_g_hudelem();
void HudElem_SetDefaults(game_hudelem_s *hud);
void HudElem_DebugPrintScriptSource(int clientNum, const char *prefix);
game_hudelem_s *HudElem_Alloc(ClientNum_t clientNum, int teamNum);
void HudElem_Free(game_hudelem_s *hud);
void HudElem_ClientDisconnect(gentity_t *ent);
void HudElem_DestroyAll();
void HudElem_SetEnumString(game_hudelem_s *hud, const game_hudelem_field_t *f, const char **names, int nameCount);
void HudElem_GetEnumString(game_hudelem_s *hud, const game_hudelem_field_t *f, const char **names, int nameCount);
void HudElem_SetLocalizedString(game_hudelem_s *hud, int offset);
void HudElem_SetFlagForeground(game_hudelem_s *hud, int offset);
void HudElem_GetFlagForeground(game_hudelem_s *hud, int offset);
void HudElem_SetFontStyle3d(game_hudelem_s *hud, int offset);
void HudElem_GetFontStyle3d(game_hudelem_s *hud, int offset);
void HudElem_SetFont3dUseGlowColor(game_hudelem_s *hud, int offset);
void HudElem_GetFont3dUseGlowColor(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenDead(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenDead(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInKillCam(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInKillCam(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInDemo(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInDemo(game_hudelem_s *hud, int offset);
void HudElem_SetFlagImmuneToDemoGameHudSettings(game_hudelem_s *hud, int offset);
void HudElem_GetFlagImmuneToDemoGameHudSettings(game_hudelem_s *hud, int offset);
void HudElem_SetFlagImmuneToDemoFreeCamera(game_hudelem_s *hud, int offset);
void HudElem_GetFlagImmuneToDemoFreeCamera(game_hudelem_s *hud, int offset);
void HudElem_SetFlagShowPlayerTeamHudelemToSpectator(game_hudelem_s *hud, int offset);
void HudElem_GetFlagShowPlayerTeamHudelemToSpectator(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhileRemoteControlling(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhileRemoteControlling(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInMenu(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInMenu(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInScope(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInScope(game_hudelem_s *hud, int offset);
void HudElem_SetFlagFadeWhenTargeted(game_hudelem_s *hud, int offset);
void HudElem_GetFlagFadeWhenTargeted(game_hudelem_s *hud, int offset);
void HudElem_SetBoolean(game_hudelem_s *hud, int offset);
void HudElem_SetColor(game_hudelem_s *hud, int offset);
void HudElem_GetColor(game_hudelem_s *hud, int offset);
void HudElem_SetAlpha(game_hudelem_s *hud, int offset);
void HudElem_GetAlpha(game_hudelem_s *hud, int offset);
void HudElem_SetGlowColor(game_hudelem_s *hud, int offset);
void HudElem_GetGlowColor(game_hudelem_s *hud, int offset);
void HudElem_SetGlowAlpha(game_hudelem_s *hud, int offset);
void HudElem_GetGlowAlpha(game_hudelem_s *hud, int offset);
void HudElem_SetFontScale(game_hudelem_s *hud, int offset);
void __cdecl HudElem_SetFont(game_hudelem_s *hud, int offset);
void HudElem_GetFont(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void __cdecl HudElem_SetAlignX(game_hudelem_s *hud, int offset);
void HudElem_GetAlignX(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void __cdecl HudElem_SetAlignY(game_hudelem_s *hud, int offset);
void HudElem_GetAlignY(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void __cdecl HudElem_SetHorzAlign(game_hudelem_s *hud, int offset);
void HudElem_GetHorzAlign(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void __cdecl HudElem_SetVertAlign(game_hudelem_s *hud, int offset);
void HudElem_GetVertAlign(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void HudElem_SetUI3DWindow(game_hudelem_s *hud, int offset);
void HudElem_GetUI3DWindow(game_hudelem_s *hud, int offset);
void Scr_GetHudElemField(int entnum, int offset);
void Scr_SetHudElemField(int entnum, int offset);
void Scr_FreeHudElemConstStrings(game_hudelem_s *hud);
void GScr_NewHudElem();
void GScr_NewDebugHudElem();
void GScr_NewDamageIndicatorHudElem();
void GScr_NewClientHudElem();
void GScr_NewScoreHudElem();
void GScr_NewTeamHudElem();
void GScr_AddFieldsForHudElems();
game_hudelem_s *HECmd_GetHudElem(scr_entref_t entref);
void HECmd_ClearAllTextAfterHudElem(scr_entref_t entref);
void HECmd_ClearTargetEnt(scr_entref_t entref);
void HECmd_SetValue(scr_entref_t entref);
void HECmd_Reset(scr_entref_t entref);
void HECmd_Destroy(scr_entref_t entref);
void HECmd_SetPlayerNameString(scr_entref_t entref);
void HECmd_SetGameTypeString(scr_entref_t entref);
void HECmd_SetMapNameString(scr_entref_t entref);
void HECmd_GetTextWidth(scr_entref_t entref);
void (*HudElem_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
void HudElem_UpdateClient(gclient_t *client, ClientNum_t clientNum, hudelem_update_t which);
void HudElem_ClearClientSingle(hudelem_s *elems, int max);
void HudElem_ClearClient(gclient_t *client, hudelem_update_t which);
void HECmd_SetText(scr_entref_t entref);
void HECmd_SetMaterial(scr_entref_t entref);
void HECmd_SetTargetEnt(scr_entref_t entref);
void HECmd_SetTimer_Internal(scr_entref_t entref, he_type_t type);
void HECmd_SetClock_Internal(scr_entref_t entref, he_type_t type);
void HECmd_SetTimer(scr_entref_t entref);
void HECmd_SetTimerUp(scr_entref_t entref);
void HECmd_SetTenthsTimer(scr_entref_t entref);
void HECmd_SetTenthsTimerUp(scr_entref_t entref);
void HECmd_SetClock(scr_entref_t entref);
void HECmd_SetClockUp(scr_entref_t entref);
void HECmd_SetWaypoint(scr_entref_t entref);
void HECmd_SetPerks(scr_entref_t entref);
void HECmd_FadeOverTime(scr_entref_t entref);
void HECmd_ChangeFontScaleOverTime(scr_entref_t entref);
void HECmd_ScaleOverTime(scr_entref_t entref);
void HECmd_MoveOverTime(scr_entref_t entref);
void HECmd_SetPulseFX(scr_entref_t entref);
void HECmd_SetCOD7DecodeFX(scr_entref_t entref);
void HECmd_SetRedactFX(scr_entref_t entref);
void HECmd_SetTypewriterFX(scr_entref_t entref);

//t6/code/src_noserver/game/g_items.cpp
void Fill_Clip(playerState_s *ps, Weapon weapon);
Weapon CurrentPrimaryWeapon(playerState_s *ps);
int G_ItemClipMask(gentity_t *ent);
void PrintPlayerPickupMessage(gentity_t *player, Weapon weapon);
Weapon WeaponPickup_GetCompatibleWeapon(gentity_t *player, Weapon weapon);
void WeaponPickup_Notifies(gentity_t *notthisItem, gentity_t *newDroppedItem, gentity_t *player, const WeaponDef *weapDef, bool pickedUp);
void PrintMessage_CannotGrabItem(gentity_t *ent, gentity_t *player, int touched, Weapon weapon);
int GetFreeDropCueIdx();
void DroppedItemClearOwner(gentity_t *pSelf);
void G_GetItemClassname(const Weapon item, unsigned __int16 *out);
bool PlayerHasAnyAmmoToTransferToWeapon(gentity_t *player, Weapon transferWeapon);
int TransferPlayerAmmoToWeaponEntity(gentity_t *player, gentity_t *weaponEnt, Weapon transferWeapon);
int TransferRandomAmmoToWeaponEntity(gentity_t *weaponEnt, Weapon transferWeapon);
int TransferSpecifiedAmmoToWeaponEntity(gentity_t *weaponEnt, Weapon transferWeapon);
void FinishSpawningItem(unsigned int a1, gentity_t *ent);
void ClearRegisteredItems();
void DumpWeaponConfigStrings();
void SaveRegisteredWeapons();
void SaveRegisteredItems();
void RegisterWeaponRumbles(const WeaponDef *weapDef);
void G_RegisterWeapon(unsigned int weapIndex);
int IsItemRegistered(int iItemIndex);
void G_SpawnItem(gentity_t *ent, const Weapon item);
void G_OrientItemToGround(gentity_t *ent, trace_t *trace);
void G_RunItem(unsigned int a1, gentity_t *ent);
int Add_Ammo(gentity_t *ent, Weapon weapon, int count, int fillClip);
bool WeaponPickup_LeechFromWeaponEnt(gentity_t *weaponEnt, gentity_t *player, int haveExactWeapon, int *pickupEvent, bool suppressNotifies);
void WeaponPickup_AddAmmoForNewWeapon(gentity_t *weaponEnt, gentity_t *player);
int WeaponPickup_Touch(gentity_t *weaponEnt, gentity_t *player, Weapon weapon, int *pickupEvent);
gentity_t *LaunchItem(const Weapon item, vec3_t *origin, vec3_t *angles, vec3_t *velocity, int ownerNum);
gentity_t *Drop_Item(gentity_t *ent, const Weapon item, float angle, int novelocity);
gentity_t *ThrowClientWeapon(gentity_t *ent, const Weapon item, float heightIncrease, float velocityIncrease);
gentity_t *ThrowDownWeapon(int a1, gentity_t *ent, Weapon weapon, unsigned __int8 weaponModel, unsigned int tag, float throwHeight, float throwDistance);
gentity_t *Drop_Weapon(gentity_t *ent, Weapon weapon, unsigned int weaponModel, unsigned int tag);
int WeaponPickup_AddWeapon(gentity_t *ent, gentity_t **pDroppedWeapon);
int WeaponPickup_Grab(gentity_t *weaponEnt, gentity_t *player, Weapon weapon, int *pickupEvent);
int WeaponPickup(gentity_t *weaponEnt, gentity_t *player, int *pickupEvent, int touched);
void Touch_Item(gentity_t *ent, gentity_t *other, int touched);
void Touch_Item_Auto(gentity_t *ent, gentity_t *other, int bTouched);

//t6/code/src_noserver/game/g_load_utils.cpp
void G_SetEntityParsePoint(const char *beginParsePoint);
void G_ResetEntityParsePoint();
const char *G_GetEntityParsePoint();
int G_EntityParseToken(char *buffer, int bufferSize);
int G_GetEntityToken(char *buffer, int bufferSize);
int G_ParseSpawnVars(SpawnVar *spawnVar);
int G_SpawnString(const SpawnVar *spawnVar, const char *key, const char *defaultString, const char **out);
unsigned int G_NewString(const char *string);
char *vtos(const vec3_t *v);

//t6/code/src_noserver/game/g_main_common.cpp
void TRACK_g_main();
int G_GetSavePersist();
void G_SetSavePersist(int savepersist);
int G_GetClientScore(ClientNum_t clientNum);
int G_GetClientDeaths(ClientNum_t clientNum);
int G_GetClientArchiveTime(ClientNum_t clientNum);
void G_SetClientArchiveTime(ClientNum_t clientNum, int time);
clientState_s *G_GetClientState(ClientNum_t clientNum);
gclient_t *G_GetPlayerState(ClientNum_t clientNum);
void *Hunk_AllocActorXAnimServer(int size);
actorState_s *G_GetActorState(int actorNum);
int G_GetClientSize();
int G_GetActorSize();
void G_CreateDObj(DObjModel_s *dobjModels, unsigned __int16 numModels, XAnimTree_s *tree, int handle, LocalClientNum_t unusedLocalClientNum);
DObj *G_GetDObj(int handle, LocalClientNum_t unusedLocalClientNum);
void G_SafeDObjFree(int handle, LocalClientNum_t unusedLocalClientNum);
void *Hunk_AllocXAnimServer(int size);
int G_IsServerGameSystem(ClientNum_t clientNum);
unsigned __int16 G_AttachWeapon(DObjModel_s *dobjModels, unsigned __int16 numModels, clientInfo_t *ci, bool hideClip);
int SortRanks(const void *a, const void *b);
bool G_ExitAfterConnectPaths();
bool G_ExitOnComError(int code);
void CalculateRanks();
BOOL G_IsEntWalkable(LocalClientNum_t localClientNum, int entityNum);
bool G_GetEntityOriginAngles(LocalClientNum_t localClientNum, int entityNum, vec3_t *origin, vec3_t *angles);
char G_GetVelocity(LocalClientNum_t localClientNum, int entIndex, vec3_t *outVelocity);
void G_EntityLinkFromPMove(int entityNum, int parentEntityNum, const int tagName);
void G_LogPrintf(const char *fmt, ...);
void ExitLevel();
void G_SafeDObjFree(gentity_t *ent);

//t6/code/src_noserver/game/g_mem_track.cpp
void G_track_init();

//t6/code/src_noserver/game/g_missile.cpp
void G_RegisterMissileDvars();
BOOL IsZombiesValuableItem(const WeaponDef *weapDef);
BOOL G_IsClientControlledMissile(const playerState_s *ps);
int IsMissileClientControlled(const gentity_t *missile);
int G_ClearMissileClientControlled(const gentity_t *missile);
void MissileLandAngles(gentity_t *ent, trace_t *trace, vec3_t *vAngles, int bForceAlign, int bKeepSpeed);
void MissileLandAnglesFlat(gentity_t *ent, trace_t *trace, vec3_t *angles);
void MissileLandAnglesFlatMaintainingDirection(gentity_t *ent, trace_t *trace, vec3_t *angles);
int CheckCrumpleMissile(gentity_t *ent, trace_t *trace);
void CheckGrenadeDanger(gentity_t *grenadeEnt);
BOOL skip_horses(int entnum);
void G_MissileTrace(trace_t *results, const vec3_t *start, const vec3_t *end, int passEntityNum, int contentmask, Weapon weapon);
char GrenadeBounceVelocity(const vec3_t *preBounceVelocity, float dot, const vec3_t *normal, int surfType, const WeaponDef *weapDef, trajectory_t *pos, float *rollSlideSpeed, vec3_t *rollSlideDir, bool isDud);
bool GrenadeDud(gentity_t *ent, const WeaponDef *weapDef);
bool JavelinProjectile(gentity_t *ent, const WeaponDef *weapDef);
bool JavelinDud(gentity_t *ent, const WeaponDef *weapDef);
int GetSplashMethodOfDeath(gentity_t *ent);
bool isDud(gentity_t *ent, const WeaponDef *weapDef);
void G_UnlinkPlayerToRocket(gentity_t *ent);
void AttachMissileToEntity(gentity_t *missile, int entnum, int boneName, int hitLocation, vec3_t *velocity);
int StickMissile(gentity_t *ent, gentity_t *other, const WeaponDef *weapDef, trace_t *trace, hitLocation_t hitLocation, vec3_t *velocity);
bool isBounceProjectile(gentity_t *ent);
void createRetrieveableProjectile(gentity_t *ent, gentity_t *other, const WeaponDef *weapDef, trace_t *trace, hitLocation_t hitLocation, vec3_t *dir, vec3_t *endpos);
bool GrenadeCanApplyImpactDamage(gentity_t *missile, gentity_t *hitEnt, const WeaponDef *weapDef);
void G_TimedObjectThink(gentity_t *ent);
int GetSurfaceType(gentity_t *ent, bool inWater);
void Missile_PenetrateGlass(trace_t *results, gentity_t *ent, const vec3_t *start, const vec3_t *end, int damage, bool predicted);
void DrawMissileDebug(vec3_t *start, vec3_t *end);
void TRACK_missile_attractors();
void Missile_InitAttractors();
void Missile_FreeAttractorRefs(gentity_t *ent);
int Missile_GetFreeAttractor();
void Scr_MissileCreateAttractorEnt();
void Scr_MissileCreateAttractorOrigin();
void Scr_MissileCreateRepulsorEnt();
void Scr_MissileCreateRepulsorOrigin();
void Scr_MissileDeleteAttractor();
void Missile_ApplyAttractorsRepulsors(gentity_t *missile);
void RunMissile_Destabilize(gentity_t *missile);
void RunMissile_BroadcastActorEvents(gentity_t *missile);
bool IsMissileLockedOn(gentity_t *ent);
void GetTargetPosition(gentity_t *ent, vec3_t *result);
void MissileVerticalSteerToTarget(gentity_t *ent, const vec2_t *toTargetHorzRelDir, float horzDistToTarg, float vertDistToTarg, float currentHorzSpeed, vec3_t *steer);
void MissileVerticalSteering(gentity_t *ent, const vec3_t *toTargetRelative, float currentHorzSpeed, vec3_t *steer);
bool MissileIsReadyForSteering(gentity_t *ent);
bool DroneClimbExceededAngle(gentity_t *ent, const vec3_t *targetPos);
bool DroneClimbExceededDistance(gentity_t *ent, const vec3_t *targetPos);
void DroneClimbOffset(gentity_t *ent, vec3_t *targetPos);
float DroneMaxDPS(gentity_t *ent, bool impactAvoidance);
float DroneRotateDir(gentity_t *ent, const vec3_t *currentDir, const vec3_t *targetDir, vec3_t *resultDir, float currentRoll, bool avoidImpact);
void DroneRotateVelocity(gentity_t *ent, vec3_t *resultVel);
float DroneClimbCeiling(gentity_t *ent);
bool DroneClimbIsAboveCeiling(gentity_t *ent, const vec3_t *targetPos);
void DroneSteering(gentity_t *ent, const WeaponDef *weapDef);
bool JavelinClimbExceededAngle(gentity_t *ent, const vec3_t *targetPos);
bool JavelinClimbWithinDistance(gentity_t *ent, const vec3_t *targetPos);
void JavelinClimbOffset(gentity_t *ent, vec3_t *targetPos);
float JavelinMaxDPS(gentity_t *ent);
float JavelinRotateDir(gentity_t *ent, const vec3_t *currentDir, const vec3_t *targetDir, vec3_t *resultDir);
void JavelinRotateVelocity(gentity_t *ent, const vec3_t *currentVel, const vec3_t *targetDir, vec3_t *resultVel);
float JavelinClimbCeiling(gentity_t *ent);
bool JavelinClimbIsAboveCeiling(gentity_t *ent, const vec3_t *targetPos);
void JavelinSteering(char *a1, gentity_t *ent, const WeaponDef *weapDef);
void HeatSeekingSteering(gentity_t *ent, const WeaponDef *weapDef);
void G_MakeMissilePickupItem(gentity_t *ent);
void PredictBounceMissile(gentity_t *ent, trajectory_t *pos, trace_t *trace, int time, int velocityTime, vec3_t *origin, vec3_t *endpos);
int G_PredictMissile(unsigned int a1, gentity_t *ent, int duration, vec3_t *vLandPos, int allowBounce, int *timeAtRest);
void G_InitGrenadeEntity(gentity_t *parent, gentity_t *grenade);
void G_InitGrenadeMovement(gentity_t *grenade, const vec3_t *start, const vec3_t *dir, int rotate, WeapRotateType rotateType);
void InitGrenadeTimer(const gentity_t *parent, gentity_t *grenade, const WeaponDef *weapDef, int time);
gentity_t *G_FireGrenade(gentity_t *parent, vec3_t *start, vec3_t *dir, Weapon grenadeWPID, unsigned __int8 grenModel, int rotate, int time);
int G_SetMissileClientControlled(const gentity_t *missile);
int BounceMissile(gentity_t *ent, trace_t *trace);
void G_LinkPlayerToRocket(gentity_t *ent, gentity_t *player);
void AttachBoltGrenade(gentity_t *ent, gentity_t *hitEnt, trace_t *trace, hitLocation_t hitLocation);
void MissileImpact(gentity_t *ent, trace_t *trace, vec3_t *dir, vec3_t *endpos);
void G_ExplodeMissile(unsigned int a1, float ent, gentity_t *a3);
void RunMissile_CreateWaterSplash(const gentity_t *missile, const vec3_t *hitPos, const trace_t *trace);
void MissileHorzSteerToTarget(gentity_t *ent, const vec2_t *currentRight, const vec2_t *toTargetRelative, float currentHorzSpeed, vec3_t *steer, bool tvGuided);
void MissileTrajectoryClientControlled(gentity_t *ent, vec3_t *result, gentity_t *owner);
void TVMissileTrajectoryClientControlled(gentity_t *ent, vec3_t *result);
void GuidedMissileSteering(gentity_t *ent);
void MissileTrajectory(gentity_t *ent, vec3_t *result);
bool CheckForMissileClientControlledDetonation(gentity_t *ent);
bool UpdateGuidedMissileFuelTime(gentity_t *ent, bool initTimer);
void G_RunMissileInternal(unsigned int a1, char *a2, gentity_t *ent);
void G_RunMissile(gentity_t *ent);
void InitRocketTimer(gentity_t *bolt, const WeaponDef *weapDef);
gentity_t *G_FireRocket(gentity_t *parent, Weapon weapon, vec3_t *start, vec3_t *dir, const vec3_t *gunVel, gentity_t *target, const vec3_t *targetOffset);
gentity_t *G_DropBomb(gentity_t *parent, Weapon weapon, vec3_t *start, vec3_t *dir, const vec3_t *gunVel, gentity_t *target, const vec3_t *targetOffset);

//t6/code/src_noserver/game/g_mover.cpp
void TRACK_g_mover();
void G_PushEntity(gentity_t *check, gentity_t *pusher, const vec3_t *move, const vec3_t *amove, const mover_info_t *mi);
char IsEntityLinkedToMe(gentity_t *self, gentity_t *other);
int GetRopeIndex(unsigned int targetname);
void DeleteConstraint(int rope_index);
void G_UpdatePhysicsPose(gentity_t *ent);
void G_MoverSlide(gentity_t *ent);
void trigger_use_shared(gentity_t *self, SpawnVar *spawnVar);
void trigger_use_touch(gentity_t *a1, SpawnVar *a2);
void G_MoverPush(gentity_t *pusher, const mover_info_t *mi);
void G_CreatePhysicsObject(gentity_t *ent);
void G_CalcEntityPhysicsPositions(gentity_t *ent);
void G_MoverTeam(const mover_info_t *a1, gentity_t *ent, const mover_info_t *mi);
void G_MoverTeam_New(gentity_t *ent);
void G_RunMover(gentity_t *ent);

//t6/code/src_noserver/game/g_player_corpse.cpp
int G_GetPlayerCorpseIndex(gentity_t *ent, const char *error_msg);
int G_GetFreePlayerCorpseIndex();
void PlayerCorpse_Free(gentity_t *ent);
bool G_GetAnimDeltaForCorpse(gentity_t *ent, vec3_t *originChange);
void G_RunCorpseAnimate(gentity_t *ent);
void G_BounceCorpse(gentity_t *ent, corpseInfo_t *corpseInfo, trace_t *trace, vec3_t *endpos);
void G_RunCorpseMove(unsigned int a1, gentity_t *ent);
void G_RunCorpse(gentity_t *ent);

//t6/code/src_noserver/game/g_scr_main.cpp
void Scr_NetworkOriginError(const char *entityName, const vec3_t *origin);
void GScr_Throw();
void GScr_CreatePrintChannel();
void GScr_getEnterButton();
void GScr_printChannelSet();
void Scr_MakeGameMessage(int iClientNum, const char *pszCmd);
void iprintln();
void iprintlnbold();
void GScr_print3d();
void GScr_line();
void GScr_box();
void GScr_debugstar(clientDebugLineInfo_t *a1);
void GScr_circle();
void GScr_sphere();
void Scr_GetReflectionLocs();
void Scr_GetReflectionOrigin();
void GScr_AddDebugCommand();
void GScr_BBPostDemoStreamStatsForRound();
void GScr_GetWeaponFuseTime();
void GScr_GetWeaponProjExplosionSound();
void GScr_DoesWeaponReplaceSpawnWeapon();
void GScr_IsFloat();
void GScr_IsInt();
void GScr_IsVec();
void GScr_IsString();
void Scr_isPC();
void GScr_IsArray();
void GScr_IsAlive();
void GScr_IsSpawner();
void GScr_TableLookupFindCoreAsset();
void GScr_TableLookupRowNum();
void GScr_TableLookupColumnForRow();
void GScr_TableLookup();
void GScr_TableLookupIString();
void GScr_IsPlayer();
void GScr_IsSentient();
void GScr_IsGodMode();
void GScr_GetGametypeSetting();
bool GScr_SetGametypeSetting();
void CleanDvarValue(const char *dvarValue, char *outString, int size);
void GScr_SetDvar();
void GScr_SetDvarInt();
void GScr_MakeDvarServerInfo();
void GScr_SendAIScriptKeys();
void GScr_GetTime();
void Scr_isWiiU();
void Scr_RandomInt();
void Scr_RandomFloat();
void Scr_RandomIntRange();
void Scr_RandomFloatRange();
void GScr_log();
void GScr_sin();
void GScr_cos();
void GScr_tan();
void GScr_asin();
void GScr_acos();
void GScr_atan();
void GScr_CastInt();
void GScr_CastFloat();
void GScr_CastIString();
void GScr_min();
void GScr_max();
void GScr_floor();
void GScr_ceil();
void GScr_sqrt();
void GScr_pow();
void GScr_LerpFloat();
void GScr_LerpVector();
void GScr_DiffTrack();
void GScr_DiffTrackAngle();
void GScr_GetMinBitCountForNum();
void GScr_VectorFromLineToPoint();
void GScr_PointOnSegmentNearestToPoint();
void GScr_GetArrayKeys();
void GScr_GetFirstArrayKey();
void GScr_GetNextArrayKey();
void GScr_GetLastArrayKey();
void GScr_GetPrevArrayKey();
int GScr_MoveToStatPath(ddlState_t *resultState, int numParams, ddlState_t *searchState);
statAddValue_t *GScr_AddStatFromState(ddlState_t *searchState, ClientNum_t clientNum, statValue_t addValue, statsLocation location);
statValue_t GetStatValueFromParams(int numParam);
gunLevelRow_t *CheckWeaponChallengeForStatValue(int weaponStatIndex, statAddValue_t statValue);
bool CheckPrerequisiteChallengeComplete(ClientNum_t clientNum, int itemIndex, challengeTableRow_t *challengeRow);
challengeTableRow_t *CheckChallengeForStatValue(statAddValue_t statValue, int rank, int pLevel, challengeTableRow_t *challengeRow, int itemIndex);
bool IsChallengeCompleted(ClientNum_t clientNum, ddlState_t *searchState, int rank, int pLevel, challengeTableRow_t *challengeRow, int itemIndex);
bool GScr_IsItemPurchasedForClientNum(ClientNum_t clientNum, int itemIndex);
void SetStatAddValueToChallengeMax(statAddValue_t *statAddValue, int maxValue);
void GScr_CallGunChallengeCallback(gentity_t *playerEnt, int rankID, int itemIndex, eAttachment attachment, int rewardXP);
float GetStatFromState(ClientNum_t clientNum, ddlState_t *searchState);
float GetPlayerStatValue(ClientNum_t clientNum, const char *statName);
float GetGameTypeStatValue(ClientNum_t clientNum, const char *statName);
void SetStatFromState(ClientNum_t clientNum, ddlState_t *searchState, float value);
void SetPlayerStatValue(ClientNum_t clientNum, const char *statName, float value);
void SetGameTypeStatValue(ClientNum_t clientNum, const char *statName, float value);
int GScr_GetWeaponStatIndex(int argNum, int *attachmentBits, int *weaponIdx);
const char *RegisterNewScore(__int16 a1, char a2, int *nameHash, int addPlayerStat, int scoreInfoTable, int a6, const StringTable *a7);
const char *GScr_RegisterXP();
void Scr_ClearScoreInfo();
void Scr_LoadScoreInfo(MemoryFile *memFile);
scoreInfo_t *FindScoreInfo(int nameHash);
int GScr_GetXPScaled(const ClientNum_t clientNum, statValue_t addValue);
int GScr_GetGunXPScaled(const ClientNum_t clientNum, statValue_t addValue);
void __cdecl GScr_AddRankXPToPlayerEnt(gentity_t *playerEnt, const ClientNum_t clientNum, statValue_t addValue);
void __cdecl GScr_AddGameTypeStatMoreInternal(gentity_t *playerEnt, ClientNum_t clientNum, const char *statNameInput, statValue_t addValue, ddlState_t *searchState, int gameTypeIndex);
void GScr_AddGameTypeStatInternal(gentity_t *playerEnt, ClientNum_t clientNum, const char *statNameInput, statValue_t addValue);
void GScr_AddPlayerStatWithGameTypeGroupInternal(ClientNum_t clientNum, const char *statName, statValue_t addValue);
void GScr_AddAttachmentStatInternal(gentity_t *playerEnt, ClientNum_t clientNum, int attachmentNum, const char *statNameInput, int statNameHash, statValue_t addValue);
void GScr_AddGroupStatInternal(gentity_t *playerEnt, ClientNum_t clientNum, int groupIndex, const char *statNameInput, int statNameHash, statValue_t addValue);
int __cdecl GScr_AddWeaponStatMoreInternal(gentity_t *playerEnt, ClientNum_t clientNum, int weaponStatIndex, const char *statNameInput, int statNameHash, statValue_t addValue, challengeTableRow_t *challengeRow);
int GScr_AddSpecialWeaponStatInternal(gentity_t *playerEnt, ClientNum_t clientNum, int weaponStatIndex, const char *statNameInput, const char *prefix, itemGroup_t groupIndex, statValue_t addValue);
int GScr_AddSpecialWeaponStat(gentity_t *playerEnt, ClientNum_t clientNum, int weaponStatIndex, const char *statName, int statNameHash, const char *prefix, itemGroup_t groupIndex, statValue_t addValue);
void GScr_AddBonusCardStatInternal(char *a1, gentity_t *playerEnt, ClientNum_t clientNum, statValue_t addValue, const char *statName, int statNameHash, loadoutClass_t loadoutClassNum);
int __cdecl GScr_AddWeaponStatInternal(gentity_t *playerEnt, ClientNum_t clientNum, int weaponStatIndex, int weaponIndex, int attachmentBits, const char *weapName, const char *statName, statValue_t addValue, int statNameHash, loadoutClass_t loadoutClassNum);
void GScr_UploadStats();
char Scr_Distance();
char Scr_Distance2D();
void Scr_Distance2DSquared();
void Scr_DistanceSquared();
void Scr_Length();
void Scr_LengthSquared();
void Scr_Closer();
char Scr_VectorDot();
char Scr_VectorCross();
char Scr_VectorNormalize();
void Scr_VectorLerp();
void Scr_CombineAngles();
void Scr_AbsAngleClamp180();
void Scr_AbsAngleClamp360();
void Scr_AngleLerp();
void Scr_RotatePoint();
void Scr_IsSubStr();
void Scr_GetSubStr();
void Scr_ToLower();
void Scr_ToUpper();
void Scr_StrTok();
void Scr_SoundFade();
gentity_t *Scr_PlaySoundAtPosition();
void GScr_GetLocalProfileInt();
void GScr_GetLocalProfileFloat();
void GScr_GetLocalProfileArrayInt();
void GScr_GetLocalProfileString();
void GScr_SetLocalProfileVar();
void GScr_SetLocalProfileArrayVar();
void GScr_OpenFile();
void GScr_CloseFile();
void Scr_FPrint_internal(bool commaBetweenFields);
void GScr_FPrintln();
void GScr_FPrintFields();
void GScr_FReadLn(const char *notthis);
void GScr_FGetArg();
void GScr_ExecDevgui();
void Scr_CreateNewArray();
void Scr_ArrayRemoveValue();
void Scr_ArrayRemoveIndex();
void Scr_ArrayInsert();
void Scr_ArrayCombine();
void Scr_ArrayCopy();
void Scr_IsInArray();
int Scr_SortAscending(const void *v1, const void *v2);
int Scr_SortDescending(const void *v1, const void *v2);
void Scr_ArraySort();
void Scr_SessionModeIsOnlineGame();
void Scr_SessionModeIsPrivateOnlineGame();
void Scr_SessionModeIsPrivate();
void Scr_SessionModeIsSystemlink();
void Scr_SessionModeIsZombiesGame();
void Scr_GameModeIsMode();
void Scr_GameModeIsUsingXP();
void Scr_GameModeIsUsingStats();
int Scr_GetTeamFlags(unsigned int i);
AISpecies Scr_GetSpecies(unsigned __int16 speciesString);
void Scr_GetFreeActorCount();
actor_t *Scr_GetAIArray();
actor_t *Scr_GetAISpeciesArray();
void Scr_GetSpawnerArray();
void Scr_GetScriptMoverArray();
void Scr_GetZBarrierArray();
void Scr_GetItemArray();
void Scr_GetCorpseArray();
void Scr_GetSpawnerTeamArray();
void Scr_GetVehicleSpawnerArray();
void Scr_GetVehicleArray();
void GScr_LUINotifyEvent_Internal(const ClientNum_t clientNum, bool sendToSpectators);
void GScr_LUINotifyEvent();
void Scr_ActivateClientExploder();
void Scr_DeactivateClientExploder();
void GScr_GetMissileOwner();
void GScr_GetStartOrigin();
void GScr_GetStartAngles();
void GScr_DisableGrenadeSuicide();
void GScr_EnableGrenadeSuicide();
unsigned int GScr_PrecacheLeaderboards();
void GScr_GetClassIndexFromName();
void GScr_DeployRiotshield();
void Scr_GetNumExpectedPlayers();
void Scr_GetNumConnectedPlayers();
void (*Scr_GetCommonFunction(const char **pName, int *type, int *min_args, int *max_args))();
gentity_t *GetEntity(scr_entref_t entref);
gentity_t *GetPlayerEntity(scr_entref_t entref);
void G_EntityStateSetPartBits(gentity_t *ent, const unsigned int *partBits);
void G_EntityStateGetPartBits(const gentity_t *ent, unsigned int *partBits);
void ScrCmd_RunScriptOnEnt(scr_entref_t entref);
void ScrCmd_hidepart(scr_entref_t entref);
void ScrCmd_showpart(scr_entref_t entref);
void ScrCmd_showallparts(scr_entref_t entref);
void ScrCmd_SendAIScriptVals(scr_entref_t entref);
gentity_t *GScr_SetupLightEntity(scr_entref_t entref);
void GScr_GetLightColor(scr_entref_t entref);
void GScr_SetLightColor(scr_entref_t entref);
void GScr_GetLightIntensity(scr_entref_t entref);
void GScr_SetLightIntensity(scr_entref_t entref);
void GScr_GetLightRadius(scr_entref_t entref);
void GScr_SetLightRadius(scr_entref_t entref);
void GScr_GetLightFovInner(scr_entref_t entref);
void GScr_GetLightFovOuter(scr_entref_t entref);
void GScr_SetLightFovRange(scr_entref_t entref);
void GScr_GetLightExponent(scr_entref_t entref);
void GScr_SetLightExponent(scr_entref_t entref);
void ScrCmd_PlaySoundToPlayer(scr_entref_t entref);
void GScr_SetSpawnerTeam(scr_entref_t entref);
void GScr_Launch(scr_entref_t entref);
void GScr_SetMovingPlatformEnabled(scr_entref_t entref);
void GScr_IsMovingPlatform(scr_entref_t entref);
void GScr_SetViewModelRenderFlag(scr_entref_t entref);
void GScr_SetDrawInfrared(scr_entref_t entref);
void ScrCmd_Unlink(scr_entref_t entref);
void ScrLinkTo_Internal(scr_entref_t entref, bool blendToTag);
void ScrCmd_LinkTo(scr_entref_t entref);
void ScrCmd_LinkToBlendToTag(scr_entref_t entref);
void ScrCmd_EnableLinkTo(scr_entref_t entref);
void ScrCmd_LinkToUpdateOffset(scr_entref_t entref);
void ClientmaskSetFlagVisible(int *mask, int clientNum);
void PlayerLinkTo_Internal(scr_entref_t entref, PlayerLinkToType linkType);
void __cdecl ScrCmd_PlayerLinkTo(scr_entref_t entref);
void __cdecl ScrCmd_PlayerLinkToDelta(scr_entref_t entref);
void __cdecl ScrCmd_PlayerLinkWeaponViewToDelta(scr_entref_t entref);
void CheckTimes(float *totalTime, float accelTime, float decelTime);
void ScrCmd_PlayerLinkToBlend(char *a1, scr_entref_t entref);
void ScrCmd_PlayerLinkToAbsolute(scr_entref_t entref);
void ScrCmd_PlayerCamLinkTo(scr_entref_t entref);
void ScrCmd_PlayerCamUnlink(scr_entref_t entref);
void ScrCmd_LerpViewAngleClamp(char *a1, scr_entref_t entref);
char AttachCmd(gentity_t *ent, unsigned int *tagNameResult);
void ScrCmd_attachShieldModel(scr_entref_t entref);
void ScrCmd_RefreshShieldAttachment(scr_entref_t entref);
void DetachCmd(gentity_t *ent);
void ScrCmd_detachShieldModel(scr_entref_t entref);
void ScrCmd_PlayerLinkedOffsetEnable(scr_entref_t entref);
void ScrCmd_PlayerLinkedOffsetDisable(scr_entref_t entref);
void ScrCmd_PlayerLinkedSetUseBaseAngleForViewClamp(scr_entref_t entref);
void ScrCmd_DontInterpolate(scr_entref_t entref);
void ScrCmd_MagicGrenadeType(scr_entref_t entref);
void GScr_StartFadingBlur(scr_entref_t entref);
void GScr_WorldToLocalCoords(scr_entref_t entref);
void GScr_SetTurretSpinning(scr_entref_t entref);
void GScr_SetScriptMoverFlag(scr_entref_t entref);
void ScrCmd_SetVisionSetForPlayer(scr_entref_t entref);
void ScrCmd_UseServerVisionset(scr_entref_t entref);
void ScrCmd_SetInfraredVision(scr_entref_t entref);
void GScr_SetCharacterIndex(scr_entref_t entref);
void GScr_UsePlayerFootstepTable(scr_entref_t entref);
void ScrCmd_attach(scr_entref_t entref);
void ScrCmd_detach(scr_entref_t entref);
void ScrCmd_detachAll(scr_entref_t entref);
void ScrCmd_GetAttachSize(scr_entref_t entref);
void ScrCmd_GetAttachModelName(scr_entref_t entref);
void ScrCmd_GetAttachTagName(scr_entref_t entref);
void ScrCmd_GetAttachIgnoreCollision(scr_entref_t entref);
void ScrCmd_ResetFov(scr_entref_t entref);
void (*BuiltIn_GetCommonMethod(const char **pName, int *type, int *min_args, int *max_args))(scr_entref_t);
int Scr_GetArrayValues_Vector(int parameter_index, int parent_id, vec3_t *vector_array, int vector_array_size, const char *array_type_description);
void GScr_linelist();
void GScr_AreAllMissionsAtScore(scr_entref_t entref);
void GScr_GetNumChallengesComplete(scr_entref_t entref);
void GScr_HasCompletedAllGameChallenges(scr_entref_t entref);
void GScr_GetDStat(scr_entref_t entref);
void GScr_GetDStatArrayCount(scr_entref_t entref);
void GScr_SetDStat(scr_entref_t entref);
char IsItemLockedForChallenge(scr_entref_t entref, int itemIndex, bool purchaseRequired);
int GScr_AddChallengeStat(gentity_t *playerEnt, int itemIndex, challengeTableRow_t *challengeRow);
int GScr_CallChallengeCallback(int a1, gentity_t *playerEnt, int itemIndex, challengeTableRow_t *challengeRow);
void GScr_UpdateStatRatio(scr_entref_t entref);
void GScr_GameHistoryStartMatch(scr_entref_t entref);
void GScr_GameHistoryFinishMatch(scr_entref_t entref);
void GScr_CheckWeaponMastery(gentity_t *playerEnt, ClientNum_t clientNum, int weaponStatIndex);
void GScr_AddRankXPValue(scr_entref_t entref);
void GScr_HasSeasonPass(scr_entref_t entref);
void __cdecl GScr_AddPlayerStatInternal(gentity_t *playerEnt, ClientNum_t clientNum, const char *statName, statValue_t addValue);
void GScr_AddPlayerStat(scr_entref_t entref);
void __cdecl GScr_AddPlayerStatWithGameTypeInternal(scr_entref_t entref, bool setGlobalStat);
void GScr_AddPlayerStatWithGameType(scr_entref_t entref);
void GScr_AddGameTypeStat(scr_entref_t entref);
void GScr_AddDStat(scr_entref_t entref);
void __cdecl GScr_AddBonusCardStat(scr_entref_t entref);
void GScr_AddWeaponStat(scr_entref_t entref);
void GScr_SetEMPJammed(scr_entref_t entref);
void GScr_IsEMPJammed(scr_entref_t entref);
void GScr_LUINotifyEventPlayer(scr_entref_t entref);
void GScr_TrackWeaponFireNative(scr_entref_t entref);
void ScrCmd_SetActorWeapon(scr_entref_t entref);
void GScr_AddRankXP(scr_entref_t entref);

//t6/code/src_noserver/game/g_scr_mover.cpp
int ScriptMover_UpdateMove(trajectory_t *pTr, vec3_t *vCurrPos, const mover_positions_t *positionControl);
void Reached_ScriptMover(vec3_t *a1, trajectory_t *a2, gentity_t *pEnt);
void ScriptMover_SetupMove(trajectory_t *pTr, const vec3_t *vPos, const float fTotalTime, const float fAccelTime, const float fDecelTime, vec3_t *vCurrPos, mover_positions_t *positionControl);
void ScriptMover_SetupPhysicsLaunch(trajectory_t *pTr, trajectory_t *paTr, const vec3_t *contact_point, const vec3_t *initial_force);
void ScriptMover_SetupMoveSpeed(trajectory_t *pTr, const vec3_t *vSpeed, const float fTotalTime, const float fAccelTime, const float fDecelTime, vec3_t *vCurrPos, mover_positions_t *positionControl);
void ScriptMover_Move(gentity_t *pEnt, const vec3_t *vPos, const float fTotalTime, const float fAccelTime, const float fDecelTime);
void ScriptMover_GravityMove(gentity_t *mover, const vec3_t *velocity, const float totalTime);
void InitScriptMover(gentity_t *pSelf);
void SP_script_brushmodel(gentity_t *self);
void SP_script_model(gentity_t *pSelf);
void SP_script_origin(gentity_t *pSelf);
void ScriptEntCmdGetCommandTimes(float *pfTotalTime, float *pfAccelTime, float *pfDecelTime);
void ScriptEntCmd_MoveTo(char *a1, scr_entref_t entref);
void ScriptEntCmd_GravityMove(scr_entref_t entref);
void ScriptEntCmd_MoveSlide(scr_entref_t entref);
void ScriptEntCmd_StopMoveSlide(scr_entref_t entref);
void ScriptEnt_MoveAxis(scr_entref_t entref, int iAxis);
void ScriptEntCmd_MoveX(scr_entref_t entref);
void ScriptEntCmd_MoveY(scr_entref_t entref);
void ScriptEntCmd_MoveZ(scr_entref_t entref);
void ScriptEntCmd_RotateTo(char *a1, scr_entref_t entref);
void ScriptEnt_DevAddRotate(scr_entref_t entref, int iAxis);
void ScriptEntCmd_DevAddPitch(scr_entref_t entref);
void ScriptEntCmd_DevAddYaw(scr_entref_t entref);
void ScriptEntCmd_DevAddRoll(scr_entref_t entref);
void ScriptEnt_RotateAxis(scr_entref_t entref, int iAxis);
void ScriptEntCmd_RotatePitch(scr_entref_t entref);
void ScriptEntCmd_RotateYaw(scr_entref_t entref);
void ScriptEntCmd_RotateRoll(scr_entref_t entref);
void ScriptEntCmd_Vibrate(scr_entref_t entref);
void ScriptEntCmd_RotateVelocity(char *a1, scr_entref_t entref);
void ScriptEntCmd_SetCanDamage(scr_entref_t entref);
void ScriptEntCmd_SetCheapFlag(scr_entref_t entref);
void ScriptEntCmd_IgnoreCheapEntityFlag(scr_entref_t entref);
void ScriptEntCmd_PhysicsLaunch(scr_entref_t entref);
void ScriptEntCmd_Solid(scr_entref_t entref);
void ScriptEntCmd_NotSolid(scr_entref_t entref);
void (*ScriptEnt_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);

//t6/code/src_noserver/game/g_stepslide.cpp
bool G_SlideMove(unsigned int a1, slide_move_params_t *params);
void G_StepSlideMove(unsigned int a1, slide_move_params_t *parm);

//t6/code/src_noserver/game/g_svcmds.cpp
int StringToFilter(char *s, ipFilter_s *f);
void UpdateIPBans();
void AddIP(ipFilter_s *a1, char *str);
void G_ProcessIPBans();
void Svcmd_AddIP_f();
void Svcmd_RemoveIP_f();
void Svcmd_EntityList_f();
int ConsoleCommand();

//t6/code/src_noserver/game/g_targets.cpp
void G_InitTargets();
void G_LoadTargets();
void Scr_Target_SetShader();
void Scr_Target_SetOffscreenShader();
void Scr_Target_GetArray();
int Target_GetTargetIndex(gentity_t *ent);
void Scr_Target_IsTarget();
void Scr_Target_SetTurretAquire();
void Scr_Target_Set();
char Targ_Remove(gentity_t *ent);
void Targ_RemoveAll();
void Scr_Target_Remove();
bool G_WorldDirToScreenPos(const gentity_t *player, float fov_x, const vec3_t *worldDir, vec2_t *outScreenPos, bool relativeToReticle);
bool ScrGetTargetScreenPos(vec2_t *screenPos, bool relativeToReticle);
void Scr_Target_IsInCircle();
void Scr_Target_IsInRect();
void Scr_Target_StartLockOn();
void Scr_Target_ClearLockOn();
bool G_TargetGetOffset(const gentity_t *targ, vec3_t *result);
bool G_TargetAttackProfileTop(const gentity_t *ent);
void Scr_Target_SetAttackMode();
void Scr_Target_SetJavelinOnly();
$580888C0E76BEA18C0DDD064E36B47DD *Target_GetTargetArray();
void Scr_Target_GetOffset();

//t6/code/src_noserver/game/g_vehicle.cpp
void Vehicle_RegisterDvars();
void VEH_Strdup(unsigned __int8 *pMember, const char *str);
void VEH_DebugCapsule(vec3_t *pos, float rad, float height, float r, float g, float b);
gentity_t *VEH_GetVehicle(int entNum);
BOOL VEH_IsSeatPresent(gentity_t *ent, int seatIdx, const VehicleDef *info);
Weapon VEH_GetSeatWeapon(gentity_t *const vehicle, const int seatIndex);
VehicleSeat *VEH_GetSeat(vehicle_t *veh, int seatIdx);
VehicleSeat *VEH_GetSeat(gentity_t *vehEnt, int seatIdx);
int VEH_GetSeatOccupantEntNum(vehicle_t *veh, int seatIdx);
int VEH_GetSeatOccupantEntNum(gentity_t *vehEnt, int seatIdx);
int VEH_SetSeatOccupantEntNum(vehicle_t *veh, int seatIdx, int occEntNum);
gentity_t *VEH_GetSeatOccupantEntity(vehicle_t *veh, int seatIdx);
gentity_t *VEH_GetSeatOccupantEntity(gentity_t *vehEnt, int seatIdx);
void VEH_GetWheelOrigin(gentity_t *ent, int idx, vec3_t *origin);
bool VEH_DObjHasRequiredTags(gentity_t *ent, int defIndex);
void VEH_InitEntity(gentity_t *ent, vehicle_t *veh, int defIndex);
void VEH_UpdatePhysics(gentity_t *ent, const PlayerVehicleState *vehicleState);
void VEH_JoltBody(gentity_t *ent, const vec3_t *dir, float intensity, float speedFrac, float decel);
void VEH_CalcAccel(gentity_t *ent, char *move, vec3_t *bodyAccel, vec3_t *rotAccel);
void VEH_ClipVelocity(const vec3_t *in, const vec3_t *normal, vec3_t *out);
int VEH_CorrectAllSolid(gentity_t *ent, trace_t *trace);
void VEH_ClearGround();
void VEH_GroundTrace(gentity_t *ent);
void VEH_MoveTrace(gentity_t *ent);
BOOL VEH_SlideMove(gentity_t *ent, int gravity, float frameTime, unsigned int *bumpEntityNum);
void VEH_StepSlideMove(int *a1, float gravity, int a3);
void VEH_SlideMoveAndNotify(gentity_t *ent, int gravity, float frameTime);
void VEH_GroundMove(gentity_t *ent, float frameTime);
void VEH_AirMove(gentity_t *ent, int gravity);
void VEH_GroundPlant(float ent, vec3_t *a2, int a3, gentity_t *phys, vehicle_physic_t *gravity, int a6);
void VEH_BackupPosition(gentity_t *ent);
bool AttachedStickyMissile(gentity_t *vehicle, gentity_t *missile);
void PushAttachedStickyMissile(gentity_t *vehicle, gentity_t *missile, vec3_t *deltaOrigin, vec3_t *deltaAngles);
void VEH_GetBoundingBoxFromCollmap(vec3_t *bbMins, gentity_t *vehicle, vec3_t *bbMaxs);
bool VEH_ClampPointToBoundingBox(gentity_t *a1, vec3_t *a2, gentity_t *vehicle, const vec3_t *point, vec3_t *out);
void VEH_PushEntity(gentity_t *ent, gentity_t *target, vec3_t *pushDir, vec3_t *deltaOrigin, vec3_t *deltaAngles);
void VEH_TouchEntities(gentity_t *ent);
void VEH_DebugAim(gentity_t *ent, const vec4_t *color, int duration);
void VEH_PredictPlayerPosition(const gentity_t *ent, const playerState_s *ps, vec3_t *vPos);
void VEH_UpdateAim(gentity_t *ent);
void VEH_UpdateGunnerAim(gentity_t *ent, int gunnerIndex);
bool Veh_GunnerBurstFirePending(const Weapon weapon, int weaponShotCount);
void VEH_UpdateBody(gentity_t *ent, const VehicleDef *info);
void VEH_UpdateSteering(gentity_t *ent);
void VEH_UpdateQuadrotor(gentity_t *ent);
bool VEH_ShouldEjectOccupants(gentity_t *ent);
void VEH_UpdateAvoidance(vec3_t *pos, vec3_t *goal, float radius, float height, vec3_t *newGoalPos);
bool VEH_IsHovering(vehicle_t *veh);
void VEH_UpdateAngleAndAngularVel(int index, float desiredAngle, float accel, float decel, float overShoot, vehicle_physic_t *phys);
void VEH_SetHoverGoal(gentity_t *ent);
float VEH_UpdateMove_GetDesiredYaw(vehicle_t *veh, vec3_t *desiredDir);
void VEH_UpdateYawAndNotify(gentity_t *ent, float desiredYaw);
void VEH_UpdateVelocityWithRotation(gentity_t *ent);
void VEH_UpdateMoveOrientation(vec3_t *a1, vehicle_t *a2, float desiredYaw, gentity_t *ent);
void VEH_CheckHorizontalVelocityToGoal(vehicle_t *veh, const vec2_t *vecToGoal, float accelMax, vec3_t *accelVec);
void VEH_CheckVerticalVelocityToGoal(vehicle_t *veh, float verticalDist, vec3_t *accelVec);
float VEH_UpdateMove_CheckStop(vehicle_t *veh, float distToGoal);
void VEH_GetNewSpeedAndAccel(vehicle_t *veh, float dt, int hovering, float speedScale, float *newSpeed, float *accelMax);
void VEH_UpdateYawAngularVel(gentity_t *ent, float desiredYaw);
void VEH_UpdateAngle(int index, float desiredAngle, float acceleration, vehicle_physic_t *phys);
void VEH_DebugPlaneOnCurve(gentity_t *ent);
void VEH_UpdatePlaneRoll(gentity_t *ent);
void VEH_UpdatePlaneOnCurve(gentity_t *ent);
void VEH_UpdatePlaneFree(gentity_t *ent);
void VEH_UpdatePathOffset(vehicle_t *veh, const VehicleDef *info, vec3_t *origin, vec3_t *angles);
bool VEH_DoAutoTilt(vehicle_t *veh);
void VEH_UpdatePathTransition(vehicle_t *veh, vec3_t *origin, vec3_t *angles);
double VEH_GetMaxSpeed(gentity_t *ent, bool useGDT);
void VEH_SetLinkAngleClamps(const VehicleDef *info, gentity_t *player, int seatIndex, vec3_t *playerAngles);
void VEH_SetPlayerVehicle(gentity_t *ent, bool enable);
char VEH_ShouldLinkPlayer(gentity_t *ent, gentity_t *player, int seatIndex);
void VEH_LinkPlayer(gentity_t *ent, gentity_t *player, int seatIndex, bool changingSeats);
bool VEH_ExitPosOkay(gentity_t *vehEnt, int exitIndex, vec3_t *origin);
BOOL VEH_IsHorse(gentity_t *ent);
int VEH_GetNextSeat(const VehicleDef *info, int currentSeat);
void G_ParseScrVehicleDef();
void VEH_UpdateViewClampsOnPlayer(gentity_t *ent, const VehicleDef *info);
void G_ReloadVehicleDef();
void G_InitScrVehicles();
void G_SetupScrVehicles(void *notthis);
void G_FreeScrVehicles();
void GScr_GetVehicleArray(int teamFlags, bool spawner);
void G_MakeVehicleUsable(gentity_t *ent, bool usable);
void G_UpdateVehicleTags(gentity_t *ent);
int G_GetNumVehicles();
team_t VEH_GetOccupantsTeam(gentity_t *vehEnt);
bool VEH_IsSeatOccupied(gentity_t *ent, int seatIndex);
int VEH_GetSeatPlayerOccupies(gentity_t *ent, gentity_t *player);
int VEH_GetSeatToEnter(gentity_t *ent, gentity_t *player, bool scriptUse, int *entryPoint);
VehicleMantlePoints VEH_GetPlayerMantlePoint(gentity_t *ent, gentity_t *player);
int VEH_IsUsable(gentity_t *ent, gentity_t *player);
double VEH_GetRadius(vehicle_physic_t *phys);
bool VEH_IsPlayerDriving(const gentity_t *player);
void Scr_Vehicle_Controller(const gentity_t *pSelf, int *partBits);
bool VEH_AvoidTracePassed(const gentity_t *pSelf, const vec3_t *avoidPos);
void VEH_UpdateLink(gentity_t *pSelf);
void Scr_Vehicle_Touch(gentity_t *pSelf, gentity_t *pOther);
vehicle_t *G_GetVehicleTypeString(ClientNum_t clientNum, int entityNum, VehicleDef **vehDef);
void Scr_Vehicle_Use(gentity_t *pEnt, gentity_t *pOther);
int VEH_GetVehicleDefIndex(const gentity_t *vehicle);
const VehicleDef *VEH_GetVehicleDef(const gentity_t *vehicle);
bool VEH_GetWheelBone(gentity_t *vehEnt, int wheelIndex, int *wheelBone);
void VEH_GetBoneOrigin(gentity_t *vehEnt, int boneIndex, vec3_t *result);
int VEH_CanPlayerPlaceVehicle(int a1, const gentity_t *player, const float boundingRadius, const float boundingHeight, const float startForward, const float startUp, const float sweepDistance, const float plancementMinNormal, vec3_t *outOrigin, vec3_t *outAngles);
char VEH_IsOccupied(gentity_t *ent);
int G_LoadVehicle(const char *name);
int VEH_GetDefFromName(const char *name);
char VEH_ValidatePosition(unsigned int a1, gentity_t *ent, const vec3_t *origin);
void VEH_SetPosition(gentity_t *a1, unsigned int a2, gentity_t *ent, const vec3_t *origin, const vec3_t *vel, const vec3_t *angles);
void VEH_InitFromInfo(gentity_t *ent, const VehicleDef *info);
void VEH_InitPhysics(gentity_t *ent, int defIndex);
void VEH_InitVehicle(gentity_t *ent, vehicle_t *veh, int defIndex);
gentity_t *VEH_FireGunnerWeapon(gentity_t *ent, int gunnerIndex, gentity_t *attacker);
bool ShouldCoolDown(vehicle_t *veh, gentity_t *player, const WeaponDef *weapDef, int gunnerIndex, int checkButton);
bool ShouldHeatUp(vehicle_t *veh, gentity_t *player, const WeaponDef *weapDef, int gunnerIndex, int checkButton, bool burstFirePending);
void VEH_UpdateGunnerWeapon(gentity_t *ent, int gunnerIndex, int msec);
void VEH_UpdateDriverWeapons(gentity_t *ent);
void VEH_UpdateClient(gentity_t *ent);
void VEH_UpdatePathPosition(gentity_t *ent, vehicle_pathpos_t *vpp, vec3_t *origin, vec3_t *angles);
void VEH_CheckPathEnd(int a1, gentity_t *ent);
int VEH_UpdateMove_CheckGoalAndNearGoal(gentity_t *ent, vec3_t *goalPosition);
void VEH_UpdateMoveToGoal(gentity_t *ent, const vec3_t *goalPos);
vec3_t *VEH_UpdateMoveToGoalAircraft(gentity_t *ent, const vec3_t *goalPos);
void VEH_UpdateMoveToGoalBoat(gentity_t *ent, const vec3_t *goalPos);
void VEH_UpdateHover(gentity_t *ent);
void VEH_UpdateAIMove(gentity_t *ent);
void VEH_UpdatePath(gentity_t *ent);
void VEH_Update(gentity_t *ent);
void VEH_GetSeatExitPositionAndAngles(gentity_t *vehicle, gentity_t *player, vec3_t *exitOrigin, vec3_t *exitViewAngles);
void VEH_UnseatPlayer(gentity_t *vehicle, gentity_t *player, bool remoteControlled, const char *error_msg, vec3_t *exitOrigin, vec3_t *exitViewAngles);
void VEH_PlayerExit(gentity_t *vehicle, gentity_t *player, int unlinkReasonFlag, bool remoteControlled, const char *error_msg);
void VEH_UnlinkPlayer(gentity_t *player, int unlinkReasonFlag, const char *error_msg);
void VEH_FinishedAnimating(gentity_t *player, pmoveVehAnimState_t vehAnimState);
void VEH_SwitchClientToSeat(gentity_t *ent, gentity_t *player, int seatIndex);
int VEH_NextAvailableSeat(gentity_t *player);
void __cdecl VEH_SwitchClientToNextSeat(gentity_t *ent, gentity_t *player);
void VEH_RinitVehiclesUsingInfo(int defIndex);
char VEH_UpdateField(const char *vehicleDefName, const char *keyValue);
void G_FreeVehicle(gentity_t *ent);
void G_HideVehicle(gentity_t *ent);
int G_GetVehicleDefIndex(const char *name);
bool VEH_IsRemoteControl(gentity_t *vehEnt);
void VEH_Teleport(unsigned int a1, gentity_t *pSelf, vec3_t *origin, vec3_t *angles, vec3_t *vel);
void VEH_UpdateDebug(char *a1, gentity_t *pSelf);
void Scr_Vehicle_Init(gentity_t *pSelf);
void VEH_AvoidUpdate(const gentity_t *pSelf, const vehicle_t *veh, NitrousVehicle *nitrousVeh, const float radius, const vec3_t *pos, const vec3_t *vel, float *goalSpeed, vec3_t *goal);
void VEH_UpdateNitrousPosition(unsigned int a1, char *a2, gentity_t *pSelf);
void Scr_Vehicle_Think(gentity_t *pSelf);
void Launch_Vehicle(gentity_t *ent, int damage, const vec3_t *point, const vec3_t *dir, int mod);
void Scr_Vehicle_Pain(gentity_t *pSelf, gentity_t *pAttacker, int damage, const vec3_t *point, const int mod, const vec3_t *dir, const hitLocation_t hitLoc, const Weapon weapon);
void Scr_Vehicle_Die(gentity_t *pSelf, gentity_t *pInflictor, gentity_t *pAttacker, const int damage, const int mod, const Weapon weapon, const vec3_t *dir, const hitLocation_t hitLoc, int timeOffset);
void SP_script_vehicle(gentity_t *pSelf, SpawnVar *spawnVar);

//t6/code/src_noserver/game/g_vehicle_path.cpp
void VP_AddDebugLine(const vec3_t *start, const vec3_t *end, int forceDraw);
void VP_DebugArrow(const vec3_t *pos, const vec3_t *angles);
void VP_SetScriptVariable(const char *key, const char *value, vehicle_node_t *node);
void VP_ParseFields(vehicle_node_t *node, const SpawnVar *spawnVar, const bool setScriptVariable);
void VP_ClearNode(vehicle_node_t *node);
void VP_InitNode(vehicle_node_t *node, __int16 nodeIdx);
void VP_CopyNode(const vehicle_node_t *src, vehicle_node_t *dst);
vehicle_node_t *VP_GetNodeByIndex(__int16 index);
int VP_GetNextNodeIndex(int index);
__int16 VP_GetNodeIndex(unsigned __int16 name, vec3_t *origin);
void VP_CalcNodeSpeed(__int16 nodeIdx);
void VP_CalcNodeTension(__int16 nodeIdx);
void VP_CalcNodeLookAhead(__int16 nodeIdx);
void VP_CalcNodeRadius(__int16 nodeIdx);
void VP_CalcNodeAngles(__int16 nodeIdx, vec3_t *angles);
float VP_GetSlide(const vehicle_pathpos_t *vpp);
void VP_GetAngles(const vehicle_pathpos_t *vpp, vec3_t *angles);
void VP_GetLookAheadXYZCustom(const vehicle_pathpos_t *vpp, vec3_t *lookXYZ);
void VP_GetLookAheadXYZ(const vehicle_pathpos_t *vpp, vec3_t *lookXYZ);
int VP_UpdatePathPosCustom(vehicle_pathpos_t *vpp);
int VP_UpdatePathPos(vehicle_pathpos_t *vpp, const vec3_t *dir);
int VP_FindClosestPathNode(const vec3_t *pos);
path_t *VP_GetFreeAIPath(int entityNum);
void VP_FreeAIPath(path_t *path);
path_t *VP_GetAIPath(int index);
void VP_UpdateAIPath(const vec3_t *origin, vehicle_pathpos_t *vpp);
void VP_DrawAIPath(const vec3_t *origin, const vehicle_pathpos_t *vpp);
vehicle_custom_path_t *VP_GetFreeCustomPath();
void VP_FreeCustomPath(vehicle_custom_path_t *path);
vehicle_custom_path_t *VP_GetCustomPath(int index);
void VP_DrawCustomPath(const vec3_t *a1, vehicle_custom_path_t *customPath);
void G_LoadVehiclePaths(MemoryFile *memFile);
void G_LoadVehicleHeightMeshes(MemoryFile *memFile);
vehicle_node_t *GetCurrNode(vehicle_pathpos_t *vpp);
void VP_CalcPos(vehicle_pathpos_t *vpp);
void VP_Advance(vehicle_pathpos_t *vpp, float dt, int use_spline_speed, int drivePath);
void VP_DrawPath(vec3_t *p_origin, vehicle_pathpos_t *vpp);
void G_InitVehiclePaths();
void G_FreeVehiclePaths();
void G_FreeVehiclePathsScriptInfo();
void G_SetupSplinePaths(float speed, bool scriptConnect);
void G_ConnectVehiclePaths();
void G_SetupVehiclePaths(float scriptConnect, bool a2);
void G_VehInitPathPos(vehicle_pathpos_t *vpp);
void G_VehFreePathPos(vehicle_pathpos_t *vpp);
void G_VehSetUpPathPos(vehicle_pathpos_t *vpp, __int16 nodeIdx);
int G_VehUpdatePathPos(vehicle_pathpos_t *vpp);
void G_VehSetSwitchNode(vehicle_pathpos_t *vpp, __int16 srcNodeIdx, __int16 dstNodeIdx);
void TRACK_g_vehicle_path();
void SP_info_vehicle_node(const SpawnVar *spawnVar, int rotated, int radiantLiveUpdate);
void G_ClearSelectedVehicleNode();
vehicle_node_t *G_FindVehicleNode(int guid);
__int16 GScr_GetVehicleNodeIndex(unsigned int index);
void GScr_AddFieldsForVehicleNode();
void GScr_GetVehicleNodeField(int entnum, int offset);
void GScr_GetVehicleNode();
void GScr_GetVehicleNodeArray();
void GScr_GetAllVehicleNodes();
void GScr_GetTimeFromVehicleNodeToNode();
void GScr_ReconnectVehicleNodes(float a1);
void GScr_SetVehicleNodeEnabled();
void G_SpawnHeliHeightLock(SpawnVar *spawnVar);
int VP_FindAIPath(const vec3_t *start, const vec3_t *end, vehicle_pathpos_t *vpp, gentity_t *ent, int heightOffset, float radius, float height);
int VP_FindCustomPath(const vec3_t *start, const vec3_t *end, vehicle_pathpos_t *vpp);
double VP_TraversePath(const vehicle_pathpos_t *vpp, const bool draw);
void VP_DrawRaceTrack(__int16 nodeIdx);
void G_DrawVehiclePaths(vec3_t *a1);
void G_ProcessVehicleNodeCommand(float command, const RadiantCommand *a2, SpawnVar *spawnVar);
void GScr_CreateTrack();

//t6/code/src_noserver/game/g_vehicle_phys.cpp
void VEH_ClampAcceleration(vec3_t *acceleration, float maxAcceleration);
BOOL G_IsVehicleHelicopter(const VehicleDef *info);
BOOL G_IsVehiclePlane(const VehicleDef *info);
BOOL G_IsVehicleBoat(const VehicleDef *info);
void VEH_UpdateTiltForAcceleration(vehicle_physic_t *phys, const VehicleDef *info, const vec3_t *vel, const vec3_t *prevVel, float maxAcceleration, float dragScale);
void VEH_UpdatePathFollow(vehicle_physic_t *phys, const VehicleDef *info, vec3_t *origin, vec3_t *angles, int autoTilt, float overrideAccel);

//t6/code/src_noserver/game/g_vehicle_script_cmd.cpp
void TRACK_g_scr_vehicle();
gentity_t *GScr_GetVehicle(scr_entref_t entref);
int VEH_GetSeatFiringOriginAngles(gentity_t *const vehEnt, const int seatIndex, vec3_t *origin, vec3_t *angles);
void VEH_ResetWheels(gentity_t *ent, vehicle_physic_t *phys);
long double GScr_Vehicle_DamageScale(unsigned int a1, unsigned int a2, gentity_t *pSelf, gentity_t *pAttacker, gentity_t *pInflictor, const vec3_t *point, int mod, Weapon weapon, int *damageFromUnderneath);
void GScr_GetNumVehicles();
void GScr_SetHeliHeightPatchEnabled();
void GScr_PrecacheVehicle();
void GScr_GetVehicleTreadFXArray();
bool VEH_IsImmune(gentity_t *ent, int mod, int damageFlags, Weapon weapon);
void (*ScriptVehicle_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
void CMD_VEH_AttachPath(scr_entref_t entref);
void CMD_VEH_GetModel(scr_entref_t entref);
void CMD_VEH_GetAttachPos(scr_entref_t entref);
void CMD_VEH_StartPath(scr_entref_t entref);
void CMD_VEH_DrivePath(scr_entref_t entref);
void CMD_VEH_PathMove(scr_entref_t entref);
void CMD_VEH_PathMoveClear(scr_entref_t entref);
void CMD_VEH_PathFixedOffset(scr_entref_t entref);
void CMD_VEH_PathFixedOffsetClear(scr_entref_t entref);
void CMD_VEH_PathVariableOffset(scr_entref_t entref);
void CMD_VEH_PathVariableOffsetClear(scr_entref_t entref);
void CMD_VEH_GetPathFixedOffset(scr_entref_t entref);
void CMD_VEH_GetPathVariableOffset(scr_entref_t entref);
void CMD_VEH_SetDrivePathPhysicsScale(scr_entref_t entref);
void CMD_VEH_SetSwitchNode(scr_entref_t entref);
void CMD_VEH_Script_SetSpeed(gentity_t *ent);
void CMD_VEH_SetSpeed(scr_entref_t entref);
void CMD_VEH_SetSpeedImmediate(scr_entref_t entref);
void CMD_VEH_GetSpeed(scr_entref_t entref);
void CMD_VEH_GetSpeedMPH(scr_entref_t entref);
void CMD_VEH_GetGoalSpeedMPH(scr_entref_t entref);
void CMD_VEH_SetBrake(scr_entref_t entref);
void CMD_VEH_GetBrake(scr_entref_t entref);
void CMD_VEH_GetHandBrake(scr_entref_t entref);
void CMD_VEH_GetScriptBrake(scr_entref_t entref);
void CMD_VEH_SetAcceleration(scr_entref_t entref);
void CMD_VEH_SetDeceleration(scr_entref_t entref);
void CMD_VEH_ResumeSpeed(scr_entref_t entref);
void CMD_VEH_SetYawSpeed(scr_entref_t entref);
void CMD_VEH_SetMaxPitchRoll(scr_entref_t entref);
void CMD_VEH_SetAirResitance(scr_entref_t entref);
void CMD_VEH_GetSteering(scr_entref_t entref);
void CMD_VEH_GetThrottle(scr_entref_t entref);
void CMD_VEH_SetPhysAngles(scr_entref_t entref);
void CMD_VEH_SetTurningAbility(scr_entref_t entref);
void CMD_VEH_SetJitterParams(scr_entref_t entref);
void CMD_VEH_SetHoverParams(scr_entref_t entref);
void CMD_VEH_JoltBody(scr_entref_t entref);
void CMD_VEH_FreeVehicle(scr_entref_t entref);
void CMD_VEH_GetWheelSurface(scr_entref_t entref);
void CMD_VEH_GetVehicleOwner(scr_entref_t entref);
void CMD_VEH_IsVehicleUsable(scr_entref_t entref);
void CMD_VEH_MakeVehicleUsable(scr_entref_t entref);
void CMD_VEH_MakeVehicleUnusable(scr_entref_t entref);
void CMD_VEH_UseVehicle(scr_entref_t entref);
void CMD_VEH_SetViewClamp();
void CMD_VEH_ResetViewClamp(scr_entref_t entref);
void CMD_VEH_SetVehicleLookatText(scr_entref_t entref);
void CMD_VEH_NearGoalNotifyDist(scr_entref_t entref);
void VEH_GenerateCurveForPlane(gentity_t *ent, vec3_t *goals, int numGoals, const vec3_t *goalAngles);
void CMD_VEH_SetPlaneGoalPos(char *entnum, scr_entref_t entref);
void CMD_VEH_SetPlaneBarrelRoll(scr_entref_t entref);
void CMD_VEH_SetGoalYaw(scr_entref_t entref);
void CMD_VEH_ClearGoalYaw(scr_entref_t entref);
void CMD_VEH_SetTargetYaw(scr_entref_t entref);
void CMD_VEH_ClearTargetYaw(scr_entref_t entref);
void CMD_VEH_SetDefaultPitch(scr_entref_t entref);
void CMD_VEH_ClearDefaultPitch(scr_entref_t entref);
void CMD_VEH_GetAngularVelocity(scr_entref_t entref);
void CMD_VEH_SetAngularVelocity(scr_entref_t entref);
void CMD_VEH_SetVehVelocity(scr_entref_t entref);
void CMD_VEH_SetTurretTargetVec(scr_entref_t entref);
void CMD_VEH_SetTurretTargetEnt(scr_entref_t entref);
void CMD_VEH_ClearTurretTarget(scr_entref_t entref);
void CMD_VEH_SetGunnerTargetVec(scr_entref_t entref);
void CMD_VEH_GetGunnerTargetVec(scr_entref_t entref);
void CMD_VEH_SetGunnerTargetEnt(scr_entref_t entref);
void CMD_VEH_ClearGunnerTarget(scr_entref_t entref);
void CMD_VEH_SetGunnerTurretOnTargetRange(scr_entref_t entref);
void CMD_VEH_GetGunnerTargetEnt(scr_entref_t entref);
void CMD_VEH_GetGunnerAnimPitch(scr_entref_t entref);
void CMD_VEH_GetGunnerAnimYaw(scr_entref_t entref);
void CMD_VEH_SetLookAtEnt(scr_entref_t entref);
void CMD_VEH_ClearLookAtEnt(scr_entref_t entref);
void CMD_VEH_CancelAIMove(scr_entref_t entref);
void CMD_VEH_SetVehicleType(scr_entref_t entref);
void CMD_VEH_GetPhysAcceleration(scr_entref_t entref);
void CMD_VEH_SetPhysAcceleration(scr_entref_t entref);
void CMD_VEH_DrawTrajectory(scr_entref_t entref);
void CMD_VEH_SetRotorSpeed(scr_entref_t entref);
void CMD_VEH_GetMaxSpeed(scr_entref_t entref);
void CMD_VEH_TakePlayerControl(scr_entref_t entref);
void CMD_VEH_ReturnPlayerControl(scr_entref_t entref);
void CMD_VEH_SetWeapon(scr_entref_t entref);
void CMD_VEH_FireWeapon(scr_entref_t entref);
void CMD_VEH_FireGunnerWeapon(scr_entref_t entref);
void CMD_VEH_StopFireWeapon(scr_entref_t entref);
void CMD_VEH_IsTurretReady(scr_entref_t entref);
void CMD_VEH_SetMaxSpeed(scr_entref_t entref);
void CMD_VEH_GetOccupants(scr_entref_t entref);
void CMD_VEH_GetSeatOccupant(scr_entref_t entref);
void CMD_VEH_GetOccupantSeat(scr_entref_t entref);
void CMD_VEH_SetSeatOccupied(scr_entref_t entref);
void CMD_VEH_SeatGetWeapon(scr_entref_t entref);
void CMD_VEH_GetSeatFiringOrigin(scr_entref_t entref);
void CMD_VEH_GetSeatFiringAngles(scr_entref_t entref);
void CMD_VEH_IsGunnerFiring(scr_entref_t entref);
void CMD_VEH_DisableGunnerFiring(scr_entref_t entref);
void CMD_VEH_finishVehicleDamage(scr_entref_t entref);
void CMD_VEH_finishVehicleRadiusDamage(scr_entref_t entref);
void CMD_VEH_IsVehicleImmuneToDamage(scr_entref_t entref);
void CMD_VEH_SetMantleEnabled(scr_entref_t entref);
void CMD_VEH_SetVehicleAvoidance(scr_entref_t entref);
void CMD_VEH_GetVehicleAvoidance(scr_entref_t entref);
void CMD_VEH_CanSee(scr_entref_t entref);
void CMD_VEH_SeenRecently(scr_entref_t entref);
void CMD_VEH_ClearEnemy(scr_entref_t entref);
void CMD_VEH_SetEntityTarget(scr_entref_t entref);
void CMD_VEH_ClearEntityTarget(scr_entref_t entref);
void CMD_VEH_GetTurretHeatValue(scr_entref_t entref);
void CMD_VEH_IsVehicleTurretOverheating(scr_entref_t entref);
void CMD_VEH_SetPathTransitionTime(scr_entref_t entref);
void CMD_VEH_GetVehicleAvoidanceNodes(scr_entref_t entref);
void CMD_VEH_MakeSentient(scr_entref_t entref);
void CMD_VEH_SetGoalPos(int a1, scr_entref_t entref);
void CMD_VEH_ClearGoalPos(scr_entref_t entref);

//t6/code/src_noserver/game/g_weapon.cpp
void Weapon_SetWeaponParamsWeapon(weaponParms *wp, Weapon weapon);
void G_AntiLagRewindClientPos(int gameTime, AntilagClientStore *antilagStore);
void G_AntiLagRewindClientIndexPos(int clientNum, AntilagClientStore *antilagClients);
void G_AntiLag_RestoreClientPos(AntilagClientStore *antilagStore);
actorAntilagFrame_t *G_GetActorAntilagFrame(int *time);
void G_GetActorPositionsFromCache(actorAntilagFrame_t *frame, vec3_t **pos, vec3_t **angles, bool *success);
bool G_GetActorPositionsAtTime(int gametime, vec3_t *pos, vec3_t *angles, bool *success);
void G_AntiLag_RewindActorPos(int gameTime, antilagActorStore_t *antilagStore);
void G_AntiLag_RestoreActorPos(antilagActorStore_t *antilagStore);
void G_ArchiveActorAntilagFrame();
vehicleAntilagFrame_t *G_GetVehicleAntilagFrame(int *time);
void G_GetVehiclePositionsFromCache(vehicleAntilagFrame_t *frame, vec3_t **pos, vec3_t **angles, bool *success);
bool G_GetVehiclePositionsAtTime(int gametime, vec3_t *pos, vec3_t *angles, bool *success);
void G_AntiLag_RewindVehiclePos(char *a1, int gameTime, antilagVehicleStore_t *antilagStore);
void G_AntiLag_RestoreVehiclePos(antilagVehicleStore_t *antilagStore);
void G_ArchiveVehicleAntilagFrame();
gentity_t *Weapon_Throw_Grenade(gentity_t *ent, Weapon grenType, unsigned __int8 grenModel, weaponParms *wp, bool pumpScripts);
gentity_t *Weapon_GrenadeLauncher_Fire(gentity_t *ent, Weapon grenType, unsigned __int8 grenModel, weaponParms *wp, bool pumpScripts);
gentity_t *Weapon_RocketLauncher_Fire(gentity_t *ent, Weapon weapon, float spread, weaponParms *wp, const vec3_t *gunVel, gentity_t *target, const vec3_t *targetOffset, bool pumpScripts);
gentity_t *Weapon_BombDrop_Fire(gentity_t *ent, Weapon weapon, float spread, weaponParms *wp, const vec3_t *gunVel, gentity_t *target, const vec3_t *targetOffset);
void Weapon_Overheat_Update(gentity_t *ent);
void Weapon_Flamethrower_Update(gentity_t *ent, weaponParms *wp);
void Weapon_Flamethrower_Fire(gentity_t *ent, weaponParms *wp);
BOOL LogAccuracyHit(gentity_t *target, gentity_t *attacker);
void G_CalcMuzzlePoints(const gentity_t *ent, weaponParms *wp, int shotCount);
Weapon G_GetWeaponDefBasedOnNumberOfBullets(int numBulletsQueued, Weapon weapon);
void FireWeapon(gentity_t *ent, int gametime, int shotCount);
void DeployWeapon(unsigned int a1, clientDebugLineInfo_t *a2, gentity_t *ent);
void BreakDownWeapon(gentity_t *ent);
void G_UseOffHand(gentity_t *ent);
void G_UpdatePlayerWeaponOptions(playerState_s *pPS, Weapon weapon, renderOptions_s weaponOptions);
Weapon G_GetWeaponForName_Internal(const char *name);
Weapon G_GetWeaponForName(const char *name);
int G_GetBaseWeaponItemIndex(const char *pszWeaponName, int *attachmentBits, int *weaponIdx);
void G_SelectWeapon(ClientNum_t clientNum, Weapon weapon);
void G_SetEquippedOffHand(ClientNum_t clientNum, Weapon offHandWeapon);
Weapon G_PlayerTurretWeapon(const playerState_s *ps);
Weapon G_GetPlayerVehicleWeapon(const playerState_s *ps);
Weapon G_GetPlayerWeapon(const playerState_s *ps);
unsigned int G_GetShieldTagName(const gentity_t *ent);
char G_GetShieldTagMatrix(const gentity_t *ent, vec3_t *resultMatrix);
void G_AddShieldSplashDamageEvent(gentity_t *ent, float originalDamageRawPoints, float originalDamageScale, float shieldProtection);
bool Melee_Trace(gentity_t *ent, vec3_t *hitOrigin);
void Weapon_Melee_NotifyClient(gentity_t *attacker, gentity_t *victim, int eventType, const Weapon weapon, vec3_t *hitOrigin, vec3_t *hitDir, unsigned __int16 boneIndex, bool shieldHit);
gentity_t *Weapon_Melee_internal(gentity_t *ent, weaponParms *wp);
gentity_t *Weapon_Melee(gentity_t *ent, weaponParms *wp, float range, float width, float height, int gametime);
void Weapon_Napalm_Flame(gentity_t *ent, trace_t *trace, int count);
void FireWeaponMelee(gentity_t *ent, int gametime);
int G_GivePlayerWeapon(playerState_s *pPS, Weapon weapon, unsigned __int8 altModelIndex, renderOptions_s weaponOptions);
void G_SetupWeaponDef();
double G_GetShieldCosOfAngleToPoint(const gentity_t *shieldHolder, const vec3_t *point);
void G_GetShieldTagNormal(const gentity_t *ent, vec3_t *resultNormal);
double G_GetShieldBlastDamageProtection(gentity_t *ent, const vec3_t *blastOrigin);

//t6/code/src_noserver/game/g_weapon_load_obj.cpp
bool G_ParseAIWeaponAccurayGraphFile(const char *buffer, const char *fileName, vec2_t *knots, int *knotCount);
bool G_ParseWeaponAccurayGraphInternal(WeaponDef *weaponDef, const char *dirName, const char *graphName, vec2_t *knots, int *knotCount);
char G_ParseWeaponAccurayGraphs(WeaponDef *weaponDef);

//t6/code/src_noserver/game/g_zbarrier.cpp
void G_RunZBarrier(gentity_t *ent);
void ZBarrier_SetCollisionState(gentity_t *ent, int pieceIndex, bool onOff);
void ZBarrier_SetPieceState(gentity_t *pSelf, int pieceIndex, int state, float scalar);
void ZBarrier_Think(gentity_t *pSelf);
void G_ZBarrier_FinishSpawningAll();
int SP_ZBarrier(gentity_t *ent);

//t6/code/src_noserver/game/linkto.cpp
int G_EntLinkToUpdateOffset(gentity_t *ent, const vec3_t *originOffset, const vec3_t *anglesOffset);
BOOL G_EntIsLinked(gentity_t *ent);
BOOL G_EntIsLinkedTo(gentity_t *ent, gentity_t *parent);
void G_UpdateTagInfoOfChildren(gentity_t *parent, int bHasDObj);
void G_CalcTagParentAxis(gentity_t *ent, vec3_t *parentAxis);
void G_CalcTagParentRelAxis(gentity_t *ent, vec3_t *parentRelAxis);
void G_CalcTagAxis(gentity_t *ent, int bAnglesOnly);
void G_CalcFixedLinkTargetAxis(gentity_t *ent, vec3_t *axis);
int G_SetFixedLinkNonPlayer(gentity_t *ent, const int eAngles, const int contentMask, vec3_t *outTargetOrigin);
void G_DefaultViewAngleClampGoal(viewClampState *clamp);
void G_SnapToViewAngleClampGoal(viewClampState *clamp);
__int64 CalcLerpFraction(float startTime, __int64 a2, float a3, float a4);
void G_UpdateViewAngleClamp(gclient_t *,vec3_t const &);
void G_InitPlayerLinkAngles(gentity_t *ent);
void G_GeneralLink(gentity_t *ent);
bool SetPlayerVehicleLinkViewAngles(gentity_t *ent);
void SetPlayerFixedLinkViewAngles(gentity_t *ent, const vec3_t *worldAxis, float lerpFraction);
void SetPlayerFixedLinkOrigin(gentity_t *ent, const vec3_t *worldAxis, float lerpFraction);
void G_SetFixedLinkPlayer(char *a1, gentity_t *ent);
void G_TransferLinkedEntities(gentity_t *from, gentity_t *to);
char G_ShouldClientLinkTo();
void EntUnlink_Internal(gentity_t *ent);
int EntLinkTo_Internal(gentity_t *ent, gentity_t *parent, unsigned int tagName);
int __cdecl G_EntLinkTo(gentity_t *ent, gentity_t *parent, unsigned int tagName);
int __cdecl G_EntLinkToWithOffset(gentity_t *ent, gentity_t *parent, unsigned int tagName, const vec3_t *originOffset, const vec3_t *anglesOffset);
void G_EntUnlink(gentity_t *ent);

//t6/code/src_noserver/game/pathnode.cpp
vec3_t *Path_GetPillarStandOverOffset();
void TRACK_pathnode();
int Node_DangerousCount(const pathnode_t *pNode, const team_t team);
BOOL Node_IsDangerous(const pathnode_t *pNode, const team_t team);
BOOL Node_IsFriendly(const pathnode_t *pNode, const team_t team);
void Node_MarkDangerous(pathnode_t *pNode, const team_t team, const int dangerous);
void Scr_FindPath();
void Path_GetType(pathnode_t *node);
void Scr_SetPathnodeField(int entnum, int offset);
void Scr_GetPathnodeField(int entnum, int offset);
void Path_CallFunctionForNodes(scriptInstance_t inst, void (*function)(scriptInstance_t, pathnode_t *));
void PathNode_UpdateStringField(const char *destKey, unsigned __int16 *destScrString, const char *key, const char *value);
void PathNode_UpdateFloatField(const char *destKey, float *destFloat, const char *key, const char *value);
void parented_pathnode_list_delete(gentity_t *gent);
void G_UpdateTrackExtraNodes();
void GScr_AddFieldsForPathnode();
void ScrCmd_SetDangerousNode(scr_entref_t entref);
void ScrCmd_IsDangerousNode(scr_entref_t entref);
pathnode_t *Scr_GetPathnode(scriptInstance_t inst, unsigned int index);
void G_FreePathnodesScriptInfo();
bool Path_CompareNodesIncreasing(const pathsort_t *ps1, const pathsort_t *ps2);
unsigned int Path_ConvertNodeToIndex(const pathnode_t *node);
pathnode_t *Path_ConvertIndexToNode(int index);
void Path_Init(int restart);
int NodeSmoothCacheEntry(int i, int j);
BOOL Path_NodesSmooth(const pathnode_t *node0, const pathnode_t *node1);
void Path_NodesInCylinder_process(pathnode_t *pnode);
int Path_IsDynamicBlockingEntity(gentity_t *ent);
int Path_IsBadPlaceLink(int nodeNumFrom, int nodeNumTo, team_t eTeam);
void Path_InitLinkCounts();
int Path_InitLinkInfoArray();
GameWorldMp *Path_InitNodesDynamic();
void Path_PreSpawnInitPaths();
void Path_CheckSpawnExitNodesConnectivity();
void Path_DrawDebugNoLinks(const vec3_t *a1, const pathnode_t *node, const vec4_t *color);
void Path_DrawDebugLink(float node, const pathnode_t *a2, const int i, const bool bShowAll, float heightOffset, const int showNodeDrawType);
void Path_GetCornerNodeCheckOffset(const pathnode_t *node, vec3_t *offset);
void Path_GetPeekOutLine(const pathnode_t *node, const vec3_t *offset, vec3_t *start, vec3_t *end);
void Path_DrawDebugPeekOuts(const pathnode_t *node);
void Path_DrawDebugFindPath(int a1, const vec3_t *vOrigin);
double Path_NodeActorAngle(const pathnode_t *node);
BOOL Path_NodesVisible(const pathnode_t *node0, const pathnode_t *node1);
BOOL Path_ExpandedNodeVisible(const pathnode_t *node0, const pathnode_t *node1);
BOOL Path_NodeSafeFrom(const pathnode_t *node0, const pathnode_t *node1);
pathnode_t *Path_FirstNode(int typeFlags);
bool Path_IsDynamicallySpawnedNode(pathnode_t *node);
pathnode_t *Path_NextNode(pathnode_t *prevNode, int typeFlags);
int Path_IsOnlyOwner(const pathnode_t *node, const sentient_t *owner);
sentient_t *Path_GetNodeOwner(const pathnode_t *node);
int Path_CanStealPriorityNode(const pathnode_t *node, sentient_t *claimer);
bool Path_CanStealNode(const pathnode_t *node, sentient_t *claimer);
void Path_ClaimNodeInternal(pathnode_t *node, sentient_t *claimer);
void Path_MarkNodeOverlap(pathnode_t *node);
void Path_ClaimNode(pathnode_t *node, sentient_t *claimer);
void Path_RevokeClaim(pathnode_t *node, sentient_t *pNewClaimer);
void Path_RelinquishNode(sentient_t *claimer, int timeUntilRelinquished);
BOOL Path_IsReallyDangerousNode(const pathnode_t *node, team_t eTeam);
unsigned int Path_IsNodeNegotiationHint(const pathnode_t *node);
int Path_AllowedStancesForNode(pathnode_t *node);
pathnode_t *Path_LoadNode(unsigned int index);
void Path_ValidateNode(pathnode_t *node);
void Path_ValidateAllNodes();
void Path_CheckLinkLeaks();
void Path_CheckUserCountLeaks();
void Path_DisconnectPath(pathnode_t *node, pathlink_s *link);
void Path_ConnectPath(pathnode_t *node, pathlink_s *link);
void Path_UpdateBadPlaceCountForLink(pathlink_s *link, int teamflags, int delta);
void Path_UpdateHasBadPlaceLink(pathnode_t *node);
void Path_UpdateArcBadPlaceCount(float arc, badplace_arc_t *a2, int teamflags, int delta);
void Path_CheckForInwardLinks(pathnode_t *node, int currDepth, int maxDepth, float fRadiusSqrd, float fHeightSqrd, float fMaxRadiusSqrd, float fMaxHeightSqrd, vec3_t *centroid, badplace_arc_t *arc, vec3_t *side0, vec3_t *side1, int teamflags, int delta);
int Path_IsNodeInArc(pathnode_t *pNode, const vec3_t *origin, float radius, float angle0, float angle1, float halfHeight);
void ReadEntityDisconnectedLinks(gentity_t *ent, MemoryFile *memFile);
BOOL IsNodeEnabled(const pathnode_t *pNode);
void G_DeleteRunTimePathnode(pathnode_t *node);
pathnode_t *G_FindPathNode(int guid);
void G_ClearSelectedPathNode();
void Scr_SetNodePriority();
void Scr_IsNodeOccupied();
void Scr_GetNodeOwner();
void Scr_SetTurretNode();
void Scr_UnsetTurretNode();
void parented_pathnode_list_add(pathnode_parent_t *node_parent);
void parented_pathnode_list_update(unsigned int a1, gentity_t *gent, const phys_mat44 *mat, const vec3_t *delta_angles);
void parented_pathnode_lists_reset_position(int a1, generic_avl_map_node_t *gamn);
bool pathnode_is_resized(pathnode_t *node);
pathnode_parent_t *get_pathnode_parent(const pathnode_t *node);
int get_pathnode_parent_entity(const unsigned int pathnode_i);
int Node_DoesLink(const pathnode_t *nodeA, const pathnode_t *nodeB);
int G_NodeValidLink(const pathnode_t *pNode);
void G_MarkBadPathnodes();
void Scr_AddPathnode(scriptInstance_t inst, pathnode_t *node);
void Scr_GetNode();
void Scr_GetNodeArray();
void Scr_GetAllNodes();
void Scr_GetVisibleNode();
void Scr_NodesVisible();
void Scr_GetVisibleNodes();
void Scr_NodesCanPath();
void Scr_CanClaimNode();
void Scr_SetEnableNode();
void Scr_DeletePathNode();
void Path_Shutdown();
void Path_NodesInCylinder_r(pathnode_tree_t *tree);
void Path_MovingNodesInCylinder();
int Path_NodesInCylinder(const vec3_t *origin, const vec3_t *enemyPos, float maxDist, float maxHeight, pathsort_t *nodes, int maxNodes, int typeFlags, int spawnFlags);
int Path_NodesInRadius(const vec3_t *origin, float maxDist, pathsort_t *nodes, int maxNodes, int typeFlags, int spawnFlags);
void Path_InitPaths();
void Path_DrawDebugNodeBox(const pathnode_t *node, float size, const vec4_t *color_, int depthTest);
void Path_DrawDebugNodeBox(const vec4_t *a1, int a2, const pathnode_t *node, const vec4_t *color, int depthTest);
void Path_DrawDebugNode(char *a1, const vec3_t *cameraPos, const pathnode_t *node);
void Path_DrawVisData();
void Path_RelinquishNodeNow(sentient_t *claimer);
void Path_MarkNodeInvalid(pathnode_t *node, team_t eTeam, int invalidTime);
void Path_MarkAllConnectedNodesDangerous(pathnode_t *node, team_t eTeam);
void Path_ConnectPathsForEntity(gentity_t *ent);
void Path_DisconnectPathsForEntity(char *a1, gentity_t *ent);
void Path_UpdateBrushBadPlaceCount(gentity_t *brushEnt, int teamflags, int delta);
void G_SetPathnodeScriptVariable(const char *key, const char *value, pathnode_t *ent);
void G_ParsePathnodeScriptFields(pathnode_t *node, SpawnVar *spawnVar);
void parented_pathnode_lists_construct();
void destroy_pathnode_resized_links(void *prl_);
pathnode_resized_links_t *pathnode_resized_links_get(pathnode_t *node);
int Path_AreNodesLinked(pathnode_t *node_from, pathnode_t *node_to);
void pathnode_resized_links_add(pathnode_t *node_from, pathnode_t *node_to, bool bWarnAboutDupeLinks);
void pathnode_resized_links_remove(pathnode_t *node_from, pathnode_t *node_to);
void destroy_pathnode_parent(void *node_parent);
void setup_pathnode_parent(pathnode_t *node, const int entnum, const vec3_t *origin_loc);
void level_init_pathnode_parernt_system(int restart);
void pathnode_resized_links_load(MemoryFile *memFile);
void pathnode_parent_load(MemoryFile *memFile);
void pathnode_load(MemoryFile *memFile);
void node_droptofloor(int a1, pathnode_t *node, int force_drop);
void G_DropPathNodeToFloor(pathnode_t *a1, unsigned int nodeIndex);
void G_DropPathnodesToFloor();
void G_SpawnPathnodeDynamic(SpawnVar *spawnVar, pathnode_t *spawnedNode);
void Scr_DrawNode();
void Scr_LinkNodes();
void Scr_UnLinkNodes();
void Scr_NodesAreLinked();
void Scr_DropNodeToFloor(int a1);
void Path_AutoDisconnectPaths();
int Path_CanClaimNode(const pathnode_t *node, sentient_t *claimer);
void Path_ForceClaimNode(pathnode_t *node, sentient_t *claimer);
void G_ProcessPathnodeCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void Scr_SpawnPathNode();
void GetNodesInRadius(int sorted);
void Scr_GetNodesInRadius();
void Scr_GetNodesInRadiusSorted();
pathnode_t *Path_NearestNodeNotCrossPlanes(const vec3_t *vOrigin, pathsort_t *nodes, int typeFlags, float fMaxDist, PathBlockPlanes *blockPlanes, int *returnCount, int maxNodes, nearestNodeHeightCheck heightCheck, int ownerEnt, float physRadius, float physHeight, int spawnFlags);
void Path_UpdateLimitedDepthArcBadPlaceCount(badplace_arc_t *arc, int teamflags, int delta, int depth);
void Scr_GetNodeArraySorted();
void Scr_GetCoverNodeArray();
void Scr_GetAnyNodeArray();
void Path_DrawDebugNearestNode(const vec3_t *vOrigin);
pathnode_t *Path_NearestNodeNoHeightCheck(const vec3_t *vOrigin, int ownerEnt, float physRadius, float physHeight, int spawnFlags);
pathnode_t *Path_NearestNode(const vec3_t *vOrigin, PathBlockPlanes *blockPlanes, int ownerEnt, float physRadius, float physHeight, int spawnFlags);
void Scr_GetNearestNode();
bool Path_InitializeSpawns(pathnode_t **spawns);
void Path_FlagUnconnectedNode(pathnode_t *node);
void Path_DrawDebugUnconnected(pathnode_t *node);
void Path_DrawDebug(int a1);
void Path_Update();

//#include "game/pathnode.h"

//#include "game/pathnode_load_db.h"

//t6/code/src_noserver/game/pathnode_load_obj.cpp
void Path_CreateNodes();
void Path_InitStatic(int restart);
void Path_ShutdownStatic();
void G_ParsePathnodeField(const char *key, const char *value, pathnode_t *node);
void G_ParsePathnodeFields(SpawnVar *a1, SpawnVar *spawnVar, pathnode_t *node, nodeType type);
void SP_spawn_node(const char *a1, SpawnVar *spawnVar, nodeType type);
pathnode_t *SP_spawn_node_dynamic(const char *a1, SpawnVar *spawnVar, nodeType type);
int G_GetNodeTypeFromClassname(const char *classname);
void G_SpawnPathnodeStatic(SpawnVar *spawnVar, const char *classname);
pathnode_t *G_SpawnPathnodeStaticRunTime(SpawnVar *spawnVar, const char *classname);
void Scr_FreePathnodeFields(pathnode_t *node);
void Path_ErasePaths(const char *pathsError);
bool Path_AreBackToBackCornerNodes(pathnode_t *node, pathnode_t *otherNode);
BOOL Path_FindOverlappingNodes();
pathnode_tree_t *Path_BuildNodeBsp_r(unsigned __int16 *nodes, int numNodes);
void Path_DisconnectChokeLinks(unsigned int nodeAIndex, unsigned int nodeBIndex, unsigned int nodeALink, unsigned __int16 *newLinkCounts);
bool Path_DisconnectNodeForChokePoint(unsigned int nodeAIndex, unsigned int chokeIndex, unsigned __int16 *newLinkCounts);
pathlink_s *Path_DisconnectNodesOnOppositeSideOfChokeNode(pathlink_s *pSourceLinks, unsigned int *totalLinkCount);
bool Path_LinkIsDynamic(unsigned __int16 from, unsigned __int16 to);
bool Path_TwoWayLink(unsigned __int16 from, unsigned __int16 to);
char Path_FindLinkToNode_r(const pathnode_t *searchNode, unsigned __int16 searchIndex, unsigned __int16 fromIndex, unsigned __int16 goalIndex, int *currentDepth, const int maxDepth);
bool Path_RemoveRedundantLink(const pathnode_t *sourceNode, unsigned int sourceIndex, unsigned __int16 goalIndex);
void Path_DisconnectLink(pathnode_t *nodeA, pathnode_t *nodeB, bool removeRedundantLinks);
pathlink_s *Path_OptimizeGraph(char *a1, pathlink_s *pSourceLinks, unsigned int *totalLinkCount, bool removeRedundantLinks);
bool Path_IsSafeToMoveBetweenNodes(const pathnode_t *nodeFrom, const pathnode_t *nodeTo);
bool Path_CornerSafeLinkCheck(pathnode_t *nodeFrom, pathnode_t *nodeTo);
void Path_MarkSafeShuffleLinks();
bool isDeflectionOK(float *a1, float *a2, float movedir, const vec2_t *a4);
bool Path_NodeCanBeDoubleWide(unsigned int a1, pathnode_t *node);
bool Path_NodeCanBeQuadrotorNode(unsigned int a1, col_context_t *a2, pathnode_t *node, const float defaultHeightOffset);
void GetNodeAttackPoint(const pathnode_t *node, vec3_t *attackPos);
int Path_GetExpandedNodeNums_r(int iNodeStart, float fDistLeft, int *iNodeNums, int iNodeCount);
int Path_CheckExpandedNodeVis(int (*iNodeNums)[8192], int *iNodeCount, unsigned __int8 *visbuf);
void Path_BuildNodeVis(unsigned __int8 *visbuf, int iVisCacheSize);
bool Path_SmoothPathIsFloating(const vec3_t *vStart, const vec3_t *vEnd);
void Path_BuildSmoothCache(unsigned __int8 *smoothBuf, int smoothSize);
void Path_SavePaths();
bool Path_CornerNodeCheck(pathnode_t *node);
void Path_MarkValidCoverNodePeekOuts();
pathlink_s *G_GetNextAvailableTempLinks();
void Path_MakePathDataPermanent(pathlink_s *pSourceLinks, unsigned int totalLinkCount, unsigned __int8 *pVis, int visBytes, unsigned __int8 *pSmooth, int smoothBytes);
int Path_LoadPathsInternal();
void Path_LoadPaths();
int Path_CanLinkQuadrotorNodes(pathnode_t *pNodeFrom, pathnode_t *pNodeTo);
int Path_CanLinkNodes(pathnode_t *pNodeFrom, int *pbNegotiationLink);
bool Path_AttemptLink1(pathnode_t *pNodeFrom, pathnode_t *pNodeTo, pathlink_s *pLinks, int iMaxLinks);
bool __cdecl Path_AttemptLink(pathnode_t *pNodeFrom, pathnode_t *pNodeTo, pathlink_s *pLinks, int iMaxLinks);
void Path_ConnectPaths();
void Path_ConnectPathsForSingleNode(pathnode_t *node);

//t6/code/src_noserver/game/scr_const.cpp
void initBoneMap();
void GScr_LoadConsts();

//t6/code/src_noserver/game/sentient.cpp
sentient_t *Sentient_Alloc(gentity_t *ent);
void Sentient_DissociateSentient(sentient_t *self, sentient_t *other);
void Sentient_GetOrigin(const sentient_t *self, vec3_t *vOriginOut);
void Sentient_GetVelocity(const sentient_t *self, vec3_t *vVelOut);
void Sentient_GetCentroid(const sentient_t *self, vec3_t *vCentroidOut);
void Sentient_GetEyePosition(const sentient_t *self, vec3_t *vEyePosOut);
void Sentient_GetThirdPersonEyePosition(const sentient_t *self, vec3_t *vEyePosOut);
void Sentient_GetDebugEyePosition(const sentient_t *self, vec3_t *vEyePosOut);
pathnode_t *Sentient_NearestNode(sentient_t *self);
pathnode_t *Sentient_NearestNodeSuppressed(sentient_t *self, PathBlockPlanes *blockPlanes);
void Sentient_InvalidateNearestNode(sentient_t *self);
void Sentient_SetEnemy(sentient_t *self, gentity_t *enemy, int bNotify, int resetThreatUpdate);
sentient_t *Sentient_FirstSentient(const int iTeamFlags);
sentient_t *Sentient_NextSentient(sentient_t *pPrevSentient, const int iTeamFlags);
const char *Sentient_NameForTeam(team_t eTeam);
void Sentient_SetTeam(sentient_t *self, team_t eTeam);
void Sentient_ClaimNode(sentient_t *self, pathnode_t *node);
void Sentient_NodeClaimRevoked(sentient_t *self, pathnode_t *node);
void Sentient_StealClaimNode(sentient_t *self, sentient_t *other);
void Sentient_BanNearNodes(sentient_t *self);
void G_InitSentients();
bool Sentient_NearestNodeDirty(sentient_t *self, bool originChanged);
int Sentient_IsEnemyIndoor(sentient_t *self);
void Sentient_Dissociate(sentient_t *pSentient);
void Sentient_Free(sentient_t *sentient);

//#include "game/sentient.h"

//t6/code/src_noserver/game/sentient_fields.cpp
void SentientScr_ReadOnly(sentient_t *pSelf, const sentient_fields_s *pField);
void SentientScr_GetTeam(sentient_t *pSelf);
void GScr_AddFieldsForSentient();
void Scr_SetSentientField(const char *a1, sentient_t *sentient, int offset);
void Scr_GetSentientField(sentient_t *sentient, int offset);
void SentientScr_SetTeam(sentient_t *pSelf);

//t6/code/src_noserver/game/turret.cpp
void Turret_RegisterDvars();
void G_InitTurrets();
void Turret_SetMinimapVisible(gentity_t *self, int isVisible);
void Fire_Lead(gentity_t *ent, gentity_t *activator, int bUseAccuracy);
void turret_shoot_internal(gentity_t *self, gentity_t *other);
void turret_UpdateSound(gentity_t *self);
void turret_CalculateConvergenceAngularVelocity(const gentity_t *self, const vec2_t *desiredAngles, vec2_t *angularVelocity);
void Turret_ScanStart(gentity_t *self, const WeaponDef *weapDef, float deltaYaw);
void Turret_ScanStop(gentity_t *self);
void Turret_ScanForEnemies(gentity_t *self);
int turret_UpdateTargetAngles(gentity_t *a1, char *a2, gentity_t *self, const vec2_t *desiredAngles, int bManned);
BOOL turret_IsFiring(gentity_t *self);
void turret_SetState(gentity_t *self, int state);
void turret_ClearTargetEnt(gentity_t *self);
void turret_SetDefaultDropPitch(gentity_t *self, float pitch);
void turret_SetScanningPitch(gentity_t *self, float pitch);
void turret_shoot(gentity_t *a1, gentity_t *self);
int turret_CanTargetPoint(const gentity_t *self, const vec3_t *vPoint, vec3_t *vSource, vec2_t *localAngles);
void Turret_PredictPosition(const gentity_t *ent, const playerState_s *ps, vec3_t *vPos);
int turret_CanTargetSentient(const playerState_s *a1, vec3_t *a2, vec3_t *self, const gentity_t *sentient, const sentient_t *targetPosition, vec3_t *muzzlePosition, vec3_t *localAngles, vec2_t *a8);
void turret_aimat_vector_internal(gentity_t *self, const vec3_t *origin, int bShoot, const vec2_t *desiredAngles);
int turret_aimat_vector(gentity_t *self, vec3_t *origin, int bShoot, vec2_t *desiredAngles);
void turret_SetTargetEnt(gentity_t *self, gentity_t *ent);
int turret_aimat_Sentient_Internal(gentity_t *self, sentient_t *enemy, int bShoot, int missTime, vec2_t *desiredAngles);
int turret_aimat_Sentient(gentity_t *self, sentient_t *enemy, int bShoot, int missTime);
int turret_aimat_Ent(gentity_t *self, gentity_t *ent, int bShoot);
int turret_SightTrace(const vec3_t *start, const vec3_t *end, int passEnt1, int passEnt2, gentity_t *turret);
int turret_isTargetVisible(gentity_t *self, const gentity_t *target, float *distSqr);
gentity_t *turret_findBestKillstreakTarget(gentity_t *self);
gentity_t *turret_findBestGroundKillstreakTarget(gentity_t *self);
sentient_t *turret_findBestTarget(char *a1, gentity_t *self);
void turret_target_sentry(gentity_t *self, TurretInfo *turretInfo);
void turret_target_killstreak(gentity_t *self, TurretInfo *turretInfo);
void turret_think_auto_nonai(gentity_t *self);
void turret_RestoreDefaultDropPitch(unsigned int a1, gentity_t *self);
void turret_UpdateOverheating(gentity_t *self, gentity_t *owner);
void turret_think(char *a1, gentity_t *self);
void turret_controller(const gentity_t *self, int *partBits);
int turret_behind(gentity_t *self, gentity_t *other);
BOOL G_IsTurretUsable(gentity_t *a1, gentity_t *a2, gentity_t *self, gentity_t *owner);
void G_DeactivateTurret(gentity_t *self);
void turret_find_max_angles(unsigned int a1, gentity_t *pOwner, gentity_t *pTurret);
void SP_turret(gentity_t *self, SpawnVar *spawnVar);
void Turret_SetTurretCarried(gentity_t *self, int carried);
void Turret_SetTurretOwner(gentity_t *self, gentity_t *owner);
void G_PlayerTurretPositionAndBlend(gentity_t *ent);
void turret_clientaim(gentity_t *self, gentity_t *other);
void turret_track(gentity_t *self, gentity_t *other);
void G_ClientStopUsingTurret(gentity_t *self);
void turret_think_client(gentity_t *self);
void turret_think_init(gentity_t *self);
void G_FreeTurret(gentity_t *self);
void turret_use(gentity_t *self, gentity_t *owner);
void Turret_ScrRemoteUse(gentity_t *self, gentity_t *owner);
void Turret_ScrStopRemoteUse(gentity_t *self, gentity_t *owner);

//t6/code/src_noserver/game/vehicle_fields.cpp
void GScr_AddFieldsForVehicle();
void Scr_SetVehicleField(gentity_t *pSelf, int offset);
void Scr_GetVehicleField(gentity_t *pSelf, int offset);
void VehicleScr_ReadOnly(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetVehicleDefField(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_SetVehicleType(gentity_t *pSelf);
void VehicleScr_GetVehicleClass(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetVehicleTreadFxArray(gentity_t *pSelf, const vehicle_fields_s *pField);
void VechicleScr_GetVehicleLightFXArray(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetTeam(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetPathDistanceTraveled(gentity_t *pSelf);
void VehicleScr_Clamp_0_1(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_SetTeam(gentity_t *pSelf);

//t6/code/src_noserver/game/vehicle_threat.cpp
BOOL Vehicle_CheckIgnore(sentient_t *self, sentient_t *enemy);
void DebugResetThreatStrings(const vehicle_t *self);
void DebugThreatStringAll(const vehicle_t *self, sentient_t *enemy, int threat);
void DebugThreatStringSimple(const vehicle_t *self, gentity_t *enemy, const char *string, const vec4_t *color);
void DebugThreatNodes(const vehicle_t *self, sentient_t *enemy, pathnode_t *selfNode, pathnode_t *enemyNode, const vec4_t *color);
int Vehicle_ThreatFromScariness(float a1);
int Vehicle_ThreatFromDistance(const float fDistance);
int Vehicle_IsFullyAware(vehicle_t *self, sentient_t *enemy, int isCurrentEnemy);
int Vehicle_ThreatFromVisibilityAndAwareness(int isVisible, int isFullyAware, int friendlyTimingOut);
int Vehicle_ThreatBonusForCurrentEnemy(int isCurrentEnemy, int isFullyAware, int friendlyTimingOut, int isPlayer, int isDamaged);
void Vehicle_IncrementThreatTime(vehicle_t *self);
void Vehicle_InitPotentialTarget(PotentialTargetData *potentialTarget, gentity_t *entity, float dist, const vec3_t *dirToEnemy);
sentient_info_t *SentientInfo(vehicle_t *self, const sentient_t *enemy);
gentity_t *Vehicle_GetScriptTargetEntity(vehicle_t *self);
gentity_t *Vehicle_GetTargetEntity(vehicle_t *self);
sentient_t *Vehicle_GetTargetSentient(vehicle_t *self);
void Vehicle_PotentialThreat_Debug(vehicle_t *self);
void Vehicle_GetPerfectInfo(vehicle_t *self, sentient_t *other);
void Vehicle_UpdateNearbyEnemyInfo(vehicle_t *self, sentient_sort_t *enemyList, int enemyCount);
void GetVehicleLookAtPosition(const gentity_t *ent, const vec3_t *viewPos, vec3_t *lookAtPos);
int PointInFovAndRange(vehicle_t *self, const vec3_t *vEyePos, const vec3_t *vPoint, float fovDot, float fMaxDistSqrd);
bool Vehicle_SightTrace(vehicle_t *self, const vec3_t *start, const vec3_t *end, int passEntNum);
bool Vehicle_CanSeePointExInternal(vehicle_t *self, const vec3_t *vPoint, float fovDot, float fMaxDistSqrd, int ignoreEntityNum, vec3_t *vViewPos);
bool Vehicle_CanSeePointEx(vehicle_t *self, const vec3_t *vPoint, float fovDot, float fMaxDistSqrd, int ignoreEntityNum);
void Vehicle_UpdateVisCache(vehicle_t *self, const gentity_t *ent, sentient_info_t *pInfo, bool bVisible);
char Vehicle_CanSeeEntityEx(char *a1, vehicle_t *self, const gentity_t *ent, float fovDot, float fMaxDistSqrd);
char Vehicle_CanSeeEntity(vehicle_t *a1, char *a2, vehicle_t *self, const gentity_t *ent);
char Vehicle_CanSeeSentient(vehicle_t *self, sentient_t *sentient, int iMaxLatency);
char Vehicle_RecentlySeeSentient(vehicle_t *self, sentient_t *sentient, int latency);
void Vehicle_UpdateSight(vehicle_t *self);
void Vehicle_DissociateSentient(vehicle_t *self, sentient_t *other);
void DebugLastKnownEnemyPositions(vehicle_t *self);
int Vehicle_UpdateSingleThreat(vehicle_t *self, sentient_t *enemy, float enemyDist);
void Vehicle_UpdateThreat(vehicle_t *self);
sentient_info_t *SentientInfo(actor_t *self, const sentient_t *enemy);

