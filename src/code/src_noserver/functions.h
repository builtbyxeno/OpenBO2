#pragma once

#include "types.h"

//t6/code/src_noserver/bison.simple
int yyparse();

//t6/code/src_noserver/aim_assist/aim_assist.cpp
double AA_GetAutoMeleeRange(Weapon weapon);
void TRACK_aim_assist();
float AimAssist_LerpDvars(const dvar_t *from, const dvar_t *to, float frac);
void AimAssist_RegisterDvars();
void AimAssist_Init(LocalClientNum_t localClientNum);
void AimAssist_BackupPlayerState(LocalClientNum_t localClientNum, const playerState_s *ps);
void AimAssist_FovScale(AimAssistGlobals *aaGlob, float tanHalfFovY);
void AimAssist_CreateScreenMatrix(AimAssistGlobals *aaGlob);
bool AimAssist_ConvertToClipBounds(;
float AimAssist_GetCrosshairDistSqr(;
bool AimAssist_DoBoundsIntersectCenterBox(;
double AimAssist_GetAimAssistRange(Weapon weapon, float adsLerp);
// double AimAssist_GetAutoAimRange@<st0>(double a1@<st1>, LocalClientNum_t localClientNum, Weapon weapon);
void AimAssist_AddToTargetList(AimAssistGlobals *aaGlob, const AimScreenTarget *screenTarget);
int AimTarget_GetTagPos(;
int AimAssist_CalcAimPos(LocalClientNum_t localClientNum, const centity_t *targetEnt, vec3_t *aimPos);
void AimAssist_UpdateScreenTargets(;
int AimAssist_GetScreenTargetCount(LocalClientNum_t localClientNum);
int AimAssist_GetScreenTargetEntity(LocalClientNum_t localClientNum, int targetIndex);
void AimAssist_ClearEntityReference(LocalClientNum_t localClientNum, int entIndex);
bool AimAssist_IsPrevTargetEntity(LocalClientNum_t localClientNum, int entIndex);
AimScreenTarget *AimAssist_GetTargetFromEntity(AimAssistGlobals *aaGlob, int entIndex);
// AimScreenTarget *AimAssist_GetBestTarget@<eax>(;
// AimScreenTarget *AimAssist_GetPrevOrBestTarget@<eax>(;
void AimAssist_CalcAdjustedAxis(const AimInput *input, float *pitchAxis, float *yawAxis);
bool AimAssist_IsPlayerUsingOffhand(const AimAssistPlayerState *ps);
int AimAssist_IsSlowdownActive(const AimAssistPlayerState *ps);
void AimAssist_CalcSlowdown(const AimInput *input, float *pitchScale, float *yawScale);
float AimAssist_GetProfileSensitivity(LocalClientNum_t localClientNum);
// double AimAssist_ApplyTurnRates@<st0>(;
void AimAssist_ClearAutoAimTarget(AimAssistGlobals *aaGlob);
void AimAssist_ClearAutoMeleeTarget(AimAssistGlobals *aaGlob);
void AimAssist_SetAutoMeleeTarget(AimAssistGlobals *aaGlob, const AimScreenTarget *screenTarget);
bool AimAssit_ShouldMeleeChargeMoveLimit(;
void AimAssist_ScreenTargetGetAimPos(;
void AimAssist_DrawCenterBox(;
void AimAssist_DrawTargets(LocalClientNum_t localClientNum, const playerState_s *ps, const vec4_t *color);
// void AimAssist_DrawDebugOverlay(bool a1@<dil>, LocalClientNum_t localClientNum);
void AimAssist_UpdateTweakables(const AimInput *input, LocalClientNum_t localClientNum);
void AimAssist_UpdateAdsLerp(const AimInput *input);
void AimAssist_Setup(LocalClientNum_t localClientNum, const playerState_s *ps);
bool AimAssist_UpdateAutoAimTarget(AimAssistGlobals *aaGlob);
void AimAssist_SetAutoAimTarget(AimAssistGlobals *aaGlob, const AimScreenTarget *screenTarget);
bool AimAssist_ShouldAutoAim(const AimInput *input);
void AimAssist_ApplyAutoAim(const AimInput *input, AimOutput *output);
void AimAssist_ApplyLockOn(const AimInput *input, AimOutput *output);
bool AimAssist_UpdateAutoMeleeTarget(AimAssistGlobals *aaGlob, LocalClientNum_t localClientNum);
bool AimAssist_IsMeleePressed(const AimInput *input, const AimAssistGlobals *aaGlob);
void AimAssist_ApplyAutoMelee(const AimInput *input, AimOutput *output);
void AimAssist_UpdateGamePadInput(;
void AimAssist_UpdateMouseInput(;

//t6/code/src_noserver/aim_assist/aim_target.cpp
void TRACK_aim_target();
const dvar_t *AimTarget_RegisterDvars();
void AimTarget_Init(LocalClientNum_t localClientNum);
BOOL R_SortStaticModelsOnAxis_PosX(;
void AimTarget_AddTargetToList(LocalClientNum_t localClientNum, const AimTarget *target);
int AimTarget_GetTagUpdateInterval(const centity_t *ent);
void AimTarget_GetTargetBounds(const centity_t *targetEnt, vec3_t *mins, vec3_t *maxs);
float AimTarget_GetTargetRadius(const centity_t *targetEnt);
void AimTarget_GetTargetCenter(const centity_t *targetEnt, vec3_t *center);
bool AimTarget_IsTargetValid(const cg_t *cgameGlob, const centity_t *targetEnt);
void AimTarget_CreateTarget(LocalClientNum_t localClientNum, const centity_t *targetEnt, AimTarget *target);
bool AimTarget_PlayerInValidState(const playerState_s *ps);
void AimTarget_ProcessEntityInternal(LocalClientNum_t localClientNum, const centity_t *ent);
void AimTarget_UpdateClientTargets(LocalClientNum_t localClientNum);
;
void AimTarget_GetClientTargetList(;

//t6/code/src_noserver/bgame/bg_actor.cpp
int BG_Actor_GetAnimStateIndex(unsigned __int16 animStateName);
char *BG_Actor_GetAnimStateName(int animStateIndex);
char *BG_Actor_GetAnimStateCategoryName(int animStateIndex);
void BG_Actor_FastForwardAnimState(;
void BG_Actor_GetAnimState(entityState_s *es, int *animState, int *animSubState);
void BG_Actor_SetAnimState(entityState_s *es, int animState, int animSubState);
bool BG_Actor_ApplyNewAnimState(XAnimTree_s *pAnimTree, actorLerpFrame_t *lf, int newAnimationState);
void BG_Actor_UpdateAnimationState(;
XAnim_s *BG_Actor_GetAnims();
void BG_Actor_CreateAnims(void *(*xanimAlloc)(int));
void BG_Actor_ShutdownAnims();

//t6/code/src_noserver/bgame/bg_actor_dog.cpp
void BG_Dog_SetNewAnimationState(;
void BG_Dog_UpdateAnimationState(;

//t6/code/src_noserver/bgame/bg_actor_dog_animations_mp.cpp
XAnim_s *Dog_GetAnims();
void Dog_CreateAnims(void *(*xanimAlloc)(int));
void Dog_ShutdownAnims();
void BG_Dog_GetRunAnimWeights(float leanAmount, float *center, float *left, float *right);
void BG_Dog_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Clear_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Init_Normal_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Init_Attack_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Start(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Stop(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Think(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Walk_Think(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Clear_All_Turns(DObj *obj);
void BG_Dog_Move_Turn_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Turn_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Turn_Around_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Turn_Around_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Around_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Around_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Stop_Init(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Stop_Idle(LocalClientNum_t localClientNum, const entityState_s *es, ActorAnimStates prevState);
void BG_Dog_Stop_AttackIdle(;
void BG_Dog_Stop_AttackIdle_Bark(;
void BG_Dog_Stop_AttackIdle_Growl(;
void BG_Dog_Pain_Main(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Front(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Back(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Front(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Back(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Front(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Back(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Fast_Forward_Front(;
void BG_Dog_Death_Fast_Forward_Back(;
void BG_Dog_Death_Fast_Forward_Left(;
void BG_Dog_Death_Fast_Forward_Right(;
void BG_Dog_Flashed(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_AttackIdle(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_AttackIdle_Bark(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_AttackIdle_Growl(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Run(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Player_Close_Range(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Miss(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Miss_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Miss_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Clear_Traverse_Anims(;
void BG_Dog_Traverse_Jump_Up_40(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Jump_Up_80(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Jump_Down_40(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Jump_Down_80(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Wallhop(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Window(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Through_Hole_42(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run(LocalClientNum_t localClientNum, const entityState_s *es, ActorAnimStates prevState);
void BG_Dog_Move_Walk(LocalClientNum_t localClientNum, const entityState_s *es, ActorAnimStates prevState);

//t6/code/src_noserver/bgame/bg_actor_prone.cpp
int BG_ActorIsProne(actor_prone_info_s *pInfo, int iCurrentTime);
double BG_GetActorProneFraction(actor_prone_info_s *pInfo, int iCurrentTime);

//t6/code/src_noserver/bgame/bg_animation.cpp
const char *BG_GetPlayerAnimScriptFileName();
void TRACK_bg_animation_mp();
int BG_StringHashValue(const char *fname);
void BG_AnimParseError(const char *msg, ...);
unsigned int BG_AnimationIndexForString(const char *string);
int BG_IndexForString(const char *token, animStringItem_t *strings, int allowFail);
char *BG_CopyStringIntoBuffer(const char *string, char *buffer, unsigned int bufSize, unsigned int *offset);
void BG_InitWeaponString(int index, const char *name);
void BG_InitWeaponStrings();
void BG_AddVehicleName(const char *vehName, int vehType, int drivers, int gunners, int passengers);
unsigned int BG_AnimGetConditionValue(animScriptItem_t *scriptItem, int conditionIndex);
int BG_GetVehicleAnimSetIndex(unsigned __int16 animSetStr);
void BG_SetupAnimNoteTypes(animScriptData_t *scriptData);
void BG_SetAnimConditionFlags(int condIndex, unsigned int result);
void BG_ParseConditionBits(;
int BG_ParseConditions(const char **text_pp, animScriptItem_t *scriptItem);
void BG_ParseCommands(const char **input, animScriptItem_t *scriptItem, animScriptData_t *scriptData);
const char *GetWeaponTypeName(int type);
int GetValueForBitfield(unsigned int bitfield);
const char *BG_GetConditionString(int condition, int value);
int BG_EvaluateConditions(clientInfo_t *ci, animScriptItem_t *scriptItem);
animScriptItem_t *BG_FirstValidItem(int client, animScript_t *script);
animScriptCommand_t *BG_AnimScriptEventGetCommand(;
void BG_SetConditionBit(ClientNum_t client, int condition, int value);
unsigned int BG_GetConditionValue(const clientInfo_t *ci, const int condition);
int BG_GetConditionBit(const clientInfo_t *ci, const int condition);
Weapon BG_GetPlayerStateWeapon(const pmove_t *pm);
Weapon BG_GetNextPlayerStateWeapon(const pmove_t *pm);
void BG_AnimUpdatePlayerStateConditions(pmove_t *pmove);
int BG_IsCrouchingAnim(const clientInfo_t *ci, int animNum);
int BG_IsProneAnim(const clientInfo_t *ci, int animNum);
int BG_IsKnifeMeleeAnim(const clientInfo_t *ci, int animNum);
BOOL BG_IsSliding(const clientInfo_t *ci);
void BG_SetNewAnimation(;
void BG_RunLerpFrameRate(;
void BG_PlayerAnimation_VerifyAnim(XAnimTree_s *pAnimTree, lerpFrame_t *lf);
void BG_SwingAngles(;
void BG_PlayerAngles(LocalClientNum_t localClientNum, const entityState_s *es, clientInfo_t *ci);
void BG_Player_DoControllersInternal(;
void BG_Player_DoControllersSetup(const entityState_s *es, clientInfo_t *ci, int frametime);
void BG_PlayerAnimation(;
void BG_UpdatePlayerDObj(;
void BG_FindAnims();
scr_animtree_t BG_FindAnimTree(const char *filename, int bEnforceExists);
void BG_FindAnimTrees();
void BG_ResetAnimSpeeds();
void BG_SetSAnimSpeed(int handle, float rate);
double BG_GetSAnimSpeed(int handle);
void BG_SetCAnimSpeed(int handle, float rate);
double BG_GetCAnimSpeed(int handle);
void BG_AnimParseAnimScript(;
const char *BG_GetCurrentMoveStatus(playerState_s *ps);
int BG_PlayAnim(;
int BG_ExecuteCommand(;
int BG_AnimScriptAnimation(pmove_t *pm, aistateEnum_t state, scriptAnimMoveTypes_t movetype, int force);
int BG_AnimScriptEvent(;
void BG_SetConditionValue(ClientNum_t client, int condition, unsigned __int64 value);
unsigned __int16 BG_AddWorldModelWeaponAttachments(;
unsigned __int16 BG_AttachWeaponStowedModel(;
void BG_LoadAnim(const char *levelName, bool canModifyChecksum);
void BG_FinalizePlayerAnims(const char *levelName);
void BG_PostLoadAnim(const char *levelName);

//t6/code/src_noserver/bgame/bg_animconditions.cpp
void BG_LocalEvalPlayerAnimType(pmove_t *pm);
void BG_EvalPlayerAnimType(const entityState_s *es);
void BG_LocalEvalNextPlayerAnimType(pmove_t *pm);
void BG_LocalEvalWeaponClass(pmove_t *pm);
void BG_EvalWeaponClass(const entityState_s *es);
void BG_LocalEvalNextWeaponClass(pmove_t *pm);
void BG_LocalEvalMounted(pmove_t *pm);
void BG_EvalMounted(const entityState_s *es);
void BG_LocalEvalMoveStatus(pmove_t *pm);
void BG_EvalMoveStatus(const entityState_s *es);
void BG_LocalEvalPrevDirection(pmove_t *pm);
void BG_LocalEvalDirection(pmove_t *pm);
void BG_EvalDirection(const entityState_s *es);
void BG_LocalEvalDmgDirection(pmove_t *pm);
void BG_EvalDmgDirection(const entityState_s *es);
void BG_LocalEvalDmgType(pmove_t *pm);
void BG_LocalEvalStance(pmove_t *pm);
void BG_EvalStance(const entityState_s *es);
void BG_LocalEvalUnderhand(pmove_t *pm);
void BG_EvalUnderhand(const entityState_s *es, const clientInfo_t *ci);
void BG_EvalFiring(const entityState_s *es);
void BG_LocalEvalWeaponPosition(pmove_t *pm);
void BG_EvalWeaponPosition(const entityState_s *es);
void BG_LocalEvalSlope(pmove_t *pm);
void BG_EvalSlope(const entityState_s *es);
void BG_LocalEvalPerk(pmove_t *pm);
void BG_LocalEvalAttachment(pmove_t *pm);
void BG_LocalEvalRiotShieldNext(pmove_t *pm);
void BG_LocalEvalVehicleName(pmove_t *pm);
void BG_LocalEvalVehicleSeatTo(pmove_t *pm);
void BG_LocalEvalEvent(pmove_t *pm);
void BG_LocalEvalFiring(pmove_t *pm);

//t6/code/src_noserver/bgame/bg_animstatedef.cpp
;
void BG_AnimStateDef_Precache(int aiIndex, scr_animtree_t animtree, unsigned __int16 animStateDefName);
void BG_AnimStateDef_ParseError(const char *filename, const char *msg);
void BG_AnimStateDef_ValidateAgainstPropertyNames(;
void BG_AnimStateDef_SetFlag(AnimState *state, int flag);
void BG_AnimStateDef_TokenizeNotify(AnimState *state, const char **data_p, char *token, const char *filename);
void BG_AnimStateDef_Parse(AnimStateDef *def);
void BG_AnimStateDef_Load_Internal(AnimStateDef *def, void *(*animStateDefAlloc)(int));
// void BG_AnimStateDef_Load(void *(*a1)(int)@<edx>, void *(*animStateDefAlloc)(int));
AnimStateDef *BG_AnimStateDef_GetDefFromEntityState(const entityState_s *es);
unsigned __int16 BG_AnimStateDef_GetAnimIndex(const entityState_s *es);
bool BG_AnimStateDef_GetFlag(const entityState_s *es, int flag);
unsigned __int16 BG_AnimStateDef_GetNotify(const entityState_s *es);
void BG_AnimStateDef_SetNewAnimationState(;
void BG_AnimStateDef_Update(LocalClientNum_t localClientNum, const entityState_s *es, actorInfo_t *actorInfo);
unsigned __int16 BG_AnimStateDef_GetName(const entityState_s *es);
XAnim_s *BG_AnimStateDef_GetAnims(const entityState_s *es);
bool BG_AnimStateDef_IsMissingLegs(const entityState_s *a1, int a2);
unsigned __int16 BG_AnimStateDef_GetCurrentStateName(const entityState_s *es);
int BG_AnimStateDef_GetCurrentSubStateIndex(const entityState_s *es);
float BG_AnimStateDef_GetCurrentAnimTime(const entityState_s *es, XAnimTree_s *tree);
int BG_AnimStateDef_GetAnimIndex(;
int BG_AnimStateDef_GetAnimStateIndex(const entityState_s *es, unsigned __int16 stateName);
int BG_AnimStateDef_GetAnimSubStateCount(const entityState_s *es, unsigned __int16 stateName);
int BG_AnimStateDef_GetAnimSubStateIndex(;
void BG_AnimStateDef_GetCurrentStateInfo(;
void BG_AnimStateDef_Shutdown();

//t6/code/src_noserver/bgame/bg_attachments_load_obj.cpp
int Attachment_GetStringArrayIndex(const char *value, const char **stringArray, int arraySize);
// int BG_ParseAttachmentSpecificFieldType@<eax>(;
WeaponAttachment *BG_LoadDefaultWeaponAttachment_LoadObj();
WeaponAttachment *BG_LoadDefaultWeaponAttachment_FastFile();
WeaponAttachment *BG_LoadDefaultWeaponAttachment();
char BG_AttachmentUpdateField(const char *attachmentName, const char *keyValue);

//t6/code/src_noserver/bgame/bg_attachments_unique_load_obj.cpp
void SetConfigString(char **ppszConfigString, const char *pszKeyValue);
void SetConfigString2(char **a1, const char *a2);
// int BG_ParseAttachmentUniqueSpecificFieldType@<eax>(;
int WeaponAttachmentUnique_GetSoundOverrideFieldOffset(eAttachmentOverrideSounds overrideField);
int WeaponAttachmentUnique_GetEffectOverrideFieldOffset(eAttachmentOverrideEffects overrideField);
char BG_AttachmentUniqueUpdateField(const char *attachmentName, const char *keyValue);
void SetConfigString(char **ppszConfigString, const char *pszKeyValue);

//t6/code/src_noserver/bgame/bg_attachment_load_db.h
void Load_WeaponAttachment(bool atStreamStart);
void Load_WeaponAttachmentPtr(bool atStreamStart);
void Load_WeaponAttachmentPtrArray(bool atStreamStart, int count);
void Mark_WeaponAttachmentPtr();

//t6/code/src_noserver/bgame/bg_attachment_unique_load_db.h
void Mark_WeaponAttachmentUnique();
void Mark_WeaponAttachmentUniquePtr();
void Load_WeaponAttachmentUnique(bool atStreamStart);
void Load_WeaponAttachmentUniquePtr(bool atStreamStart);
void Load_WeaponAttachmentUniquePtrArray(bool atStreamStart, int count);

//t6/code/src_noserver/bgame/bg_clientfields.cpp
int BG_GetFieldOffset(const NetField *pFields, int numFields, const char *pName);
void BG_InitClientFields();
void BG_ShutdownClientFields();
int BG_SortClientFields(const void *arg0, const void *arg1);
int BG_GetClientFieldSetFromSetName(const char *pSetName);
const char *BG_GetClientFieldSetName(int system);
unsigned int BG_GetClientFieldTypeFromTypeName(unsigned __int16 typeName);
void BG_ReportClientFieldAllocation();
void BG_ReportClientFields(const char *pMsg);
unsigned int BG_GetClientFieldsHash();
unsigned int BG_GetClientFieldsHighestVersionUsed();
unsigned int BG_BuildHashFromClientFieldSystem(bgsClientFields_s *pSys);
void BG_RemoveObsoleteClientFields();
void BG_PerformClientFieldSort();
unsigned int BG_GetClientFieldVersion(const char *pSetName, const char *pFieldName);
void BG_AllocateBitSpaceToFields();
void BG_FinalizeClientFieldRegistration();
clientField_s *BG_GetClientField(int system, const char *pFieldName, bool bErrorIfNotFound);
void BG_AddClientfieldCodeCallback(;
void BG_AddClientfieldCodeCallback(;
clientField_s *BG_RegisterClientFieldInternal(;
void BG_RegisterClientField(;
void BG_RegisterClientField(;
unsigned int BG_GetClientFieldIntVal(int system, const char *pFieldName, void *pData);
void BG_SetClientFieldIntVal(int system, clientField_s *pField, void *pData, int val);
double BG_GetClientFieldFloatValInternal(clientField_s *pField, unsigned int val);
double BG_GetClientFieldFloatVal(int system, const char *pFieldName, void *pData);
void BG_SetClientFieldFloatVal(int system, clientField_s *pField, void *pData, float val);
void BG_ReportPendingClientfieldCallbackEvents(LocalClientNum_t localClientNum);
void BG_AddClientfieldCallbackEvent(;
void BG_AddClientfieldCallbackEvent(;
void BG_ExecuteClientFieldCallbacks(LocalClientNum_t localClientNum);
void BG_ProcessClientFieldSet(;

//t6/code/src_noserver/bgame/bg_common_load_db.h
void Mark_WeaponCamoSetArray(int count);
void Mark_WeaponCamoMaterialArray(int count);
void Mark_WeaponCamoMaterialSetArray(int count);
void Mark_WeaponCamo();
void Mark_WeaponCamoPtr();
void Load_WeaponCamoSetArray(bool atStreamStart, int count);
void Load_WeaponCamoMaterialArray(bool atStreamStart, int count);
void Load_WeaponCamoMaterialSetArray(bool atStreamStart, int count);
void Load_WeaponCamo(bool atStreamStart);
void Load_WeaponCamoPtr(bool atStreamStart);

//t6/code/src_noserver/bgame/bg_dtp.cpp
void Dtp_RegisterDvars();
int Dtp_CalcSurfaceType(pmove_t *pm, pml_t *pml);
BOOL Dtp_IsSliding(const playerState_s *ps);
void Dtp_AdjustDamage(const playerState_s *ps, float fallHeight, int *damage);
void Dtp_Start(pmove_t *pm, pml_t *pml, float _height);
void Dtp_Interrupt(pmove_t *pm);
void Dtp_CheckForEnd(pmove_t *pm);
void Dtp_AirMove(playerState_s *ps, const pmove_t *pm);
BOOL Dtp_CanMove(pmove_t *pm);
;
int Dtp_IsDtp(const pmove_t *pm, const playerState_s *ps);
int Dtp_Update(pmove_t *pm, pml_t *pml);

//t6/code/src_noserver/bgame/bg_emblems.cpp
int BG_EmblemsGetUnlockedLayerCount(ControllerIndex_t controllerIndex);
EmblemLayer *BG_EmblemsGetLayerCost(int layer);
int BG_EmblemsGetLayerUnlockLevel(int layer);
int BG_EmblemsGetPurchasedLayerCount(ControllerIndex_t controllerIndex);
int ResultSort(const void *a, const void *b);
int BG_EmblemsGetIconCost(__int16 id);
int BG_EmblemsGetIconUnlockLevel(__int16 id);
int BG_EmblemsGetIconUnlockPLevel(__int16 id);
int BG_EmblemsGetIconUnclassifyAt(__int16 id);
const vec4_t *BG_EmblemsGetIconDefaultColor(const vec4_t *result, __int16 id);
double BG_EmblemsGetIconOutlineSize(__int16 id);
bool BG_EmblemsCheckDLCLocked(emblemChallengeLookup_t *challengeLookup);
char BG_EmblemsIsIconLocked(ControllerIndex_t controllerIndex, __int16 id);
bool BG_EmblemsIsIconPurchased(ControllerIndex_t controllerIndex, __int16 id);
void BG_EmblemsCheckEmblemAndBackingUnlocks(const ControllerIndex_t controllerIndex);
EmblemBGCategory *BG_EmblemsGetCategoryCount();
const GfxViewParms *BG_EmblemsGetCategoryDesc(int index);
EmblemIcon *BG_EmblemsGetBackgroundCount();
__int16 BG_EmblemsGetBackgroundID(int index);
int BG_EmblemsGetBackgroundIndex(__int16 id);
int BG_EmblemsGetBackgroundCost(__int16 id);
int BG_EmblemsGetBackgroundUnlockLevel(__int16 id);
int BG_EmblemsGetBackgroundUnlockPLevel(__int16 id);
int BG_EmblemsGetBackgroundUnclassifyAt(__int16 id);
EmblemIcon *BG_EmblemsGetBackgroundMaterial(__int16 id);
int BG_EmblemsGetBackgroundMTXIndex(__int16 id);
bool BG_EmblemsIsBackgroundMTX(__int16 id);
bool BG_EmblemsIsBackgroundPurchased(ControllerIndex_t controllerIndex, __int16 id);
GfxColor *BG_GetSwatchColorByIndex(int rowNumber, int columnNumber);
emblemChallengeLookup_t *BG_EmblemGetChallengeLookup(__int16 emblemIndex);
emblemChallengeLookup_t *BG_EmblemBackingGetChallengeLookup(__int16 backingIndex);
void BG_EmblemsClearDefaults();
void BG_EmblemsSetDefaultForLevel(int minlevel, int maxlevel, CompositeEmblemLayer *s_emblem, int layerCount);
void BG_EmblemsGenerateDefault(;
bool BG_EmblemsIsIconHidden(ControllerIndex_t controllerIndex, __int16 id);
int BG_EmblemsGetPurchasedBackgroundCount(ControllerIndex_t controllerIndex);
const char *BG_EmblemsGetBackgroundDesc(ControllerIndex_t controllerIndex, __int16 id);
const char *BG_EmblemsGetBackgroundUnlockDesc(ControllerIndex_t controllerIndex, __int16 id);
bool BG_EmblemsIsBackgroundClassified(ControllerIndex_t controllerIndex, __int16 id);
ResultCache *BG_EmblemsGetResults(;
int BG_EmblemsGetIconCount(;
__int16 BG_EmblemsGetIconID(;
const char *BG_EmblemsGetIconDesc(ControllerIndex_t controllerIndex, __int16 id);
const char *BG_EmblemsGetIconUnlockDesc(ControllerIndex_t controllerIndex, __int16 id);
bool BG_EmblemsIsIconClassified(ControllerIndex_t controllerIndex, __int16 id);
char BG_EmblemsIsBackgroundLocked(ControllerIndex_t controllerIndex, __int16 id);

//t6/code/src_noserver/bgame/bg_emblems_load_db.h
void Load_EmblemCategoryArray(bool atStreamStart, int count);
void Load_EmblemIconTypeArray(bool atStreamStart, int count);
void Load_EmblemBGCategoryArray(bool atStreamStart, int count);
void Mark_EmblemIconArray(int count);
void Mark_EmblemBackgroundArray(int count);
void Mark_EmblemSetPtr();
void Load_EmblemIconArray(bool atStreamStart, int count);
void Load_EmblemBackgroundArray(bool atStreamStart, int count);
void Load_EmblemSet(bool atStreamStart);
void Load_EmblemSetPtr(bool atStreamStart);

//t6/code/src_noserver/bgame/bg_faction.cpp
void BG_FactionData_Clear();
void BG_FactionData_GetTeamColor(team_t team, vec4_t *out);
const char *BG_GetTeamName(const team_t team);
bool BG_IsTeamBased();
const char *BG_GetFactionForTeam(const team_t team, const char *mapName);
char BG_GetFactionColor(const char *factionName, vec4_t *out);
void BG_FactionData_Init(const char *mapName);

//t6/code/src_noserver/bgame/bg_helicopter.cpp
void BG_HeliCmdScale(bool scaleMovement, const char *move, vec4_t *outFracs);
void BG_HeliCalcAccelFromTilt(;
void BG_HelicopterHeightTrace(;
void BG_HelicopterGroundTrace(;
int BG_VehicleHeliLockHeight(VehicleState *vehicleState);
void BG_CalculateRotorArms(;
void BG_HeliCalcAccel(;
void BG_HeliMaintainHeight_UpdateHeight(pmove_t *pm, const pml_t *pml, VehicleState *vehicleState);
void BG_PlayerStateToVehicleStateHelicopter(;
;
char BG_VehicleHelicopterVerticalMove(pmove_t *pm, const pml_t *pml, VehicleState *vehicleState);
;

//t6/code/src_noserver/bgame/bg_jump.cpp
void Jump_RegisterDvars(int a1, dvarType_t a2);
double Jump_GetHeight();
void Jump_ClearState(playerState_s *ps);
char Jump_GetStepHeight(playerState_s *ps, const vec3_t *origin, float *stepSize);
BOOL Jump_IsPlayerAboveMax(playerState_s *ps);
void Jump_ActivateSlowdown(playerState_s *ps);
void Jump_ApplySlowdown(playerState_s *ps);
float Jump_GetSlowdownFriction(playerState_s *ps);
// float Jump_ReduceFriction@<st0>(playerState_s *a1@<ecx>, int a2@<xmm0>, playerState_s *ps);
void Jump_ClampVelocity(playerState_s *ps, const vec3_t *origin);
float Jump_GetLandFactor(playerState_s *ps);
void Jump_Start(pmove_t *pm, pml_t *pml, float height);
void Jump_PushOffLadder(playerState_s *ps, pml_t *pml, pmove_t *pm);
void Jump_AddSurfaceEvent(playerState_s *ps, pml_t *pml);
// char Jump_Check@<al>(pmove_t *a1@<edi>, pmove_t *pm, pml_t *pml);

//t6/code/src_noserver/bgame/bg_mantle.cpp
void Mantle_RegisterDvars();
void Mantle_DebugPrint(const char *msg);
int Mantle_GetUpLength(const MantleState *mstate);
int Mantle_GetOverLength(const MantleState *mstate);
int Mantle_GetAnim(MantleState *mstate);
void Mantle_GetAnimDelta(MantleState *mstate, int time, vec3_t *delta);
int Mantle_FindTransition(float curHeight, float goalHeight);
void Mantle_SetHaveWeapon(MantleState *mstate, const playerState_s *ps);
void Mantle_Start(pmove_t *pm, playerState_s *ps, MantleResults *mresults);
bool Hatch_FindHatchSurface(;
void Mantle_CreateAnims(void *(*xanimAlloc)(int));
void Mantle_ShutdownAnims();
bool Mantle_FindMantleSurface(pmove_t *pm, pml_t *pml, trace_t *trace, vec3_t *mantleDir);
void Mantle_Move(pmove_t *pm, playerState_s *ps, pml_t *pml);
void Mantle_CapView(playerState_s *ps);
void Mantle_ClearHint(playerState_s *ps);
bool Mantle_IsWeaponInactive(const playerState_s *ps);
BOOL Mantle_IsWeaponEquipped(const playerState_s *ps);
BOOL Mantle_DoAnim(const playerState_s *ps);
int __thiscall Mantle_GetDuration(const MantleState *this);
double Mantle_GetMantleFrac(const playerState_s *ps);
bool Mount_CanPlayerDeployTurret(playerState_s *ps);
;
;
;
;
char Hatch_CheckHatch(pmove_t *pm, pml_t *pml);
;
;

//t6/code/src_noserver/bgame/bg_misc.cpp
void BG_RegisterDvars(int a1, dvarType_t a2);
double BG_GetFallDamageMaxHeight();
double BG_GetFallDamageMinHeight();
double BG_GetSprintSpeedScale();
bool BG_GetSprintUnlimited();
double BG_GetSprintMinTime();
double BG_GetSprintStrafeSpeedScale();
double BG_GetFriction();
char *BG_GetEntityTypeName(const int eType);
Weapon G_FindItem(const char *pickupName);
char HaveRoomForAmmo(const playerState_s *ps, const Weapon weapon);
bool BG_PlayerCanPickUpWeaponType(const WeaponDef *weapDef, const playerState_s *ps);
bool WeaponEntCanBeGrabbed(;
BOOL BG_CanItemBeGrabbed(const entityState_s *ent, const playerState_s *ps, int touched);
BOOL BG_PlayerHasRoomForEntAllAmmoTypes(const entityState_s *ent, const playerState_s *ps);
// void BG_EvaluateTrajectoryInternal(float a1@<ebx>, const trajectory_t *tr, int atTime, vec3_t *result);
// void BG_EvaluateTrajectoryDelta(float a1@<edi>, const trajectory_t *tr, int atTime, vec3_t *result);
bool BG_ValidateOrigin(const vec3_t *pos, unsigned int xyBits, unsigned int zBits, const vec3_t *mapCenter);
bool BG_ValidateOrigin(int a1, unsigned int a2);
bool BG_ValidateZOriginValue(const float val, const float mapCenterValue);
void BG_PlayerToEntitySetPitchAngles(playerState_s *ps, entityState_s *s);
void BG_PlayerToEntitySetTrajectory(playerState_s *ps, entityState_s *s, int snap);
void BG_GetPlayerViewDirection(const playerState_s *ps, vec3_t *forward, vec3_t *right, vec3_t *up);
void BG_GetPlayerGunDirection(;
void BG_ApplyLinkAngles(const vec3_t *linkAngles, vec3_t *viewangles);
void BG_LerpFontScale(const hudelem_s *elem, int time, float *toScale);
void BG_LerpHudColors(const hudelem_s *elem, int time, hudelem_color_t *toColor);
int BG_LoadShellShockDvars(const char *name);
void BG_SetShellShockParmsFromDvars(shellshock_parms_t *parms);
int BG_SaveShellShockDvars(const char *name);
shellshock_parms_t *BG_GetShellshockParms(const int index);
BOOL BG_IsShellshockAnim(const playerState_s *ps);
void BG_CreateXAnim(XAnim_s *anims, unsigned int animIndex, const char *name);
void BG_CheckThread();
int BG_GetMaxSprintTime(const playerState_s *ps);
bool BG_ClipMoveToDobj(const entityState_s *es);
int BG_GetFriendlyFireStatus();
const char *BG_DisplayName(const clientInfo_t *ci, int type);
void BG_UpdateClientControlledMissile(vec3_t *angles, const usercmd_s *cmd, int msec);
unsigned __int8 BG_ShieldHitEncode(const vec3_t *hitPos, bool fromTheFront);
void BG_ShieldHitDecode(unsigned int encoded, vec3_t *result, bool *resultHitFront);
void BG_ShieldHitDecode(unsigned int encoded, int *segY, int *segZ, bool *resultHitFront);
void BG_ClipCameraToHeliPatch(vec3_t *origin, vec3_t *oldpos, vec3_t *velocity, vec3_t *breachPos);
BOOL BG_PlayerTouchesItem(const playerState_s *ps, const entityState_s *item, int atTime);
void BG_AddPredictableEventToPlayerstate(int newEvent, unsigned int eventParm, playerState_s *ps);
void BG_AddUnpredictableEventToPlayerstate(int newEvent, unsigned int eventParm, playerState_s *ps);
void BG_AddEntityStateEvent(int newEvent, unsigned int eventParm, entityState_s *es, const int eventTime);
void BG_AddSentinelEventToEntityState(entityState_s *es, const int eventTime);
void BG_PlayerToEntityProcessEvents_Internal(;
void BG_PlayerToEntityProcessEvents(playerState_s *ps, entityState_s *s, unsigned __int8 handler);
void BG_PlayerToEntitySetMisc(playerState_s *ps, entityState_s *s);
void BG_PlayerStateToEntityState(;
;
void BG_GetPlayerViewOrigin(const playerState_s *ps, vec3_t *origin, int time);

//t6/code/src_noserver/bgame/bg_misctables.cpp
int VEH_ParseSpecificField(;
void TRACK_bg_misctables();

//t6/code/src_noserver/bgame/bg_mover.cpp
bool entity_is_a_mover(const int entnum, const int max_ents);
// void __thiscall mover_info_t::init(mover_info_t *this, const vec3_t *origin, const vec3_t *angles, int time);
// void __thiscall mover_info_t::add_record(mover_info_t *this, const vec3_t *origin, const vec3_t *angles, int time);
// void __thiscall mover_info_t::get_position(mover_info_t *this, int time, vec3_t *origin, vec3_t *angles);
// void sv_rewind_context_t::~sv_rewind_context_t(sv_rewind_context_t *this@<ecx>, int a2@<ebp>);
// void actors_rewind_context_t::restore(actors_rewind_context_t *this@<ecx>, int a2@<ebp>);
int get_entity_mover(gentity_t *ent);
void RestoreMovers(unsigned __int8 handler, LocalClientNum_t localClientNum, bool doLink);
mover_info_t *cl_get_mover_info(centity_t *ent);
mover_info_t *sv_get_mover_info(gentity_t *ent);
// void mover_info_t::apply_rotation(mover_info_t *this@<ecx>, int a2@<ebp>, vec3_t *v);
// void mover_info_t::apply_rotation_translation(mover_info_t *this@<ecx>, int a2@<ebp>, vec3_t *v);
void AdjustMovers(unsigned __int8 handler, LocalClientNum_t localClientNum, int time, bool doLink);
;
void cl_destroy_mover_info(void *mi_);
void cl_mover_info_level_init(LocalClientNum_t localClientNum);
mover_info_t *cl_create_mover_info(centity_t *ent);
void sv_destroy_mover_info(void *mi_);
void sv_mover_info_level_init();
void sv_destroy_mover_info(gentity_t *ent);
mover_info_t *sv_update_mover_info(gentity_t *ent, vec3_t origin, vec3_t angles, int time);
void mover_info_apply_rotation(const int gentnum, vec3_t *v);
void mover_info_apply_rotation_xy(const int gentnum, vec2_t *v);
void mover_info_apply_rotation_translation(const int gentnum, vec3_t *v);
// void __thiscall sv_rewind_context_t::sv_rewind_context_t(;
// void __thiscall actors_rewind_context_t::rewind(;

//t6/code/src_noserver/bgame/bg_mover.h
// mover_record_t *__thiscall mover_info_t::get_prev_origin(mover_info_t *this);
// vec3_t *__thiscall mover_info_t::get_prev_angles(mover_info_t *this);

//t6/code/src_noserver/bgame/bg_perks.cpp
void Perks_CalculateStringHashes();
unsigned int BG_GetPerkIndexForName(const char *perkName);
const char *BG_GetPerkNameForIndex(unsigned int perkIndex);
void Perks_RegisterDvars(int a1, dvarType_t a2);
char BG_WeaponHasPerk(Weapon weapon, unsigned int perkIndex);

//t6/code/src_noserver/bgame/bg_perks.h
bool BG_PerkBitSet(const unsigned int *perks, unsigned int perkIndex);
bool BG_HasPerk(const playerState_s *ps, unsigned int perkIndex);
void BG_SetPerk(unsigned int *perks, unsigned int perkIndex);
void BG_UnsetPerk(unsigned int *perks, unsigned int perkIndex);

//t6/code/src_noserver/bgame/bg_pmove.cpp
float PM_GetMoveSpeedScale(pmove_t *pm, const WeaponDef *weapDef);
void PM_AddEvent(playerState_s *ps, int newEvent);
void PM_AddTouchEnt(pmove_t *pm, int entityNum);
void PM_AddTouchGlass(pmove_t *pm, int glassId);
void PM_ClipVelocity(const vec3_t *in, const vec3_t *normal, vec3_t *out);
void PM_ProjectVelocity(const vec3_t *velIn, const vec3_t *normal, vec3_t *velOut);
int PM_GetEffectiveStance(const playerState_s *ps);
int PM_GetSprintLeft(const playerState_s *ps, const int gametime);
bool PM_IsSprinting(const playerState_s *ps);
void PM_StartSprint(playerState_s *ps, pmove_t *pm, const pml_t *pml, int sprintLeft);
void PM_UpdateVisionAnims(pmove_t *pm, pml_t *pml);
void PM_UpdateScriptedAnim(pmove_t *pm, pml_t *pml);
int PM_GetEntityOrigin(;
BOOL PM_GetEntityVelocity(;
float PM_GetMeleeChargeFriction(pmove_t *pm, pml_t *pml);
void PM_Friction(playerState_s *ps, pml_t *pml, pmove_t *pm);
void PM_Accelerate(playerState_s *ps, const pml_t *pml, vec3_t *wishdir, float wishspeed, float accel);
void PM_DoSlideAdjustments(playerState_s *ps, const pml_t *pml);
float PM_MoveScale(playerState_s *ps, float fmove, float rmove, float umove);
float PM_CmdScale(playerState_s *ps, usercmd_s *cmd);
double PM_DamageScale_Walk(int damage_timer);
void PM_SetMovementDir(pmove_t *pm, pml_t *pml);
unsigned int PM_GroundSurfaceType(playerState_s *ps, pml_t *pml);
void PM_DeadMove(playerState_s *ps, pml_t *pml);
int PM_FootstepType(pmove_t *pm, pml_t *pml);
int PM_DamageLandingForSurface(playerState_s *ps, pml_t *pml);
void PM_CrashLand(pmove_t *pm, pml_t *pml);
int PM_GetWaterLevel(const playerState_s *ps, float waterHeight);
void PM_SetWaterLevel(pmove_t *pm);
int PM_GetViewHeightLerpTime(const playerState_s *ps, int iTarget, int bDown);
float PM_ViewHeightTableLerp(int iFrac, viewLerpWaypoint_s *pTable, int lowVal, int highVal);
void PM_ViewHeightAdjust(pmove_t *pm, pml_t *pml);
bool PlayerProneAllowed(pmove_t *pm);
bool PM_IsPlayerFrozenByWeapon(const playerState_s *ps);
bool PM_ShouldLeaveStanceAlone(const playerState_s *ps);
void PM_FootstepEvent(pmove_t *pm, pml_t *pml, int iOldBobCycle, int iNewBobCycle, int bFootStep);
BOOL PM_ShouldMakeFootsteps(pmove_t *pm);
int PM_Footsteps_TurnAnim(pmove_t *pm, clientInfo_t *ci);
int PM_ShouldFlinch(playerState_s *ps);
bool PM_Footstep_LadderMove(pmove_t *pm, pml_t *pml);
void PM_Footsteps_NotMoving(pmove_t *pm, pml_t *pml, int stance);
scriptAnimMoveTypes_t PM_GetMoveAnim(;
void PM_Footstep_NotTryingToMove(pmove_t *pm, pml_t *pml);
void PM_VehicleDrive(pmove_t *pm, pml_t *pml);
int BG_CalcBob(pmove_t *pm, pml_t *pml, int old, float bobmove);
void PM_ApplyMovementAnimations(;
void PM_ApplyLegAnimations(;
float PM_CalcPlayerPitch(playerState_s *ps, pml_t *pml);
bool PM_IsInAir(pmove_t *pm, pml_t *pml);
void PM_DropTimers(playerState_s *ps, pml_t *pml);
int BG_CheckProneTurned(playerState_s *ps, float newProneYaw, unsigned __int8 handler);
void PM_UpdateViewLockedEnt(;
void PM_UpdateViewAngles_Clamp(playerState_s *ps, usercmd_s *cmd, unsigned __int8 handler);
void PM_UpdateViewAngles_RangeLimited(playerState_s *ps);
void PM_UpdateViewAngles_LadderClamp(playerState_s *ps);
void PM_UpdateViewAngles_ProneYawClamp(;
void PM_UpdateViewAngles_PronePitchClamp(playerState_s *ps);
void PM_UpdateViewAngles_Prone(;
BOOL PM_ViewRangeLimited(const playerState_s *ps);
// void PM_UpdatePronePitch(unsigned int ebp0@<ebp>, pmove_t *pm, pml_t *pml);
void PM_SetProneMovementOverride(playerState_s *ps);
void PM_ClearLadderFlag(playerState_s *ps);
void PM_MeleeChargeClear(playerState_s *ps);
float PM_GetMeleeChargeYaw(pmove_t *pm);
bool PM_MeleeChargeIsValid(pmove_t *pm, pml_t *pml);
// void PM_MeleeChargeStart(pml_t *a1@<edx>, pmove_t *a2@<ecx>, pmove_t *pm, pml_t *pml);
bool PM_IsValidCharge(pmove_t *pm);
void PM_MeleeChargeCatchupVelocity(pmove_t *pm, pml_t *pml);
void PM_MeleeChargeUpdate(pmove_t *pm, pml_t *pml);
void PM_MeleeChargeCheck(pmove_t *pm);
bool PM_MeleeChargeMove_IsActive(pmove_t *pm);
void PM_MeleeChargeMove(pmove_t *pm, pml_t *pml);
void ClearPlayerVelocity(playerState_s *ps);
void PM_UpdatePush(pmove_t *pm, pml_t *pml);
void BG_seedRandWithGameTime(unsigned int *pHoldrand);
unsigned int BG_rand(unsigned int *pHoldrand);
int BG_irand(int min, int max, unsigned int *pHoldrand);
double BG_random(unsigned int *pHoldrand);
void PM_trace(;
int PM_GetSprintLeftLastTime(const playerState_s *ps);
void PM_EndSprint(playerState_s *ps, pmove_t *pm, const pml_t *pml);
char PM_SprintStartInterferingButtons(;
float PM_CmdScaleForStance(const pmove_t *pm);
bool PM_SprintEndingButtons(const pmove_t *pm);
float PM_CmdScale_Walk(pmove_t *pm, usercmd_s *cmd);
void PM_FlyMove(pmove_t *pm, pml_t *pml);
void PM_NoclipMove(pmove_t *pm, pml_t *pml);
void PM_UFOMove(pmove_t *pm, pml_t *pml);
float PM_GetMaxSpeed(pmove_t *pm, int walking, int sprinting);
// void PM_Footsteps(int a1@<esi>, pmove_t *pm, pml_t *pml);
;
void PM_UpdateViewAngles(;
void PM_UpdatePlayerWalkingFlag(pmove_t *pm);
void PM_WeaponThrustCheck(pmove_t *pm, pml_t *pml);
void TurretNVGTrigger(pmove_t *pm);
void BG_srand(unsigned int *pHoldrand);
void PM_playerTrace(;
;
bool PM_CanCrouch(playerState_s *ps, pmove_t *pm);
bool PM_CanStand(playerState_s *ps, pmove_t *pm);
void PM_UpdateSprint(pmove_t *pm, const pml_t *pml);
void PM_SwimMove(pmove_t *pm, pml_t *pml);
int PM_CorrectAllSolid(pmove_t *pm, pml_t *pml, trace_t *trace);
;
;
;
;
void PM_CheckLadderMove(pmove_t *pm, pml_t *pml);
void PM_AirMove(pmove_t *pm, pml_t *pml);
void PM_WalkMove(pmove_t *pm, pml_t *pml);
void PM_LadderMove(pmove_t *pm, pml_t *pml);
void PmoveSingle(pmove_t *pm);
void Pmove_1(pmove_t *pm);
void Pmove(pmove_t *pm);

//t6/code/src_noserver/bgame/bg_public.h
void BG_EvaluateTrajectory(const trajectory_t *tr, int atTime, vec3_t *result);
// void __thiscall WeaponDobjInfo::Add(WeaponDobjInfo *this, const WeaponDef *weapDef, unsigned int dobjModelMask);
Weapon GetWeapon(const cg_t *cgameGlob);
long double BG_GetSpeed(const playerState_s *ps, int time);
// const WeaponDef *__thiscall WeaponDobjInfo::GetWeapon(WeaponDobjInfo *this, WeaponDobjInfo::Slot slot);
// void __thiscall WeaponDobjInfo::Add(;
BOOL IsBulletImpactMOD(meansOfDeath_t mod);

//t6/code/src_noserver/bgame/bg_scriptmoveranim.cpp
void BG_ScriptMoverAnim_Shutdown();
void BG_ScriptMoverAnim_UseAnimTree(scr_animtree_t animtree);
int BG_ScriptMoverAnim_FindAnimTree(XAnimTree_s *tree);
void BG_ScriptMoverAnim_ClearServerEntity(gentity_t *ent);
void BG_ScriptMoverAnim_SetupServerEntity(;
void BG_ScriptMoverAnim_UpdateClientAnimation(LocalClientNum_t localClientNum, centity_t *cent);

//t6/code/src_noserver/bgame/bg_slidemove.cpp
gjk_polygon_cylinder_t *create_gjkcc_gjk_geom(;
// void gjkcc_info::update_cg(;
// bool __thiscall gjk_double_sphere_t::is_foot(gjk_double_sphere_t *this, const phys_vec3 *hit_point);
// bool __thiscall gjk_polygon_cylinder_t::is_foot(gjk_polygon_cylinder_t *this, const phys_vec3 *hit_point);
// bool __thiscall gjk_brush_t::is_walkable(gjk_brush_t *this, const phys_vec3 *hit_point, const phys_vec3 *up);
// bool __thiscall gjk_partition_t::is_walkable(gjk_partition_t *this, const phys_vec3 *hit_point, const phys_vec3 *up);
char gjk_collide(;
void init_pgi(phys_gjk_input *pgi, const gjk_trace_input_t *gti);
void sort_gi_list(gjk_geom_info_t **list, const int list_count);
char is_sentient(gjk_geom_info_t *gi);
char no_push_out(const gjk_trace_output_t *gto);
int PM_VerifyPronePosition(pmove_t *pm, vec3_t *vFallbackOrg, vec3_t *vFallbackVel);
double PM_PermuteRestrictiveClipPlanes(;
void setup_player_gjk_slide_move_input(;
// gjkcc_info *__thiscall gjkcc_info_database_t::gjkcc_info_find(;
// bool gjk_cylinder_t::is_foot@<al>(gjk_cylinder_t *this@<ecx>, float a2@<ebp>, const phys_vec3 *hit_point);
void setup_query_input(;
void setup_trace_info(;
// ;
void gjk_trace(const gjk_trace_input_t *gti, list_gjk_trace_output *list);
void add_hit_info(;
// bool gjk_push_out@<al>(;
// BOOL gjk_slide_move1@<eax>(;
BOOL gjk_slide_move(;
void gjk_sentient_push(;
;
// void render_gjkcc_collision(int a1@<esi>, pmove_t *pm);
void PM_gjk_ground_trace(;
;
;
void gjkcc_epilog(const gjkcc_input_t *gjkcc_in, const vec3_t *origin);
void gjk_player_trace(;
// gjkcc_info *__thiscall gjkcc_info_database_t::create_gjkcc_info(;
void destroy_gjkcc_info(void *gcci_);
// gjkcc_info *__thiscall gjkcc_info_database_t::gjkcc_info_find_or_create(;
// void __thiscall gjkcc_info_database_t::gjkcc_info_destroy(;
// void __thiscall gjkcc_info_database_t::gjkcc_info_destroy_all(gjkcc_info_database_t *this, const bool is_server_thread);
void destroy_client_gjkcc_info(LocalClientNum_t localClientNum);
void destroy_all_server_gjkcc_info();
void gjkcc_prolog(const gjkcc_input_t *gjkcc_in, const vec3_t *origin);

//t6/code/src_noserver/bgame/bg_unlockable_items.cpp
void BG_UnlockablesBuildUnlockMapping(const char *unlockMappingTableName);
int BG_UnlockablesGetUnlockIndexFromGroup(itemGroup_t group);
int BG_UnlockablesGetUnlockIndexFromName(const char *name);
const char *BG_UnlockablesGetUnlockLocString(int unlockIndex);
unsigned int BG_UnlockablesGetCurrentUnlocks(const ControllerIndex_t controllerIndex, int unlockIndex);
int BG_UnlockablesSpendUnlocks(const ControllerIndex_t controllerIndex, int unlockIndex, int cost);
void BG_UnlockablesSetItemIndex(;
void BG_UnlockablesSetGlobalItemIndex(const CACRoot *cacRoot, loadoutSlot_t loadoutSlot, int itemIndex);
void BG_UnlockablesSetLoadoutItem(const CACRoot *cacRoot, int customClass, int loadoutSlot, int itemIndex);
int BG_UnlockablesGetGlobalItemIndex(const CACRoot *cacRoot, loadoutSlot_t loadoutSlot);
int BG_UnlockablesGetItemIndex(;
// int BG_UnlockablesGetLoadoutItem@<eax>(;
void BG_UnlockablesEquipClassToSlot(;
const CACRoot *BG_UnlockablesGetLocalCACRoot(;

//t6/code/src_noserver/bgame/bg_unlockable_items_mp.cpp
const char *BG_UnlockablesGetLoadoutSlotName(loadoutSlot_t loadoutSlot);
int FindEntryInList(const char *stringEntry, const char **textArray, int numEntries);
int BG_UnlockablesCompareItemsBySortKey(const void *arg0, const void *arg1);
int BG_UnlockablesIsItemAttachmentValid(itemInfo_t *itemInfo, eAttachment attachment);
bool BG_UnlockablesIsGrenadeOrEquipment(itemInfo_t *itemInfo);
bool BG_UnlockablesIsPrimaryOrSecondary(itemInfo_t *itemInfo);
void BG_UnlockablesParseDefaultClassesForItem(;
void BG_UnlockablesParseAttachmentsForItem(itemInfo_t *itemInfo, const char *attachmentList);
itemInfo_t *BG_UnlockablesGetItemInfo(int itemIndex);
int BG_GetSpecialtyCollectionCount();
loadoutSlot_t BG_SpecialtyCollectionLoaoutSlot(int collectionIndex);
bool BG_HasSpecialtyCollection(int collectionIndex, unsigned int *perks);
// int BG_UnlockablesGetItemGroupFromName@<eax>(;
// int BG_UnlockablesGetClassIndexFromName@<eax>(;
int BG_UnlockablesGetBonusCardNameHashFromIndex(bonusCards_t bonusCard);
bonusCards_t BG_UnlockablesGetBonusCardIndexFromNameHash(int bonusCardNameHash);
void BG_UnlockablesBuildBonusCardNameHash();
const char *BG_UnlockablesGetNameForClass(loadoutClass_t customClass);
const char *BG_UnlockablesGetItemGroupName(itemGroup_t groupIndex);
int BG_UnlockablesCompareGunLevelRows(const void *a, const void *b);
gunLevelRow_t *BG_UnlockablesGetGunLevelRowForChallenge(int itemIndex, int currentXP);
void BG_UnlockablesHashItemGroupNames();
bool BG_UnlockablesAllItemsFree();
bool BG_UnlockablesAllItemsUnlocked();
char __thiscall BG_UnlockablesBuildClanTagFeatureRows(const StringTable *this);
unsigned int BG_UnlockablesGetEquippedClanTagFeatureIndex(const ControllerIndex_t controllerIndex);
const GfxViewParms *BG_UnlockablesGetClanTagFeature(unsigned int index, clanTagFeatureColumn_t column);
int BG_UnlockablesGetClanTagFeaturePLvlUnlock(unsigned int index);
bool BG_UnlockablesIsClanTagFeatureLocked(const ControllerIndex_t controllerIndex, unsigned int index);
bool BG_UnlockablesIsClanTagFeaturePurchased(const ControllerIndex_t controllerIndex, unsigned int index);
int BG_UnlockablesGetItemAttachmentNumWithAttachPoint(int itemIndex, int attachmentNum, int attachmentPoint);
int BG_UnlockablesIsItemAttachmentValid(int itemIndex, eAttachment attachment);
int BG_UnlockablesGetItemAttachmentIndexForAttachmentPoint(;
itemInfo_t *__thiscall BG_UnlockablesGetItemRefHash(void *this);
int __thiscall BG_UnlockablesGetItemCount(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemUnlockLevel(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemUnlockPLevel(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemMomentumCost(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemAllocationCost(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetRealItemCost(void *this);
int __thiscall BG_UnlockablesGetItemCost(void *this);
int __thiscall BG_UnlockablesGetItemDualWieldCost(void *this);
int __thiscall BG_UnlockablesGetItemDualWieldIndex(void *this);
int __thiscall BG_UnlockablesGetItemDualWieldBaseIndex(void *this);
int BG_UnlockablesGetNumItemAttachmentsWithAttachPoint(int itemIndex, int attachPoint);
int __thiscall BG_UnlockablesGetNumItemAttachments(void *this);
int BG_UnlockablesGetNumItemAttachmentsAtPoint(int itemIndex, eAttachmentPoint point);
eAttachment BG_UnlockablesGetItemAttachmentAtPointByIndex(;
const char *__thiscall BG_UnlockablesGetItemGroup(void *this);
int __thiscall BG_UnlockablesGetItemGroupEnum(void *this);
// int BG_UnlockablesGetLoadoutSlotFromString@<eax>(;
int __thiscall BG_UnlockablesGetItemLoadoutSlot(void *this);
bool BG_UnlockablesIsItemLockedForRank(int pLevel, int rank);
bool BG_UnlockablesIsPrestigeTokenSpent(unsigned __int8 *buffer, int pLevel);
bool BG_UnlockablesSpendPrestigeToken(unsigned __int8 *buffer);
int BG_UnlockablesGetPrestigeTokenTypeFromBuffer(unsigned __int8 *buffer, int pLevel);
char BG_UnlockablesIsItemPermanentlyUnlockedFromBuffer(unsigned __int8 *buffer, int itemIndex);
bool BG_UnlockablesIsItemLockedFromBuffer(unsigned __int8 *buffer, int itemIndex);
unsigned __int8 __thiscall BG_UnlockablesGetItemDLCIndex(void *this);
char BG_UnlockablesIsItemDLCAvailable(const ControllerIndex_t controllerIndex);
bool __thiscall BG_UnlockablesItemHasDualWield(void *this);
bool __thiscall BG_UnlockablesItemIsDualWield(void *this);
bool BG_UnlockablesIsItemValidNotNull(int itemIndex);
bool BG_UnlockablesSetItemPurchased(;
int BG_UnlockablesGetCustomClassCountFromBuffer(unsigned __int8 *buffer);
bool BG_UnlockablesIsItemPublicPurchasedFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
bool BG_UnlockablesIsItemPurchasedFromBuffer();
void BG_UnlockablesSetPurchasedBits(unsigned __int8 *statsBuffer, unsigned __int8 *purchasedItems);
BOOL BG_UnlockablesGetItemAttachmentAllocationCost(int itemIndex, int attachmentNum);
int BG_UnlockablesGetItemAttachmentXPInternal(itemInfo_t *itemInfo, int attachmentNum);
int BG_UnlockablesGetItemAttachmentXP(int itemIndex, int attachmentNum);
unsigned int BG_UnlockablesGetGunXPFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
unsigned int BG_UnlockablesGetGunPLevelFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
void BG_UnlockablesSetGunXp(const ControllerIndex_t controllerIndex, const int itemIndex, const int gunXP);
void BG_UnlockablesSetGunXPCmd();
void BG_UnlockablesSetAllGunXPToMaxCmd();
bool BG_UnlockablesIsItemAttachmentLockedFromBuffer(;
bool BG_UnlockablesIsItemAttachmentLocked(;
int BG_SetBonusCardInUse(;
BOOL BG_GetBonusCardInUse(;
BOOL BG_AnyBonusCardInUse(;
int BG_UnlockablesGetStatPathForChallenge(;
bool ChallengeLockedByXPGroup(const ControllerIndex_t controllerIndex, challengeTableRow_t *challengeRow);
bool BG_UnlockablesItemOptionLockedByChallenge(;
bool BG_UnlockablesItemOptionLocked(const ControllerIndex_t controllerIndex, int itemIndex, int optionIndex);
bool BG_UnlockablesEmblemIsElite(int emblemIndex);
void BG_UnlockablesEquipClassSpecialPropertiesToSlot(;
const char *BG_UnlockablesGetWeaponOptionRef(;
int BG_UnlockablesGetLocalEquippedItemInSlot(;
int BG_UnlockablesGetDefaultItem(int loadoutSlot);
int BG_UnlockablesGetDefaultWeaponItem();
void BG_UnlockablesEquipDefaultClass(;
void BG_UnlockablesEquipDefaultCustomMatchClassCmd();
void BG_UnlockablesEquipDefaultLeagueClassCmd();
void BG_UnlockablesEquipDefaultClassCmdInternal(;
void BG_UnlockablesEquipDefaultClassCmd();
void BG_UnlockablesEquipDefaultClassToProfileCmd();
void BG_UnlockablesUIEquipDefaultClassCmd();
void BG_UnlockablesZeroClassSet(;
void BG_UnlockablesZeroClassSetCmdInternal(;
void BG_UnlockablesZeroPublicMatchClassSetCmd();
void BG_UnlockablesZeroCustomMatchClassSetCmd();
void BG_UnlockablesZeroLeagueMatchClassSetCmd();
void BG_UnlockablesCopyToClassSet(;
void BG_UnlockablesCopyToClassSetCmdInternal(;
void BG_UnlockablesCopyToPublicMatchClassSetCmd();
void BG_UnlockablesCopyToCustomMatchClassSetCmd();
void BG_UnlockablesCopyToLeagueMatchClassSetCmd();
void BG_UnlockablesSetClassSetNameFromLocStringCmdInternal(;
void BG_UnlockablesSetPublicMatchClassSetNameFromLocStringCmd();
void BG_UnlockablesSetCustomMatchClassSetNameFromLocStringCmd();
void BG_UnlockablesSetLeagueMatchClassSetNameFromLocStringCmd();
bool BG_UnlockablesGetClassSetsDDLState(ddlState_t *ddlState, int specificGameMode);
// int BG_UnlockablesGetDefaultClassSlotIndexFromName@<eax>(;
int BG_UnlockablesBuildItemListForGroup(itemGroup_t group);
void BG_UnlockablesBuildItemListForGroupCmd();
int BG_UnlockablesBuildItemListForGroupForWeaponTable(itemGroup_t group);
void BG_UnlockablesBuildItemListForGroupForWeaponTableCmd();
void BG_UnlockablesCopyClassSection(;
void BG_UnlockablesCopyClassCmd();
void BG_UnlockablesSetClanTagCmd();
void BG_UnlockablesClearWeaponInfo(;
int BG_UnlockablesGetBonusCardSet(const ControllerIndex_t controllerIndex, const loadoutClass_t customClass);
int BG_UnlockablesGetItemEquipCount(;
// int BG_UnlockablesGetAllocationCost@<eax>(;
// int BG_UnlockablesGetUsedAllocation@<eax>(;
void BG_UnlockablesGetBonusCardSetCmd();
void BG_UnlockablesGetUsedAllocationCmd();
int BG_UnlockablesGetItemsByGroup(itemGroup_t group, unsigned __int8 *buffer, unsigned int bufferSize);
void BG_PerformPushItem_ToCACMPShared(int numItemsInSlot, int itemNum, void *param);
// char validateCACStatus_s::ValidateClass_NoDuplicateCards(;
// char validateCACStatus_s::ValidateClass_NoDuplicates(;
// char validateCACStatus_s::ValidateClass_HasBonusCard(;
// char __thiscall validateCACStatus_s::verifyUnusedAttachmentSlotsCheck(;
// void __thiscall validateCACStatus_s::Print(validateCACStatus_s *this);
// void __thiscall validateCACStatus_s::Initialize(;
const char *BG_UnlockablesGetColStringForItemIndex(int itemIndex, statsTableColumns_t column);
loadoutSlot_t BG_UnlockablesGetCountSlot(itemInfo_t *itemInfo);
void BG_UnlockablesHandleDefaultGrenadeStatus(;
bool BG_UnlockablesIsPrimaryOrSecondaryFromIndex(int itemIndex);
void BG_UnlockablesParseDLCInfo(const char *dlcInfo, itemInfo_t *itemInfo);
char BG_UnlockablesIsMaxLevelFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
const char *BG_UnlockablesGetItemName(int a1, statsTableColumns_t a2);
const char *BG_UnlockablesGetItemRef(int a1, statsTableColumns_t a2);
const char *BG_UnlockablesGetItemImage(int a1, statsTableColumns_t a2);
bool __thiscall BG_UnlockablesDLCWeaponDisabled(void *this);
const char *BG_UnlockablesGetItemDesc(int a1, statsTableColumns_t a2);
bool BG_UnlockablesIsItemLocked(const ControllerIndex_t controllerIndex, int itemIndex);
bool BG_UnlockablesIsItemDualWieldLocked(const ControllerIndex_t controllerIndex);
// char BG_UnlockablesIsItemTrackedByMap@<al>(;
bool BG_UnlockablesIsItemNew(const ControllerIndex_t controllerIndex, int itemIndex);
char BG_UnlockablesIsItemGroupNew(;
bool BG_UnlockablesIsItemPurchased(const ControllerIndex_t controllerIndex, int itemIndex);
bool BG_UnlockablesIsItemDualWieldPurchased(const ControllerIndex_t controllerIndex);
void BG_UnlockablesSetBonusCardBits(;
bool BG_UnlockablesEmblemOrBackingLockedByChallenge(;
bool BG_UnlockablesEmblemLockedByChallenge(ControllerIndex_t controllerIndex, int emblemIndex);
bool BG_UnlockablesEmblemBackingLockedByChallenge(ControllerIndex_t controllerIndex, int backingIndex);
int BG_UnlockablesGetItemIndexFromName(const char *itemName);
// int BG_UnlockablesGetItemIndexFromRefHash@<eax>(;
int BG_UnlockablesGetItemIndexFromRef(const char *itemName);
int BG_UnlockablesGetItemIndexforWeapon(Weapon weapon);
void BG_UnlockablesClearItemNew(ControllerIndex_t controllerIndex, int itemIndex);
void BG_UnlockablesClearAllItemsNew(ControllerIndex_t controllerIndex);
void BG_UnlockablesEquipClass(ControllerIndex_t controllerIndex, loadoutClass_t customClass, int itemIndex);
bool BG_UnlockablesIsItemEquipped(ControllerIndex_t controllerIndex, loadoutClass_t customClass, int itemIndex);
void BG_UnlockablesEquipClassCmd();
void BG_UnlockablesEquipDefaultItemToSlotCmd();
// const char *BG_UnlockablesGetDefaultClassSlotFromName@<eax>(;
void BG_UnlockablesClearItemNewCmd();
void BG_UnlockablesClearAllItemsNewCmd();
int BG_UnlockablesGetNumPurchasedItemsInCurrentList(const ControllerIndex_t controllerIndex);
int BG_UnlockablesBuildItemListForSlotName(const ControllerIndex_t controllerIndex, const char *slotName);
void BG_UnlockablesBuildItemListForSlotNameCmd();
int BG_UnlockablesBuildItemListForGroupName(const ControllerIndex_t controllerIndex, const char *groupName);
void BG_UnlockablesBuildItemListForGroupNameCmd();
int BG_UnlockablesBuildItemListForSlotNameAndGroup(;
void BG_UnlockablesBuildItemListForSlotNameAndGroupCmd();
int BG_UnlockablesGetItemIndexInSlot(int itemNum);
bool BG_UnlockablesBonusCardEquipAction(;
bool BG_UnlockablesIsBonusCardInSet(const int cardSet, const char *cardName);
void BG_UnlockablesIsBonusCardInSetCmd();
void BG_UnlockablesEquipBonusCardCmd();
void BG_UnlockablesUnequipBonusCardCmd();
void BG_UnlockablesPushItemsByGroupName(;
// char validateCACStatus_s::ValidateClass_ByGroupSearch(;
// int __thiscall validateCACStatus_s::ValidateClass_GetNumItemAttachments(;
// bool __thiscall validateCACStatus_s::ValidateClass_BonusCard_PrerequisitesAndRules(;
// void validateCACStatus_s::ValidateClass_BonusCards(validateCACStatus_s *this, loadoutSlot_t a2);
// bool __thiscall validateCACStatus_s::ValidateClass_AdditionalGrenadeCheck(;
// void validateCACStatus_s::ValidateClass_Grenade(validateCACStatus_s *this, loadoutSlot_t a2, int slotIndex);
// void validateCACStatus_s::ValidateClass_Specialties(validateCACStatus_s *this, loadoutSlot_t a2);
// void validateCACStatus_s::ValidateClass_KillStreaks(validateCACStatus_s *this, loadoutSlot_t a2);
// void validateCACStatus_s::ValidateClass_BaseWeapon(;
// bool validateCACStatus_s::ValidateClass_Attachments_CheckMaxAllowed(;
// void validateCACStatus_s::ValidateClass_VerifyNoAttachments(;
// char validateCACStatus_s::Verify(;
bool BG_UnlockablesCheckItemsInClass(;
char BG_Unlockable_CheckLoadOutVsRank(unsigned __int8 *buffer);
void BG_UnlockablesBuildDefaultClasses(defaultClassInfo_t *defaultClassInfoTable);
void BG_UnlockablesParseDualWieldInfo(itemInfo_t *itemInfo);
void BG_UnlockablesParseSpecialtyInfo(itemInfo_t *itemInfo);
// const char *BG_GetSpecialtyCollectionImageName@<eax>(statsTableColumns_t a1@<edx>, int collectionIndex);
// const char *BG_GetSpecialtyCollectionName@<eax>(statsTableColumns_t a1@<edx>, int collectionIndex);
void BG_UnlockablesBuildGunLevels();
bool BG_UnlockablesIsItemInUnlockedByCAC(int itemIndex);
bool BG_UnlockablesBuildItemInfo(;
unsigned int BG_UnlockablesBuildActualDefaultItems();
unsigned int BG_UnlockablesBuildDefaultItems();
void BG_InitUnlockables();
eAttachment BG_UnlockablesGetItemAttachment(int itemIndex, int attachmentNum);
void BG_UnlockablesPurchaseItem(const ControllerIndex_t controllerIndex, int itemIndex, int cost);
const char *BG_UnlockablesGetItemAttachmentRef(int itemIndex, int attachmentNum);
void BG_UnlockablesPurchaseItemCmd();
void BG_UnlockablesSetUnlockedAttachmentBits(;
// const char *BG_UnlockablesGetAttachmentRef@<eax>(;
// const char *BG_UnlockablesGetItemReferenceInLoadoutSlot@<eax>(;
// void validateCACStatus_s::ValidateClass_WeaponOption(;
// char __thiscall validateCACStatus_s::ValidateClass_NoConflictingAttachments(;
// void validateCACStatus_s::ValidateClass_Attachments(;
// bool validateCACStatus_s::Validate(;
void BG_UnlockablesValidateClassCmd();
void BG_UnlockableItemsInit();

//t6/code/src_noserver/bgame/bg_vehicle.cpp
VehicleDef *BG_GetVehicleDef(int index);
BOOL BG_IsVehicleAircraftRemote(const VehicleDef *info);
bool BG_VehicleUsesCylinderGJK(const VehicleDef *vehDef);
bool BG_VehicleUsesGJK(const VehicleDef *vehDef);
PhysGeomList *G_VEH_GetCollmap(LocalClientNum_t localClientNum, const int entNum);
PhysGeomList *CG_VEH_GetCollmap(LocalClientNum_t localClientNum, const int entNum);
// colgeom_visitor_inlined_t<300> *G_GetVehicleProximityCache(;
// colgeom_visitor_inlined_t<300> *CG_GetVehicleProximityCache(;
VehicleDef *G_GetVehicleDef(LocalClientNum_t localClientNum, const playerState_s *ps);
VehicleDef *CG_GetVehicleDef(LocalClientNum_t localClientNum, const playerState_s *ps);
int CG_GetWheelOrigin(const pmove_t *pm, int wheelIndex, vec3_t *result);
int G_GetWheelOrigin(const pmove_t *pm, int wheelIndex, vec3_t *result);
const VehicleDef *BG_GetVehicleDef(const pmove_t *pm);
int BG_GetWheelOrigin(const pmove_t *pm, int wheelIndex, vec3_t *result);
void BG_GetVehicleBounds(const pmove_t *pm, vec3_t *mins, vec3_t *maxs);
void BG_VehicleClipVelocity(const vec3_t *velocity, const vec3_t *normal, vec3_t *clippedVelocity);
;
void BG_PlayerStateToVehicleState(;
;
void BG_VehicleGroundTrace(pmove_t *pm, VehicleState *vehicleState, GroundTrace *groundTrace);
;
;
void BG_VehicleGroundMove(;
;
;
void BG_VehicleMove(pmove_t *pm, const pml_t *pml);

//t6/code/src_noserver/bgame/bg_vehicleinfo_db.h
// void __thiscall VehicleParameter::SetDefaultValues(VehicleParameter *this);

//t6/code/src_noserver/bgame/bg_vehicleinfo_load_db.h
void Load_VehicleDriveBySoundArray(bool atStreamStart, int count);
void Load_VehicleEngineSoundArray(bool atStreamStart, int count);
void Load_VehicleEngine(bool atStreamStart);
void Mark_VehicleDef();
void Mark_VehicleDefPtr();
void Load_VehicleDef(bool atStreamStart);
void Load_VehicleDefPtr(bool atStreamStart);

//t6/code/src_noserver/bgame/bg_vehicleinfo_load_obj.cpp
void VEH_Strcpy(unsigned __int8 *pMember, const char *pKeyValue);
void InitVehicle(VehicleDef *vehicleDef);
// VehicleDef *VehicleDefLoadFile@<eax>(FsThread a1@<edi>, const char *name, void *(*Alloc)(int));
VehicleDef *VehicleDefPrecache(const char *name, void *(*Alloc)(int));
VehicleDef *VehicleDef_Register_FastFile(const char *name);
unsigned __int8 *Hunk_AllocVehicleDefPrecache(int size);
VehicleDef *VehicleDef_Register_LoadObj(const char *name);
VehicleDef *VehicleDef_Register();
void VehicleDef_PostLoadFixUp(VehicleDef *vehicleDef);

//t6/code/src_noserver/bgame/bg_vehicles_mp.cpp
unsigned __int16 BG_VehiclesGetSlotTagName(int seatIndex);

//t6/code/src_noserver/bgame/bg_vehicle_anim.cpp
void VehAnim_RegisterDvars();
void VehAnim_Init();
void VehAnim_GetAnimDelta(XAnimTree_s *tree, int animIndex, vec4_t *rot, vec3_t *trans);
void VehAnim_UpdatePosRot(;

//t6/code/src_noserver/bgame/bg_vehicle_csptable.cpp
void TRACK_bg_vehicle_csptable();

//t6/code/src_noserver/bgame/bg_weapons.cpp
void BG_ParsePenetrationDepthTable(const char *penetrateType, float *depthTable, const char *buffer);
void BG_LoadPenetrationDepthTable();
bool BG_AdvanceTrace(BulletFireParams *bp, BulletTraceResults *br, float dist);
double BG_GetSurfacePenetrationDepth(PenetrateType penetrateType, int surfaceType);
void PM_StartWeaponAnim(playerState_s *ps, int anim, int leftAnim);
void PM_ContinueWeaponAnim(playerState_s *ps, int anim, int leftAnim);
const char *BG_GetImpactTypeName(int impactTypeIndex);
Weapon BG_GetFirstEquippedOffhand(const playerState_s *ps, int offhandSlot);
int *BG_GetWeaponState(playerState_s *ps, bool leftGun);
BOOL BG_IsAimDownSightWeapon(const Weapon weapon);
BOOL BG_IsAdsOnlyWeaponChange(Weapon oldWeapon, Weapon newWeapon);
bool BG_CanPlayerHaveWeapon(const Weapon weapon);
BOOL BG_ValidateWeaponNumber(const Weapon weapon);
bool BG_IsWeaponValid(const playerState_s *ps, const Weapon weapon);
bool BG_WeaponBlocksProne(const Weapon weapon);
bool BG_IsOverheatingWeapon(const Weapon weapon);
bool BG_IsBayonetWeapon(const Weapon weapon);
char BG_IsUseAsMeleeWeapon(const Weapon weapon);
void BG_TakeHeldWeapon(playerState_s *ps, const Weapon weapon);
bool PM_IsAdsAllowed(pmove_t *pm, pml_t *pml);
void PM_ExitAimDownSight(playerState_s *ps);
int PM_Weapon_GetMaxChargeLevelForClipAmmo(playerState_s *ps, Weapon weapon);
double BG_GetChargeShotWeaponCenterSpeed(const playerState_s *ps, const Weapon weapon);
void PM_UpdateQuickScope(pmove_t *pm, pml_t *pml, float oldWeaponFrac);
BOOL BG_UsingSniperScope(const playerState_s *ps);
int BG_UsingTacticalInsertion(const playerState_s *ps);
BOOL BG_UsingVariableZoomWeapon(const playerState_s *ps);
BOOL BG_UsingVariableZoomScope(const playerState_s *ps);
bool BG_PlayerWeaponOverheating(const playerState_s *ps, const Weapon weapon);
double BG_PlayerWeaponOverheatPercent(const playerState_s *ps, const Weapon weapon);
void BG_PlayerWeaponOverheatUpdate(playerState_s *ps, const Weapon weapon, float amount);
int PM_IsWeaponMinFireTimeElapsed(playerState_s *ps, bool leftGun);
void BG_Weapon_PlayEjectBrass(playerState_s *ps);
void PM_Weapon_FinishRechamber(playerState_s *ps);
int PM_Weapon_CheckForRechamber(playerState_s *ps, int delayedAction);
Weapon PM_GetWeaponIndexForHand(playerState_s *ps);
int PM_GetWeaponOnVehicleReloadTime(playerState_s *ps);
bool BG_PlayDWThirdPersonReload(playerState_s *ps);
BOOL BG_IsAltSwitch(const playerState_s *ps, const Weapon lastWeapon, const Weapon weapon);
bool BG_CanFastSwitch(const WeaponDef *weapDef, int weaponState);
char BG_IsQuickSwitch(Weapon oldweapon, Weapon newweapon, int weaponState);
void PM_BeginWeaponChange(pmove_t *pm, pml_t *pml, Weapon newweapon, const bool quick);
void PM_Weapon_BeginWeaponRaise(;
bool BG_CheckIfDualWieldEmpty(playerState_s *ps);
void BG_SwitchWeaponsIfEmpty(playerState_s *ps);
Weapon BG_GetValidPrimaryWeaponForAltMode(;
int PM_GetWeaponFireButton(Weapon weapon, pmove_t *pm, bool runLeftGun);
void PM_Weapon_FinishWeaponRaise(playerState_s *ps);
void PM_Weapon_ReloadDelayedAction(playerState_s *ps);
void PM_Weapon_FinishReloadEnd(playerState_s *ps);
bool PM_CheckForReloadInterferingWeaponStates(pmove_t *pm, pml_t *pml, playerState_s *ps, int weaponState);
float PM_AddQuickScopeSpread(playerState_s *ps);
bool ShotLimitReached(playerState_s *ps, const Weapon weapon);
bool BurstFirePending(playerState_s *ps);
bool PM_Weapon_TriggerPullPending(const playerState_s *ps);
BOOL BG_CheckIfIntroShot(const playerState_s *ps, const Weapon weapon);
bool BG_CheckIfLastShot(playerState_s *ps, Weapon weapon);
void PM_Weapon_StartFiring(pmove_t *pm, pml_t *pml, int delayedAction);
int PM_Weapon_GetAmmoRequired(playerState_s *ps, Weapon weapon);
void PM_Weapon_Jam(playerState_s *ps);
void PM_Weapon_SetFPSFireAnim(playerState_s *ps);
void PM_Weapon_AddFiringAimSpreadScale(playerState_s *ps);
void DrawPlantDebug(vec3_t *start, vec3_t *end);
int PM_Weapon_CheckFriendlyFire(pmove_t *pm);
void PM_Weapon_MeleeFire(playerState_s *ps, int leftGun);
void PM_Weapon_MeleeInit(pmove_t *pm, pml_t *pml, bool right, bool left);
void PM_Weapon_Idle(playerState_s *ps);
void PM_Weapon_RiotshieldPrepare(pmove_t *pm, pml_t *pml);
void PM_Weapon_RiotshieldHold(playerState_s *ps);
void PM_Weapon_Riotshield(pmove_t *pm);
void PM_Weapon_OffHand_HoldUse(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHandInit(playerState_s *ps);
void PM_Weapon_OffHandEnd(playerState_s *ps);
void PM_SendEmtpyOffhandEvent(playerState_s *ps, OffhandSlot offhandSlot);
void PM_Detonate(playerState_s *ps, int delayedAction);
void PM_Weapon_FinishNightVisionWear(playerState_s *ps);
void PM_Weapon_FinishNightVisionRemove(playerState_s *ps);
void PM_WeaponSwimIn(playerState_s *ps);
void PM_WeaponSwimOut(playerState_s *ps);
void Sprint_State_Raise(playerState_s *ps);
void Sprint_State_Loop(playerState_s *ps);
void Crawl_State_In(playerState_s *ps);
void Crawl_State_Out(playerState_s *ps, int tryingToFiring);
void ContinuousFire_State_In(playerState_s *ps);
void ContinuousFire_State_Loop(playerState_s *ps);
void ContinuousFire_State_Out(playerState_s *ps);
void Dtp_State_In(playerState_s *ps);
void Slide_State_In(playerState_s *ps);
void Dtp_State_Out(playerState_s *ps);
void Dtp_State_Loop(playerState_s *ps);
void Deploy_State_Deploy(playerState_s *ps);
void Deploy_State_Breakdown(playerState_s *ps);
void PM_Weapon_CheckForDtp(pmove_t *pm);
void PM_Weapon_CheckForSlide(pmove_t *pm);
void PM_Weapon_CheckForDeploy(pmove_t *pm);
void PM_Weapon_CheckForMantle(pmove_t *pm);
void UpdateRiotShieldSwitchingFlag(playerState_s *ps);
void __thiscall PM_ResetWeaponState(playerState_s *this);
int BG_PlayerWeaponCountPrimaryTypes(const playerState_s *ps);
bool BG_PlayerWeaponsFull_Primaries(const playerState_s *ps);
char BG_PlayerHasCompatibleWeapon(const playerState_s *ps, const Weapon weapon);
BOOL BG_ThrowingBackGrenade(const playerState_s *ps);
void BG_CalcVehicleTurretWeaponPosOffset(;
WeaponVariantDef *BG_LoadWeaponVariantDef_LoadObj(const char *name);
WeaponVariantDef *BG_LoadWeaponVariantDef_FastFile(const char *name);
WeaponVariantDef *BG_LoadWeaponVariantDef();
PlayerHeldWeapon *BG_GetFuelTankTime(const playerState_s *ps, const Weapon weapon);
void BG_SetFuelTankTime(playerState_s *ps, const Weapon weapon, int time);
void BG_AddFuelTankTime(playerState_s *ps, const Weapon weapon, int time);
char *BG_GetWeaponName(const Weapon weapon, char *output, unsigned int maxStringLen);
void BG_GetWeaponFireBarrelInfo(const WeaponDef *weapDef, int currentBarrel, int *startBarrel, int *numBarrels);
BOOL BG_WeaponNotUsedOnVehicle(int eFlags);
BOOL BG_WeaponUsedOnVehicle(int eFlags);
Weapon BG_GetViewmodelWeaponIndex(const playerState_s *ps);
int BG_TakePlayerWeapon(playerState_s *ps, const Weapon weapon);
// void PM_UpdateAimDownSightFlag(pml_t *a1@<edx>, pmove_t *a2@<ecx>, pmove_t *pm);
void PM_UpdateScopeZoom(pmove_t *pm);
void PM_UpdateSpinLerp(pmove_t *pm, pml_t *pml);
void PM_UpdateChargeShot(pmove_t *pm, pml_t *pml);
bool ShouldFireChargeShotWeapon(playerState_s *ps, pmove_t *pm);
void PM_HoldBreathFire(playerState_s *ps);
void PM_UpdateAirburstLase(pmove_t *pm, pml_t *pml);
BOOL BG_UsingVehicleWeapon(const playerState_s *ps);
int PM_InteruptWeaponWithProneMove(playerState_s *ps);
void PM_SetWeaponReloadAddAmmoDelay(playerState_s *ps);
void PM_SetReloadingState(playerState_s *ps);
void PM_BeginWeaponReload(pmove_t *pm, pml_t *pml);
void BG_TakeClipOnlyWeaponIfEmpty(playerState_s *ps, Weapon weapon);
void PM_Weapon_FinishWeaponChange(pmove_t *pm, pml_t *pml, int previousWeaponState);
int PM_Weapon_AllowReload(playerState_s *ps);
void PM_Weapon_FinishReloadStart(pmove_t *pm, int delayedAction);
void PM_Weapon_FinishReload(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckFuelTime(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForReload(pmove_t *pm, pml_t *pml);
void PM_AdjustAimSpreadScale(pmove_t *pm, pml_t *pml);
void UpdatePendingTriggerPull(pmove_t *pm);
bool PM_Weapon_BurstFireWaitingForTriggerRelease(;
int PM_Weapon_WeaponTimeAdjust(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForChangeWeapon(pmove_t *pm, pml_t *pml);
int PM_Weapon_ShouldBeFiring(pmove_t *pm, int delayedAction, bool testOnly, bool runLeftGun);
int PM_Weapon_CheckFiringAmmo(pmove_t *pm, pml_t *pml);
bool PM_Weapon_IsHoldingGrenade(pmove_t *pm);
;
;
void PM_Weapon_FireWeapon(pmove_t *pm, pml_t *pml, int delayedAction);
void PM_Weapon_MeleeEnd(playerState_s *ps, int leftGun);
void PM_Weapon_CheckForMelee(pmove_t *pm, pml_t *pml, int delayedAction);
void PM_Weapon_RiotshieldStart(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForDeployRiotshield(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHandPrepare(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHandHold(playerState_s *ps);
void PM_Weapon_OffHandStart(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHand(pmove_t *pm);
bool PM_UpdateGrenadeThrow(playerState_s *ps, pml_t *pml);
bool PM_Weapon_CheckGrenadeHold(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckForDetonation(pmove_t *pm);
void PM_Weapon_CheckForGrenadeThrowCancel(pmove_t *pm);
void PM_Weapon_CheckForNightVision(pmove_t *pm);
char Crawl_Set_Direction(pmove_t *pm, int delayedAction);
void Crawl_State_Continue_Loop(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckForContinuousFire(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckForProne(pmove_t *pm);
void PM_Weapon_CheckForAirburstMark(pmove_t *pm);
void BG_IncrementViewMovementIdleTime(playerState_s *ps, float frametime);
void BG_IncrementWeaponMovementIdleTime(const playerState_s *ps, float frametime, int *weaponIdleTime);
void PM_UpdateSwayPrediction(playerState_s *ps, float frametime);
void PM_Weapon_Turret(pmove_t *pm, pml_t *pml);
void BG_WeaponFireRecoil(;
void BG_AssertOffhandIndexOrNone(const Weapon offHandWeapon);
char BG_HoldWeapon(playerState_s *ps, const Weapon weapon);
Weapon BG_GetFirstAvailableOffhand(const playerState_s *ps, int offhandSlot);
void BG_GetSpreadForWeapon(const playerState_s *ps, const Weapon weapon, float *minSpread, float *maxSpread);
void PM_UpdateAimDownSightLerp(pmove_t *pm, pml_t *pml);
void PM_UpdateHoldBreath(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForOffHand(pmove_t *pm, pml_t *pml);
void Sprint_State_Drop(playerState_s *ps);
void PM_Weapon_CheckForSprint(pmove_t *pm);
int BG_CheckForUniversalActionDW(playerState_s *ps);
void PM_Weapon(pmove_t *pm, pml_t *pml);

//t6/code/src_noserver/bgame/bg_weapons.h
bool isWeaponNone(Weapon weapon);
int BG_GetHeldWeaponSlot(const playerState_s *ps, const Weapon weapon);
PlayerHeldWeapon *BG_GetHeldWeaponConst(const playerState_s *ps, const Weapon weapon);
BOOL BG_PlayerHasWeapon(const playerState_s *ps, const Weapon weapon);
int BG_PlayerFuelTankTime(const playerState_s *ps, const Weapon weapon);
PlayerHeldWeapon *BG_GetHeldWeapon(const playerState_s *ps, const Weapon weapon);
PlayerHeldWeapon *BG_PlayerWeaponGetADSSelect(const playerState_s *ps, const Weapon weapon);
unsigned __int8 BG_GetPlayerWeaponModel(const playerState_s *ps, const Weapon weapon);
double BG_PlayerWeaponHeat(const playerState_s *ps, const Weapon weapon);
Weapon BG_GetBaseWeapon(const Weapon weapon);
PlayerHeldWeapon *BG_GetHeldWeapon(playerState_s *ps, const Weapon weapon);
void BG_PlayerSetWeaponQuickReload(playerState_s *ps, const Weapon weapon, bool quickReload);
void BG_SetEverHadAllPlayerHeldWeapons(playerState_s *ps, bool hadWeapon);
void BG_PlayerSetEverHadWeapon(playerState_s *ps, const Weapon weapon, bool hadWeapon);
void BG_PlayerSetFuelTankTime(playerState_s *ps, const Weapon weapon, int fuelTankTime);
void BG_PlayerWeaponSetNeedsRechamber(playerState_s *ps, const Weapon weapon, bool needsRechamber);
PlayerHeldWeapon *BG_PlayerWeaponBlockPickupWeapon(const playerState_s *ps, const Weapon weapon);
int BG_GetFreeHeldWeaponSlot(const playerState_s *ps);
BOOL BG_PlayerEverHadWeapon(const playerState_s *ps, const Weapon weapon);
BOOL BG_PlayerWeaponNeedsRechambered(const playerState_s *ps, const Weapon weapon);
int BG_PlayerWeaponIncrementADSSelect(playerState_s *ps, const Weapon weapon);
BOOL BG_PlayerWeaponQuickReload(const playerState_s *ps, const Weapon weapon);

//t6/code/src_noserver/bgame/bg_weapons_ammo.cpp
void TRACK_bg_weapons_ammo();
Weapon BG_GetWeaponForAmmoClip(const Weapon weapon);
Weapon BG_GetWeaponForAmmoPool(const Weapon weapon);
void BG_SetupWeaponDefAmmoIndexes(const Weapon weapon, WeaponDef *weapDef, WeaponVariantDef *weapVarDef);
void BG_SetupWeaponAttachmentsAmmoIndexes(;
void BG_SetupWeaponDefSharedAmmoIndexes(const Weapon weapon, WeaponDef *weapDef);
void BG_SetupWeaponDefClipIndexes(const Weapon weapon, WeaponDef *weapDef, WeaponVariantDef *weapVarDef);
void BG_SetupWeaponAttachmentsClipIndexes(;
void BG_ClearWeaponDefAmmo();
int BG_GetSharedAmmoCapSize(int capIndex);
AmmoClip *BG_GetAmmoClip(playerState_s *ps, const Weapon weapon);
int BG_AddAmmoToClip(playerState_s *ps, const Weapon weapon, int amount);
void BG_SetAmmoInClip(playerState_s *ps, const Weapon weapon, int amount);
AmmoPool *BG_GetAmmoPool(playerState_s *ps, const Weapon weapon);
void BG_AddAmmoToPool(playerState_s *ps, const Weapon weapon, int amount);
void BG_SetAmmoInPool(playerState_s *ps, const Weapon weapon, int amount);
void AddValueToArray(int *weaponArray, int value);
BOOL BG_WeaponIsClipOnly(Weapon weapon);
int BG_GetClipSize(const Weapon weapon);
int BG_GetAmmoInClip(const playerState_s *ps, const Weapon weapon);
int BG_GetAmmoNotInClip(const playerState_s *ps, const Weapon weapon);
int BG_GetAmmoPlayerMax(const playerState_s *ps, const Weapon weapon, const Weapon weaponToSkip);
int BG_GetMaxPickupableAmmo(const playerState_s *ps, const Weapon weapon);
int BG_GetTotalAmmoReserve(const playerState_s *ps, const Weapon weapon);
int BG_WeaponAmmo(const playerState_s *ps, Weapon weapon);
void PM_ReloadClip(playerState_s *ps);
int PM_WeaponUseAmmo(playerState_s *ps, Weapon weapon, int amount);
int PM_WeaponAmmoAvailable(playerState_s *ps);
BOOL PM_WeaponClipEmpty(playerState_s *ps);

//t6/code/src_noserver/bgame/bg_weapons_ammo.h
int BG_GetStartAmmo(Weapon weapon);
int BG_GetMaxAmmo(Weapon weapon);

//t6/code/src_noserver/bgame/bg_weapons_attachment.cpp
const char **BG_GetAttachmentNames();
const char *BG_GetAttachmentName(eAttachment index);
eAttachment BG_GetAttachmentIndex(const char *name);
int BG_GetAttachmentPointIndex(const char *name);
int BG_GetWeaponAttachmentCount();
const char *BG_GetAttachmentDisplayName(eAttachment attachment);
const char *BG_GetAttachmentReference(eAttachment attachment);
const char *BG_GetAttachmentImage(eAttachment attachment);
const char *BG_GetAttachmentDesc(eAttachment attachment);
int BG_GetAttachmentAllocationCost(eAttachment attachment);
int BG_GetAttachmentCompatibleAttachmentsBitMask(eAttachment attachment);
eAttachmentPoint BG_GetAttachmentPointIndexFromAttachment(eAttachment attachment);
bool BG_IsAttachmentCompatible(unsigned __int64 bitMask, eAttachment attachment);
bool BG_AreAttachmentsCompatible(eAttachment attachment1, eAttachment attachment2);
const AttachmentTableEntry *BG_GetAttachmentTableEntry(int index);
const char *BG_GetWeaponOptionDisplayName(int weaponOption);
const char *BG_GetWeaponOptionReference(int weaponOption);
const char *BG_GetWeaponOptionImage(int weaponOption);
eWeaponOptionGroup BG_GetWeaponOptionGroup(int weaponOption);
int BG_GetWeaponOptionUnlockLvl(int weaponOption);
int BG_GetWeaponOptionSubIndex(int weaponOption);
int BG_GetWeaponOptionUnlockPLevel(int weaponOption);
bool BG_GetWeaponOptionIsElite(int weaponOption);
int BG_GetWeaponOptionNumFromIndexAndGroup(int index, eWeaponOptionGroup weaponOptionGroup);
int BG_GetWeaponOptionFromName(const char *optionName);
void BG_LoadWeaponAttachmentTableRow(;
void BG_LoadAttachmentRow(;
void BG_LoadWeaponOptionRow(;
void BG_LoadWeaponOptions(const StringTable *attachmentTable);
void BG_LoadWeaponAttachmentTable();
int BG_GetWeaponOptionMTXIndex(int weaponOption);
int BG_GetWeaponAttachmentCount(const Weapon weapon);

//t6/code/src_noserver/bgame/bg_weapons_def.cpp
// void __thiscall WeaponVariantDefHash::Set(WeaponVariantDefHash *this, int wi);
unsigned int BG_GetNumWeapons();
WeaponVariantDef *BG_GetWeaponVariantDef(const Weapon weapon);
WeaponDef *BG_GetWeaponDef(const Weapon weapon);
unsigned int BG_FreeWeaponDefStrings();
void BG_ShutdownWeaponDefFiles();
void BG_SetupAttachmentAlts(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupAttachmentDualWield(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupWeaponAlts(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupDualWieldAlts(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupWeaponMountedVersions(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_InitDefaultWeaponDef();
void BG_ClearWeaponDef();
void BG_WeaponMyChanges();
void BG_SetUpAmmoForWeapon(Weapon weapon);
int BG_WeaponVariantNameHashCompare(const void *a, const void *b);
Weapon BG_FindWeaponForName(const char *name);
bool BG_IsDefaultWeapon(const char *name);
Weapon BG_SortWeaponAttachments(const Weapon weapon);
Weapon BG_GetWeaponForFullName(const char *name, Weapon (*getWeaponForName)(const char *));
int GunPerkCount();
int GunPerkFromIndex(int index);
unsigned int BG_SetupWeaponVariantDef(WeaponVariantDef *weapVariantDef, void (*regWeap)(unsigned int));
void BG_FillInAllWeaponItems();
Weapon BG_GetWeaponForName(const char *name, void (*regWeap)(unsigned int));
Weapon BG_GetWeaponForName(const char *name);
void BG_SetupAltWeaponIndex(;
void BG_WeaponVariantPrecache(;
void PrecacheGunPerk_r(;
void WeaponVariantPrecacheGunPerk(;
bool BG_WeaponVariantPrecache_r(;
// bool BG_LoadWeaponTableBaseAndVariants@<al>(;
int BG_GetWeaponTableItemIndex(Weapon weapon);
char BG_LoadWeaponTable(const char *weaponNamePostfix, void (*regWeap)(unsigned int));

//t6/code/src_noserver/bgame/bg_weapons_load_db.h
void Mark_flameTable();
void Load_flameTable(bool atStreamStart);
void Mark_WeaponDef();
void Mark_WeaponVariantDef();
void Mark_WeaponVariantDefPtr();
void Load_WeaponDef(bool atStreamStart);
void Load_WeaponVariantDef(bool atStreamStart);
void Load_WeaponVariantDefPtr(bool atStreamStart);

//t6/code/src_noserver/bgame/bg_weapons_load_obj.cpp
char *BG_GetPlayerAnimTypeName(int index);
int BG_GetPlayerAnimTypeIndex(int typeEnum);
void TRACK_bg_weapons_load_obj();
const char *BG_GetWeaponTypeName(weapType_t type);
const char *BG_GetWeaponClassName(weapClass_t type);
const char *BG_GetWeaponInventoryTypeName(weapInventoryType_t type);
void BG_LoadWeaponStrings();
void BG_LoadPlayerAnimTypes();
int Weapon_GetStringArrayIndex(const char *value, const char **stringArray, int arraySize);
void BG_ClearWeaponDefInternal();
char **BG_RegisterSurfaceTypeSounds(const char *surfaceSoundBase);
// int BG_ParseWeaponDefSpecificFieldType@<eax>(;
void BG_SetupTransitionTimes(WeaponVariantDef *weapVariantDef);
void BG_CheckWeaponDamageRanges(WeaponVariantDef *weapVariantDef);
void BG_SetupAttachmentField(WeaponVariantDef *weapVariantDef);
void BG_SetupAttachmentField_OldStyle(WeaponVariantDef *weapVariantDef, const char *name);
void BG_CheckProjectileValues(WeaponFullDef *weaponFullDef);
void InitWeaponDef(WeaponFullDef *weapFullDef);
flameTable *BG_LoadFlameTableInternal(const char *folder, const char *name);
flameTable *BG_GetFlameTable(const char *folder, const char *name);
char BG_LoadWeaponFile(const char *szFileName, char *szBuffer, int iBufferSize);
void BG_LoadWeaponMergeSupport();
char BG_SplitWeaponDefNames(;
int BG_MergeWeaponDefClipName(char **value, char *mergedValue, int size);
int BG_MergeWeaponDefFloatValue(char **value, char *mergedValue);
int BG_MergeWeaponDefBitFieldValue(char **value, char *mergedValue, int size);
int BG_MergeWeaponDefHidetags(char **value, char *mergedValue, int size);
bool BG_IsAnimationField(const char *fieldName);
int BG_MergeWeaponDefAnimations(const char *fieldName, char **value, char *mergedValue, int size);
int BG_MergeWeaponDefSpecialCases(const char *fieldName, char **value, char *mergedValue, int size);
bool BG_LoadWeaponVariantDefFile(;
WeaponVariantDef *BG_LoadWeaponVariantDefInternal(const char *folder, const char *name, const char *postfix);
char BG_WeaponUpdateField(const char *weaponName, const char *keyValue);
// bool BG_FlameTableUpdateField@<al>(;
void BG_CamoParseMaterialIndex(const char *key, unsigned int *set, unsigned int *mat);
char BG_CamoSetReplaceFlags(WeaponCamo *camo, const char *key, WeaponCamoMaterialFlags flag, int value);
char BG_WeaponCamoUpdateField(const char *camoName, const char *keyValue);
WeaponFullDef *__thiscall BG_LoadDefaultWeaponVariantDef_LoadObj(WeaponFullDef *this);
WeaponVariantDef *BG_LoadDefaultWeaponVariantDef_FastFile();
WeaponVariantDef *BG_LoadDefaultWeaponVariantDef();

//t6/code/src_noserver/bgame/bg_weapons_util.cpp
void BG_WeaponNameToComponentList(const char *name, WeaponComponentList *componentList);
void BG_WeaponNameToIdentifiedComponentList(const char *name, WeaponComponentList *componentList);
void BG_WeaponComponentListIdentify(WeaponComponentList *componentList);
int BG_WeaponComponentListCountAttachments(const WeaponComponentList *componentList);
void BG_WeaponComponentListRemove(;
void BG_WeaponComponentListRemoveAllAttachments(;
void BG_WeaponComponentListNthAttachment(;
void BG_WeaponComponentListToName(const WeaponComponentList *componentList, char *name, int size);
void BG_WeaponComponentListToBaseName(const WeaponComponentList *componentList, char *name, int size);
bool BG_WeaponUsesBurstFire(weapFireType_t fireType);
BOOL BG_WeaponUsesAttachments(const WeaponVariantDef *weapVariantDef);
bool BG_WeaponHasAttachment(const Weapon weapon, eAttachment attachment);
void BG_GetWeaponAttachments(const Weapon weapon, WeaponAttachment *(*attachmentList)[3]);
void BG_GetWeaponAttachmentUniques(const Weapon weapon, WeaponAttachmentUnique *(*attachmentUniqueList)[3]);
WeaponAttachmentUnique *BG_GetAttachmentUnique(const Weapon weapon, eAttachment attachment);
TracerDef *BG_TracerType(const Weapon weapon, bool friendly);
bool BG_WeaponBulletFire_ExplodeOnImpact(const Weapon weapon);
Weapon BG_PlayerPrimaryMeleeWeapon(const playerState_s *ps);
bool BG_ShouldWeaponIgnoreAttachments(const Weapon weapon);
void BG_GetAttachmentAnimationOverrideMask(const Weapon weapon, int (*overrideMask)[3]);
unsigned int BG_GetAttachmentAnimationOverrideADSIndex(const Weapon weapon);
BOOL BG_IsAttachmentUniqueOverridingAnimation(WeaponAttachmentUnique *attachment, int animType);
int BG_GetAttachmentOverrideChildIndex(;
const char *BG_GetAttachmentAnimationOverride_Internal(;
const char *BG_GetAttachmentAnimationFirstRaiseOverride(;
void BG_EnsureUniqueAttachments(Weapon *weapon);
char BG_IsDualWield(const Weapon weapon);
char BG_IsSilenced(const Weapon weapon);
char BG_IsDualMag(const Weapon weapon);
char BG_IsLaserSight(const Weapon weapon);
char BG_IsInfraRed(const Weapon weapon);
bool BG_IsTVGuided(const Weapon weapon);
char BG_IsSharedAmmo(const Weapon weapon);
char BG_IsSegmentedReload(const Weapon weapon);
char BG_IsMMS(const Weapon weapon);
double BG_GetMMSMaxDist(const Weapon weapon);
void BG_GetADSDofStartEnd(const Weapon weapon, float *start, float *end);
unsigned int BG_GetOverriddenSound(;
unsigned int BG_FireSound(const Weapon weapon);
unsigned int BG_FireSoundPlayer(const Weapon weapon);
unsigned int BG_FireFinalKillcamSound(const Weapon weapon);
unsigned int BG_FireFinalKillcamSoundPlayer(const Weapon weapon);
unsigned int BG_FireSoundStart(const Weapon weapon, bool isPlayer);
const FxEffectDef *BG_GetOverriddenEffect(;
const FxEffectDef *BG_ViewFlashEffect(const Weapon weapon);
const FxEffectDef *BG_WorldFlashEffect(const Weapon weapon);
void BG_GetHideTags(const Weapon weapon, unsigned __int16 *hideTags);
void BG_GetADSZoomFOV(const Weapon weapon, float *adsZoomFov1, float *adsZoomFov2, float *adsZoomFov3);
double BG_GetADSZoomInFrac(const Weapon weapon);
double BG_GetADSZoomOutFrac(const Weapon weapon);
void BG_GetSwaySettings(;
void BG_GetADSSwaySettings(;
int BG_GetFireTime(const Weapon weapon);
int BG_GetReloadTime(const Weapon weapon);
int BG_GetReloadEmptyTime(const Weapon weapon);
int BG_GetReloadAddTime(const Weapon weapon);
int BG_GetReloadQuickTime(const Weapon weapon);
int BG_GetReloadQuickEmptyTime(const Weapon weapon);
int BG_GetReloadQuickAddTime(const Weapon weapon);
Weapon BG_GetAltWeapon(const Weapon weapon);
Weapon BG_GetDualWieldWeapon(const Weapon weapon);
char BG_IsAltWeaponAdsOnly(const Weapon weapon);
char BG_IsAltWeaponDisableSwitching(const Weapon weapon);
double BG_GetAltScopeADSTransInTime(const Weapon weapon);
double BG_GetAltScopeADSTransOutTime(const Weapon weapon);
void BG_GetADSTransTimeScales(const Weapon weapon, float *adsTransInTimeScale, float *adsTransOutTimeScale);
void BG_GetADSRecoilReduction(const Weapon weapon, float *rate, float *limit);
weapFireType_t BG_GetFireType(const Weapon weapon);
bool BG_GetForceBounce(const Weapon weapon);
double BG_GetStackFireAccuracyDecay(const Weapon weapon);
double BG_GetStackFireSpread(const Weapon weapon);
PenetrateType BG_GetPenetrateType(const Weapon weapon);
void BG_GetPerks(const Weapon weapon, unsigned int *perks);
double BG_GetADSViewKickCenterSpeed(const Weapon weapon);
double BG_GetADSIdleAmount(const Weapon weapon);
double BG_GetDamageRangeScale(const Weapon weapon);
double BG_GetADSMoveSpeedScale(const Weapon weapon);
int BG_GetFirstRaiseTime(const Weapon weapon);
int BG_GetAltRaiseTime(const Weapon weapon);
int BG_GetAltDropTime(const Weapon weapon);
int BG_GetReloadAmmoAdd(const Weapon weapon);
int BG_GetReloadStartAdd(const Weapon weapon);
void BG_GetHipSpreadScale(const Weapon weapon, float *min, float *max);
double BG_GetHipIdleAmount(const Weapon weapon);
void BG_GetStandMoveAndRotation(const Weapon weapon, vec3_t *move, vec3_t *rot);
void BG_GetStrafeRotation(const Weapon weapon, vec3_t *rot);
Material *BG_GetOverlayMaterial(const Weapon weapon);
Material *BG_GetOverlayMaterialLowRes(const Weapon weapon);
weapOverlayReticle_t BG_GetOverlayReticle(const Weapon weapon);
Material *BG_GetDpadIcon(const Weapon weapon, weaponIconRatioType_t *ratio);
double BG_GetWeaponHitLocationMultiplier(const Weapon weapon, hitLocation_t hitLoc);
bool BG_IsBaseWeaponAttachmentDisabled(const Weapon weapon);
bool BG_IsBaseWeaponClipAttachmentDisabled(const Weapon weapon);
XModel *BG_GetClipWorldModel(const Weapon weapon);
eAttachment BG_IsOverridingBaseWeaponAttachmentOffsets(const Weapon weapon);
void BG_GetViewAttachmentOffsetsOverride(const Weapon weapon, eAttachment attachment, vec3_t *offset);
void BG_GetWorldAttachmentOffsetsOverride(const Weapon weapon, eAttachment attachment, vec3_t *offset);
void BG_GetLeftHandIK(const Weapon weapon, const float **offset, const float **rotation);
void BG_GetLeftHandProneIK(const Weapon weapon, const float **offset, const float **rotation);
int BG_GetWeaponDamageForRange(const Weapon weapon, const vec3_t *start, const vec3_t *hitPos);
bool BG_ShotLimitReached(const Weapon weapon, int weaponShotCount);
const char *BG_GetAttachmentAnimationOverride(;
char BG_IsLeftHandWeapon(const Weapon weapon);
void BG_WeaponComponentListSort(const char *originalName, WeaponComponentList *componentList, char *outputName);

//t6/code/src_noserver/bgame/bg_weapons_util.h
unsigned int BG_GetWeaponAttachmentMask(const Weapon weapon);

//t6/code/src_noserver/bgame/bg_weapons_view.cpp
double BG_GetBobCycle(const playerState_s *ps);
long double BG_CalculateWeaponMovement_VerticalBobFactor(const playerState_s *ps, float cycle, float speed);
long double BG_CalculateWeaponMovement_HorizontalBobFactor(const playerState_s *ps, float cycle, float speed);
void BG_ComputeAndApplyWeaponMovement_IdleAngles(weaponState_t *ws, vec3_t *angles);
void BG_ComputeAndApplyWeaponMovement_DamageKickAngles(weaponState_t *ws, vec3_t *angles);
void BG_ApplyWeaponMovement_LeanOrigin(weaponState_t *ws, vec3_t *origin);
float BG_CalculateWeaponMovement_GetSprintLerp(const weaponState_t *ws, const WeaponDef *weapDef);
float BG_CalculateWeaponMovement_GetDTPLerp(const weaponState_t *ws, const WeaponDef *weapDef);
void BG_CalculateWeaponMovement_Base_Internal_WeaponState(;
void BG_CalculateWeaponMovement_Base_Internal_Stance(;
void BG_CalculateWeaponMovement_Base_Internal_Movement(;
void BG_CalculateWeaponMovement_Base_Internal_Save(;
void BG_CalculateWeaponMovement_Base(weaponState_t *ws);
void BG_CalculateWeaponMovement_Sway(weaponState_t *ws);
void BG_CalculateWeaponMovement_Bob(weaponState_t *ws);
void BG_SetWeaponMovementAngles(weaponState_t *ws, vec3_t *angles);
void BG_CalculateWeaponMovement(weaponState_t *ws, vec3_t *origin, vec3_t *angles);
long double BG_CalculateViewMovement_VerticalBobFactor(const playerState_s *ps, float cycle, float speed);
long double BG_CalculateViewMovement_HorizontalBobFactor(const playerState_s *ps, float cycle, float speed);
void BG_CalculateViewMovement_DamageKick(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovement_IdleAngles(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovement_BobAngles(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovement_AdsBob(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovementAngles(;

//t6/code/src_noserver/bgame/bg_wind.cpp
void BG_Wind_RegisterDvars();
// void DisplayWindDebug(clientDebugLineInfo_t *a1@<edi>);
void BG_SeedVarintWinds(int variant_seed, int start_time);
void BG_UpdateVariantWind(VariantWind *wind, int variantIndex, const vec3_t *seedWindVector, int cur_time);
void CG_UpdateWind(int cur_time);
void BG_GetVariantWindVector(int which, vec3_t *out);

//t6/code/src_noserver/botlib/l_memory.cpp
char *GetMemory(unsigned int size);
char *GetClearedMemory(unsigned int size);
void FreeMemory(void *ptr);

//t6/code/src_noserver/botlib/l_precomp.cpp
void SourceError(source_s *source, char *str, ...);
void SourceWarning(source_s *source, char *str, ...);
void PC_PushIndent(source_s *source, int type, parseSkip_t skip);
void PC_PushScript(source_s *source, script_s *script);
token_s *PC_CopyToken(token_s *token);
int PC_ReadSourceToken(source_s *source, token_s *token);
int PC_UnreadSourceToken(source_s *source, token_s *token);
int PC_ReadDefineParms(source_s *source, define_s *define, token_s **parms, int maxparms);
int PC_StringizeTokens(token_s *tokens, token_s *token);
int PC_MergeTokens(token_s *t1, token_s *t2);
int PC_NameHash(char *name);
void PC_AddDefineToHash(define_s *define, define_s **definehash);
define_s *PC_FindHashedDefine(define_s **definehash, char *name);
int PC_FindDefineParm(define_s *define, const char *name);
void PC_FreeDefine(define_s *define);
int PC_ExpandBuiltinDefine(;
int PC_ExpandDefine(;
void PC_ConvertPath(char *path);
int PC_Directive_include(source_s *source);
int PC_ReadLine(token_s *token, source_s *source, bool expandDefines);
// int PC_Directive_undef@<eax>(source_s *a1@<edx>, token_s *a2@<ecx>, source_s *source);
define_s *PC_CopyDefine(source_s *source, define_s *define);
void PC_AddGlobalDefinesToSource(source_s *source);
// int PC_Directive_if_def@<eax>(source_s *a1@<edx>, token_s *a2@<ecx>, source_s *source, int type);
// int PC_Directive_ifdef@<eax>(source_s *a1@<edx>, token_s *a2@<ecx>, source_s *source);
// int PC_Directive_ifndef@<eax>(source_s *a1@<edx>, token_s *a2@<ecx>, source_s *source);
int PC_Directive_else(source_s *source);
int PC_Directive_endif(source_s *source);
int PC_OperatorPriority(int op);
int PC_EvaluateTokens(source_s *source, token_s *tokens, int *intvalue, long double *floatvalue, int integer);
int PC_Evaluate(source_s *source, int *intvalue, long double *floatvalue, int integer);
int PC_DollarEvaluate(source_s *source, int *intvalue, long double *floatvalue, int integer);
int PC_Directive_elif(source_s *source);
int PC_Directive_if(source_s *source);
int PC_Directive_line(source_s *source);
int PC_Directive_error(source_s *source);
int PC_Directive_pragma(source_s *source);
void UnreadSignToken(source_s *source);
int PC_Directive_eval(source_s *source);
int PC_Directive_evalfloat(source_s *source);
int PC_ReadDirective(source_s *source);
int PC_DollarDirective_evalint(source_s *source);
int PC_DollarDirective_evalfloat(source_s *source);
int PC_ReadDollarDirective(source_s *source);
source_s *LoadSourceFile(const char *filename);
void FreeSource(source_s *source);
int PC_FreeSourceHandle(int handle);
// int PC_ReadLineHandle@<eax>(source_s *a1@<edx>, int handle, pc_token_s *pc_token);
void PC_UnreadLastTokenHandle(int handle);
int PC_SourceFileAndLine(int handle, char *filename, int *line);
int PC_ReadToken(source_s *source, token_s *token);
int PC_CheckTokenString(source_s *source, char *string);
int PC_ReadTokenHandle(int handle, pc_token_s *pc_token);
// int PC_Directive_define@<eax>(source_s *a1@<edx>, token_s *a2@<ecx>, source_s *source);
define_s *PC_DefineFromString(const char *string);
int PC_LoadSourceHandle(const char *filename, const char **builtinDefines);

//t6/code/src_noserver/botlib/l_script.cpp
void PS_CreatePunctuationTable(script_s *script, punctuation_s *punctuations);
void ScriptError(script_s *script, const char *str, ...);
void ScriptWarning(script_s *script, const char *str, ...);
int PS_ReadWhiteSpace(script_s *script);
int PS_ReadEscapeCharacter(script_s *script, char *ch);
int PS_ReadString(script_s *script, token_s *token, int quote);
int PS_ReadName(script_s *script, token_s *token);
void NumberValue(char *string, int subtype, unsigned int *intvalue, long double *floatvalue);
int PS_ReadNumber(script_s *script, token_s *token);
int PS_ReadPunctuation(script_s *script, token_s *token);
int PS_ReadPrimitive(script_s *script, token_s *token);
int PS_ReadToken(script_s *script, token_s *token);
void StripDoubleQuotes(char *string);
BOOL EndOfScript(script_s *script);
script_s *LoadScriptFile(const char *filename);
script_s *LoadScriptMemory(const char *ptr, int length, const char *name);
void FreeScript(script_s *script);

//t6/code/src_noserver/cgame/cg_ammocounter.cpp
void CG_AmmoCounterRegisterDvars();
void GetBaseRectPos(LocalClientNum_t localClientNum, const rectDef_s *rect, vec2_t *base);
Weapon GetWeaponAltIndex(const cg_t *cgameGlob, Weapon weapon);
void AmmoColor(cg_t *cgameGlob, vec3_t *color, Weapon weapon);
float AmmoCounterFadeAlpha(LocalClientNum_t localClientNum, cg_t *cgameGlob);
void DrawClipAmmoMagazine(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoShortMagazine(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoShotgunShells(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoRockets(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoBeltfed(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmo(;
void CG_DrawAmmoCounterSingle(LocalClientNum_t localClientNum, rectDef_s *rect, vec4_t *color, bool last);
void CG_DrawPlayerWeaponAmmoStock(;
void CG_DrawFuelTankPercentage(;
void CG_DrawPlayerWeaponAmmoClip(;
void CG_DrawPlayerWeaponAmmoClipDualWield(;
void DpadIconDims(;
void DpadTextPos(;
bool ActionSlotIsActive(LocalClientNum_t localClientNum, unsigned int slotIdx);
float DpadFadeAlpha(LocalClientNum_t localClientNum, cg_t *cgameGlob);
// double CG_GetHudAlphaDPad@<st0>(cg_t *a1@<edx>, LocalClientNum_t a2@<ecx>, LocalClientNum_t localClientNum);
// double CG_GetHudAlphaAmmoCounter@<st0>(;
char CG_ActionSlotIsUsable(const LocalClientNum_t localClientNum, unsigned int slotIdx);
void CG_DrawPlayerActionSlotDpad(;
void CG_DrawPlayerActionSlotCarousel(;
void CG_DrawPlayerActionSlotBack(;
void CG_DrawPlayerActionSlotArrow(;
void CG_DrawPlayerActionSlot(;
void CG_DrawPlayerWeaponBackground(;
void CG_DrawPlayerWeaponAmmoClipGraphic(;
void CG_DrawPlayerWeaponAmmoClipGraphicDualWield(;
void DrawStretchPicGun(;
void CG_DrawPlayerWeaponIcon(;
void CG_DrawPlayerWeaponLowAmmoWarning(;

//t6/code/src_noserver/cgame/cg_bolt.cpp
void CG_InitBolt(LocalClientNum_t localClientNum);
void CG_UpdateBolt(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_camera.cpp
void InterpolateAnglesSmooth(;
void CG_StartCameraTween(LocalClientNum_t localClientNum, float tweenTime);
float CG_UpdateCameraTweenFOV(LocalClientNum_t localClientNum, float currentFov);
void CG_UpdateCameraTween(LocalClientNum_t localClientNum);
void CG_UpdateVehicleInitView(LocalClientNum_t localClientNum, CameraMode newMode);
void CG_SetSoundFutz(LocalClientNum_t localClientNum);
void CG_UpdateSoundFutz(LocalClientNum_t localClientNum, CameraMode newMode);
void CG_UpdateCameraTransition(;
int CG_RemapVehicleButton(LocalClientNum_t localClientNum, int *twokeys, int button, Bind_t vehicleBinding);
void CG_UpdateVehicleBindings(LocalClientNum_t localClientNum);
bool CG_RenderPlayerFromMissilePOV(LocalClientNum_t localClientNum);
bool CG_SpikeCameraViewActive(LocalClientNum_t localClientNum);
bool CG_ScriptedExtraCamActive(LocalClientNum_t localClientNum);
float CG_ScriptedExtraCamFov(LocalClientNum_t localClientNum);
char ShouldDoCameraTransition(cg_t *cgameGlob, CameraMode prevMode, CameraMode newMode, bool useTagCamera);
char ShouldDoThirdPersonVehicle(;
CameraMode CG_UpdateCameraMode(LocalClientNum_t localClientNum);
CameraMode CG_GetExtraCamMode(LocalClientNum_t localClientNum);
void CG_ApplyViewAnimation(LocalClientNum_t localClientNum);
bool CG_ShouldDefaultViewFov(LocalClientNum_t localClientNum);
float CG_GetWeaponViewFov(;
double CG_GetTurretViewFov(LocalClientNum_t localClientNum, const playerState_s *ps);
float CG_GetViewFov(LocalClientNum_t localClientNum, const playerState_s *forWeapon);
void CG_CalcFovInternal(;
void CG_CalcFov(LocalClientNum_t localClientNum, float fov_x);
void CG_CalculateGunnerOffset_Sway(;
;
void CG_GetExtraCamOrigin(LocalClientNum_t localClientNum, vec3_t *out);
void CG_CalcExtraCamViewValues(LocalClientNum_t localClientNum);
void RemoteEyesShake(cg_t *cgameGlob, centity_t *possessedEnt);
bool GetWeaponviewEyeValues(LocalClientNum_t localClientNum);
void CG_GetMissileViewOrigin(LocalClientNum_t localClientNum, vec3_t *out);
void CG_CalcScriptedExtraCamViewValues(LocalClientNum_t localClientNum);
// void CG_CalcMissileAngleValues(float a1@<esi>, LocalClientNum_t localClientNum);
long double CG_Player3rdPersonVehicle_GetPitchOffsetRelativeToADirection(;
bool CG_Player3rdPersonVehicle_GetViewAngles(;
void CG_Player3rdPersonVehicle_GetLookAtPosition(;
float CG_Player3rdPersonVehicle_GetDampedSpringDistance(;
int CG_Get3rdPersonVehicleMask(int vehicleType);
void CG_OffsetVehicleView(LocalClientNum_t localClientNum, CameraMode camMode);
int CG_ScrCamActive(LocalClientNum_t localClientNum);
void CG_ScrCamCalcView(LocalClientNum_t localClientNum);
void CG_ExtraCamDebug_SetView(LocalClientNum_t localClientNum);
void CG_ExtraCamDebug_SaveView(LocalClientNum_t localClientNum);
// void CG_CalcFov_ExtraCam(float a1@<xmm0>, LocalClientNum_t localClientNum);
BOOL InScriptExtraCamDebugMode3();
void CG_ExtraCam_GetViewOrigin(LocalClientNum_t localClientNum, ExtraCamLodInfo *extraCamLodInfo);
void CG_UpdateScriptExtraCams(LocalClientNum_t localClientNum);
void CG_ResetScriptExtraCam(ScriptExtraCam *scriptExtraCam);
bool CG_ExtraCamIsActive(LocalClientNum_t localClientNum);
BOOL CG_IsUsingMultiExtraCam(LocalClientNum_t localClientNum);
// void __thiscall ExtraCamClientStateRestore::ExtraCamClientStateRestore(;
// void __thiscall ExtraCamClientStateRestore::~ExtraCamClientStateRestore(ExtraCamClientStateRestore *this);
void CG_GetClientExtraCamParms(LocalClientNum_t localClientNum, GfxExtraCamParms *extraCamParms);
void CG_CaptureCameraOffset(LocalClientNum_t localClientNum);
;
void CG_CalcMissileViewValues(LocalClientNum_t localClientNum);
bool CG_ShouldVehicleCamAutoRecenter(LocalClientNum_t localClientNum, const VehicleDef *info);
void CG_CalcVehicleViewValues(LocalClientNum_t localClientNum);
void CG_Calc3rdPersonVehicleViewValues(LocalClientNum_t localClientNum);
void CG_RadiantCamCalcView(LocalClientNum_t localClientNum);
char GetRemoteEyeValues(LocalClientNum_t localClientNum);
bool CG_CalcRemoteEyesViewValues(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_camerashake.cpp
void TRACK_cg_camerashake();
int CG_UpdateCameraShake(const cg_t *cgameGlob, CameraShake *shake);
void CG_StartShakeCamera(;
// void CG_ShakeCamera(CameraShake *a1@<edx>, const cg_t *a2@<ecx>, LocalClientNum_t localClientNum);
void CG_ClearCameraShakes(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_colltree.cpp
void TRACK_CG_CollWorld();
void CG_ClearEntityCollWorld(LocalClientNum_t localClientNum);
void CG_AddEntityToCollSector(LocalClientNum_t localClientNum, int entIndex, unsigned __int16 sectorIndex);
unsigned __int16 CG_AllocEntityCollSector(;
void CG_SortEntityCollSector(;
void CG_UnlinkEntityColl(LocalClientNum_t localClientNum, int entIndex);
void CG_LinkEntityColl(;

//t6/code/src_noserver/cgame/cg_compass.cpp
void CG_CompassRegisterDvars();
bool CG_IsSelectingLocation(LocalClientNum_t localClientNum);
void CG_ApplySplitScreenCompassScale(CompassType compassType, float *x, float *y, float *w, float *h);
bool CG_WorldPosToCompass(;
void CG_CompassCalcDimensions(;
double CG_FadeCompass(LocalClientNum_t localClientNum, int displayStartTime, CompassType compassType);
void CG_DrawPlayerPopUps(;
void CG_DrawPlayerCOD7TypeWriter(;
void CG_DrawPlayerRedationText(;
void CG_DrawPlayerPopInText(;
void CG_CompassDrawPlayerNorthCoord(;
void CG_CompassDrawPlayerEastCoord(;
void CG_CompassDrawPlayerNCoordScroll(;
void CG_CompassDrawPlayerECoordScroll(;
void CG_UpdateEnemyScramblerAlpha(LocalClientNum_t localClientNum);
void CG_CompassDrawRound(;
void CalcCompassPointerSize(CompassType compassType, float *w, float *h);
void DrawIconDistanceText(;
void CG_CompassDrawTickertape(;
void CG_SetGridTable();
void CG_GetGridFromPos(LocalClientNum_t localClientNum, vec3_t *pos, char *gridName);
double CG_GetHudAlphaCompass(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_drawtools.cpp
double CG_GetPicWidth(Material *mat);
void CG_DrawRotatedPicPhysicalW(;
void CG_DrawRotatedPicPhysical(;
void CG_DrawRotatedPicW(;
void CG_DrawRotatedPic(;
void CG_DrawRotatedQuadPic(;
void CG_DrawStringExt(;
int CG_DrawDevString(;
int CG_DrawSmallDevStringColor(;
double CG_FadeAlpha(int timeNow, int startMsec, int totalMsec, int fadeMsec);
vec4_t *CG_FadeColor(int timeNow, int startMsec, int totalMsec, int fadeMsec);
void CG_MiniMapChanged(LocalClientNum_t localClientNum);
void CG_NorthDirectionChanged(LocalClientNum_t localClientNum);
void CG_RelativeTeamColor(ClientNum_t clientNum, vec4_t *color, LocalClientNum_t localClientNum);
int CG_DrawBigDevString(;

//t6/code/src_noserver/cgame/cg_draw_debug.cpp
void CG_DrawScriptUsage(const ScreenPlacement *scrPlace);
int CG_CompareSndInfoChannel(const void *va, const void *vb);
int CG_CompareSndInfoPriority(const void *va, const void *vb);
int CG_CompareSndInfoAlias(const void *va, const void *vb);
int CG_CompareSndInfoDryLevel(const void *va, const void *vb);
int CG_CompareSndInfoDistance(const void *va, const void *vb);
int CG_CompareSndInfoEntity(const void *va, const void *vb);
void CG_DrawSoundOverlay(const ScreenPlacement *scrPlace);
void CG_DrawPerformanceWarnings(LocalClientNum_t localClientNum);
void CG_DrawModelBoneAxis(LocalClientNum_t localClientNum);
void CG_DrawFxText(const char *text, vec2_t *profilePos);
void CG_DrawFxPriorityText(const char *text, vec2_t *profilePos);
void CG_DrawDebugPlayerHealth(LocalClientNum_t localClientNum);
void CG_DrawDebugPlayerSprint(LocalClientNum_t localClientNum);
void CG_DrawEntDObjBoneDebug(LocalClientNum_t localClientNum, int entNum);
void CG_DrawDebugOverlays(LocalClientNum_t localClientNum);
void CG_DrawFullScreenDebugOverlays(LocalClientNum_t localClientNum);
void CG_DrawGfxStatsLine(;
void CG_DrawGfxStatsMatrix(const ScreenPlacement *scrPlace, GfxPrimStatsCounters counter);
// void CG_DrawGfxStats(int a1@<ebx>, LocalClientNum_t localClientNum);
void CG_DrawVersion(LocalClientNum_t localClientNum);
void CG_QuickPrintFlush();
double CG_GetCornerDebugPrintScale_X();
double CG_GetCornerDebugPrintScale_Y();
double CG_CornerDebugPrint(;
char *DebugSessionInfo();
void CG_DrawTaskErrorDebugInfo(LocalClientNum_t localClientNum);
void CG_DrawHostDebugInfo(LocalClientNum_t localClientNum);
void CG_DrawChangelistMismatch(LocalClientNum_t localClientNum);
void CG_DebugLineVertical(const vec3_t *p, const vec4_t *color, int depthTest, int duration);
void CG_DebugStarWithText(;
void CG_DebugBox(;
void CG_DebugBoxOriented(;
float CG_CornerDebugPrintCaption(;
float CG_DrawSnapshot(LocalClientNum_t localClientNum, float posY);
float CG_DrawViewpos(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float CG_DrawCullDistDebugText(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float CG_DrawShadowMapDebugText(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float DrawEntityCounts(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float posY);
double CG_DrawAnimTagInfo(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float posY);
double CG_DrawFPS(;
void CG_QuickPrint(const char *fmt, ...);
void CG_DrawUpperRightDebugInfo(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_indicators.cpp
void CG_GrenadeIndicator_GetPlayerPosition(const cg_t *cgameGlob, vec3_t *playerOrigin);
// void CG_DrawFriendlyIndicators(int a1@<edi>, int a2@<esi>, LocalClientNum_t localClientNum);
void CG_DrawFlashDamage(const cg_t *cgameGlob);
bool CG_ShouldDrawDamageDirectionIndicators(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_DrawDamageDirectionIndicators(LocalClientNum_t localClientNum);
void CG_DrawWarningPointer(;
void CG_DrawWarningIcon(;
void CG_ClearHudGrenades();
// double CG_AddHudGrenade_PositionCheck@<st0>(;
void CG_AddHudGrenade(const cg_t *cgameGlob, const centity_t *grenadeEnt);
// void CG_DrawGrenadeIndicators(float a1@<edi>, LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_names.cpp
void TRACK_cg_draw_names();
void CG_ClearOverheadFade();
OverheadFade *CG_GetOverheadFade(LocalClientNum_t localClientNum);
void CG_ClearPlayerDetails();
void CG_InitPlayerDetails(LocalClientNum_t localClientNum, int targetClientNum);
bool CG_CalcNamePosition(LocalClientNum_t localClientNum, const vec3_t *origin, float *xOut, float *yOut);
int CG_GetZombiePlayerColorIndex(LocalClientNum_t localClientNum, ClientNum_t currentClientNum);
void CG_DrawOverheadNames(LocalClientNum_t localClientNum, const centity_t *cent, float alpha, int mode);
bool CG_CanSeeFriendlyHeadInView(;
void CG_GetFriendlyHeadPos(LocalClientNum_t localClientNum, const centity_t *cent, vec3_t *end);
int CG_CheckIfDrivingRemoteControlVehicle(LocalClientNum_t localClientNum, unsigned __int16 EntId);
;
void CG_ScanForCrosshairEntity(LocalClientNum_t localClientNum);
int compareEntityDist(const void *v1, const void *v2);
void CG_AddDrawName(LocalClientNum_t localClientNum, int entnum, float alpha, team_indicator teamIndicator);
void CG_DrawNames(LocalClientNum_t localClientNum);
bool CG_IsValidCrosshairEntity(;
bool ShouldDrawCrosshairNames(LocalClientNum_t localClientNum);
// void CG_DrawCrosshairNames(LocalClientNum_t a1@<ecx>, int a2@<ebx>, LocalClientNum_t localClientNum);
bool activeKillstreakWithLineOfSightOverlay(LocalClientNum_t localClientNum, const cg_t *cgameGlob, int entnum);
bool PlayerCanSeeEnemyNames(LocalClientNum_t localClientNum, int entnum);
bool ShouldDrawPlayerName(LocalClientNum_t localClientNum, int entnum, int team);
bool ShouldDrawFriendlyName(LocalClientNum_t localClientNum, const centity_t *cent, int entnum, int team);
int GetVehicleDriverEntNum(const cg_t *cgameGlob, const centity_t *cent, int entnum);
;
// char CG_CanSeeFriendlyHead@<al>(vec3_t *a1@<edi>, LocalClientNum_t localClientNum, const centity_t *cent);
void CG_DrawActorName(LocalClientNum_t localClientNum, const centity_t *cent, bool flashed);
void CG_DrawFriendlyName(;
void CG_DrawFriendlyNames(LocalClientNum_t localClientNum);
void CG_DrawVisibleNames(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_reticles.cpp
void CG_CalcCrosshairPosition(const cg_t *cgameGlob, float *x, float *y);
char CG_GetWeapReticleZoom(const cg_t *cgameGlob, float *zoom);
void CG_DrawFrameOverlay(;
void CG_DrawNightVisionOverlay(LocalClientNum_t localClientNum);
bool CG_UsingLowResViewPort(LocalClientNum_t localClientNum);
void CG_UpdateScissorViewport(refdef_t *refdef, vec2_t *drawPos, vec2_t *drawSize);
void CG_DrawAdsOverlay(;
void CG_DrawWeapReticle(LocalClientNum_t localClientNum);
void CG_CalcCrosshairColor(const LocalClientNum_t localClientNum, float alpha, vec4_t *color);
void CG_DrawTurretCrossHair(LocalClientNum_t localClientNum);
float CG_GetVehicleCrossHairAlpha(LocalClientNum_t localClientNum);
bool ShouldShowCrosshairOnVehicle(const cg_t *cgameGlob, const WeaponDef *weapDef);
bool CG_DrawVehicleCrossHair(LocalClientNum_t localClientNum);
bool AllowedToDrawCrosshair(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState);
void CG_DrawAdsAimIndicator(;
void CG_TransitionToAds(;
bool CG_DrawReticleCenter(;
void CG_CalcReticleSpread(;
void CG_CalcReticleColor(;
void CG_DrawReticleSides(;
bool ShouldDrawCrosshair(const cg_t *cgameGlob, const playerState_s *ps);
;

//t6/code/src_noserver/cgame/cg_effects_load_db.h
void Mark_FxImpactTable();
void Mark_FxImpactTablePtr();
void Load_FxImpactEntryArray(bool atStreamStart, int count);
void Load_FxImpactTable(bool atStreamStart);
void Load_FxImpactTablePtr(bool atStreamStart);

//t6/code/src_noserver/cgame/cg_effects_load_obj.cpp
const char *CG_FleshTypeToName(int fleshTypeId);
int CG_AddImpactFileToList(const char *filePath, int index, char **fileList, int *fileCount, int maxFiles);
int CG_GetIncludesForFile(const char *file, char **list, int *count, int max);
// int CG_BuildFileList@<eax>(int a1@<edx>, const char *rootFilePath, char **list, int *count);
int CG_ProcessFileList(char **list, int count, EffectFile *effectFile);
void CG_RegisterImpactEffectsForFile(const char *filePath, EffectFile *effectFile, char *listbuf);
FxImpactTable *CG_RegisterImpactEffects_FastFile();
int CG_RegisterImpactEffects_NonFlesh(;
FxImpactTable *CG_RegisterImpactEffects_LoadObj(const char *filePath);
FxImpactTable *CG_RegisterImpactEffects();

//t6/code/src_noserver/cgame/cg_event.cpp
void CG_Obituary(LocalClientNum_t localClientNum, const entityState_s *ent);
void RemoteMissileBoostEvent(LocalClientNum_t localClientNum, centity_t *cent, int eventParm);
void CG_ObituaryRevive(LocalClientNum_t localClientNum, const entityState_s *ent);
void CG_DirectionalHitIndicator(LocalClientNum_t localClientNum, const entityState_s *ent);
void CG_ItemPickup(LocalClientNum_t localClientNum, Weapon weapon);
void CG_SetWetness(LocalClientNum_t localClientNum, int entNum, float wetness, int invert);
void CG_ExplosionEvent(;
void CG_ProjectileExplosionEvent(;
const DObj *CG_GetBoneIndex(;
unsigned int CG_PlayBoltedEffect(;
unsigned int CG_PlayBoltedEffectRelative(;
void CG_PlayFx(LocalClientNum_t localClientNum, centity_t *cent, const vec3_t *angles);
void CG_PlayFxOnTag(LocalClientNum_t localClientNum, centity_t *cent, int eventParm);
void CG_SetInvalidCmdHint(cg_t *cgameGlob, InvalidCmdHintType hintType);
void CG_SetInvalidStanceHint(cg_t *cgameGlob, invalid_cmd_hint_t type);
void CG_StopWeaponSound(;
bool CG_IsSoundEventLouder(LocalClientNum_t localClientNum, centity_t *cent);
void CG_DoJumpEvent(;
void CG_DoLandEvent(;
void CG_GibEvent(LocalClientNum_t localClientNum, centity_t *cent, unsigned int eventParm);
void CG_GrabWeapon(;
void CG_PhysLaunch(LocalClientNum_t localClientNum, centity_t *cent, const entityState_s *es);
bool CG_CheckIfDualWieldEmpty(playerState_s *ps, Weapon weapon);
;
void CG_CheckEvents(LocalClientNum_t localClientNum, centity_t *cent);
void CG_CheckEntEvents(LocalClientNum_t localClientNum, centity_t *cent);

//t6/code/src_noserver/cgame/cg_footstepfxtable_load_db.h
void Mark_FootstepFXTableDefPtr();
void Load_FootstepFXTableDef(bool atStreamStart);
void Load_FootstepFXTableDefPtr(bool atStreamStart);

//t6/code/src_noserver/cgame/cg_footsteptable_load_db.h
void Load_FootstepTableDef(bool atStreamStart);
void Load_FootstepTableDefPtr(bool atStreamStart);
void Mark_FootstepTableDefPtr();

//t6/code/src_noserver/cgame/cg_hudelem.cpp
void CG_HudElemRegisterDvars();
void DirectiveFakeIntroSeconds(LocalClientNum_t localClientNum, const char *arg0, char *result);
void ParseDirective(const char *directive, char *resultName, char *resultArg0);
void GetHudelemDirective(;
char ReplaceDirective(;
void CG_TranslateHudElemMessage(;
void SafeTranslateHudElemString(LocalClientNum_t localClientNum, int index, char *hudElemString);
float HudElemStringWidth(;
int GetHudElemTime(const hudelem_s *elem, int timeNow);
const char *HudElemTimerString(const hudelem_s *elem, int timeNow);
const char *HudElemTenthsTimerString(const hudelem_s *elem, int timeNow);
float HudElemMaterialWidth(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
float HudElemMaterialHeight(;
float HudElemWidth(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
float HudElemHeight(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
void GetHudElemOrg(;
void SetHudElemPos(const ScreenPlacement *scrPlace, const hudelem_s *elem, cg_hudelem_t *cghe);
float OffsetHudElemY(const hudelem_s *elem, const cg_hudelem_t *cghe, float offsetY);
void ConsolidateHudElemText(;
void CopyStringToHudElemString(const char *string, char *hudElemString);
void GetHudElemInfo(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe);
void HudElemColorToVec4(const hudelem_color_t *hudElemColor, vec4_t *resultColor);
void DrawHudElemString(;
void DrawHudElemClock(LocalClientNum_t localClientNum, const hudelem_s *elem, const cg_hudelem_t *cghe);
void DrawHudElemMaterial(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe);
float HudElemWaypointHeight(LocalClientNum_t localClientNum, const hudelem_s *elem);
char WorldPosToScreenPos(LocalClientNum_t localClientNum, const vec3_t *worldPos, vec2_t *outScreenPos);
char WorldPosToExtraCamScreenPos(LocalClientNum_t localClientNum, const vec3_t *worldPos, vec2_t *outScreenPos);
BOOL ClampScreenPosToEdges(;
float GetScaleForDistance(LocalClientNum_t localClientNum, const vec3_t *worldPos);
float WaypointFadeGetTimeFrac(const cg_t *cgameGlob, int currentTime);
void WaypointTargetFade(;
void DrawOffscreenViewableWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem);
float DrawHudElemPerk(;
void DrawHudElemPerkName(;
void DrawHudElemPerks(;
void DrawSingleHudElem2d(LocalClientNum_t localClientNum, const hudelem_s *elem);
int compare_hudelems(const void *pe0, const void *pe1);
int GetSortedHudElems(LocalClientNum_t localClientNum, hudelem_s **elems);
int GetSortedDebugHudElems(hudelem_s **elems);
void CG_Draw2dHudElemList(;
void CG_Draw2dHudElems(LocalClientNum_t localClientNum, int foreground);
void AddDrawSurfForHudElemWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem);
bool RB_AddWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem, int slot);
void RB_AddWaypoints(LocalClientNum_t localClientNum);
void RB_ClearWaypoints(LocalClientNum_t localClientNum);
void CG_AddDrawSurfsFor3dHudElems(LocalClientNum_t localClientNum);
void CG_AddWaypoint(;
int RB_NumDrawWaypoints(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_info.cpp
void CG_LoadingString(LocalClientNum_t localClientNum, const char *s);
BOOL CG_IsShowingProgress_LoadObj();
BOOL CG_IsShowingProgress_FastFile();
void CG_DrawInformation(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_laser.cpp
laser_cache_t *get_laser_cache(int entnum);
void CG_LaserRegisterDvars();
bool CG_LaserForceOnEnabled();
void AddCore(;
void CG_AddCore(;
void CG_LaserDraw(;
void CG_LaserClearAll();
void CG_LaserAdd(LocalClientNum_t localClientNum, int entnum);
void CG_LaserDrawAll(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_local.h
centity_t *CG_GetEntity(LocalClientNum_t localClientNum, int entityIndex);
BOOL CG_LoadScripts();
unsigned __int8 GetAITypeFromCent(centity_t *cent);
bool CG_EntityNeedsScriptThread(LocalClientNum_t localClientNum, centity_t *cent);
bool CG_EntityNeedsClientMainThread(LocalClientNum_t localClientNum, centity_t *cent);
ViewModelInfo *CG_GetLocalClientViewModelInfo(LocalClientNum_t localClientNum);
BOOL CG_FakeEntInUse(LocalClientNum_t localClientNum, int fakeEntNum);
centity_t *CG_GetFakeEntity(LocalClientNum_t localClientNum, int fakeEntNum);
ClientPlayerWeaponInfo *CG_GetLocalClientWeaponInfo(LocalClientNum_t localClientNum, Weapon weapon);
int CG_GetInfraredRenderFlags();
int CG_GetLocalClientFromEntity(int entnumber);
void CG_SetFakeEntInUse(LocalClientNum_t localClientNum, int fakeEntNum);
void CG_ClearFakeEntInUse(LocalClientNum_t localClientNum, int fakeEntNum);
bool CG_GetVelocity(LocalClientNum_t localClientNum, int entIndex, vec3_t *outVelocity);

//t6/code/src_noserver/cgame/cg_localents.cpp
void TRACK_cg_localents();
void CG_InitLocalEntities(const LocalClientNum_t localClientNum);
localEntity_s *CG_AllocLocalEntity(const LocalClientNum_t localClientNum);
void CG_AddMovingTracer(const cg_t *cgameGlob, localEntity_s *le);
// void CG_AddLocalEntityTracerBeams(localEntity_s *next@<edx>, const LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_main.cpp
void TRACK_cg_main();
int CG_irand(int min, int max);
double CG_flrand(float min, float max);
;
bool CG_HasClientSystemBeenInitialzed();
bool CG_HaveClientScriptsBeenRun();
void CG_ClientDoneWithInitialization();
void CG_ResetClientInitializationState();
void CG_ResetClientScriptsRunStatus();
void CG_SetClientScriptsRunStatus();
void CG_UpdateUIDeviceContexts(LocalClientNum_t localClientNum, int time);
void CG_UpdateFov(float value);
char CG_IsThirdPerson(LocalClientNum_t localClientNum);
BOOL CG_IsEntWalkable(LocalClientNum_t localClientNum, int entityNum);
BOOL CG_IsCreateFX();
int CScriptMover_UpdateMove(;
void CG_InitScreenDimensions(LocalClientNum_t localClientNum);
int CScr_LoadScriptAndLabel(const char *filename, const char *label);
void CG_AddFootstepEvent(;
void CG_AddPlayerFootstepEvent(;
void CG_ProcessFootstepEvents(LocalClientNum_t localClientNum, cg_t *cgameGlob);
bool CG_IsSonarAttachment(LocalClientNum_t localClientNum);
void CG_SetupSonar(LocalClientNum_t localClientNum);
void CG_UpdateVehicleBindings_f();
void CG_InitConsoleCommands();
void CG_ShutdownConsoleCommands();
float CG_GetDefaultFovForView(LocalClientNum_t localClientNum);
void CG_SetThirdPersonForAllLocalClients(bool value);
void CG_SetThirdPerson(LocalClientNum_t localClientNum, bool value);
void CG_UpdateFovCallBack();
void CG_RegisterDvars();

//t6/code/src_noserver/cgame/cg_mem_track.cpp
void CG_track_init();

//t6/code/src_noserver/cgame/cg_perf.cpp
void UpdateData(CG_PerfData *data, int value);
void CG_PerfInit();
void CG_PerfUpdate();

//t6/code/src_noserver/cgame/cg_playerstate.cpp
void CG_DamageFeedback(LocalClientNum_t localClientNum, int yawByte, int pitchByte, int damage);
void CG_Respawn(LocalClientNum_t localClientNum, int spectate);
void CG_ResetSpectatorViewAngles(LocalClientNum_t localClientNum);
void CG_CheckPlayerstateEvents(;
void CG_TransitionPlayerState(;
void CG_ClearTransPlayerState(transPlayerState_t *transPs);
void CG_ExtractTransPlayerState(const playerState_s *ps, transPlayerState_t *transPs);

//t6/code/src_noserver/cgame/cg_pose.cpp
void BG_Player_DoControllers(const CEntPlayerInfo *player, const DObj *obj, int *partBits);
void CG_Player_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Vehicle_DoControllersAir(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Destructible_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Turret_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Actor_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_DoBaseOriginController(const cpose_t *pose, const DObj *obj, int *setPartBits);
void CG_Vehicle_PostDObjCalcSkel(const cpose_t *pose, const DObj *obj, int *partBits);
;
void CG_Vehicle_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
DObjAnimMat *CG_DObjCalcPose(const cpose_t *remote_pose, const DObj *obj, int *partBits);

//t6/code/src_noserver/cgame/cg_pose.h
int CompressAngle(float angle);
int CompressSignedUnit(float unit);

//t6/code/src_noserver/cgame/cg_pose_utils.cpp
void CG_UsedDObjCalcPose(const cpose_t *pose);
void CG_CullIn(const cpose_t *pose);

//t6/code/src_noserver/cgame/cg_rumble.cpp
void Rumble_Strcpy(unsigned __int8 *member, const char *keyValue);
bool ParseRumbleGraph(RumbleGraph *graph, const char *buffer, const char *fileName);
bool ReadRumbleGraph(RumbleGraph *graph, const char *rumbleFileName);
// char LoadRumbleGraph@<al>(;
bool CG_LoadRumble(RumbleGraph *rumbleGraphArray, RumbleInfo *info, const char *name, int rumbleNameIndex);
void CG_RegisterRumbles(LocalClientNum_t localClientNum);
void DrawActiveRumbles(LocalClientNum_t localClientNum, const ActiveRumble *activeRumbleArray);
void RemoveInactiveRumbles(LocalClientNum_t localClientNum, ActiveRumble *activeRumbleArray);
void CalcActiveRumbles(;
int GetRumbleInfoIndexFromName(LocalClientNum_t localClientNum, const char *rumbleName);
bool DuplicateRumbleExists(;
ActiveRumble *NextAvailableRumble(const cg_t *cgameGlob, ActiveRumble *arArray);
void PlayRumbleInternal(;
void CG_PlayRumbleOnEntity(LocalClientNum_t localClientNum, const char *rumbleName, int entityNum);
void CG_PlayRumbleOnPosition(LocalClientNum_t localClientNum, const char *rumbleName, const vec3_t *pos);
void CG_PlayRumbleLoopOnEntity(LocalClientNum_t localClientNum, const char *rumbleName, int entityNum);
void CG_PlayRumbleLoopOnPosition(LocalClientNum_t localClientNum, const char *rumbleName, const vec3_t *pos);
void CG_PlayRumbleOnClient(LocalClientNum_t localClientNum, const char *rumbleName);
void CG_PlayLoopRumbleOnClient(LocalClientNum_t localClientNum, const char *rumbleName);
void CG_StopRumble(LocalClientNum_t localClientNum, int entityNum, const char *rumbleName);
void CG_StopAllRumbles(LocalClientNum_t localClientNum);
void CG_SetRumbleReceiver(LocalClientNum_t localClientNum, int entityNum, const vec3_t *position);
void CG_DrawRumbleDebug(LocalClientNum_t localClientNum);
void RumbleGraphEventCallback(const DevGraph *graph, DevEventType event, LocalClientNum_t localClientNum);
void RumbleGraphTextCallback(const DevGraph *graph, const float inputX, const float inputY, char *text);
void InitDevguiRumbleGraphInteral(const char *rumbleName, RumbleGraph *rumbleGraph, RumbleInfo *rumbleInfo);
void CG_InitDevguiRumbleGraph(LocalClientNum_t localClientNum);
void CG_UpdateRumble(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_scr_main.cpp
unsigned __int16 CScr_GetMeansOfDeathConstString(int mod);
void CScr_Notify(;
void CScr_ToLower();
void CScr_ReadOnly(centity_t *cent, const cent_field_s *pField);
void CScr_GetType(centity_t *cent, const cent_field_s *pField);
void CScr_GetWeaponName(centity_t *cent, const cent_field_s *pField);
void CScr_SetOrigin(centity_t *cent, const cent_field_s *pField);
void CScr_SetAngles(centity_t *cent, const cent_field_s *pField);
void CScr_GetModel(centity_t *cent, const cent_field_s *pField);
void VehicleCScr_GetVehicleDefField(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleClass(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleTreadFxArray(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleLightFXArray(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleLightFXTagArray(centity_t *cent, const cent_field_s *pField);
void CScr_FreeFakeEntity(LocalClientNum_t localClientNum, int entNum);
void CScr_DeleteFakeEnt();
void CScr_IsString();
void CScr_IsArray();
void assertCmd();
void assertmsgCmd();
void debugBreakCmd();
void print();
void println();
void CScr_IPrintLnBold();
void CScr_Print3D();
void CScr_RandomInt();
void CScr_RandomFloat();
void CScr_RandomIntRange();
void CScr_RandomFloatRange();
void CScr_VectorFromLineToPoint();
void CScr_PointOnSegmentNearestToPoint();
char CScr_Distance();
void CScr_Distance2D();
void CScr_DistanceSquared();
void CScr_Length();
void CScr_LengthSquared();
void CScr_Closer();
void CScr_VectorDot();
void CScr_VectorCross();
void CScr_VectorNormalize();
void CScr_VectorLerp();
void CScr_LerpFloat();
void CScr_LerpVector();
void CScr_GetMinBitCountForNum();
void CScr_CombineAngles();
void CScr_AbsAngleClamp180();
int Effect_Index(LocalClientNum_t clientNum, const char *name);
void CScr_LoadedFX();
void CScr_BulletTracer();
void CScr_AnimateUI();
void CScr_GetAnimLength();
void CScr_ShowUI();
void CScr_GetSystemTime();
void CScr_GetServerTime();
void CScr_ClientHasSnapShot();
void CScr_GetMapCenter();
char CScr_SetDvar();
void CScr_SetSavedDvar();
void CScr_IsStereoOn();
void CScr_IsMatureContentEnabled();
void CScr_GetDebugDvar();
void CScr_GetDebugDvarInt();
void CScr_GetDebugDvarFloat();
void CScr_SetDvarBool();
void CScr_SetDvarFloat();
void CScr_SetDvarInt();
void CScr_PlaySound();
void CScr_PlaySoundOnEntity(scr_entref_t entref);
void CScr_PlayLoopSoundOnEntity(scr_entref_t entref);
void CScr_StopLoopSoundOnEntity(scr_entref_t entref);
void CScr_IsPlayingLoopSound(scr_entref_t entref);
void CScr_SetSoundContext();
void CScr_SetSoundEntContext(scr_entref_t entref);
void CScr_SetLoopState(scr_entref_t entref);
void robot_mixer_behavior(_mixerLight_t *pMixer, const cg_t *cgameGlob);
void CG_MixerLightNotifyListener(unsigned int objectId, unsigned int notifyString);
void CScr_AllocateMixerLights();
void CScr_IsMixerLightBehaviorHardCoded();
void CScr_IsMixerBehaviorHardCoded();
void CG_FreeMixerLights();
void CG_TurnOffMixerExploder(_mixerLight_t *pMixer);
void CG_TurnOnMixerExploder(_mixerLight_t *pMixer);
void CG_SetMixerLightIntensity(;
void CG_DeleteLightModels(_lightModel_t *lightModel);
void CG_CreateLightModelsAndFX(;
void CScr_AllocateSoundRandoms();
void CG_FreeSoundRandoms();
void CG_AddSoundRandomToActiveList(soundRandom_t *soundRandom);
void CG_RunSoundRandoms();
void CScr_CreateSoundRandom();
void CScr_SoundSetMusicState();
void CScr_SoundLoopEmitter();
void CScr_SoundStopLoopEmitter();
void CScr_SoundLineEmitter();
void CScr_SoundStopLineEmitter();
void CScr_GetAliasName();
void CScr_GetAliasCount();
void CScr_IsAliasLoop();
void CScr_StopLocalSound();
void CScr_SoundTimescale();
void CScr_SoundPlaying();
void CScr_SetSoundVolume();
void CScr_SetSoundPitch();
void CScr_SetSoundVolumeRate();
void CScr_SetSoundPitchRate();
void CScr_GetRealTime();
void CScr_GetPlaybackTime();
void CScr_GetKnownLength();
void CScr_SetGroupSnapshot();
void CScr_SetAmbientSnapshot();
void CScr_SetAmbientSideChainDuck();
void CScr_SetGlobalFutz();
void CScr_SetHealthSnapshot();
void CScr_SetLevelFadeSnapshot();
void CScr_StopSound();
void CScr_ScaleSpeed();
void CScr_DeactivateReverb();
void CScr_SetReverb();
void CScr_GetArrayKeys();
void CScr_GetFirstArrayKey();
void CScr_GetNextArrayKey();
void CScr_GetLastArrayKey();
void CScr_GetPrevArrayKey();
void CScr_GetLocalClientPos();
void CScr_AimingAtFriendly();
void CScr_SplitArgs();
void CScr_SetThirdPerson();
void CScr_sin();
void CScr_cos();
void CScr_tan();
void CScr_asin();
void CScr_acos();
void CScr_atan();
void CScr_min();
void CScr_max();
void CScr_floor();
void CScr_ceil();
void CScr_sqrt();
void CScr_CastInt();
void CScr_CastFloat();
void CScr_CastIString();
void CScr_GetLocalClientEyePos();
void CScr_GetLocalClientAngles();
char CScr_Spawn();
void CScr_IsAlive();
void CScr_GetWeaponAmmoClip();
void CScr_IsThrowingGrenade();
void CScr_IsMeleeing();
void CScr_IsSwitchingWeapons();
void CScr_IsOnTurret();
void CScr_IsSubStr();
void CScr_GetSubStr();
void CScr_StrTok();
void CScr_MakeLocalizedString();
void CScr_GetSpecies(centity_t *cent, const cent_field_s *pField);
void CScr_GetIsDog(centity_t *cent, const cent_field_s *pField);
void CScr_GetIsBigDog(centity_t *cent, const cent_field_s *pField);
void CScr_PlayerJumpEvent(;
void CScr_PlayerLandEvent(;
void CScr_PlayerFoliageEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, bool quiet);
void CScrCmd_GetThrottle(scr_entref_t entref);
void CScrCmd_GetBrake(scr_entref_t entref);
void CScrCmd_GetMaxSpeed(scr_entref_t entref);
void CScrCmd_GetSteering(scr_entref_t entref);
void CScrCmd_GetMaxReverseSpeed(scr_entref_t entref);
void CScrCmd_IsDriving(scr_entref_t entref);
void CScrCmd_IsLocalPlayerWeaponViewOnlyLinked(scr_entref_t entref);
void CScrCmd_IsLocalPlayerViewLinked(scr_entref_t entref);
void CScrCmd_IsLocalClientDriver(scr_entref_t entref);
void CScrCmd_GetLocalClientDriver(scr_entref_t entref);
void CScrCmd_GetWheelSurface(scr_entref_t entref);
void CScrCmd_IsWheelSliding(scr_entref_t entref);
void CScrCmd_IsWheelColliding(scr_entref_t entref);
void CScrCmd_GetLocalGunnerAngles(scr_entref_t entref);
void CScrCmd_SetStunned(scr_entref_t entref);
void CScr_IsInVehicle();
void CScr_IsXenon();
void CScr_GetSurfaceStrings();
void CScr_FindStaticModelIndex();
void CScr_HideStaticModel();
void CScr_UnhideStaticModel();
void CScr_GetFootstepStrings();
void CScrCmd_IsVehiclePeelingOut(scr_entref_t entref);
void CScr_line();
void CScr_box();
void CScr_PixBeginEvent();
void CScr_debugstar();
void CScr_GetMaxLocalClients();
void CScr_GetActiveLocalClients();
void CScr_LocalClientActive();
void CScr_IsSplitScreenHost();
void CScr_IsSplitScreen();
void CScr_StopBink();
void CScr_GetBinkLength();
void CScr_IsBinkFinished();
void CScr_FxParamError(LocalClientNum_t localClientNum, int paramIndex, const char *errorString, int fxId);
void CScr_SetFxAngles(int givenAxisCount, vec3_t *axis, vec3_t *angles);
unsigned int CScr_PlayFXInternal(;
void CScr_PlayFX();
void CScr_StopFX();
void CScr_IsFXPlaying();
void CScr_DisableImpactMarks();
void CScr_EnableImpactMarks();
void CScr_GetGenericEnt(LocalClientNum_t localClientNum, int offset, const char *pName);
void CScr_GetEnt();
void CScrCmd_IsAlive(scr_entref_t entref);
void CScr_GetEntByNum();
void CScr_GetEntArray();
void CScr_GetLocalPlayers();
void CScr_GetLocalPlayer();
void CScr_GetNonPredictedLocalPlayer();
void CScr_PrecacheRumble();
void CScr_PlayRumbleOnPosition_Internal();
;
char CScr_TracePoint();
void CScr_OpenFile();
void CScr_CloseFile();
void CScr_FPrint_internal(bool commaBetweenFields);
void CScr_FPrintln();
void CScr_FPrintFields();
void __thiscall CScr_FReadLn(const char *this);
void CScr_FGetArg();
void CScr_SetUI3DTextureWindow();
void CScr_GetWeaponModel();
void CScr_CreateNewArray();
void CScr_ArrayRemoveValue();
void CScr_ArrayRemoveIndex();
void CScr_ArrayInsert();
void CScr_ArrayCombine();
void CScr_ArrayCopy();
void CScr_IsInArray();
void CScr_SessionModeIsOnlineGame();
void CScr_SessionModeIsPrivateOnlineGame();
void CScr_SessionModeIsPrivate();
void CScr_SessionModeIsSystemlink();
void CScr_SessionModeIsZombiesGame();
void CScr_GameModeIsMode();
void CScr_GameModeIsUsingXP();
void CScr_GameModeIsUsingStats();
void CScr_TriggerFX();
char CScr_VisionSetNaked();
bool CScr_VisionSetNakedLerp();
void CScr_GetVisionSetNaked();
void CScr_SetRippleWave();
// void CScr_Project2DTo3D(unsigned int a1@<ebp>);
void CScr_ForwardRotateAroundUpByAngle();
int CScr_ScriptCallbackOnFootstepEvent();
char *CScr_UseFootstepTable();
char *CScr_UseFootstepFXTable();
char CScr_FootstepDoNothing();
char CScr_FootstepDoEverything();
void CScr_FootstepDoSound();
void CScr_FootstepDoFootstepFX();
void CScr_SetDemoLockOnValues();
void CScr_TableLookupFindCoreAsset();
void CScr_TableLookupRowNum();
void CScr_TableLookupColumnForRow();
void CScr_TableLookup();
void CScr_TableLookupIString();
void BG_EvalVehicleName();
void CScr_CreateQRCode();
void CScr_DeleteQRCode();
void CScr_ForceAmbientRoom();
void CScr_ForceAmbientPackage();
void CScr_SetAmbientPackage();
void CScr_SetAmbientRoomContext();
void CScr_RopePulse();
void CScr_SetForceNotSimple(scr_entref_t entref);
void CScrCmd_GetCamPosByLocalClientNum();
void CScrCmd_GetCamAnglesByLocalClientNum();
void CScrCmd_DemoIsAnyFreeMoveCamera();
void CScrCmd_DemoIsMovieCamera();
void CScrCmd_DemoIsEditCamera();
void CScrCmd_DemoIsDollyCamera();
void CScrCmd_GetScreenWidth();
void CScrCmd_GetScreenHeight();
void (*CScr_GetFunction(const char **pName, int *type, int *min_args, int *max_args))();
;
void CScrCmd_SetModel(scr_entref_t entref);
void CScrCmd_SetScale(scr_entref_t entref);
void CScr_Attach(scr_entref_t entref);
void CScrCmd_GetSpeed(scr_entref_t entref);
void CScrCmd_GetStance();
void CScrCmd_GetWeaponPosFrac();
void CScrCmd_GetEntNum(scr_entref_t entref);
void CScrCmd_GetEntityNumber(scr_entref_t entref);
void CScrCmd_MakeLight(scr_entref_t entref);
void CScr_GetLightColor(scr_entref_t entref);
void CScr_SetLightColor(scr_entref_t entref);
void CScr_GetLightIntensity(scr_entref_t entref);
void CScr_SetLightIntensity(scr_entref_t entref);
void CScr_GetLightRadius(scr_entref_t entref);
void CScr_SetLightRadius(scr_entref_t entref);
void CScr_GetLightFovInner(scr_entref_t entref);
void CScr_GetLightFovOuter(scr_entref_t entref);
// void CScr_SetLightFovRange(float a1@<edi>, scr_entref_t entref);
void CScr_GetLightExponent(scr_entref_t entref);
void CScr_SetLightExponent(scr_entref_t entref);
void CScr_MakeLightSlave(scr_entref_t entref);
void CScrCmd_PlayRumbleOnEntity_Internal(scr_entref_t entref, int event);
void CScrCmd_PlayRumbleOnEntity(scr_entref_t entref);
void CScrCmd_PlayRumbleLoopOnEntity(scr_entref_t entref);
void CScrCmd_StopRumble(scr_entref_t entref);
void CScrCmdGetCommandTimes(float *pfTotalTime, float *pfAccelTime, float *pfDecelTime);
void CScriptMover_SetupMove(;
void CScriptMover_SetupMoveSpeed(;
void CScriptMover_MoveGravity(;
void CScrCmd_MoveGravity(scr_entref_t entref);
void CScrCmd_MoveTo(scr_entref_t entref);
void CScrEnt_MoveAxis(scr_entref_t entref, int iAxis);
void CScrEntCmd_MoveX(scr_entref_t entref);
void CScrEntCmd_MoveY(scr_entref_t entref);
void CScrEntCmd_MoveZ(scr_entref_t entref);
void CScriptEnt_RotateAxis(scr_entref_t entref, int iAxis);
void CScrCmd_RotatePitch(scr_entref_t entref);
void CScrCmd_RotateYaw(scr_entref_t entref);
void CScrCmd_RotateRoll(scr_entref_t entref);
void CScrCmd_RotateTo(scr_entref_t entref);
void CScrCmd_RotateVelocity(scr_entref_t entref);
void CScr_StartPoisoning(scr_entref_t entref);
void CScr_StopPoisoning(scr_entref_t entref);
void CScr_IsPoisoned(scr_entref_t entref);
void CScrCmd_GetCamPos(scr_entref_t entref);
void CScrCmd_GetCamAngles(scr_entref_t entref);
void CScr_UseAnimTree(scr_entref_t entref);
XAnimTree_s *CScr_GetEntAnimTree(centity_t *ent);
void CScr_HasAnimTree(scr_entref_t entref);
void CScr_ClearAnim(scr_entref_t entref);
void CScr_ClearAnimLimited(scr_entref_t entref);
void CScr_HandleAnimError(int error);
void CScr_SetAnimKnobInternal(scr_entref_t entref, unsigned int flags, bool bFlagged);
void CScr_SetAnimKnob(scr_entref_t entref);
void CScr_SetAnimKnobLimited(scr_entref_t entref);
void CScr_SetAnimKnobRestart(scr_entref_t entref);
void CScr_SetAnimKnobLimitedRestart(scr_entref_t entref);
void CScr_SetAnimKnobAllInternal(scr_entref_t entref, unsigned int flags, bool bFlagged);
void CScr_SetAnimKnobAll(scr_entref_t entref);
void CScr_SetAnimKnobAllLimited(scr_entref_t entref);
void CScr_SetAnimKnobAllRestart(scr_entref_t entref);
void CScr_SetAnimKnobAllLimitedRestart(scr_entref_t entref);
void CScr_SetAnimInternal(scr_entref_t entref, unsigned int flags, __int16 bFlagged, bool scripted);
void CScr_SetAnim(scr_entref_t entref);
void CScr_SetAnimLimited(scr_entref_t entref);
void CScr_SetAnimRestart(scr_entref_t entref);
void CScr_SetAnimLimitedRestart(scr_entref_t entref);
void CScr_SetFlaggedAnim(scr_entref_t entref);
void CScr_SetFlaggedAnimLimited(scr_entref_t entref);
void CScr_SetFlaggedAnimRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimLimitedRestart(scr_entref_t entref);
void CScr_AnimScripted(scr_entref_t entref);
void CScr_AnimFlaggedScripted(scr_entref_t entref);
void CScr_SetFlaggedAnimKnob(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobLimited(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobLimitedRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobAll(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobAllRestart(scr_entref_t entref);
void CScr_AnimGetChildAt(scr_entref_t entref);
void CScr_AnimGetNumChildren(scr_entref_t entref);
void CScr_GetAnimTime(scr_entref_t entref);
void CScr_GetAnimCurrFrameCount(scr_entref_t entref);
void CScr_SetAnimTime(scr_entref_t entref);
void CScr_SetEntityAnimRate(scr_entref_t entref);
void CScr_GetEntityAnimRate(scr_entref_t entref);
void CScrCmd_IsPlayer(scr_entref_t entref);
void CScrCmd_IsLocalPlayer(scr_entref_t entref);
void CScrCmd_IsAI(scr_entref_t entref);
void CScr_HasDObj(scr_entref_t entref);
void CScr_SetCompassIcon(scr_entref_t entref);
void CScrCmd_IsSplitScreenHost(scr_entref_t entref);
void CScrCmd_UnderWater(scr_entref_t entref);
void CScrCmd_LinkTo(scr_entref_t entref);
void CScrCmd_Unlink(scr_entref_t entref);
void CScr_Map_Material(scr_entref_t entref);
void CScr_Set_Filter_Pass_Material(scr_entref_t entref);
void CScr_Set_Filter_Pass_Enabled(scr_entref_t entref);
void CScr_Set_Filter_Pass_Quads(scr_entref_t entref);
void CScr_Set_Filter_Pass_Constant(scr_entref_t entref);
void CScr_Set_Filter_Bit_Flag(scr_entref_t entref);
void CScr_Set_Overlay_Material(scr_entref_t entref);
void CScr_Set_Overlay_Constant(scr_entref_t entref);
void CScr_SetInfraredVisionset(scr_entref_t entref);
void CScr_SetSonarEnabled(scr_entref_t entref);
void CScr_ForceInfraredMaterialsStreaming(scr_entref_t entref);
void CScr_Set_Overlay_Enabled(scr_entref_t entref);
void CScr_LaunchRagdoll(scr_entref_t entref);
void CScr_Show(scr_entref_t entref);
void CScr_Hide(scr_entref_t entref);
void CScrCmd_GetEye(scr_entref_t entref);
void CScrCmd_GetEyeApprox(scr_entref_t entref);
void CScrCmd_GetLocalClientNumber(scr_entref_t entref);
void CScr_MapShaderConstant(scr_entref_t entref);
void CScr_SetShaderConstant(scr_entref_t entref);
void CScr_MakeMixerLight(scr_entref_t entref);
void CScr_ActivateMixer(scr_entref_t entref);
int CG_GetMixerLightSide(int param);
void CScr_SetMixerLightModels(scr_entref_t entref);
void CScr_SetMixerSpinModels(scr_entref_t entref);
void CScr_SetMixerLightBehavior(scr_entref_t entref);
void CScr_SetMixerExploderId(scr_entref_t entref);
void CScr_SetMixerBehavior(scr_entref_t entref);
void CScr_SetMixerLightParam(scr_entref_t entref);
void CScr_SetMixerParam(scr_entref_t entref);
void CScr_SetMixerL2RRampSpeed(scr_entref_t entref);
void CScr_SetMixerR2LRampSpeed(scr_entref_t entref);
void CScr_SetMixerLightRotateTime(scr_entref_t entref);
void CScr_SetMixerLightIntensity(scr_entref_t entref);
void CScr_SetMixerLightColor(scr_entref_t entref);
void CScr_SetMixerLightExponent(scr_entref_t entref);
void CScr_SetMixerLightRadius(scr_entref_t entref);
void CScr_SetMixerLightFovRange(scr_entref_t entref);
team_t GetTeam(centity_t *cent);
void CScr_GetTeamName(centity_t *cent, const cent_field_s *pField);
void CScr_GetPlayerName(centity_t *cent, const cent_field_s *pField);
void CScrCmd_GetCharacterIndex(scr_entref_t entref);
void CScr_SetMaterialOverride(scr_entref_t entref);
void CScr_ClearMaterialOverride(scr_entref_t entref);
void CScr_SetStepTriggerSound(scr_entref_t entref);
void CScr_ClearStepTriggerSound(scr_entref_t entref);
void CScr_GetMovementType(scr_entref_t entref);
void CScr_IsInsideHeightLock(scr_entref_t entref);
void CScr_SetAmbientTrigger(scr_entref_t entref);
void CScr_SoundSetAmbientState(;
void CScr_SoundPlayUiDecodeLoop(const char *decodeString, const int playTimeMs);
void CScr_IsGrenadeDud(scr_entref_t entref);
void (*CScr_GetMethod(const char **pName, int *type, int *min_args, int *max_args))(scr_entref_t);
void CScr_LoadLevel(bool bPrecacheGameType);
void CScr_FreeScripts();
unsigned int CG_SetEntityScriptVariableInternal(const char *key, const char *value);
unsigned int CG_SpawnStruct(const SpawnVar *spawnVar);
void CG_SpawnNode();
void CScr_GlassSmash(const vec3_t *pos, const vec3_t *dir);
void CScr_BuildClientsideAITypeList(bool bRestarting);
void CScr_GetPlayerFootstepTables();
void *CScr_LoadEntityscriptAlloc(int size);
void CScr_LoadEntityScripts();
void *CScr_SetupClientZBarrierIndicesAlloc(int size);
void CScr_SetupClientZBarrierIndices();
int CScr_UpdateTagInternal(;
void CScr_LoadStructs();
unsigned __int16 CScr_ExecEntThread(centity_t *ent, int handle, unsigned int paramcount);
;
void CG_DoTouchTriggers(centity_t *ent, LocalClientNum_t localClientNum);
void CScr_GetField(centity_t *ent, cent_field_s *fieldarray, unsigned int offset);
void CScr_GetEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_SetField(centity_t *ent, cent_field_s *fieldarray, unsigned int offset);
int CScr_SetEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_GetObjectField(unsigned int classnum, int entnum, LocalClientNum_t clientNum, int offset);
// int CScr_SetObjectField@<eax>(;
void CScr_PostLoadScripts();
unsigned int CScr_GetFakeEntity(LocalClientNum_t localClientNum);
void CScr_SpawnFakeEnt();
centity_t *CScr_SetFakeEntOrg();
int CScr_PlayLoopedFX();
void CScr_PlayLoopSound();
unsigned int CScr_StopLoopSound();
void firecaster_light_behavior(;
void fire_flicker_internal(;
void fire_flicker_light_behavior(;
void flickerthenstop_light_behavior(;
void explode_then_flicker_light_behavior(;
void electrical_flicker_light_behavior(;
void generic_strobe_light_behavior(;
void generic_double_strobe_light_behavior(;
void light_off_light_behavior(;
void generic_pulsing_light_behavior(;
void television_light_behavior(;
void generic_flickering_light_behavior(;
void CG_HandleSpinnerLights(;
// void CG_RunMixerLights(float a1@<edi>);
void CScr_SpawnPlane();
;
void CScrCmd_Delete(scr_entref_t entref);
void CScrCmd_SetViewModelRenderFlag(scr_entref_t entref);
void CScrCmd_ForceDelete(scr_entref_t entref);
void CScrCmd_GetVelocity(scr_entref_t entref);
void CScrCmd_IsTouching(scr_entref_t entref);
void CG_FreeEntityDelay(centity_t *ed);

//t6/code/src_noserver/cgame/cg_scr_main.h
void CScr_AddEntity(centity_t *cent, LocalClientNum_t clientNum);
void CScr_FreeEntity(centity_t *cent, LocalClientNum_t clientNum);
void CScr_AddStruct();

//t6/code/src_noserver/cgame/cg_shellshock.cpp
void CG_PerturbCamera(cg_t *cgameGlob);
void SaveScreenToBuffer(LocalClientNum_t localClientNum);
int CG_DrawShellShockSavedScreenBlendBlurred(;
int CG_DrawShellShockSavedScreenBlendFlashed(;
void EndShellShockSound(LocalClientNum_t localClientNum);
void EndShellShockLookControl(LocalClientNum_t localClientNum);
void EndShellShockCamera(LocalClientNum_t localClientNum);
void EndShellShockScreen(LocalClientNum_t localClientNum);
void EndShellShock(LocalClientNum_t localClientNum);
void UpdateShellShockSound(;
void UpdateShellShockLookControl(;
void UpdateShellShockCamera(;
void UpdateShellShockVisionSet(;
void CG_UpdateShellShock(;
void CG_StartShellShock(cg_t *cgameGlob, const shellshock_parms_t *parms, int start, int duration);
bool CG_Flashbanged(LocalClientNum_t localClientNum);
bool CG_Flared(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_sound.cpp
void CG_RegisterSoundDvars();
void CG_ClearSoundPlaybackTracking();
bool CG_ShouldPlaySoundOnLocalClient(;
SndEntHandle CG_SndEntHandle(LocalClientNum_t localClientNum, int entIndex);
void CG_PlaySound(;
void CG_PlaySound(;
void CG_PlaySound(;
int CG_PlaySoundWithHandle(;
int CG_PlaySoundWithHandle(;
void CG_FlushLoops();
void CG_PumpEntityLoopSound(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_PlayAnimScriptSoundAlias(ClientNum_t clientIndex, SndAliasList *aliasList);
void CG_SubtitlePrint(int msec, const char *subtitle);
void CG_SubtitleSndLengthNotify(int msec, const char *lengthNotifyData);
void CG_ScriptSndLengthNotify(int msec, int lengthNotifyData);
void CG_CopySoundEntityOrientation(;
unsigned int CG_SoundGetUseCount(const SndEntHandle sndEnt);
void CG_GetSoundEntityOrientation(;
void CG_StopSoundAlias(LocalClientNum_t localClientNum, int entityNum, unsigned int aliasName);
void CG_SndFireReset();
void CG_SndUpdateFire();
void CG_FlameSourceUpdate(;
void CG_SoundWhizby(;
void CG_SndUpdate();
void CG_SoundUpdateListeners(LocalClientNum_t localClientNum);
void CG_GetLoopingSoundPosition(LocalClientNum_t localClientNum, centity_t *cent, vec3_t *sndOrigin);
void CG_UpdateLoopingFireSounds(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_CheckADSRaiseAndLower(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_Turret_UpdateTurretRotationSound(LocalClientNum_t localClientNum, centity_t *cent);
void CG_SoundForceAmbientRoomChange(bool forceChange, bool defaultRoom, unsigned int roomHash);
void CG_SoundForceAmbientPackageChange(bool forceChange, bool defaultPackage, unsigned int packageHash);
void CG_SoundInitAmbientColliders();
void CG_SoundSetAmbientData(const snd_ambient_script_data *ambData);
void CG_SoundSetAmbientContext(;
void CG_GetHighestPriorityRoomIndices(cg_t *cgameGlob, snd_ambient_collider *currentCollider);
void CG_SoundAmbientCheckOverrides(cg_t *cgameGlob, snd_ambient_collider *collider);
void CG_SoundUpdateAmbient();
void CG_StopZombieVoxSounds(LocalClientNum_t localClientNum, int entityNum);
bool CG_SoundEntInUse(const SndEntHandle sndEnt);
void CG_SndGameReset();

//t6/code/src_noserver/cgame/cg_spawn.cpp
const char *CG_GetEntityTypeName(centity_t *cent);
int CG_GetModelIndex(const char *name, LocalClientNum_t localClientNum);
void CScr_FreeFields(const cent_field_t *fields, unsigned __int8 *base);
void CScr_FreeEntityFields(centity_t *cent);
void CG_ParseEntityFields(;
void CG_InitScriptMover(centity_t *cent);
bool CG_SetTriggerBrushModel(LocalClientNum_t localClientNum, centity_t *ent);
void CG_InitSentientTrigger(centity_t *self, int spawnflags);
bool CG_IsPositionInZeroGravity(const vec3_t *position);
void CG_PrintEntities(LocalClientNum_t localClientNum);
centity_t *CG_Spawn(LocalClientNum_t localClientNum);
void CG_Free(LocalClientNum_t localClientNum, int entNum);
void CG_ShutdownFakeEntities(LocalClientNum_t localClientNum);
bool CG_InitTrigger(LocalClientNum_t localClientNum, centity_t *self);
void CG_SP_trigger_multiple(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_once(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_radius(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_box(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_CallSpawn(LocalClientNum_t localClientNum, SpawnVar *spawnVar);
void CG_SpawnEntitiesFromString(LocalClientNum_t localClientNum);
void CG_InitFakeEntities(LocalClientNum_t localClientNum, bool spawnEntsFromMap);

//t6/code/src_noserver/cgame/cg_vehicle.cpp
cgVehicleTurretLoopState_t CG_VehicleComputeTurretRotationState(float angularVel, cgVehicle_t *vehicle);
void CG_Vehicle_UpdateTurretRotateSounds(LocalClientNum_t localClientNum, centity_t *cent);
bool CG_ShouldLockTurretToPlayerView(const centity_t *cent, const VehicleDef *info, const playerState_s *ps);
void CG_UpdateVehicleSoundOrigins(centity_t *cent, const DObj *obj);
void CG_InitAntenna(centity_t *cent, const DObj *obj);
int GetSoundInfoForVehicle(LocalClientNum_t localClientNum, const centity_t *cent, float *slideRate);
void CG_CrossFadeVehicleMaterialEffects(;
void CG_UpdateWheeledSurfaceSounds(;
void CG_UpdateSurfaceSounds(;
void CG_UpdateVehicleNotifies(LocalClientNum_t localClientNum, centity_t *cent);
char CG_VehicleOccupiedByPlayer(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Vehicle_GetSoundOriginForGun(centity_t *cent, int gunIndex, vec3_t *sndOrigin);
bool CircleLineIntersect(vec3_t *p1, vec3_t *p2, vec3_t *center, float radius, float *t0, float *t1);
bool CG_Vehicle_GetWheelBone(;
void CG_Vehicle_GetBoneOrigin(;
int CG_Vehicle_GetVehicleDefIndex(const centity_t *cent);
const VehicleDef *CG_Vehicle_GetVehicleDef(const centity_t *cent);
bool CG_Vehicle_IsDefRemoteControl(int index);
bool CG_Vehicle_IsRemoteControl(const centity_t *cent);
BOOL CG_Vehicle_IsGunnerTurretFiring(const centity_t *cent, int gunnerIndex);
bool CG_Vehicle_IsGunFiring(const centity_t *cent, int gunIndex);
void CG_Vehicle_RegisterMaterials();
void CG_Vehicle_UpdateEngine(;
void CG_Vehicle_UpdateMaterialTime(centity_t *cent, int dt, float speed);
void CG_VehicleDebug(centity_t *cent, const DObj *obj);
void CG_Vehicle_UpdateAntennas(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_Vehicle_UpdateMinigun(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_AllocClientVehicle(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_UpdateVehicleEngineSounds(;
void CG_UpdateVehicleTags(centity_t *ent);
void CG_TriggerLoopingVehFire(;
void CG_UpdateLoopingVehicleFireSounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateDriveBySounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateVehicleSounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Vehicle_Init();
void CG_Vehicle_SetupCollisionCache(cg_t *cgameGlob, centity_t *cent, bool uses_vehicle_cache);
void CG_Vehicle_PreControllersAir(;
;
;

//t6/code/src_noserver/cgame/cg_vehicle_hud.cpp
void CG_TargetsChanged(LocalClientNum_t localClientNum, int num);
void CG_ParseAllTargets(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_visionsets.cpp
void CG_RegisterVisionSetsDvars();
const char *RawBufferOpen(const char *path, const char *backupPath);
bool ApplyTokenToField(int fieldNum, const char *token, visionSetVars_t *settings);
bool LoadVisionSettingsFromBuffer(const char *buffer, const char *filename, visionSetVars_t *settings);
bool LoadVisionFile(const char *name, visionSetVars_t *resultSettings);
bool GetVisionSet(LocalClientNum_t localClientNum, const char *name, visionSetVars_t *resultSettings);
bool LerpBool(bool from, bool to, float fraction, visionSetLerpStyle_t style);
int LerpInteger(int from, int to, const float fraction, visionSetLerpStyle_t style);
float LerpStepFloat(float from, float to, const float fraction, visionSetLerpStyle_t style);
float LerpFloat(float from, float to, float fraction, visionSetLerpStyle_t style);
void LerpVec4(;
bool VisionSetCurrent(LocalClientNum_t localClientNum, visionSetMode_t mode, const char *name);
bool CG_VisionSetStartLerp_To(;
// char CG_VisionSetLerp_To@<al>(;
void SetDefaultVision(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_Naked(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_Night(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_LastStand(LocalClientNum_t localClientNum);
void CG_VisionSetMyChanges();
bool CG_InLastStandVision(const LocalClientNum_t localClientNum);
bool CG_InFlareVision(const LocalClientNum_t localClientNum);
char CG_LookingThroughNightVision(const LocalClientNum_t localClientNum);
void DrawVisionSetDebug(LocalClientNum_t localClientNum, visionSetMode_t curChannel);
void CG_VisionSetApplyToRefdef(LocalClientNum_t localClientNum, bool isExtracam);
void UpdateVarsLerpCustom(;
void UpdateVarsLerp(;
void CG_InitVisionSets(LocalClientNum_t localClientNum);
void CG_VisionSetsUpdate(LocalClientNum_t localClientNum);
bool LoadVisionFileForTweaks(visionSetVars_t *setVars);
void CG_VisionSetUpdateTweaksFromFile_Film();
void CG_VisionSetUpdateTweaksFromFile_CharPrimary();
void CG_VisionSetUpdateTweaksFromFile_Bloom();

//t6/code/src_noserver/cgame/cg_weapons.cpp
void CG_RegisterWeaponDvars();
float GetWeaponAnimRate(LocalClientNum_t localClientNum, const Weapon weapon, XAnim_s *anims, int animIndex);
float GetWeaponAnimTimeFrac(;
void StartWeaponAnim(;
// double StartCameraAnim@<st0>(;
void StopCameraAnim(DObj *obj);
void PlayIdleAnim(;
void PlayLeftIdleAnim(;
void PlayADSAnim(;
bool CG_JavelinADS(LocalClientNum_t localClientNum);
bool CG_UICheckWeapLockBlink(LocalClientNum_t localClientNum, float blinkPerSec);
bool CG_UICheckWeapLockAttackTop(LocalClientNum_t localClientNum);
bool CG_UICheckWeapLockAttackDirect(LocalClientNum_t localClientNum);
int CheckForValidAnimIDDW(int animID);
void EnsureValidLeftAnim(;
void WeaponRunXModelAnims(;
void CG_ResetWeaponAnimTrees(LocalClientNum_t localClientNum, const playerState_s *ps, int newPlayerstate);
int CG_WeaponDObjHandle(LocalClientNum_t localClientNum);
void CG_CreateWeaponViewModelXAnim(const char **animArray, const char **dwAnimArray, XAnim_s *pAnims);
Weapon RemoveAltAttachmentFromWeapon(const Weapon weapon);
void CG_CreateWeaponViewModelXAnimDefs(;
void CG_SetWeaponHidePartBits(const Weapon weapon, ViewModelInfo *viewModelInfo, DObj *obj, int modelNum);
void CG_FreeWeapons(LocalClientNum_t localClientNum);
void CG_RegisterWeapon(LocalClientNum_t localClientNum, Weapon weapon);
bool ShouldRebuildTree(;
char ShouldRebuildAnims(LocalClientNum_t localClientNum, const ViewModelInfo *viewModelInfo, Weapon weapon);
void PlayViewmodelAdsAnim(ViewModelInfo *viewModelInfo, Weapon weapon, int animIndex);
void PlayChangedViewmodelAdsAnim(;
bool ViewmodelRocketShouldBeAttached(LocalClientNum_t localClientNum, Weapon weapon);
XModel *CG_GetHandViewmodel(cg_t *cgameGlob);
void PlayNoteMappedSoundAliases(;
void ProcessWeaponNoteTracks(;
void CG_RegisterItems(LocalClientNum_t localClientNum);
void CalculateWeaponPostion_PositionToADS(cg_t *cgameGlob, playerState_s *ps);
void PlayWeaponFx(;
void WeaponFlash(;
void PlayWeaponContinuousFireFx(;
void CG_HoldBreathInit(cg_t *cgameGlob);
void HoldBreathUpdate(LocalClientNum_t localClientNum);
void ChargeShotUpdate(;
void CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum);
void CG_UpdateMinigunTurretSounds(;
void CG_UpdateJetgunSounds(;
void CG_UpdateMinigunSounds(;
void UpdateMinigunTag(;
void UpdateJetgunDialTags(;
void UpdateParalyzerDialTags(;
void CG_UpdateMinigunTags(cg_t *cgameGlob, centity_t *cent, const DObj *obj, int *partBits);
void CG_UpdateJetgunTags(;
void CG_UpdateViewModelMinigun(;
void CG_UpdateViewModelStackCounter(;
bool BulletTrace(;
bool IsEntityNotDoingClientSideBullets(LocalClientNum_t localClientNum, int entityNum);
bool CG_ShouldSimulateBulletFire(LocalClientNum_t localClientNum, BulletFireParams *bp);
bool CG_IsPlayerCrouching(clientInfo_t *ci, const centity_t *cent);
bool CG_IsPlayerADS(clientInfo_t *ci, const centity_t *cent);
void CG_GuessSpreadForWeapon(;
void RandomBulletDir(unsigned int *randSeed, float *x, float *y);
void CG_BulletEndpos(;
char CG_GetPlayerVehicleViewOrigin_Internal(;
void CG_GetPlayer3rdPersonVehicleViewOrigin(;
char CG_GetPlayerVehicleViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
void CG_GetPlayerViewDirection(;
bool CG_ShowWeaponFx(const cg_t *cgameGlob, centity_t *cent, int bViewModel);
void CG_Hack_TouchPlayerWeaponBones(LocalClientNum_t localClientNum, const cg_t *cgameGlob, centity_t *cent);
void CG_SetSonarAttachmentShaderConstants(LocalClientNum_t localClientNum, ShaderConstantSet *constantSet);
void Weapon_DrawAxisOrigin(orientation_t orient, float colorScale);
void Weapon_DrawTagAxis(LocalClientNum_t localClientNum, int entityNum, Weapon weapon, int bViewModel);
void Anim_DrawTags(LocalClientNum_t localClientNum, int entityNum, Weapon weapon, cpose_t *pose, int flags);
bool UpdateViewmodelAttachments(;
bool NeedToRebuildViewmodel(;
void CG_CalculateWeaponMovement_Landing(const cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_SaveOrigin(cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_Debug(const cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_SaveAngles(cg_t *cgameGlob, vec3_t *angles, GfxScaledPlacement *placement);
void CG_CalculateWeaponMovement_ClientSpecific(;
void CG_BuildWeaponState(cg_t *cgameGlob, weaponState_t *ws);
void CG_SaveWeaponState(const weaponState_t *ws, cg_t *cgameGlob);
Weapon NextWeapInCycle(;
Weapon CG_GetLastWeaponForAlt(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
Weapon CG_GetAltWeapon(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
Weapon CG_AltWeaponToggleIndex(LocalClientNum_t localClientNum, const cg_t *cgameGlob, Weapon *primaryWeapon);
bool ShouldToggleWeaponAltMode(LocalClientNum_t localClientNum, const playerState_s *ps);
int CG_GetBrassTagForEvent(int event);
void CG_EjectWeaponBrass(;
void CG_VehicleJolt(centity_t *cent, vec3_t *origin, vec3_t *dir);
void CG_VehicleFire(centity_t *cent, const unsigned __int16 tagName);
bool CG_FireWeapon_LocalPlayerUsingVehicleWeapon(centity_t *cent, const playerState_s *ps, int event);
void CG_FireWeapon_VehicleFire(;
void CG_FireWeapon_OriginAndDirection(;
void SetWeaponFxFlags(centity_t *cent, bool leftGun, bool shellEject, bool lastShot);
void CG_FireWeapon_Rumble(;
void CG_HideVisibleAmmo(LocalClientNum_t localClientNum, centity_t *cent, const Weapon weapon);
void CG_SndWeaponFakeFire(snd_weapon_shot *shot, const WeaponDef *weaponDef);
void CG_SndWeaponFire(snd_weapon_shot *shot);
void CG_SndAutoSimReset();
void CG_SndPingAutoSim(snd_weapon_shot *shot);
void CG_SndKillAutoSimEnt(SndEntHandle ent);
// void CG_SndUpdateAutoSim(float a1@<ebx>);
void CG_WeaponFireSingle(;
void CG_WeaponFireFake(;
void CG_PullBackWeapon(;
cg_t *CG_GetLocalClientGlobalsForEnt(LocalClientNum_t localClientNum, int entityNum);
void CG_GetViewDirection(;
void CG_CalcEyePoint(LocalClientNum_t localClientNum, int entityNum, vec3_t *eyePos);
void CalcMuzzlePoint(LocalClientNum_t localClientNum, int entityNum, vec3_t *muzzle, unsigned int flashTag);
void CG_RandomEffectAxis(const vec3_t *forward, vec3_t *left, vec3_t *up);
void CG_ImpactEffectForWeapon(;
centity_t *CG_BulletHitEvent_FindPlayerCorpse(LocalClientNum_t localClientNum, centity_t *player);
bool CG_BulletHitDeployedDeployedRiotshield(;
void CG_DogBloodEvent(LocalClientNum_t localClientNum, int entnum, vec3_t *position, int boneIndex);
void CG_DeployRiotshieldEvent(LocalClientNum_t localClientNum);
bool CalcViewmodelHitPos(;
void CG_ViewmodelShieldHitStore(LocalClientNum_t localClientNum, unsigned int eventParm, bool damaged);
void CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum);
void CG_BulletHitClientShieldEvent(;
void CG_ExplosiveImpactOnShieldEvent(LocalClientNum_t localClientNum);
void CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage);
void CG_MeleeBloodEvent(LocalClientNum_t localClientNum, const centity_t *cent, int eventParm);
void CG_MeleeSwipeEvent(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_SetBaseWeaponForStats(const WeaponVariantDef *weapVariantDef);
void CG_SetupWeaponDef();
Weapon ValidLatestPrimaryWeapon(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
char CG_ClearLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
bool CG_SetLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon altWeapon, Weapon weapon);
bool CG_UpdateLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon oldweapon, Weapon weapon);
void CG_SelectWeaponIndex(LocalClientNum_t localClientNum, const playerState_s *ps, Weapon weapon);
void CG_SelectWeaponIndex(LocalClientNum_t localClientNum, Weapon weapon);
void CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum);
Weapon CG_GetPlayerTurretWeapon(LocalClientNum_t localClientNum);
Weapon CG_GetPlayerVehicleWeapon(const playerState_s *ps, const LocalClientNum_t localClientNum);
Weapon CG_GetPlayerMeleeWeapon(const playerState_s *ps);
Weapon CG_GetPlayerWeapon(const playerState_s *ps, const LocalClientNum_t localClientNum);
Weapon CG_GetClientWeapon(ClientNum_t clientNum, const LocalClientNum_t localClientNum);
bool CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum);
bool CG_PlayerUsingMouseToControlVehicle(LocalClientNum_t localClientNum);
bool CG_PlayerUsingHandbrakeInVehicle(LocalClientNum_t localClientNum);
float CG_GetPlayerVehicleHandbrakeTurnSpeedValue(LocalClientNum_t localClientNum);
void CG_ApplyWeaponTurnRateCap(LocalClientNum_t localClientNum);
void CG_MolotovFloat(LocalClientNum_t localClientNum, const centity_t *cent, const entityState_s *es);
Material *CG_GetWeaponOverlay(LocalClientNum_t localClientNum, Weapon weapon);
BOOL CG_IsInGuidedMissile(const playerState_s *ps);
int CG_IsInRemoteKillstreakStatic(const playerState_s *ps);
int CG_AirburstLazeCancelledByMovement(;
void CG_CheckForAirburstReset(cg_t *cgameGlob, const playerState_s *ps);
BOOL CG_IsClientControlledMissile(LocalClientNum_t localClientNum);
BOOL CG_IsAirborneKillstreak(LocalClientNum_t localClientNum);
Weapon CG_GetWeaponForName_Internal(const char *name);
Weapon CG_GetWeaponForName(const char *name);
DroppedWeaponDobjInfo *CG_AllocDroppedWeaponDobjInfo(LocalClientNum_t localClientNum, centity_t *cent);
void CG_FreeDroppedWeaponDobjInfo(LocalClientNum_t localClientNum, centity_t *cent);
int AddViewmodelWeaponAttachments(;
void ChangeViewmodelDobj(;
void CG_UpdateHandViewmodel_Internal(LocalClientNum_t localClientNum, Weapon weapon, XModel *handModel);
void CG_UpdateWeaponAndHandViewmodels(LocalClientNum_t localClientNum);
void CG_UpdateMinigunSpin(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
char CG_GetPlayerViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
char CG_PrepFireParams(;
Weapon CG_GetWeaponDefBasedOnNumberOfBullets(const cg_t *cgameGlob, int numBulletsQueued, Weapon weapon);
void CG_AddPlayerWeaponFx(;
void CG_AddPlayerWeapon(;
void CG_AddViewWeapon(LocalClientNum_t localClientNum);
bool CG_CancelOffhand(cg_t *cgameGlob);
bool WeaponCycleAllowed(cg_t *cgameGlob);
char VerifyPlayerAltModeWeapon(LocalClientNum_t localClientNum, Weapon weapon);
void CG_SwitchToLastValidPrimary(LocalClientNum_t localClientNum);
char CycleWeapPrimary(LocalClientNum_t localClientNum, int cycleForward, int bIgnoreEmpty);
void CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleForward);
bool ToggleWeaponAltMode(LocalClientNum_t localClientNum, bool adsOnly);
void CG_AdsAltWeaponDown(LocalClientNum_t localClientNum);
char CG_ActionSlot_SelectWeapon(const LocalClientNum_t localClientNum, Weapon weapon, bool checkMomentumCost);
void CG_FakeFireWeapon(;
void CG_BulletHitEvent_Internal(;
void CG_BulletHitEvent(;
void CG_BulletHitClientEvent(;
char CG_ScopeIsOverlayed(LocalClientNum_t localClientNum);
int CG_GetAirburstMarkDistance(;
void CG_WeaponMyChanges();
void CG_SimulateBulletFire_Effect(;
void CG_WeaponBounceShot(;
;
;
void CG_SimulateBullet(bullet_hit_info_t *results, const int max_results, int *num_results);
;
void __thiscall CG_NextWeapon_f(cg_t *this);
void __thiscall CG_PrevWeapon_f(cg_t *this);
void CG_OutOfAmmoChange(LocalClientNum_t localClientNum);
bool ActionSlotUsageAllowed(const cg_t *cgameGlob);
void CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot);
void CG_ActionSlotUp(LocalClientNum_t localClientNum);
char CG_SelectInventoryWeapon(const LocalClientNum_t localClientNum);
void TakeClipOnlyWeaponIfEmpty(LocalClientNum_t localClientNum, playerState_s *ps);
void CG_FireWeapon(;
void CG_UpdateViewWeaponAnim(LocalClientNum_t localClientNum, int newPlayerstate);
void CG_FireVehicleWeapon(;

//t6/code/src_noserver/cgame/cg_weapon_attachments.cpp
bool CG_RangeFinderEnabled(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
bool CG_RangeFinderChangeColor(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_InitRangeFinderParameters(LocalClientNum_t localClientNum);
;
unsigned int CG_DrawRangefinderHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawBallisticCpuHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawTacticalInsertionHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawBriefcaseBombHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawPDAHackerHUD(LocalClientNum_t localClientNum);
void CG_DrawWeaponDynamicTextures(LocalClientNum_t localClientNum);
;

//t6/code/src_noserver/cgame/cg_weapon_utils.cpp
unsigned __int16 G_GetWeaponAttachBone(clientInfo_t *ci, weapType_t weapType, weapInventoryType_t invType);
unsigned __int16 CG_AttachWeaponWorldModel(;

//t6/code/src_noserver/cgame/cg_world.cpp
int CG_GetEntityBModelContents(const centity_t *cent);
void CG_GetEntityDobjBounds(;
int CG_GetEntityDObjContents(const centity_t *cent, const DObj *dobj);
bool CG_EntityHasCollision(const centity_t *cent, DObj *dobj);
bool CG_EntityNeedsLinked(LocalClientNum_t localClientNum, int entIndex);
void CG_UnlinkEntity(LocalClientNum_t localClientNum, int entIndex);
;
bool CG_EntityInArea(int entIndex, const vec3_t *mins, const vec3_t *maxs, int contentMask);
void CG_AreaEntities_r(unsigned __int16 sectorIndex, CEntityAreaParms *areaParms);
int CG_AreaEntities(;
int cmpr(const void *e0, const void *e1);
int CG_GetEntityBoneInfo(int entID, int boneIndex, vec3_t *bonePos, vec3_t *boneAxis, const char **boneName);
void CG_GetEntityBModelBounds(;
void CG_LinkEntity(LocalClientNum_t localClientNum, int entIndex);
void CG_ClipMoveToEntity(const moveclip_t *clip, int entIndex, trace_t *results);
void CG_ClipMoveToEntities_r(;
void CG_ClipMoveToEntities(const moveclip_t *clip, trace_t *results);
void CG_PointTraceToEntity(const pointtrace_t *clip, int entIndex, trace_t *results);
void CG_PointTraceToEntities_r(;
void CG_PointTraceToEntities(const pointtrace_t *clip, trace_t *results, col_context_t *context);
;
void CG_LocationalTrace(;
;
;
void CG_TraceCapsule(;

//t6/code/src_noserver/cgame/offhandweapons.cpp
bool IsOffHandDisplayVisible(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
int CalcOffHandAmmo(const playerState_s *predictedPlayerState, int weaponType);
void OffHandFlash(const cg_t *cgameGlob, const vec4_t *base_color, vec4_t *out_color);
void CG_DrawOffHandHighlight(;
void CG_DrawOffHandAmmo(;
void CG_DrawOffHandName(;
void CG_PrepOffHand(;
void CG_UseOffHand(LocalClientNum_t localClientNum, const centity_t *cent, Weapon weapon, bool isPlayerView);
void CG_SetEquippedOffHand(LocalClientNum_t localClientNum, Weapon offHandWeapon);
void CG_DrawOffHandIcon(;
void CG_SwitchOffHandCmd(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_actors_mp.cpp
void CG_UpdateActorDObj(LocalClientNum_t localClientNum, centity_t *cent, actorInfo_t *ai);
void CG_ResetActorEntity(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_Actor(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ActorCorpse(LocalClientNum_t localClientNum, centity_t *cent);
actorInfo_t *CG_ActorInfoForEntity(LocalClientNum_t localClientNum, int entNum);
BOOL CG_IsActorCorpseInfoCurrent(LocalClientNum_t localClientNum, int corpseIndex);
actorInfo_t *CG_ActorEntityScriptedAnim(LocalClientNum_t localClientNum, int entNum);
void CG_ActorProcessSnapshot(LocalClientNum_t localClientNum, centity_t *cent);

//t6/code/src_noserver/cgame_mp/cg_animscripted_mp.cpp
void CG_GetTagMatrix(;
void CG_CalcTagParentAxis(LocalClientNum_t localClientNum, centity_t *cent, vec3_t *parentAxis);
void CG_CalcEntityScriptedAnimTransform(;
void CG_LinkTransformForEntity(;
void CG_GenerateLinkInfo(;
void CG_UpdateEntityLink(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateFakeEntityLink(LocalClientNum_t localClientNum, centity_t *cent, int parentNum, int tagIndex);
void CG_UpdateFakeEntityLink(LocalClientNum_t localClientNum, centity_t *cent);
centity_t *CG_EntGetLinkToParent(LocalClientNum_t localClientNum, centity_t *cent);
void CG_CalcCurrentOriginAnglesError(LocalClientNum_t localClientNum, centity_t *cent);
BOOL CG_EntityLinked(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ScriptedAnimTransformForEntity(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ScriptedAnimUpdate(LocalClientNum_t localClientNum, centity_t *cent);
void CG_LinkedEntUpdate(LocalClientNum_t localClientNum, centity_t *cent);

//t6/code/src_noserver/cgame_mp/cg_animtree_mp.cpp
void *Hunk_AllocXAnimCreate(int size);
void CGScr_LoadAnimTrees();
void CG_SetDObjInfo(LocalClientNum_t localClientNum, int iEntNum, int iEntType, XModel *pXModel);
BOOL CG_CheckDObjInfoMatches(LocalClientNum_t localClientNum, int iEntNum, int iEntType, XModel *pXModel);
void CG_SafeDObjFree(LocalClientNum_t localClientNum, int entIndex);
void CG_FreeEntityDObjInfo(LocalClientNum_t localClientNum);
void CG_FreeClientDObjInfo(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_compassfriendlies_mp.cpp
void TRACK_cg_compassfriendlies();
void CG_ClearCompassPingData();
float GetRadarLineMargin(cg_t *cgameGlob);
bool DoesMovementCrossRadar(cg_t *cgameGlob, float radarProgress, const vec2_t *p1, const vec2_t *p2);
bool DoLinesSurroundPoint(cg_t *cgameGlob, vec3_t *radarLine1, vec3_t *radarLine2, vec2_t *pos);
void RadarPingEnemyPlayer(LocalClientNum_t localClientNum, CompassActor *actor, int time, int PerkToIgnore);
void SatellitePingEnemyPlayer(LocalClientNum_t localClientNum, CompassActor *actor, int time, int PerkToIgnore);
bool CanLocalPlayerHearActorFootsteps(;
void ActorUpdatePos(;
CompassVehicle *GetVehicle(LocalClientNum_t localClientNum, int entityNum);
CompassHelicopter *GetHelicopter(LocalClientNum_t localClientNum, int entityNum);
CompassGuidedMissile *GetGuidedMissile(LocalClientNum_t localClientNum, int entityNum);
CompassDogs *GetDogs(LocalClientNum_t localClientNum, int entityNum, int time);
CompassZombie *GetZombie(LocalClientNum_t localClientNum, int entityNum, int time);
CompassTurrets *GetCompassTurrets(LocalClientNum_t localClientNum, int entityNum, int time);
void CG_CompassUpdateVehicleDef(LocalClientNum_t localClientNum, int entityIndex);
void CG_CompassUpdateHelicopterInfo(LocalClientNum_t localClientNum, int entityIndex);
void CG_CompassUpdateGuidedMissileInfo(LocalClientNum_t localClientNum, const centity_t *missile);
void CG_CompassUpdateVehicleOccupantInfo(LocalClientNum_t localClientNum, int entityIndex);
void CG_CompassUpdateDogInfo(LocalClientNum_t localClientNum, int entityIndex);
void CG_CompassUpdateZombieInfo(LocalClientNum_t localClientNum, int entityIndex);
void CG_CompassUpdateTurretInfo(LocalClientNum_t localClientNum, int entityIndex);
void CG_CompassRadarPingEnemyVehicles(;
void CG_CompassRadarPingEnemyTurrets(;
void CG_CompassRadarPingEnemyPlayers(;
void CG_CompassIncreaseRadarTime(LocalClientNum_t localClientNum);
void CG_SensorGrenadePingPlayer(;
void CG_AddTurretWeaponPingInfo(;
void CG_CompassAddWeaponPingInfoInternal(;
void CG_CompassAddWeaponPingInfo(;
void CG_CompassAddVehicleWeaponPingInfo(;
CompassFakeFire *CG_FindFakeFireActor(;
void CG_CompassAddFakeFirePingInfo(;
void CG_AddEnemyScrambler(LocalClientNum_t localClientNum, centity_t *scramblerEnt);
void CG_ClearNearestEnemyScrambler(LocalClientNum_t localClientNum);
void CG_AddFriendlyScrambler(LocalClientNum_t localClientNum, float x, float y, int handle);
void CG_RemoveFriendlyScrambler(LocalClientNum_t localClientNum, int handle);
void CG_RemoveAllFriendlyScramblers(LocalClientNum_t localClientNum);
void CG_CompassUpdateActors(LocalClientNum_t localClientNum);
void CG_AddArtilleryPing(LocalClientNum_t localClientNum, vec3_t *position);
void CG_UpdateCompassObituary(LocalClientNum_t localClientNum, int client);

//t6/code/src_noserver/cgame_mp/cg_consolecmds_mp.cpp
void CG_Viewpos_f();
void CG_CloseScoreboard(LocalClientNum_t localClientNum);
void CG_ScoresUp(LocalClientNum_t localClientNum);
void CG_ScoresDown(LocalClientNum_t localClientNum);
void CG_ToggleScores(LocalClientNum_t localClientNum);
void CG_ShellShock_f();
void CG_ShellShock_Load_f();
void CG_ShellShock_Save_f();
void CG_QuickMessage_f();
void CG_VoiceChat_f();
void CG_TeamVoiceChat_f();
void CG_PlayRumble_f();
void CG_RestartSmokeGrenades_f();
;
;
;
void CG_PrintEntities_f();
void CG_ToggleScores_f();
void CG_InitConsoleCommandsProject();
void CG_ShutdownConsoleCommandsProject();

//t6/code/src_noserver/cgame_mp/cg_draw_mp.cpp
void TRACK_cg_draw();
void CG_DrawSay(LocalClientNum_t localClientNum);
void CG_DrawVote(LocalClientNum_t localClientNum);
void CG_DrawChatMessages(LocalClientNum_t localClientNum);
void CG_ClearCenterPrint(LocalClientNum_t localClientNum);
void CG_DrawCenterString(;
BOOL CG_CheckPlayerMovement(const usercmd_s oldCmd, const usercmd_s newCmd);
void CG_CheckHudHealthDisplay(LocalClientNum_t localClientNum);
void CG_CheckHudAmmoDisplay(LocalClientNum_t localClientNum);
void CG_CheckHudCompassDisplay(LocalClientNum_t localClientNum);
void CG_CheckHudStanceDisplay(LocalClientNum_t localClientNum);
void CG_CheckHudSprintDisplay(LocalClientNum_t localClientNum);
void CG_CheckHudOffHandDisplay(LocalClientNum_t localClientNum);
void CG_CheckHudObjectiveDisplay(LocalClientNum_t localClientNum);
void CG_CheckVehicleControlsDisplay(LocalClientNum_t localClientNum);
void CG_SetLutVolumeActiveBank(LocalClientNum_t localClientNum, unsigned __int16 bankMask);
void CG_SetLutScriptIndex(LocalClientNum_t localClientNum, __int16 scriptIndex);
void CG_SetWorldFogActiveBank(LocalClientNum_t localClientNum, unsigned __int16 bankMask);
int CG_GetWorldFogVolumeScriptID(LocalClientNum_t localClientNum);
void CG_Electrified(LocalClientNum_t localClientNum, int durationMS);
void CG_ClearElectrified(LocalClientNum_t localClientNum);
void CG_Blur(;
double CG_GetBlurRadius(LocalClientNum_t localClientNum);
void CG_StartFadingBlur(LocalClientNum_t localClientNum, int time, float blur);
void CG_ClearBlur(LocalClientNum_t localClientNum);
void CG_Burn(LocalClientNum_t localClientNum, int durationMS);
void CG_ClearBurn(LocalClientNum_t localClientNum);
void CG_ScreenBlur(LocalClientNum_t localClientNum);
bool CG_UsingAirborneKillstreakOverlay(LocalClientNum_t localClientNum);
bool CG_DrawGenericOverlay(int SortIndex, LocalClientNum_t localClientNum);
void DrawIntermission(LocalClientNum_t localClientNum);
bool IsHardcoreMode(LocalClientNum_t localClientNum);
int CG_DrawFollow(LocalClientNum_t localClientNum);
void CG_UpdatePlayerNamesInternal(LocalClientNum_t localClientNum);
char CG_StartGumpTransition(LocalClientNum_t localClientNum);
void CG_DrawHideGumpTransition(LocalClientNum_t localClientNum);
void DrawViewmodelInfo(LocalClientNum_t localClientNum);
bool ShouldUpdatePlayerNames(const playerState_s *ps);
bool CG_ShouldDrawIndicators(const playerState_s *ps);
void CG_DrawExtraCam(LocalClientNum_t localClientNum);
void CG_FlashLight(LocalClientNum_t localClientNum);
void CG_AddSceneTracerBeams(LocalClientNum_t localClientNum);
void CG_AddWaterScreenDrops(LocalClientNum_t localClientNum);
void CG_WorldRippleWave(;
void CG_GenerateSceneCodeMeshes(LocalClientNum_t localClientNum);
void CG_GenerateSceneVerts(LocalClientNum_t localClientNum);
int CG_CheckPlayerStanceChange(;
// int CG_CheckPlayerTryReload(LocalClientNum_t localClientNum, bitarray<64> *button_bits);
// int CG_CheckPlayerFireNonTurret(LocalClientNum_t localClientNum, bitarray<64> *button_bits);
void CG_DrawActive(;
// int CG_CheckPlayerMiscInput(bitarray<64> *button_bits);
void CG_CheckForPlayerInput(LocalClientNum_t localClientNum);
void CG_CheckTimedMenus(LocalClientNum_t localClientNum);
void CG_Draw2DInternal(LocalClientNum_t localClientNum);
void __thiscall CG_Draw2D(LocalClientNum_t this);

//t6/code/src_noserver/cgame_mp/cg_draw_net_mp.cpp
void CG_AddLagometerFrameInfo(const cg_t *cgameGlob);
void CG_AddLagometerSnapshotInfo(snapshot_s *snap);
void CL_TrackServerBandwidth(int kbps);
void CL_TrackServerEntities(int entities, int numChangedEntities, int archivedEntities);
void CL_TrackKillcamTime(int oldestKillcamTime);
void CG_DrawEntityCount(LocalClientNum_t localClientNum);
void CG_DrawServerBandwidth(LocalClientNum_t localClientNum);
void CG_DrawServerKillcamData(LocalClientNum_t localClientNum);
void CG_DrawDisconnect(LocalClientNum_t localClientNum);
void CG_DrawLagometer(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_ents_mp.cpp
void CG_GetLightingOrigin(const DObj *obj, const centity_t *cent, vec3_t *lightingOrigin);
XAnim_s *CG_GetTurretAnims(centity_t *cent);
void CG_Player_PreControllers(DObj *obj, centity_t *cent);
void CG_Turret_OverheatUpdate(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_Turret_PreControllers(DObj *obj, centity_t *cent);
int CG_IsCarriedTurretEnt(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Turret_UpdateMinigun(LocalClientNum_t localClientNum, centity_t *cent);
void SetBallisticAngles(LocalClientNum_t localClientNum, centity_t *cent);
bool IsWeaponRetrieveable(;
;
double CG_ScriptMover_GetBurnFraction(LocalClientNum_t localClientNum, centity_t *cent);
bool AnyLocalPlayersIsWeaponLinkedToEnt(centity_t *cent);
void CG_InitZBarriers();
void CG_CreateZBarrierPieceDObj(;
void CG_InitZBarrier(LocalClientNum_t localClientNum, centity_t *cent);
void CG_InitZBarrierPiece(;
void CG_UpdateZBarrierPieceAnim(;
void CG_GetZBarrierEffectPosition(const centity_t *pCent, const vec3_t *offset, vec3_t *axis, vec3_t *outPos);
void zbarrier_repair_logic(;
void zbarrier_piece_box_fly_away_logic(;
void zbarrier_piece_teardown_logic(;
void CG_MissileProcessSnapshot(LocalClientNum_t localClientNum, centity_t *missileCent);
void CG_ZBarrierProcessSnapshot(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateMoverAnims(LocalClientNum_t localClientNum, centity_t *cent);
void CG_SetFrameInterpolation(LocalClientNum_t localClientNum);
void CG_PlayClientRumbleNoteTracks(;
void CG_PlayClientSoundNoteTracks(;
unsigned __int16 GetBoneFromNote(unsigned __int16 note, const char *noteString);
void CG_ProcessFootstepNote(LocalClientNum_t localClientNum, centity_t *cent, const XAnimClientNotify *note);
void CG_ProcessClientNote(;
void CG_ProcessClientNoteTracks(LocalClientNum_t localClientNum, int entityNum);
void CG_ReduceOriginError(;
void CG_ReduceAnglesError(;
void CG_LerpOriginAnglesError(;
void CG_UpdateClientDobjPartBits(centity_t *cent, int entnum, LocalClientNum_t localClientNum);
void CG_ClampPrimaryLightDir(GfxLight *light, const ComPrimaryLight *refLight);
void CG_PrimaryLight(LocalClientNum_t localClientNum, centity_t *cent);
int CG_ShouldDelayEntityPacketPostPS(LocalClientNum_t localClientNum, centity_t *cent);
void DelayListAdd(DelayListInfo *listInfo, centity_t *cent);
void DelayListRemove(DelayListInfo *listInfo, centity_t *cent, centity_t *centPrev);
bool EntPacketUpdateNeedsDelayed(LocalClientNum_t localClientNum, centity_t *cent, bool contextKey);
void CG_DObjUpdateInfo(const cg_t *cgameGlob, DObj *obj, int notifyFlags);
centity_t *CG_GetPose(LocalClientNum_t localClientNum, int handle);
unsigned int CG_StartFx(LocalClientNum_t localClientNum, centity_t *cent, int startAtTime);
void CG_Fx(LocalClientNum_t localClientNum, centity_t *cent);
void CG_InterpolateEntityPosition(cg_t *cgameGlob, centity_t *cent, LocalClientNum_t localClientNum);
void CG_LerpTrajectory(;
void CG_InterpolateVehicleDriver(const cg_t *cgameGlob, centity_t *cent, int curTime);
char AnyLocalClientDriving(centity_t *cent);
bool ShouldInterpolateFromNitrousVehicleLocally(const cg_t *cgameGlob, centity_t *cent);
void CG_InterpolateVehicle(const cg_t *cgameGlob, centity_t *cent, int curTime);
void CG_CreateRagdollObject(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateRagdollPose(centity_t *cent);
void CG_CalcEntityRagdollPositions(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateMoverRecord(LocalClientNum_t localClientNum, int moverNum);
void CG_InterpolateEntityAngles(cg_t *cgameGlob, centity_t *cent, LocalClientNum_t localClientNum);
void CG_CreateNitrousVehicle(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_UpdatePhysicsPose(centity_t *cent);
void CG_UpdateTags(centity_t *ent, const DObj *obj);
unsigned int CG_AddClientScriptAttachedModel(;
unsigned int CG_AddVehicleAttachedModel(;
unsigned int CG_AddScriptMoverAttachedModel(;
unsigned int CG_AddWeaponAttachedModel(;
DObj *CG_PreProcess_GetDObj(;
void CG_DObjCalcBone(const cpose_t *pose, DObj *obj, int boneIndex);
void CG_ClearUnion(LocalClientNum_t localClientNum, centity_t *cent);
void CG_SetUnionType(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdatePoseUnion(LocalClientNum_t localClientNum, centity_t *cent);
void CG_GetPoseOrigin(const cpose_t *pose, vec3_t *origin);
void CG_GetPoseAbsMinMax(const cpose_t *pose, vec3_t *absmin, vec3_t *absmax);
void CG_GetPoseAxis(const cpose_t *pose, vec3_t *axis);
void CG_GetPoseQuat(const cpose_t *pose, vec4_t *quat);
vec3_t *CG_GetEntityOrigin(LocalClientNum_t localClientNum, unsigned int entnum);
void CG_PredictiveSkinCEntity(GfxSceneEntity *sceneEnt);
void CG_PredictiveSkelModel(GfxSceneModel *sceneModel);
void CG_SetOrigin(centity_t *ent, const vec3_t *origin);
void CG_SetAngle(centity_t *ent, const vec3_t *angle);
bool CG_IsEntityFriendlyNotEnemy(LocalClientNum_t localClientNum, const centity_t *cent);
int CG_EntityInfrared(LocalClientNum_t localClientNum, centity_t *cent);
__int16 *CG_EntitySonar(LocalClientNum_t localClientNum, centity_t *cent, bool corpse);
int CG_WhatModelShouldLocalPlayerSee(;
int CG_GetDriverClientNumFromVehicle(LocalClientNum_t localClientNum, const centity_t *vehicle);
void CG_ClientFlagResetAll(centity_t *cent);
void CG_ClientFlagSet(centity_t *cent, int flagNum);
void CG_ClientFlagClear(centity_t *cent, int flagNum);
BOOL CG_ClientFlagIsActive(const centity_t *cent, int flagNum);
BOOL CG_ClientFlagIsSet(const centity_t *cent, int flagNum);
void CG_General(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Item(LocalClientNum_t localClientNum, centity_t *cent);
;
void CG_Missile(LocalClientNum_t localClientNum, centity_t *cent);
DObj *CG_ScriptMover_GetDObj(LocalClientNum_t localClientNum, centity_t *cent);
DObj *CG_HandleZBarrierModelChanges(;
void SwitchZombieBoxWeapon(;
void ClearZombieBoxWeapon(LocalClientNum_t localClientNum, centity_t *cent);
void zbarrier_piece_box_rise_logic(;
void CG_UpdateZBarrierPieceState(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_ZBarrier(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ScriptMover(LocalClientNum_t localClientNum, centity_t *cent);
void CG_LoopFx(LocalClientNum_t localClientNum, centity_t *cent);
DObjAnimMat *CG_DObjGetLocalTagMatrix(const cpose_t *pose, DObj *obj, unsigned int tagName);
int CG_DObjGetWorldBoneMatrix(;
// int CG_DObjGetWorldTagMatrix@<eax>(;
// DObjAnimMat *CG_DObjGetWorldTagPos@<eax>(;
void CG_Vehicle(LocalClientNum_t localClientNum, centity_t *cent);
void CG_CreatePhysicsObject(LocalClientNum_t localClientNum, centity_t *cent);
void CG_CalcEntityPhysicsPositions(LocalClientNum_t localClientNum, centity_t *cent);
// void CG_CalcEntityLerpPositions(cg_t *a1@<edx>, LocalClientNum_t localClientNum, centity_t *cent);
void CG_ClientFlagCallback(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ProcessFxEntity(LocalClientNum_t localClientNum, centity_t *cent);
void CG_AddPacketFxEntity(LocalClientNum_t localClientNum, int entnum);
void CG_ProcessFakeEntity(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Turret(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ProcessEntity(LocalClientNum_t localClientNum, centity_t *cent);
void CG_AddPacketEntity(LocalClientNum_t localClientNum, int entnum);
void UpdatePacketEnt(;
void UpdateDelayedPacketEnts(;
int CG_AddPacketEntities(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_gamepad.cpp
bool CG_ShouldUpdateViewAngles(LocalClientNum_t localClientNum);
// char destructible_ent_aa::process_collision();

//t6/code/src_noserver/cgame_mp/cg_killcam.cpp
void CG_KillcamRegisterDvars();
void CG_UpdateKillCamEntityViewOffset(LocalClientNum_t localClientNum);
void CG_GetPlayerKillCamEntityLookAt(LocalClientNum_t localClientNum, vec3_t *lookAtPos);
void CG_GetKillCamEntityOrgAngles(LocalClientNum_t localClientNum, vec3_t *origin, vec3_t *angles);
float LookAtAxisAndDistance(const vec3_t *origin, const vec3_t *lookAt, vec3_t *axis);
float LookAtBothPoints(const vec3_t *point1, const vec3_t *point2, const vec3_t *campos, vec3_t *lookaxis);
void CG_UpdateTurretKillCam(float distance, GfxDepthOfField *dof);
void CG_GetTurretEntityOrgAngles(LocalClientNum_t localClientNum, vec3_t *origin, vec3_t *angles);
float CG_GetTurretKillcamHeightIncrease(const LocalClientNum_t localClientNum);
float CG_GetTurretKillcamFOV(const LocalClientNum_t localClientNum);
float CG_GetTurretKillcamBackOffset(const LocalClientNum_t localClientNum);
void CG_UpdateVehicleKillCamDof(const VehicleDef *info, float distance, GfxDepthOfField *dof);
void CG_UpdateHelicopterKillCamDof(float distance, GfxDepthOfField *dof);
void CG_UpdateHelicopterKillCam(KillCamEntityType killCamEntityType, LocalClientNum_t localClientNum);
void CG_UpdateScriptedKillCamDof(float distance, GfxDepthOfField *dof);
void CG_UpdateScriptedKillCam(;
void CG_UpdateDestructibleKillCamDof(float distance, GfxDepthOfField *dof);
void CG_UpdateDestructibleKillCam(;
;
void CG_UpdateDogKillCam(LocalClientNum_t localClientNum);
bool CG_KillCamEntityEnabled(LocalClientNum_t localClientNum);
void CG_CacheKillCamEntityPose(const LocalClientNum_t localClientNum);
void CG_CacheKillCamLookAtEntityOrigin(const LocalClientNum_t localClientNum);
void CG_UpdateKillCamEntityCache(LocalClientNum_t localClientNum);
;
const VehicleDef *CG_GetKillCamVehicleDef(LocalClientNum_t localClientNum);
void CG_UpdateVehicleKillCam(LocalClientNum_t localClientNum);
;
;
// void CG_UpdateTurretKillCam(vec3_t *a1@<edx>, LocalClientNum_t a2@<ecx>, LocalClientNum_t localClientNum);
void CG_UpdateKillCamEntity(;

//t6/code/src_noserver/cgame_mp/cg_local_mp.h
cg_t *CG_GetLocalClientGlobals(LocalClientNum_t localClientNum);
cgs_t *CG_GetLocalClientStaticGlobals(LocalClientNum_t localClientNum);
BOOL CG_IsFullyInitialized(LocalClientNum_t localClientNum);
int CG_GetLocalClientTime(LocalClientNum_t localClientNum);
BOOL CG_IsPlayerEntityNumber(const snapshot_s *nextSnap, int entNum);

//t6/code/src_noserver/cgame_mp/cg_main_mp.cpp
ClientNum_t CG_GetClientNumForLocalClient(LocalClientNum_t localClientNum);
BOOL CG_IsRagdollTrajectory(const trajectory_t *trajectory);
void CG_SetupSplitscreenDvars(bool splitscreen);
void CG_RegisterDvars_Project();
void TRACK_cg_main_project();
void CG_GetDObjOrientation(LocalClientNum_t localClientNum, int dobjHandle, vec3_t *axis, vec3_t *origin);
playerState_s *CG_GetPredictedPlayerState(LocalClientNum_t localClientNum);
void CG_GameMessage(LocalClientNum_t localClientNum, const char *msg);
void CG_BoldGameMessage(LocalClientNum_t localClientNum, const char *msg, int duration);
void CG_RegisterSurfaceTypeSounds(const char *pszType, unsigned int *sound);
void CG_RegisterImpactTypeSounds(const char *pszType, unsigned int *sound);
void CG_RegisterSounds(const char *a1, unsigned int *a2);
void CG_RegisterGrenadeFx(LocalClientNum_t localClientNum, const FxEffectDef *fxHandle);
void CG_RegisterGraphics(LocalClientNum_t localClientNum);
void CG_PlayBattleChatter(;
void CG_CheckBattleChatter();
void CG_RestartSmokeGrenades(LocalClientNum_t localClientNum);
void CG_LoadHudMenu(LocalClientNum_t localClientNum);
void CG_InitVote(LocalClientNum_t localClientNum);
XModel *CG_GetXModel(const char *modelName);
void CG_CreateDObj(;
DObj *CG_GetDObj(int handle, LocalClientNum_t localClientNum);
void CG_FreeAnimTreeInstances(LocalClientNum_t localClientNum);
void CScr_LoadGameType();
void CScr_StartupGameType();
int CScr_LoadGameTypeScript();
unsigned int CScr_LoadDogAnimScripts();
unsigned int CScr_LoadZombieAnimScripts();
unsigned int CScr_LoadZombieDogAnimScripts();
int CScr_LoadScriptsForEntities();
void CScr_LoadServerSideScripts(const char *mapname, const char *gametype, int *scr_checksum);
void CGScr_LoadClientScripts(const char *mapname);
void CGScr_LoadClientScriptsZombies(const char *mapname);
void CG_InitEntities(LocalClientNum_t localClientNum);
void CG_InitViewDimensions(LocalClientNum_t localClientNum);
ClientNum_t CG_GetClientNum(LocalClientNum_t localClientNum);
bool CG_IsShoutcaster(LocalClientNum_t localClientNum);
bool CG_IsShoutcasterListening(LocalClientNum_t localClientNum, ClientNum_t talker);
void CG_ResetShoutcasterListenIn(LocalClientNum_t localClientNum);
void CG_SetShoutcasterListenIn(LocalClientNum_t localClientNum);
void CG_AddShoutcasterListenIn(LocalClientNum_t localClientNum, ClientNum_t client);
void CG_RemoveShoutcasterListenIn(LocalClientNum_t localClientNum, ClientNum_t client);
bool CG_IsMature();
char CG_GetEntityOriginAngles(LocalClientNum_t localClientNum, int entityNum, vec3_t *origin, vec3_t *angles);
int CG_GetVehicleTypeString(ClientNum_t clientNum, int entityNum, VehicleDef **vehDef);
int CachedTag_UpdateTagInternal(;
int CachedTag_NoCache_GetTagPos(const centity_t *ent, unsigned int tagName, vec3_t *pos);
// int CachedTag_GetCachedTagPos@<eax>(;
int CachedTag_GetTagPos(;
BOOL CG_AllClientsAreLocal();
void CG_InitClientEntityCaches(LocalClientNum_t localClientNum);
void CG_FreeClientEntityCaches(LocalClientNum_t localClientNum);
void CG_ProcessFullScreenBit(LocalClientNum_t localClientNum, int oldFlags, int newFlags);
void CG_SetupGameInformation(LocalClientNum_t localClientNum);
int CG_TestServerScriptChecksum(LocalClientNum_t localClientNum, int *scr_checksum);
void CG_Scr_AddFloat_BGWrapper(float val);
void CG_Scr_AddString_BGWrapper(const char *pStr);
void CG_Scr_AddLocalClientNumber_BGWrapper(LocalClientNum_t num);
void CG_Scr_ExecEntThreadNum_BGWrapper(LocalClientNum_t lcn, int entNum, int func, int numParam);
unsigned int CG_GetServerHighestClientFieldVersion();
BOOL CG_ClientFieldServerVersionAllowsRegistration(unsigned int version);
BOOL CG_ClientFieldVersionAllowsRegistration(clientField_s *pField, unsigned int version);
void CG_CompareClientFieldHashToGameState(unsigned int hash);
void CG_ProcessClientFieldsForEntity(;
void CG_ShutdownOnceForAllClients();
void CG_SaveMigrationPers(LocalClientNum_t localClientNum);
void CG_LoadMigrationPers(LocalClientNum_t localClientNum);
void CG_ProcessTriggerDebug(centity_t *ent, trigger_info_t *trigger_info);
int CG_NotifyTriggers();
void CG_Trigger(centity_t *self, centity_t *other);
void CG_Touch_Multi(centity_t *self, centity_t *other);
void *Hunk_AllocXAnimClient(int size);
void *Hunk_AllocAnimStateDefClient(int size);
bool CG_IsClientInOurParty(LocalClientNum_t localClientNum, ClientNum_t clientNum);
void CG_LoadAnimTreeInstances(LocalClientNum_t localClientNum);
void CG_LoadAnimTrees(;
void CG_Init(;
void CG_Shutdown(LocalClientNum_t localClientNum);
XModel *CG_GetXModel(const char *name, LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_newdraw_mp.cpp
void CG_AntiBurnInHUD_RegisterDvars();
void CG_NewDraw_RegisterDvars();
BOOL CG_ShouldDrawHud(LocalClientNum_t localClientNum);
double CG_FadeHudMenu(LocalClientNum_t localClientNum, float fadeVal, int displayStartTime, int duration);
bool CG_CheckPlayerForLowAmmoSpecific(const cg_t *cgameGlob, Weapon weapon);
bool CG_CheckPlayerForLowAmmo(const cg_t *cgameGlob);
bool CG_CheckForLowClip(const playerState_s *ps, Weapon weapon);
bool CG_CheckPlayerForLowClipSpecific(const cg_t *cgameGlob, Weapon weapon);
bool CG_CheckPlayerForLowClip(const cg_t *cgameGlob);
void CG_DrawPlayerAmmoBackdrop(;
void CG_DrawPlayerAmmoValue(;
void CG_DrawPlayerHeatValue(;
void CG_DrawPlayerFuelAmmoValue(LocalClientNum_t localClientNum, const rectDef_s *rect, vec4_t *color);
void CG_DrawPlayerReloadValue(;
void CG_DrawPlayerReloadedValue(;
void CG_DrawPlayerWeaponName(;
void CG_DrawPlayerWeaponNameBack(;
void CG_CalcPlayerSprintColor(const cg_t *cgameGlob, const playerState_s *ps, vec4_t *color);
void CalcSplitScreenStanceOffset(float *x, float *y);
void CG_DrawStanceHintPrints(;
void CG_DrawPlayerStance(;
void CG_DrawPlayerSprintBack(;
void CG_DrawPlayerSprintMeter(;
double CG_CalcPlayerHealth(const playerState_s *ps);
void CG_DrawPlayerBarHealth(;
void CG_DrawPlayerBarHealthBack(;
float CG_FadeLowHealthOverlay(const cg_t *cgameGlob);
void CG_PulseLowHealthOverlay(cg_t *cgameGlob, float healthRatio);
void CG_ResetLowHealthOverlay(cg_t *cgameGlob);
// double CG_DrawPlayerLowHealthOverlay@<st0>(;
void CG_DrawPlayerDirectionalHitIndicator(;
void CG_ResetDirectionalDamageIndicators(LocalClientNum_t localClientNum, int time);
int CG_ServerMaterialName(LocalClientNum_t localClientNum, int index, char *materialName, unsigned int maxLen);
Material *CG_ObjectiveIcon(;
void CG_UpdateCursorHints(cg_t *cgameGlob);
const char *CG_GetWeaponUseString(;
const char *CG_GetUseString(LocalClientNum_t localClientNum);
void CG_DrawCursorhint(;
void CG_DrawHoldBreathHint(;
void CG_DrawHoldBreathZoomHint(;
void CG_DrawAirburstMarkHint(;
void CG_DrawRCBombHints(;
void CG_DrawGuidedMissileBoostHint(;
void CG_DrawGuidedMissileDetonateHint(;
void CG_DrawRemoteMissileSteerHint(;
void CG_DrawRemoteMissileBoostHint(;
float CG_GetClosestTargetToGuidedMissile(LocalClientNum_t localClientNum);
float CG_GetDistanceGuidedMissileAndOwner(LocalClientNum_t localClientNum);
void CG_DrawGuidedMissileInfo(;
void CG_DrawTurretPlaceHint(;
void CG_DrawMantleHint(;
char *CG_ScriptMainMenu(LocalClientNum_t localClientNum);
void CG_DrawInvalidCmdHint(;
void CG_DrawTalkerNum(;
void get_tank_hud_health_tint_color(float health_fraction, vec4_t *rgba, float black_when_dead);
void draw_tank_turret_component(;
void CG_DrawWarMomentumProgress(;
void CG_DrawWarMomentumMultiplier(;
void CG_DrawWarMomentumMultiplierDetail(;
void CG_DrawWarMomentumMultiplierBlitzkrieg(;
void CG_DrawWarText(;
void CG_DrawWristWatch(;
void DrawAirburstDistance(;
void CG_DrawAirburstCurrentDistance(;
void CG_DrawAirburstMarkDistance(;
void CG_DrawAirburstMarkTimer(;
void CG_DrawDemoControls(;
bool ShouldDrawPlayerTargetHighlightsFriendlies(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
bool ShouldDrawPlayerTargetHighlights(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
bool ShouldDrawPlayerLineOfSightTargetHighlights(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_DrawTarget(;
void CG_DrawPlayerTargetHighlights(;
void CG_DrawPlayerTargetHighlightsLineOfSight(;
void CG_DrawPlayerTargetHighlightsFriendly(;
void CG_DrawTargetHighlightsForEntity(;
void CG_DrawVehicleTargetHighlights(;
void CG_DrawTurretTargetHighlights(;
void CG_DrawDogTargetHighlights(;
void CG_DrawTargetHighlights(;
void CG_DrawTargetHighlightsFriendly(;
void CG_DrawGuidedMissileFuel(;
void CG_DrawChargeShotBulletCounter(LocalClientNum_t localClientNum, rectDef_s *rect, vec4_t *color);
void CG_OwnerDraw(;
void CG_OwnerDrawText(;

//t6/code/src_noserver/cgame_mp/cg_players_mp.cpp
void CG_AddPlayerSpriteDrawSurf(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_AddPlayerSpriteDrawSurfs(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_AddAllPlayerSpriteDrawSurfs(LocalClientNum_t localClientNum);
char CG_Player_ApplyVehicleAnimOffsets(;
void CG_PlayerUpdateUserRigidBody(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdatePerkSounds(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_GetPlayerVelocity(LocalClientNum_t localClientNum, centity_t *cent, vec3_t *velocity_out);
void CG_DropWeaponClip(;
void CG_ClearDropWeaponClip(LocalClientNum_t localClientNum, int clientNum);
void CG_UpdatePlayerDObj(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ResetPlayerEntity(;
void CG_PlayerDobjChanging(LocalClientNum_t localClientNum, clientInfo_t *ci, const Weapon weapon);
const char *CG_GetFFATeamName(ffa_team_t team);
const char *CG_GetOpposingTeamName(team_t team);
const char *CG_GetPlayerTeamName(const LocalClientNum_t localClientNum);
const char *CG_GetPlayerOpposingTeamName(const LocalClientNum_t localClientNum);
clientInfo_t *CG_GetClientInfo(const LocalClientNum_t localClientNum, ClientNum_t clientNum);
bool CG_IsPlayerDead(const LocalClientNum_t localClientNum);
int CG_GetPlayerClipAmmoCount(const LocalClientNum_t localClientNum);
char CG_ShouldSendPeerVoiceData(;
;
void CG_UpdateWeaponVisibilityInternal(LocalClientNum_t localClientNum, centity_t *cent);
// void CG_UpdateWeaponVisibilityImmediate(centity_t *a1@<edx>, LocalClientNum_t localClientNum);
bool CG_PlayerInViewFrustum(LocalClientNum_t localClientNum, const centity_t *cent);
bool CG_ClientHasPerk(LocalClientNum_t localClientNum, ClientNum_t clientNum, unsigned int perkIndex);
void CG_CopyPerks(LocalClientNum_t localClientNum, ClientNum_t clientNum, unsigned int *out);
;
int CG_PlayerInfrared(;
unsigned int CG_PlayerSonar(LocalClientNum_t localClientNum, centity_t *cent, clientInfo_t *ci, bool corpse);
void CG_Player(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Corpse(LocalClientNum_t localClientNum, centity_t *cent);

//t6/code/src_noserver/cgame_mp/cg_predict_mp.cpp
void TRACK_cg_predict();
int CG_ItemListLocalClientNum();
void CG_ClearItemList();
void CG_BuildItemList(LocalClientNum_t localClientNum, const snapshot_s *nextSnap);
void CG_TouchItem(const LocalClientNum_t localClientNum, centity_t *cent);
// void CG_TouchItemPrediction(centity_t *a1@<edx>, LocalClientNum_t a2@<ecx>, LocalClientNum_t localClientNum);
bool CG_ShouldInterpolatePlayerStateViewClamp(LocalClientNum_t localClientNum, const snapshot_s *prevSnap);
void CG_InterpolatePlayerStateViewAngles(;
void CG_ClearSavedPlayerState(LocalClientNum_t localClientNum);
void CG_SavePlayerState(LocalClientNum_t localClientNum);
void CG_CopyFlagsFromSnapshotEntity(LocalClientNum_t localClientNum);
;
void CG_PredictPlayerState_Internal(LocalClientNum_t localClientNum);
void CG_PredictPlayerState(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_scoreboard_mp.cpp
double CG_ScoreboardScaleMultiplier();
const GfxViewParms *CG_GetNameForScoreboardColumn(LocalClientNum_t localClientNum, int columnNumber);
int CG_GetColumnValue(;
void CG_SortPlayersAlphabetically(LocalClientNum_t localClientNum);
int CG_SortPlayersByClientNumComparator(const void *a, const void *b);
void CG_SortPlayersByClientNum(LocalClientNum_t localClientNum);
void CG_ResetScoreboard(LocalClientNum_t localClientNum);
void CG_UpdateMatchScoreboard(LocalClientNum_t localClientNum);
int CG_GetMatchScoreboardClientCount(LocalClientNum_t localClientNum, team_t team);
int CG_GetMatchScoreboardIndexForTeamByName(LocalClientNum_t localClientNum, int index, team_t team);
int CG_GetMatchScoreboardIndexForTeamByClientNum(LocalClientNum_t localClientNum, int index, team_t team);
int CG_GetMatchScoreboardIndexForTeamByScore(LocalClientNum_t localClientNum, int index, team_t team);
// int CG_GetMatchScoreboardIndexForTeam@<eax>(;
// int CG_GetMatchscoreboardTeam@<eax>(;
const GfxViewParms *CG_GetMatchInGamePlayerXuid(LocalClientNum_t localClientNum, int index, team_t team);
int CG_GetIndexIntoMatchScoreboard(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex);
int CG_GetWagerPlaceForMatchScoreboard(LocalClientNum_t localClientNum, int matchScoreboardIndex);
int CG_GetWagerWinningsForMatchScoreboard(;
const score_s *GetClientScore(LocalClientNum_t localClientNum, ClientNum_t clientNum);
const score_s *UI_GetOurClientScore(LocalClientNum_t localClientNum);
const score_s *UI_GetScoreAtRank(LocalClientNum_t localClientNum, int rank);
const char *CG_GetGametypeDescription(LocalClientNum_t localClientNum);
char CG_DrawScoreboard_GetTeamColorIndex(int team, LocalClientNum_t localClientNum);
int CG_ScoreboardTotalLines(LocalClientNum_t localClientNum);
void CenterViewOnClient(const LocalClientNum_t localClientNum);
BOOL CG_IsScoreboardDisplayed(LocalClientNum_t localClientNum);
BOOL CG_IsIntermission(LocalClientNum_t localClientNum);
void CG_SetFocusScoreboardCmd();
void CG_InitScoreboard();
void CG_RegisterScoreboardDvars();
void CG_RegisterScoreboardGraphics();
void CG_ScoreboardNextGamerIndex(LocalClientNum_t localClientNum);
void CG_ScoreboardPrevGamerIndex(LocalClientNum_t localClientNum);
bool Scoreboard_HandleInputNonXboxLive(LocalClientNum_t localClientNum, int key);
char Scoreboard_HandleInputXboxLive(LocalClientNum_t localClientNum, int key);
char Scoreboard_HandleInput(LocalClientNum_t localClientNum, int key);
int CG_GetPlaceWithTiesForScore(const LocalClientNum_t localClientNum, int score);
int CG_GetMatchScoreboardValueByXuid(;
int CG_GetKills(LocalClientNum_t localClientNum, const score_s *score);
int CG_GetDeaths(LocalClientNum_t localClientNum, const score_s *score);
const char *CG_GetColumnValueString(;
const char *CG_GetMatchScoreboardInfo(;
int CG_DrawScoreboard(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_scoreboard_zm.cpp
int rampScore(ClientNum_t clientNum, int score);
void CG_PlayerColor(int playerNum, const char *prefix, vec4_t *color);
void CG_RegisterScoreboardDvarsZM();
void DrawCompetitiveListString(;
float CG_DrawCompetitiveClientScore(;
void CG_DrawCompetitiveClients(LocalClientNum_t localClientNum, const vec4_t *color, rectDef_s *rect);
int CG_DrawCompetitiveScoreboard(LocalClientNum_t localClientNum, rectDef_s *rect);

//t6/code/src_noserver/cgame_mp/cg_scr_main_mp.cpp
centity_t *CScr_SpawnFXInternal(;
void CScr_DeleteFX();
char CScr_SetRimIntensity();
char CScr_SetGenericSceneValue();
void CScr_SpawnFX();
void CScr_PlayFXOnTag();
void CScr_PlayViewmodelFX();
void CScr_PlayFXOnDynEnt();
void CScr_StartWaterSheetFX();
void CScr_StopWaterSheetFX();
void CScr_IsDemoPlaying();
void CScr_GetGametypeSetting();
void CScr_IsSpectating();
void CScr_PlayerBeingSpectated();
void CScrCmd_IsBurning(scr_entref_t entref);
void CScrCmd_IsRemoteControlling(scr_entref_t entref);
void CScrCmd_OverrideLightingOrigin(scr_entref_t entref);
void CPlayerCmd_HasPerk(scr_entref_t entref);
void CScr_GetVehicleHealth(scr_entref_t entref);
void CScr_GetHeliDamageState(scr_entref_t entref);
void CScr_GetInKillcam(scr_entref_t entref);
void CScrCmd_SetRenderInThirdPersonSpectate(scr_entref_t entref);
void CScr_GetAnimState(scr_entref_t entref);
void CScr_GetAnimStateCategory(scr_entref_t entref);
void CScr_GetTotalAmmo();
void CScr_IsWeaponOverheating();
void CScr_IsADS();
void CScr_GetCurrentWeapon();
void CScr_GetCurrentWeaponIncludingMelee();
void CScr_HasWeapon();
BOOL CScr_SetLocalRadarEnabled();
void CScr_SetLocalRadarPosition();
int CScr_SetExtraCamEntity();
int CScr_SetExtraCamActive();
void CScr_GetExtraCamStatic();
int CScr_SetExtraCamStatic();
void CScr_SetExtraCamOrigin();
void CScr_SetExtraCamAngles();
void CScr_IsCameraSpikeToggled();
void CScr_GetGridFromPos();
void CScr_GetLocalPlayerTeam();
objective_t *CScr_InitClientObjectives();
void CScr_Objective_Add();
void CScr_Objective_SetIcon();
void CScr_Objective_SetStencil();
void CScr_Objective_SetIconSize();
void CScr_Objective_OnEntity();
void CScr_Objective_FlipIcon();
void CScr_Objective_Delete();
void CScr_Objective_State();
void CScr_SetClientVolumetricFog();
void CScr_GetServerVolumetricFogDensity();
void CScr_SetServerVolumetricFogDensity();
void CScr_SwitchToServerVolumetricFog();
void CScr_SwitchToClientVolumetricFog();
void CScr_IsInHelicopter();
void Scr_SetCustomDynEntFieldReadOnly(unsigned __int16 absDynEntId, const dynent_field_s *pField);
void Scr_GetDynEntStringField(unsigned __int16 absDynEntId, const dynent_field_s *pField);
void CScr_GetDynEntityField(int entnum, LocalClientNum_t clientNum, int offset);
int CScr_SetDynEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_AddFieldsForDynEntity();
void CScr_GetDynEnt();
void CScr_GetDynEntArray();
void CScr_SpawnDynEnt();
void CScr_LaunchDynEnt();
void CScr_CreateDynEntAndLaunch();
void CScr_SetDynEntEnabled();
void CScr_loadGump();
Material *CScr_useAlternateReviveIcon();
Material *CScr_setTeamReviveIcon();
void CScr_flushGump();
void CScr_setHideGumpAlpha();
void CScr_PrecacheAnimStateDef();
void CScr_ScriptMoversUseAnimTree();
void CScr_EnableFlameSystem();
cg_t *CScr_EnableDarkness();
void CScr_SetLutVolumeActiveBank();
void CScr_SetLutScriptIndex();
void CScr_SetWorldFogActiveBank();
void CScr_GetWorldFogScriptID();
void CScr_RegisterClientField();
void CScr_GetFieldSetForEntityType(cg_t *cgameGlob, centity_t *pEnt, int *pFieldSet, void **pData);
void CScr_CodeGetClientField();
void CScr_CodeGetPlayerStateClientField();
void CScr_CodeGetWorldClientField();
void CScr_SetupClientFieldCodeCallbacks();
void ClientFieldAnimSpeedCallback(;
void CScr_SetupClientFieldAnimSpeedCallbacks();
void CScr_GetClientFieldVersion();
void CScr_GetServerHighestClientFieldVersion();
void CScr_ResetZombieBoxWeapons();
const WeaponVariantDef *CScr_AddZombieBoxWeapon();
void CScr_SetMapLatLong();
void CScrCmd_SetBlurByLocalClientNum();
void CScrCmd_SetBurn();
void CScrCmd_SetElectrified();
void CScr_RopeGetPosition();
void CScr_GetRope();
cg_t *CScr_SetTeamFlagAsAway();
void CScr_GetStartOrigin();
void CScr_GetStartAngles();
void CScr_WeaponClass();
void CScr_HasDLCAvailable();
void CScr_PhysExplosionCylinder();
void CScr_ReregisterRLodScaleRigid();
void (*CScr_GetFunctionProjectSpecific(const char **pName, int *type, int *min_args, int *max_args))();
void CScrCmd_GetOwner(scr_entref_t entref);
void CScr_GetTagOrigin(scr_entref_t entref);
void CScr_GetTagAngles(scr_entref_t entref);
void CScrCmd_ShellShock(scr_entref_t entref);
void CScrCmd_Earthquake(scr_entref_t entref);
void CScr_SetEnemyGlobalScrambler(scr_entref_t entref);
void CScr_SetEnemyScramblerAmount(scr_entref_t entref);
void CScr_SetFriendlyScramblerAmount(scr_entref_t entref);
void CScr_GetFriendlyScramblerAmount(scr_entref_t entref);
void CScr_GetEnemyScramblerAmount(scr_entref_t entref);
void CScr_IsScrambled(scr_entref_t entref);
void CScr_SetNearestEnemyScrambler(scr_entref_t entref);
void CScr_ClearNearestEnemyScrambler(scr_entref_t entref);
void CScr_AddFriendlyScrambler(scr_entref_t entref);
void CScr_RemoveFriendlyScrambler(scr_entref_t entref);
void CScr_RemoveAllFriendlyScramblers(scr_entref_t entref);
void CScr_HasTacticalMaskOverlay();
void CScrCmd_SetBlur(scr_entref_t entref);
void CScr_GetStance(scr_entref_t entref);
void CScr_SetFlagAsAway(scr_entref_t entref);
void CScr_GetParentEntity(scr_entref_t entref);
void CScr_UseWeaponHideTags(scr_entref_t entref);
void CScr_SetAlphaFadeForName(scr_entref_t entref);
void CScr_UseAlternateAimParams(scr_entref_t entref);
void CScr_ClearAlternateAimParams(scr_entref_t entref);
void CScr_EquipFlashlight(scr_entref_t entref);
void CScr_RemoveFlashlight(scr_entref_t entref);
void CScr_SetPhysicsGravity(scr_entref_t entref);
void CScr_ClearPhysicsGravity(scr_entref_t entref);
void CScr_SetMultiExtraCamActive(scr_entref_t entref);
void CScr_SetSonarAttachmentEnabled(scr_entref_t entref);
void CScr_IsExtraCam(scr_entref_t entref);
void CScr_ProcessClientFieldsAsIfNew(scr_entref_t entref);
void CScr_ZBarrierGetPiece(scr_entref_t entref);
void CScr_ZBarrierGetNumPieces(scr_entref_t entref);
void (*CScr_GetMethodProjectSpecific(;
void CG_SendSwimNotify(LocalClientNum_t localClientNum, ClientNum_t clientNum, int start);
void CScr_GetEntityByIndex(centity_t *cent, const cent_field_s *pField);
void CScr_UseWeaponModel(scr_entref_t entref);

//t6/code/src_noserver/cgame_mp/cg_servercmds_mp.cpp
void CG_ParseServerInfo(LocalClientNum_t localClientNum);
void CG_ParseCodInfo(LocalClientNum_t localClientNum);
void CG_ParseCullDist();
void CG_ParseTimeScale(const LocalClientNum_t localClientNum);
void CG_BuildPartyList();
void CG_ParseGameEndTime(LocalClientNum_t localClientNum);
void CG_ParseFog(LocalClientNum_t localClientNum);
void CG_RegisterServerMaterial(int configStringIndex);
void CG_SetConfigValues(LocalClientNum_t localClientNum);
void CG_UpdateVoteString(LocalClientNum_t localClientNum, const char *rawVoteString);
void CG_ParseClientSystemStateChange(LocalClientNum_t localClientNum, int sysIndex, const char *pState);
void CG_ParseAirsupport(;
void CG_AddToTeamChat(LocalClientNum_t localClientNum, const char *str);
void CG_RemoveChatEscapeChar(char *text);
void CG_ClearEntityFxHandles(LocalClientNum_t localClientNum);
void CG_ClearGenericFilter(cg_t *gameglob);
void CG_MapReset(LocalClientNum_t localClientNum);
void CG_OpenScriptMenu(LocalClientNum_t localClientNum);
void CG_CheckOpenWaitingScriptMenu(LocalClientNum_t localClientNum);
void CG_CloseScriptMenu(LocalClientNum_t localClientNum, bool allowResponse);
void CG_MenuShowNotify(LocalClientNum_t localClientNum, int menuToShow);
void CG_SetTeamScore(LocalClientNum_t localClientNum, int team, int score);
bool LocalSound(LocalClientNum_t localClientNum);
void LocalSoundStop(LocalClientNum_t localClientNum);
void CG_SetScriptMainMenu(cg_t *cgameGlob, const char *text);
void CG_SetClientDvarFromServer(cg_t *cgameGlob, dvar_cmd_t dvarCmd, const char *value);
void CG_BurnServerCommand(LocalClientNum_t localClientNum);
void CG_ElectrifiedServerCommand(LocalClientNum_t localClientNum);
void CG_ParseExploderCommand(LocalClientNum_t localClientNum, int exploderId);
void CG_WaterDropsServerCommand(LocalClientNum_t localClientNum);
void CG_ScrCamera(LocalClientNum_t localClientNum, int cmd);
void CG_BlurServerCommand(LocalClientNum_t localClientNum);
void CG_StartFadingBlurServerCommand(LocalClientNum_t localClientNum);
void CG_ParsePlayerInfos(LocalClientNum_t localClientNum);
void CG_ConfigStringModified(LocalClientNum_t localClientNum);
void CG_MapRestart(LocalClientNum_t localClientNum, int savepersist);
void CG_DeployServerCommand(LocalClientNum_t localClientNum);
void CG_ExecuteNewServerCommands(LocalClientNum_t localClientNum, int latestSequence);

//t6/code/src_noserver/cgame_mp/cg_snapshot_mp.cpp
void CG_ShutdownEntity(LocalClientNum_t localClientNum, centity_t *cent, bool shutdown_script_for_local_client);
void CG_TeleportEntity(LocalClientNum_t localClientNum, centity_t *cent);
void ResetEntity_EventSequence(centity_t *cent);
void ResetEntity_Internal(;
void CG_ShutdownEntities(LocalClientNum_t localClientNum);
int CG_UpdateKillcamForEntity(LocalClientNum_t localClientNum, int newKillCamEntity);
void CG_UpdateClientFlags(LocalClientNum_t localClientNum, centity_t *cent, int oldEFlags2);
void CG_TransitionKillcam(LocalClientNum_t localClientNum);
void CG_UnpackMatchState(LocalClientNum_t localClientNum, MatchState *matchState);
void CG_CopyScoreFromClientState(LocalClientNum_t localClientNum, clientInfo_t *ci, clientState_s *cs);
void CG_UpdateScoreData(LocalClientNum_t localClientNum);
bool CG_LocalPlayerRespawned(LocalClientNum_t localClientNum, snapshot_s *snap);
void CG_SetNextSnap(LocalClientNum_t localClientNum, snapshot_s *snap);
snapshot_s *CG_ReadNextSnapshot(LocalClientNum_t localClientNum);
void CG_SetInitialSnapshot(LocalClientNum_t localClientNum, snapshot_s *snap);
void CG_TransitionSnapshot(LocalClientNum_t localClientNum);
void CG_ProcessSnapshots(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame_mp/cg_vehicles_mp.cpp
clientInfo_t *ClientInfoForEntity(LocalClientNum_t localClientNum, int entNum);
DObj *GetVehicleEntDObj(LocalClientNum_t localClientNum, centity_t *centVeh);
// bool CG_Vehicle_UsingVehicle@<al>(int a1@<edx>, LocalClientNum_t localClientNum, int entNum);
// bool CG_Vehicle_UsingRemoteControlVehicle@<al>(int a1@<edx>, LocalClientNum_t localClientNum, int entNum);
// int CG_Vehicle_PlayerSeat@<eax>(int a1@<edx>, LocalClientNum_t localClientNum);
void GetTagMatrix(;
void SeatTransformForClientInfo(;
void CG_Vehicle_SeatTransformForPlayer(;

//t6/code/src_noserver/cgame_mp/cg_view_mp.cpp
void TRACK_cg_view();
void CG_DrawWaterTrail(LocalClientNum_t localClientNum, const vec3_t *pos, float waterHeight);
int CG_GetNextRippleTime(centity_t *cent);
void CG_SetNextRippleTime(centity_t *cent, int time, float speed, bool in_water);
void CG_SetNextWaterCheck(centity_t *cent, int time, bool in_water);
void CG_DrawWaterTrail(LocalClientNum_t localClientNum, centity_t *cent);
void CG_DrawWaterTrail(LocalClientNum_t localClientNum);
void CG_PlayTestFx(LocalClientNum_t localClientNum);
void CG_FxSetTestPosition();
void CG_FxTest();
void CG_PrintFXNameUsage();
void CG_OffsetChaseCamView(LocalClientNum_t localClientNum, CameraMode camMode);
void CG_ClampOriginToPlayerCapsule(vec3_t *center, vec3_t *origin, int legsAnim, int time);
void CG_ThirdPersonCamAboveWater(cg_t *cgameGlob, float padding);
void CG_OffsetThirdPersonView(LocalClientNum_t localClientNum);
void CG_CalcVrect(LocalClientNum_t localClientNum);
void CG_CalcVrect_ExtraCam(LocalClientNum_t localClientNum, bool usingMultiExtraCam);
bool CG_IsEMPJammed(LocalClientNum_t localClientNum);
void CG_SmoothCameraZ(cg_t *cgameGlob);
void CG_KickAngles(cg_t *cgameGlob);
void CG_LastStandSway(LocalClientNum_t localClientNum);
void CG_OffsetFirstPersonView(cg_t *cgameGlob);
void CG_CalcCubemapViewValues(cg_t *cgameGlob);
void CG_CalcTurretViewValues(LocalClientNum_t localClientNum);
void CG_ViewRegisterDvars();
void CalcLinkedViewValues(LocalClientNum_t localClientNum, vec3_t *viewangles);
void CG_UpdateCameraVelocity(cg_t *cgameGlob);
void CG_CalcViewValues(LocalClientNum_t localClientNum);
void CG_CalcViewValues_ExtraCam(LocalClientNum_t localClientNum);
void CG_UpdateIKTiming(LocalClientNum_t localClientNum);
void CG_UpdateThirdPerson(LocalClientNum_t localClientNum, bool forExtraCam);
const ClientViewParams *CG_GetLocalClientViewParams(;
const ClientViewParams *CG_GetLocalClientViewParams(LocalClientNum_t localClientNum);
bool CG_IsClientViewportLarge(const LocalClientNum_t localClientNum);
void CG_SetView(;
void CG_ForceFullScreenView(LocalClientNum_t a1, int a2);
void DumpAnims(LocalClientNum_t localClientNum);
void DrawShellshockBlend(LocalClientNum_t localClientNum);
void CG_UpdateViewOffset(LocalClientNum_t localClientNum);
bool ShouldDoDefaultAdsDof(LocalClientNum_t localClientNum);
;
void CG_UpdateSceneDepthOfField(LocalClientNum_t localClientNum);
void CG_UpdatePoisonFX(cg_t *cgameGlob);
void CG_UpdateGenericFilter(cg_t *cgameGlob);
void CG_StartWaterSheetFX(LocalClientNum_t localClientNum, int duration, float magnitude);
void CG_StopWaterSheetFX(LocalClientNum_t localClientNum, int duration);
void CG_UpdateWaterSheetingFX(cg_t *cgameGlob, LocalClientNum_t localClientNum);
void CG_UpdateFlameFX(cg_t *cgameGlob);
void CG_SetupFlameFX(LocalClientNum_t localClientNum, int enable);
void CG_UpdateElectrifiedFX(cg_t *cgameGlob);
void CG_SetupElectrifiedFX(LocalClientNum_t localClientNum, int enable);
void CG_PickValidWeaponSelect(cg_t *cgameGlob);
void CG_ValidateWeaponSelect(cg_t *cgameGlob);
bool CG_IsInfraredWeaponOverlay(LocalClientNum_t localClientNum);
bool CG_IsInfrared(LocalClientNum_t localClientNum);
bool CG_IsTvguided(LocalClientNum_t localClientNum, bool onlyADS);
int CG_ProcessButDontDrawActiveFrame(LocalClientNum_t localClientNum, int serverTime);
void CG_CreateBeamCent(LocalClientNum_t localClientNum, clientInfo_t *ci);
;
void CG_ResetBeamEffect(LocalClientNum_t localClientNum, centity_t *cent);
void CG_ResetBeamEffects(LocalClientNum_t localClientNum);
void CG_SetClientEntCollision(LocalClientNum_t localClientNum, bool enableCollision);
int CG_DrawExtraCamFrame(;
void CG_ClearSaveScreenFx(LocalClientNum_t localClientNum);
void CG_SaveScreen(LocalClientNum_t localClientNum);
void CG_SaveScreenSection(;
void CG_BlendSavedScreenShockBlurred(;
void CG_BlendSavedScreenShockFlashed(;
void CG_ResetFullscreenFX(LocalClientNum_t localClientNum);
void CG_UpdateEntInfo(LocalClientNum_t localClientNum);
void CG_InitView(LocalClientNum_t localClientNum);
;
int CG_DrawActiveFrame(;

//t6/code/src_noserver/cgame_mp/cg_weapon_options.cpp
// void __thiscall WeaponOptions::InitWeaponOptions(WeaponOptions *this);
// void __thiscall WeaponOptions::SetupWeaponCamoRender(;
// void __thiscall WeaponOptions::SetReticle(;
// bool __thiscall WeaponOptions::IsValidRenderOption(WeaponOptions *this, renderOptions_s renderOptions, Weapon weapon);
// void __thiscall WeaponOptions::DisplayRenderOption(WeaponOptions *this, renderOptions_s renderOptions, Weapon weapon);
void GC_InitWeaponOptionsDvars();
void GC_InitWeaponOptions();
void CG_SetupWeaponCamoRender(;
bool CG_IsValidRenderOption(renderOptions_s renderOptions, Weapon weapon);
void CG_DisplayRenderOption(renderOptions_s renderOptions, Weapon weapon);
void CG_SetRangeFinderShaderConstants(LocalClientNum_t localClientNum, ShaderConstantSet *constantSet);
void CG_SetWeaponSharedShaderConstants(;
float CG_GetWeaponHeat(LocalClientNum_t localClientNum, centity_t *cent);
void CG_SetWeaponHeatConstants(;
void CG_SetWeaponHeatConstants(;
void CG_SetWeaponMMSConstants(LocalClientNum_t localClientNum, ShaderConstantSet *constantSet);
// void __thiscall WeaponOptions::SetupWeaponOptionsRender(;
void CG_SetupWeaponOptionsRender(;

//t6/code/src_noserver/client/client.h
connstate_t CL_GetLocalClientConnectionState(const LocalClientNum_t localClientNum);
unsigned int CL_LocalClient_IsCGameInitialized(LocalClientNum_t localClientNum);
XModelRigidCullInfoContext *CL_GetLocalClientMigrationState(const LocalClientNum_t localClientNum);
clientActive_t *CL_GetLocalClientGlobals(const LocalClientNum_t localClientNum);
clientUIActive_t *CL_GetLocalClientUIGlobals(const LocalClientNum_t localClientNum);
clientConnection_t *CL_GetLocalClientConnection(const LocalClientNum_t localClientNum);
void CL_SetLocalClientMigrationState(LocalClientNum_t client, clientMigState_t state);
void CL_SetLocalClientConnectionState(LocalClientNum_t client, connstate_t state);
void CL_LocalClient_SetCUIFlag(LocalClientNum_t localClientNum, int flag);
void CL_LocalClient_ClearCUIFlag(LocalClientNum_t localClientNum, int flag);
unsigned int CL_LocalClient_IsInvited(LocalClientNum_t localClientNum);
unsigned int CL_LocalClient_IsDisplayingKeyCatcherHud(LocalClientNum_t localClientNum);

//t6/code/src_noserver/client/cl_compositing.cpp
GfxImage *CL_CompositeSetupImage();
void CL_PCCopyImageGenMIPCallback(void *job);
void CL_CompositeResetLayer(CompositeEmblemLayer *layer);
void CL_CompositeClearLayer(CompositeEmblemLayer *layer);
void CL_CompositeClearRecentColor(vec4_t *recentColor);
void CL_CompositeShiftLayersUp(CompositeEmblemLayer *layers, int selectedLayer, int layerCount);
void CL_CompositeRender();

//t6/code/src_noserver/client/cl_console.cpp
void SetupChatField(const LocalClientNum_t localClientNum, int teamChat, int widthInPixels);
void Con_ChatModePublic_f(LocalClientNum_t a1, int a2);
void Con_ChatModeTeam_f(LocalClientNum_t a1, int a2);
void Con_GetTextCopy(char *text, int maxSize);
void Con_ResetMessageWindowTimes(MessageWindow *msgwnd, int serverTime);
// void Con_TimeJumped(int a1@<edx>, MessageWindow *a2@<ecx>, LocalClientNum_t localClientNum, int serverTime);
void Con_NudgeMessageWindowTimes(MessageWindow *msgwnd, int serverTimeNudge, int serverTime);
void Con_TimeNudged(LocalClientNum_t localClientNum, int serverTimeNudge);
void Con_ClearMessageWindow(MessageWindow *msgwnd);
void Con_ClearNotify(LocalClientNum_t localClientNum);
void Con_CheckResize();
void Con_InitMessageWindow(;
void __thiscall Con_Clear_f(MessageWindow *this);
;
int Con_GetDefaultMsgDuration(print_msg_dest_t dest);
void Con_UpdateMessage(LocalClientNum_t localClientNum, MessageWindow *msgwnd, int duration);
void Con_FreeFirstMessageWindowLine(MessageWindow *msgwnd);
bool Con_NeedToFreeMessageWindowLine(MessageWindow *msgwnd, int charCount);
void Con_CopyCurrentConsoleLineText(MessageWindow *msgwnd, MessageLine *msgLine);
int LatestActiveTypewrittenLineIdx(MessageWindow *msgwnd);
int PrintableCharsCount(const MessageWindow *msgwnd, MessageLine *line);
int PrintTimeTotal(MessageWindow *msgwnd, MessageLine *line);
int GetNextValidPrintTimeForLine(LocalClientNum_t localClientNum, MessageWindow *msgwnd, int flags);
void Con_UpdateMessageWindowLine(;
MessageWindow *Con_GetDestWindow(LocalClientNum_t localClientNum, print_msg_dest_t dest);
void Con_UpdateNotifyMessage(LocalClientNum_t localClientNum, int channel, int duration, int flags);
void Con_UpdateNotifyLine(LocalClientNum_t localClientNum, int channel, bool lineFeed, int flags);
void Con_InitMessageBuffer();
char CL_ConsolePrint_AddLine(;
int CL_AddMessageChar(char *msg, unsigned int msgLen, unsigned int msgMaxLen, char c);
int CL_AddMessageString(char *msg, unsigned int msgLen, unsigned int msgMaxLen, const char *string);
int CL_AddMessageIcon(;
void Con_AutoCompleteFromList(;
const GfxViewParms *Con_TokenizeInput();
char Con_AnySpaceAfterCommand();
void ConDrawInput_Text(const char *str, const vec4_t *color);
void ConDrawInput_TextLimitChars(const char *str, int maxChars, const vec4_t *color);
void ConDrawInput_TextAndOver(;
void ConDraw_Box(float x, float y, float w, float h, const vec4_t *color);
void ConDrawInput_Box(int lines, const vec4_t *color);
int Con_GetAutoCompleteColorCodedStringDiscontiguous(;
int Con_GetAutoCompleteColorCodedStringContiguous(;
bool Con_IsAutoCompleteMatch(const char *query, const char *matchToText, int matchTextLen);
void ConDrawInput_IncrMatchCounter(const char *str);
void ConDrawInput_DvarMatch(const char *str);
int CG_SortPlayersAlphabeticallyComparator(const void *a, const void *b);
int ConDrawInput_TextFieldFirstArgChar();
void ConDrawInput_AutoCompleteArg(LocalClientNum_t localClientNum, const char **stringList, int stringCount);
int ConDrawInput_GetDvarDescriptionLines(const dvar_t *dvar);
void ConDrawInput_DetailedDvarMatch(LocalClientNum_t localClientNum, const char *str);
void ConDrawInput_DetailedCmdMatch(LocalClientNum_t localClientNum, const char *str);
void ConDrawInput_CmdMatch(const char *str);
void Con_DrawAutoCompleteChoice(;
void Con_DrawInputPrompt(LocalClientNum_t localClientNum);
BOOL Con_HasTooManyMatchesToShow();
bool Con_IsDvarCommand(const char *cmd);
char Con_CycleAutoComplete(int step);
char Con_CancelAutoComplete();
void Con_AllowAutoCompleteCycling(bool isAllowed);
void TypewriterSounds(LocalClientNum_t localClientNum, const MessageWindow *msgwnd, MessageLine *line);
void Con_DrawMessageLineOnHUD(;
void Con_CullFinishedLines(int serverTime, MessageWindow *msgwnd);
double Con_GetMessageAlpha(Message *message, MessageWindow *msgwnd, int serverTime, bool scrollsIntoPlace);
void Con_DrawMessageWindowNewToOld(;
void Con_DrawMessageWindowOldToNew(;
void Con_DrawMessageWindow(;
void Con_DrawGameMessageWindow(;
void Con_DrawMiniConsole(LocalClientNum_t localClientNum, int xPos, int yPos, float alpha);
void Con_DrawErrors(LocalClientNum_t localClientNum, int xPos, int yPos, float alpha);
BOOL Con_IsValidGameMessageWindow(int windowIndex);
bool Con_IsGameMessageWindowActive(LocalClientNum_t localClientNum, int windowIndex);
void Con_DrawSay(LocalClientNum_t localClientNum, int x, int y);
void Con_ToggleConsoleOutput();
void Con_DrawOutputScrollBar(float x, float y, float width, float height);
void Con_DrawOutputText(float x, float y);
void Con_DrawOuputWindow();
void Con_PageUp();
void Con_PageDown();
void Con_Top();
void Con_Bottom();
void Con_Close(LocalClientNum_t localClientNum);
bool Con_IsActive(LocalClientNum_t localClientNum);
void CL_PlayTextFXPulseSounds(;
void Con_ToggleConsole();
void Con_Echo_f();
void Con_OneTimeInit();
void Con_Init();
void CL_ConsolePrint(;
void CL_ConsoleFixPosition();
void CL_ReviveMessagePrint(;
void CL_DeathMessagePrint(;
void Con_DrawInput(LocalClientNum_t localClientNum);
char Con_CommitToAutoComplete();
void Con_DrawSolidConsole(LocalClientNum_t localClientNum);
void Con_DrawConsole(LocalClientNum_t localClientNum);

//t6/code/src_noserver/client/cl_debugdata.cpp
void CL_DebugInitSVThreadVariables();
BOOL CreateDebugStringsIfNeeded();
// float *AddDebugStringInternal@<eax>(;
void CL_AddDebugString(const vec3_t *xyz, const vec4_t *color, float scale, const char *text, int duration);
BOOL CreateDebugSpheresIfNeeded();
// int AddDebugSphereInternal@<eax>(;
void CL_AddDebugSphere(;
BOOL CreateDebugLinesIfNeeded();
void AddDebugLineInternal(;
void CL_AddDebugLine(;
void CL_AddDebugAxis(;
void CL_AddDebugStarWithText(;
void CL_AddDebugStar(;
void CL_AddDebugBox(;
void FlushDebugStrings(clientDebugStringInfo_t *info, int fromServer);
void FlushDebugLines(clientDebugLineInfo_t *info, int fromServer);
void FlushDebugSpheres(clientDebugSphereInfo_t *info, int fromServer);
void CL_FlushDebugClientData(clientDebugStringInfo_t *a1, int a2);
void CL_UpdateDebugClientData();
void CL_FlushDebugServerData(clientDebugStringInfo_t *a1, int a2);
void CL_UpdateDebugServerData();
void CL_ShutdownDebugData();

//t6/code/src_noserver/client/cl_devgui.cpp
void CL_AddMapDirSlider(const char *dir, int locationFlags, const char *locationName);
void CL_CreateMapMenuEntriesForLocation(int locationFlags, const char *locationName);
const dvar_t *CL_RegisterDevGuiDvars();
void CL_CreateMapMenuEntries();
void CL_CreateDevGui();
void CL_DestroyDevGui();

//t6/code/src_noserver/client/cl_gamepad.cpp
void CL_ResetLastGamePadEventTime();
void CL_InitGamepadAxisBindings();
GamepadPhysicalAxis Gamepad_StringToPhysicalAxis(const char *axisName);
GamepadVirtualAxis Axis_StringToVirtualAxis(const char *axisName);
GamepadMapping Gamepad_InputTypeStringToId(const char *name);
void Gamepad_BindAxis(;
void Axis_Bind_f();
void Axis_Unbindall_f();
double CL_GamepadAxisValue(LocalClientNum_t localClientNum, int virtualAxis);
bool CL_CheckForIgnoreDueToRepeat(LocalClientNum_t localClientNum, int key, int repeatCount, int time);
void CL_GamepadResetMenuScrollTime(LocalClientNum_t localClientNum, int key, int down, unsigned int time);
bool GamepadButtonEvent_LocationSelection(;
bool GamepadButtonEvent_DevguiKeyEvent(;
void GamepadButtonEvent_UnlockableItems(;
void GamepadButtonEvent_Cheats(;
void CL_GamepadButtonEvent(;
void CL_GamepadButtonEventForPort(;
void CL_InitGamepadCommands();
void CL_GamepadGenerateAPad(;
void CL_GamepadEvent(ControllerIndex_t portIndex, int physicalAxis, int value, int time);

//t6/code/src_noserver/client/cl_input.cpp
void CL_LeanCount_Reset();
void CL_LeanCount_Increment();
BOOL CL_LeanCount_ShouldIncrementStat();
bool CG_IsSprinting(LocalClientNum_t localClientNum);
// void IN_KeyDown(int *a1@<eax>, int a2@<ecx>, int a3@<xmm0>, unsigned int time);
void IN_KeyUp(kbutton_t *b, int key, unsigned int time);
void IN_KeyDownCheat(kbutton_t *b);
void IN_KeyUpCheat(kbutton_t *b);
float CL_KeyState(kbutton_t *key);
void CL_SetStance(LocalClientNum_t localClientNum, StanceState stance);
void CL_ToggleStance(LocalClientNum_t localClientNum, StanceState preferredStance);
void __thiscall IN_UpDown(kbutton_t *this);
void __thiscall IN_UpUp(kbutton_t *this);
void IN_SpeedDown();
void IN_SpeedUp();
void IN_UpdateUseCount(LocalClientNum_t localClientNum);
void IN_UpdateUseHeld(LocalClientNum_t localClientNum);
void IN_Activate_Down(LocalClientNum_t localClientNum, int key, unsigned int time, float value);
void IN_Activate_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
void IN_Reload_Down(LocalClientNum_t localClientNum, int key, unsigned int time, float value);
void IN_Reload_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
void IN_UseReload_Down(LocalClientNum_t localClientNum, int key, unsigned int time, float value);
void IN_UseReload_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
void IN_Attack_Down(LocalClientNum_t localClientNum, int key, unsigned int time, float value);
void IN_Attack_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
// void IN_Melee_Down(int a1@<eax>, int a2@<edx>, int a3@<xmm0>, unsigned int time);
void IN_Melee_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
// void IN_Frag_Down(int a1@<eax>, int a2@<edx>, int a3@<xmm0>, unsigned int time);
void IN_Frag_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
// void IN_Smoke_Down(int a1@<eax>, int a2@<edx>, int a3@<xmm0>, unsigned int time);
void IN_Smoke_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
void IN_Stance_Down(LocalClientNum_t localClientNum, int key, unsigned int time, float value);
void IN_Stance_Up(LocalClientNum_t localClientNum, int key, unsigned int time);
void IN_WeapNextInventoryDown(LocalClientNum_t localClientNum);
void IN_WeapNextInventoryUp(LocalClientNum_t localClientNum);
void IN_ToggleADS(LocalClientNum_t localClientNum);
void IN_CenterView(LocalClientNum_t localClientNum);
void IN_LowerStance();
void IN_RaiseStance();
bool IN_IsTalkKeyHeld();
void CL_AdjustAngles(LocalClientNum_t localClientNum);
void CL_StanceButtonUpdate(LocalClientNum_t localClientNum);
void CL_GetMouseMovement(clientActive_t *cl, float *mx, float *my);
void SetMeleeChargeCmd(const AimOutput *aimOutput, usercmd_s *cmd);
void CL_SetCursorPos(int x, int y);
void CL_ShowSystemCursor(int show);
void CL_CopyDamageKickAngles(LocalClientNum_t localClientNum, usercmd_s *cmd);
int CL_ReadyToSendPacket(LocalClientNum_t localClientNum);
void CL_SendCmd(LocalClientNum_t localClientNum);
void CL_InitInput();
void CL_ShutdownInput();
void CL_ClearKeys(LocalClientNum_t localClientNum);
void CL_ExecBinding(;
bool CL_SpectatorInput(LocalClientNum_t localClientNum, int button);
// bool CL_TranslateSpecialStateButton@<al>(;
void CL_UpdateAirburstMarkDistance(;
void CL_AddCurrentStanceToCmd(LocalClientNum_t localClientNum, usercmd_s *cmd);
void CL_WeapNextButtonUpdate(LocalClientNum_t localClientNum, usercmd_s *cmd);
void CL_KeyMove(LocalClientNum_t localClientNum, usercmd_s *cmd);
int CL_MouseEvent(LocalClientNum_t localClientNum, int x, int y, int dx, int dy);
void CL_UpdateCmdButton(;
void CL_CmdButtons(LocalClientNum_t localClientNum, usercmd_s *cmd);
bool CG_HandleLocationSelectionInput(LocalClientNum_t localClientNum, usercmd_s *cmd);
// void CL_HandleSpectatorInput(LocalClientNum_t localClientNum, bitarray<64> *button_bits);
void CL_HandleSpecialStateInput(;
void CL_GamepadMove(LocalClientNum_t localClientNum, usercmd_s *cmd, float frametime_base);
void CL_MouseMove(LocalClientNum_t localClientNum, usercmd_s *cmd, float frametime_base);
usercmd_s *CL_CreateCmd(LocalClientNum_t localClientNum);
void CL_CreateNewCommands(LocalClientNum_t localClientNum);
void CL_Input(LocalClientNum_t localClientNum);

//t6/code/src_noserver/client/cl_keys.cpp
void Field_AdjustScroll(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, field_t *edit);
char Field_Paste(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, field_t *edit);
void FindMatches(const char *s);
void PrintMatches(const char *s);
int keyConcatArgs();
void ReplaceConsoleInputArgument(int replaceCount, const char *replacement);
void CompleteCmdArgument();
void CompleteDvarArgument();
void UpdateMatches(bool searchCmds, int *matchLenAfterCmds, int *matchLenAfterDvars);
// void CompleteCommand(int *a1@<ebx>, LocalClientNum_t localClientNum);
bool Console_IsScrollUpKey(int key, int isShiftDown, int isCtrlDown);
bool Console_IsScrollDownKey(int key, int isShiftDown, int isCtrlDown);
int Key_GetOverstrikeMode(LocalClientNum_t localClientNum);
void Key_SetOverstrikeMode(LocalClientNum_t localClientNum, int state);
int Key_IsDown(LocalClientNum_t localClientNum, int keynum);
int Key_StringToKeynum(LocalClientNum_t localClientNum, const char *str);
BOOL Key_IsValidGamePadChar(const char key);
const char *Key_KeynumToString(LocalClientNum_t localClientNum, int keynum, int translate);
void Key_SetBinding(LocalClientNum_t localClientNum, int keynum, Bind_t binding, BindIndex_t index);
void Key_SetBindingCheat(LocalClientNum_t localClientNum, int keynum, const char *bindingCheat);
void Key_SetBindings(LocalClientNum_t localClientNum, int *twokeys, Bind_t binding, BindIndex_t bindNum);
Bind_t Key_GetBinding(LocalClientNum_t localClientNum, int keynum, BindIndex_t index);
int Key_GetCommandAssignmentInternal(;
int Key_GetSafeFreeKey(LocalClientNum_t localClientNum, BindIndex_t bindNum);
int Key_GetMouseKeyboardCommandAssignment(;
void Key_BindMustHaveCommands(LocalClientNum_t localClientNum);
void Key_UpdateMustHaveBindings_f();
int Key_GetCommandAssignment(;
void Key_Unbind_f();
void Key_Unbind2_f();
void Key_Unbindall_f();
void Key_Unbindall2_f();
void Key_ClearStates(LocalClientNum_t localClientNum);
int CL_IsKeyPressed(const LocalClientNum_t localClientNum, const char *keyName);
void Key_Shutdown();
bool Key_IsCatcherActive(LocalClientNum_t localClientNum, int mask);
void Key_AddCatcher(LocalClientNum_t localClientNum, int orMask);
void Key_RemoveCatcher(LocalClientNum_t localClientNum, int andMask);
void Key_SetCatcher(LocalClientNum_t localClientNum, int catcher);
Bind_t Key_GetBindingForCmd(const char *cmd);
const char *Key_GetCmdForBinding(Bind_t binding);
void Field_DrawTextOverride(;
void Field_Draw(;
bool Field_KeyDownEvent(;
char Field_CharEvent(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, field_t *edit, int ch);
void Console_Key(LocalClientNum_t localClientNum, int key);
void Message_Key(LocalClientNum_t localClientNum, int key);
const char *Key_GetBindingCheat(LocalClientNum_t localClientNum, int keynum);
int Key_GetCheatAssignmentInternal(;
BOOL Key_IsCommandBound(LocalClientNum_t localClientNum, const char *command, BindIndex_t bindIndex);
void Key_Bind_f();
void Key_Bind2_f();
void Key_Bindlist_f();
void CL_InitKeyCommands();
void CL_KeyEvent(LocalClientNum_t localClientNum, int key, const int down, const unsigned int time);
void CL_ConsoleCharEvent(LocalClientNum_t localClientNum, int key);
void CL_CharEvent(LocalClientNum_t localClientNum, int key);
int CL_GetKeyBindingInternal(;
int CL_GetKeyBinding(;
int CL_GetGamePadBinding(;

//t6/code/src_noserver/client/cl_main.cpp
char CL_AnyLocalClientsRunning();
void CL_Command_DisableAllButPrimaryClients();
void CL_Command_SetClientBeingUsedAndPrimary();
void CL_Command_SetClientBeingUsedAndPrimaryAndActive();
void CL_Command_SetClientPrimary();
void CL_Command_SetClientBeingUsed();
void CL_Command_SetClientBeingUsedAndActive();
void CL_Command_DisableAllClients();
void CL_Command_SignClientOutOfUI();
void CL_Command_SignClientIn();
void CL_SetupClientsForIngame();
void CL_DrawFramedPicPhysical(;
void CL_ForwardToServer_f();
void CL_Setenv_f();
void CL_SkipLevel_f();
void CL_Vid_Restart_f();
void CL_Snd_Restart_f();
void CL_OpenedIWDList_f();
void CL_ReferencedIWDList_f();
void CL_Configstrings_f();
void CL_Clientinfo_f();
bool CL_WasMapAlreadyLoaded();
void CL_Live_StopAllParties();
void CL_Live_StopPrivateParty();
void CL_Live_LeaveParty(PartyData_s *party, ControllerIndex_t localControllerIndex);
void CL_Live_LeaveAllParties(ControllerIndex_t localControllerIndex);
char CL_Live_LocalClientJoinParty(PartyData_s *party, ControllerIndex_t localControllerIndex);
void CL_Live_StopParty(bool keepPartyTogether);
void CL_Live_PartySwitchLobbies();
void CL_ExecControllerBindings_f();
void CL_Live_ShowFriendsList();
void CL_Live_StartPartyHost(ControllerIndex_t localControllerIndex, bool silentFail);
void CL_Live_StartPartyHost();
void CL_Live_PartyMapVeto();
void CL_Live_UpdatePartyState();
void CL_Live_PartyMapReady();
void CL_UpdateSession(PartyData_s *party, SessionData *session, int maxplayers);
int CL_GetUserMaxPlayerSetting(ControllerIndex_t controllerIndex);
void CL_Live_SessionUpdate();
void CL_AnimateUI_f();
;
void CL_DrawSpinnerPhysical(float x, float y, float w, float h, const vec4_t *color);
void CL_DrawSpinner(;
void CL_DrawSpinnerLoadbarPhysical(float x, float y, float w, float h, const vec4_t *color, float percentDone);
void CL_DrawSpinnerLoadbar(;
void CL_ShutdownHunkUsers();
void CL_SendBlackboxSession(;
void CL_ResetSkeletonCache(LocalClientNum_t localClientNum);
int CL_HighestPriorityStatPacket(clientConnection_t *clc, int numCompressedStatsPackets);
void CL_CheckForResend(LocalClientNum_t localClientNum);
void CL_DisconnectError(const char *message);
void CL_DisconnectPacket(LocalClientNum_t localClientNum, netadr_t from, const char *reason);
void CL_HandleRelayPacket(LocalClientNum_t localClientNum);
char CL_HandleVoiceTypePacket(LocalClientNum_t localClientNum, msg_t *msg);
void CL_SetupForNewServerMap(LocalClientNum_t localClientNum, const char *pszMapName, const char *pszGametype);
void CL_AuthRequestPacket(LocalClientNum_t localClientNum, unsigned __int64 serverSteamID);
bool CL_DispatchConnectionlessPacket(LocalClientNum_t localClientNum, netadr_t from, msg_t *msg, int time);
// char CL_ConnectionlessPacket@<al>(int a1@<edi>, LocalClientNum_t localClientNum, netadr_t from, msg_t *msg);
char CL_PacketEvent(;
BOOL CL_LocalClientIsInGame(LocalClientNum_t localClientNum);
char CL_IsClientLocal(ClientNum_t clientNum);
void CL_ParseBadPacket_f();
void CL_SetupViewport();
;
void CL_InitRenderer();
void CL_DevGuiDvar_f();
void CL_DevGuiDvarList_f();
void CL_DevGuiCmd_f();
void CL_DevGuiOpen_f();
void CL_InitDevGui();
void CL_StartHunkUsers();
int CL_ScaledMilliseconds();
void CL_InitDedicated();
void CL_startSingleplayer_f();
void CL_startZombies_f();
void CL_startMultiplayer_f();
void CL_PlayLogo_f();
void CL_OpenScriptMenu_f();
char Playlist_ReadFromDisk();
;
void CL_VoiceFail_f();
void CL_ForceVoiceFail_f();
void CL_MigrateHost_f();
void CL_SetNatStrict_f();
void CL_SetNatOpen_f();
void CL_LoadFFOTD_f();
void CL_ChooseNextPlaylist();
void CL_ChoosePreviousPlaylist();
void CL_LocalServers_f();
void CL_FlushGump(int slot);
;
void CL_LoadGump();
void CL_AddListenIn_f();
void CL_RemoveListenIn_f();
void CL_ResetListenIn_f();
void CL_SetListenIn_f();
void CL_RemoveCommands();
void CL_RegisterDvars();
bool CL_IsServerLoadingMap();
bool CL_IsWaitingOnServerToLoadMap(LocalClientNum_t localClientNum);
void CL_SetWaitingOnServerToLoadMap(LocalClientNum_t localClientNum, bool waiting);
void CL_DrawTextPhysical(;
void CL_DrawTextPhysicalWithEffects(;
void CL_DrawText(;
void CL_DrawTextRotate(;
void CL_DrawTextPhysicalWithCursor(;
void CL_DrawTextWithCursor(;
void CL_DrawTextWithEffects(;
void CL_DrawTextWithCOD7TypeWriterEffects(;
void CL_DrawTextPhysicalWithCOD7TypeWriterEffects(;
void CL_DrawTextWithRedactEffects(;
void CL_DrawTextPhysicalWithCOD7DecodeEffects(;
void CL_DrawTextPhysicalWithRedactEffects(;
void CL_DrawTextWithPopInEffects(;
char CL_ShouldDisplayHud(LocalClientNum_t localClientNum);
BOOL CL_IsUIActive(const LocalClientNum_t localClientNum);
Font_s *CL_RegisterFont(const char *fontName, int imageTrack);
vec3_t *CL_GetMapCenter();
void CL_ConnectFromParty(;
void CL_SanitizeClanName(ControllerIndex_t controllerIndex);
void CL_UploadStatsForController(const ControllerIndex_t localControllerIndex);
void CL_ClearState(LocalClientNum_t localClientNum);
void CL_MapLoading_SetupDevmapParty();
void CL_Live_StopParty();
void CL_Live_StopPartyKeepPartyTogether();
void CL_ShutdownAll();
void CL_MapLoading(const char *mapname);
void CL_DownloadsComplete(LocalClientNum_t localClientNum);
void CL_InitLoad(const char *mapname, const char *gametype);
void CL_ShutdownRef();
void CL_DrawLogo(LocalClientNum_t localClientNum);
void __thiscall CL_ShowIP_f(bdCommonAddr *this);
void CL_RegisterCommands();
void CL_InitOnceForAllClients();

//t6/code/src_noserver/client/cl_main_dw.cpp
void CL_Live_PartyPlay();

//t6/code/src_noserver/client/cl_main_pc.cpp
void CL_Live_ShowGamerCard();
void CL_Live_UpdatePartyMapPacks();
void CL_Platform_RemoveCommands();
BOOL CL_IsPlayerMuted(SessionData *session, LocalClientNum_t localClientNum, ClientNum_t muteClientIndex);
int CL_IsPlayerMuted(LocalClientNum_t localClientNum, unsigned __int64 playerXuid);

//t6/code/src_noserver/client/cl_migration.cpp
void CL_MigrationInit();
void PingAck(const LocalClientNum_t localClientNum, netadr_t to, const int time);
void SendToHost(;
void Migration_SendMigrateToAck(;
int GetHostRating(const LocalClientNum_t localClientNum);
void CL_SaveMigrationPers(LocalClientNum_t localClientNum);
void CL_LoadMigrationPers(LocalClientNum_t localClientNum);
void HandleSaveDataMsg(const LocalClientNum_t localClientNum, netadr_t from, msg_t *msg);
void HandlePingMsg(const LocalClientNum_t localClientNum, netadr_t from, msg_t *msg);
void HandlePingAckMsg(const LocalClientNum_t localClientNum, netadr_t from, msg_t *msg);
void HandleHeaderMsg(const LocalClientNum_t localClientNum, netadr_t from, msg_t *msg);
char CL_MigrationPacket(const LocalClientNum_t localClientNum, const char *cmd, netadr_t from, msg_t *msg);
void CL_Migrate(LocalClientNum_t localClientNum, XSESSION_INFO *hostInfo, netadr_t addr);
void HandleStartMsg(const LocalClientNum_t localClientNum);

//t6/code/src_noserver/client/cl_parse.cpp
void CL_SavePredictedPlayerInformationForServerTime(clientActive_t *cl, const int serverTime);
char CL_GetClientArchiveIndexForServerTime(clientActive_t *cl, const int serverTime, int *resultIndex);
char CL_GetPredictedPlayerInformationForServerTime(clientActive_t *cl, const int serverTime, playerState_s *to);
void CL_SavePredictedVehicleForServerTime(;
int CL_GetPredictedVehicleForServerTime(;
void CL_CopyOldEntity(clientActive_t *cl, clSnapshot_t *frame, entityState_s *old);
void CL_ParsePacketMatchState(;
void CL_DeltaClient(;
void CL_ParsePacketClients(;
void CL_ParsePacketActors(;
void CL_ServerIdChanged(LocalClientNum_t localClientNum);
void CL_SystemInfoChanged(LocalClientNum_t localClientNum);
void CL_ParseMapCenter();
void StoreConfigString(int index, const char *s);
void CL_ParseConfigStrings_Internal(;
void CL_CheckBSPCheckSum(unsigned int serverChecksum);
void CL_ParseGamestate_Checksums(LocalClientNum_t localClientNum, msg_t *msg);
void CL_ParseGamestate(LocalClientNum_t localClientNum, msg_t *msg);
void CL_ParseServerMessage(LocalClientNum_t localClientNum, msg_t *msg);

//t6/code/src_noserver/client/con_channels.cpp
char Con_OpenChannel(const char *name, bool allowScript);
bool Con_ScriptHasPermission(int channel);
BOOL Con_GetChannel(const char *name, int *channel_result);
bool Con_IsChannelOpen(int channel);
void Con_FilterShowChannel(print_msg_dest_t dest, const char *channelName, bool show);
bool Con_IsChannelVisible(print_msg_dest_t dest, int channel, int errorflags);
void Con_ChannelList_f();
void Con_FilterAdd(bool show);
void Con_FilterAdd_f();
void Con_FilterRemove_f();
void Con_FilterList_f();
void Con_WriteFilterConfigString(int f);
void Con_InitChannelsForDestFromList(print_msg_dest_t dest, const char *channelNames);
void Con_InitGameMsgChannels();
void Con_InitChannels();
void Con_ShutdownChannels();

//t6/code/src_noserver/client/screen_placement.cpp
ScreenPlacement *ScrPlace_GetView(const LocalClientNum_t localClientNum);
ScreenPlacement *ScrPlace_GetViewWritable(const LocalClientNum_t localClientNum);
ScreenPlacement *ScrPlace_GetViewUIContext(const UIContextIndex_t contextIndex);
ScreenPlacement *ScrPlace_GetViewUIContextWritable(const UIContextIndex_t contextIndex);
double ScrPlace_HiResGetScaleY();
// vec2_t *ScrPlace_CalcSafeAreaOffsets@<eax>(;
void ScrPlace_SetupFloatViewport(;
void ScrPlace_SetupViewport(;
void ScrPlace_SetupUnsafeViewport(;
double ScrPlace_ApplyX(const ScreenPlacement *scrPlace, float x, int horzAlign);
double ScrPlace_ApplyY(const ScreenPlacement *scrPlace, float y, int vertAlign);
double ScrPlace_ApplyW(const ScreenPlacement *scrPlace, float w, int horzAlign);
double ScrPlace_ApplyH(const ScreenPlacement *scrPlace, float h, int vertAlign);
void ApplySplitscreenScaling(float *x, float *y, float *w, float *h, float hudSplitscreenScale);
void ScrPlace_ApplyRect(;
void ScrPlace_SetLegacySplitscreenScaling();
void ScrPlace_SetNormalSplitscreenScaling();

//t6/code/src_noserver/client/screen_placement.h
double ScrPlace_RealFromVirtual_Width(const ScreenPlacement *scrPlace, float width);
double ScrPlace_RealFromVirtual_Height(const ScreenPlacement *scrPlace, float height);
double ScrPlace_VirtualFromReal_Height(const ScreenPlacement *scrPlace, float height);

//t6/code/src_noserver/client/splitscreen.cpp
int CL_LocalClient_IsActive(LocalClientNum_t localClientNum);
BOOL CL_LocalClient_IsFirstActive(LocalClientNum_t localClientNum);
BOOL CL_LocalClient_GetActiveCount();
char CL_AllLocalClientsDisconnected();
char CL_AllLocalClientStatesActive();
char CL_AnyLocalClientStateActive();
char CL_AnyLocalClientChallenging();
int CL_GetFirstActiveLocalClient();
char CL_IsFirstActiveLocalClient(LocalClientNum_t localClientNum);
char CL_IsLastActiveLocalClient(LocalClientNum_t localClientNum);
int CL_ControllerIndexFromActiveClient(const LocalClientNum_t localActiveClientNum);
int CL_LocalActiveIndexFromClientNum(const LocalClientNum_t localClientNum);
const GfxViewParms *CL_ControllerIndex_GetUsername(ControllerIndex_t controllerIndex);
char *CL_ControllerIndex_GetXuidString(ControllerIndex_t controllerIndex);
void CL_LocalClient_SetActive(LocalClientNum_t localClientNum, bool active);
bool CL_LocalClient_IsSplitscreen();
void CL_LocalClients_SetAllUsedActive();

//t6/code/src_noserver/clientscript/cscr_animtree.cpp
void TRACK_scr_animtree();
void AnimTreeCompileError(scriptInstance_t inst, const char *msg);
// void __thiscall ScriptTokenizer::ParseIntoTokens(ScriptTokenizer *this, const char *strString);
void SetAnimCheck(scriptInstance_t inst, int bAnimCheck);
void Scr_EmitAnimationInternal(;
void Scr_EmitAnimation(;
unsigned __int8 *Hunk_AllocXAnimPrecache(int size);
int Scr_GetAnimTreeSize(scriptInstance_t inst, unsigned int parentNode);
int Scr_GetAnimTreeValueCount(scriptInstance_t inst, unsigned int rootData);
void ConnectScriptToAnim(;
int Scr_GetAnimsIndex(scriptInstance_t inst, const XAnim_s *anims);
XAnim_s *Scr_GetClientAnims(scriptInstance_t inst, unsigned int index);
XAnim_s *Scr_GetAnims(scriptInstance_t inst, unsigned int index);
void Scr_ProcessNodeValues(;
int Scr_CreateAnimationTree(;
void CreateValues(scriptInstance_t inst, XAnim_s *anims, unsigned int valueArray);
void Scr_CheckAnimsDefined(scriptInstance_t inst, unsigned int names, unsigned int filename);
void Scr_PrecacheAnimationTree(scriptInstance_t inst, unsigned int parentNode);
unsigned int Scr_UsingTreeInternal(;
void Scr_ClientUsingTree(scriptInstance_t inst, const char *filename);
int Scr_CreateAllAnimTreeData(;
scr_animtree_t CScr_RetrieveAnimTree(;
scr_animtree_t Scr_FindAnimTree(scriptInstance_t inst, const char *filename);
void Scr_FindAnim(;
void Scr_ShutdownAnimTrees(int user);
// void __thiscall ScriptTokenizer::PushNextToken(ScriptTokenizer *this);
void Scr_UsingTree(scriptInstance_t inst, const char *filename, unsigned int sourcePos);
// const char *__thiscall ScriptTokenizer::PopToken(ScriptTokenizer *this);
// bool __thiscall ScriptTokenizer::PeekIsChar(ScriptTokenizer *this, char cTestChar);
int GetAnimTreeParseProperties(ScriptTokenizer *tokenizer, unsigned int currentAnim, int *piNumComponents);
ValueType DetermineValueType(ScriptTokenizer *tokenizer);
unsigned int ParseValueFromValueList(ScriptTokenizer *tokenizer, scriptInstance_t inst, unsigned int valueName);
// char ParseNode@<al>(;
bool AnimTreeParseInternal(;
void Scr_AnimTreeParse(scriptInstance_t inst, const char *pos, unsigned int parentNode, unsigned int names);
bool Scr_LoadAnimTreeInternal(;
void Scr_LoadAnimTreeAtIndex(;

//t6/code/src_noserver/clientscript/cscr_compiler.cpp
int GetExpressionCount(sval_u exprlist);
void TRACK_scr_compiler();
void Scr_CompileRemoveRefToString(scriptInstance_t inst, unsigned int stringValue);
void EmitCanonicalString(scriptInstance_t inst, unsigned int stringValue);
void CompileTransferRefToString(scriptInstance_t inst, unsigned int stringValue, unsigned int user);
void EmitAssignmentPos(scriptInstance_t inst);
void EmitCodepos(scriptInstance_t inst, unsigned __int8 *pos);
void EmitShort(scriptInstance_t inst, __int16 value);
void EvalUndefined(sval_u sourcePos, VariableCompileValue *constValue);
void EvalInteger(int value, sval_u sourcePos, VariableCompileValue *constValue);
void EmitGetInteger(scriptInstance_t inst, int value, sval_u sourcePos);
void EvalFloat(float value, sval_u sourcePos, VariableCompileValue *constValue);
void EmitAnimTree(scriptInstance_t inst, sval_u sourcePos);
void Scr_InitFromChildBlocks(scr_block_s **childBlocks, int childCount, scr_block_s *block);
void Scr_TransferBlock(scr_block_s *from, scr_block_s *to);
void EvalString(unsigned int value, sval_u sourcePos, VariableCompileValue *constValue);
void EmitGetString(scriptInstance_t inst, unsigned int value, sval_u sourcePos);
void EvalIString(unsigned int value, sval_u sourcePos, VariableCompileValue *constValue);
void EmitGetIString(scriptInstance_t inst, unsigned int value, sval_u sourcePos);
void EmitGetVector(scriptInstance_t inst, const float *value, sval_u sourcePos);
void EmitValue(scriptInstance_t inst, VariableCompileValue *constValue);
void Scr_PushValue(scriptInstance_t inst, VariableCompileValue *constValue);
int EmitExpressionList(scriptInstance_t inst, sval_u exprlist, scr_block_s *block);
void AddFilePrecache(;
void EmitFunction(scriptInstance_t inst, sval_u func, sval_u sourcePos);
unsigned int Scr_GetBuiltin(scriptInstance_t inst, sval_u func_name);
void Scr_BeginDevScript(scriptInstance_t inst, int *type, unsigned __int8 **savedPos);
void Scr_EndDevScript(scriptInstance_t inst, int type, unsigned __int8 **savedPos);
int Scr_GetCacheType(int type);
int Scr_GetUncacheType(int type);
void Scr_CreateVector(scriptInstance_t inst, VariableCompileValue *constValue, VariableValue *value);
char EvalBinaryOperatorExpression(;
void ConnectBreakStatements(scriptInstance_t inst);
void ConnectContinueStatements(scriptInstance_t inst);
void Scr_AddBreakBlock(scriptInstance_t inst, scr_block_s *block);
void Scr_AddContinueBlock(scriptInstance_t inst, scr_block_s *block);
int CompareCaseInfo(const void *elem1, const void *elem2);
void EmitCaseStatementInfo(scriptInstance_t inst, unsigned int name, sval_u sourcePos);
void EmitStatementList(;
void EmitOpcode(;
int Scr_FindLocalVarIndex(;
// void EmitCreateLocalVars(VariableCompileValue *a1@<edx>, scriptInstance_t inst, scr_block_s *block);
void EmitRemoveLocalVars(scriptInstance_t inst, scr_block_s *block, scr_block_s *outerBlock);
void EmitNOP2(scriptInstance_t inst, bool lastStatement, unsigned int endSourcePos, scr_block_s *block);
void EmitSelfObject(scriptInstance_t inst, sval_u sourcePos);
void EmitLevelObject(scriptInstance_t inst, sval_u sourcePos);
void EmitAnimObject(scriptInstance_t inst, sval_u sourcePos);
void EmitLocalVariable(scriptInstance_t inst, sval_u expr, sval_u sourcePos, scr_block_s *block);
void EmitLocalVariableRef(scriptInstance_t inst, sval_u expr, sval_u sourcePos, scr_block_s *block);
void EmitAnimation(scriptInstance_t inst, sval_u anim, sval_u sourcePos);
void EmitAnimationAnimTree(scriptInstance_t inst, sval_u anim, sval_u animtree, sval_u sourcePos);
void EmitObject(scriptInstance_t inst, sval_u expr, sval_u sourcePos);
void EmitCastFieldObject(scriptInstance_t inst, sval_u sourcePos);
void EmitArrayVariable(;
void EmitCallBuiltinMethodOpcode(scriptInstance_t inst, int param_count, sval_u sourcePos);
void EmitCall(scriptInstance_t inst, sval_u func_name, sval_u params, bool bStatement, scr_block_s *block);
void EmitMethod(;
void EmitCallExpression(scriptInstance_t inst, sval_u expr, bool bStatement, scr_block_s *block);
void EmitCallExpressionFieldObject(scriptInstance_t inst, sval_u expr, scr_block_s *block);
bool EvalPrimitiveExpressionList(;
// bool EmitOrEvalPrimitiveExpressionList@<al>(;
void EmitExpressionListFieldObject(;
// bool EvalPrimitiveExpression@<al>(;
void EmitBoolOrExpression(;
void EmitBoolAndExpression(;
bool EmitOrEvalBinaryOperatorExpression(;
void EmitArrayPrimitiveExpressionRef(;
void EmitPrimitiveExpressionFieldObject(;
void EmitCallExpressionStatement(scriptInstance_t inst, sval_u expr, scr_block_s *block);
void EmitEndStatement(scriptInstance_t inst, sval_u sourcePos, scr_block_s *block);
void EmitFormalWaittillParameterListRefInternal(scriptInstance_t inst, sval_u *node, scr_block_s *block);
void EmitCaseStatement(scriptInstance_t inst, sval_u expr, sval_u sourcePos);
void EmitSwitchStatementList(;
void EmitBreakStatement(scriptInstance_t inst, sval_u sourcePos, scr_block_s *block);
void EmitContinueStatement(scriptInstance_t inst, sval_u sourcePos, scr_block_s *block);
void EmitDeveloperStatementList(;
void EmitClearFieldVariable(;
void EmitVariableExpression(scriptInstance_t inst, sval_u expr, scr_block_s *block);
// bool EmitOrEvalPrimitiveExpression@<al>(;
bool EmitOrEvalExpression(;
void EmitExpression(scriptInstance_t inst, sval_u expr, scr_block_s *block);
void EmitReturnStatement(scriptInstance_t inst, sval_u expr, sval_u sourcePos, scr_block_s *block);
void EmitIfStatement(;
void EmitIfElseStatement(;
void EmitWhileStatement(;
void EmitForStatement(;
void EmitWaittillStatement(;
void EmitWaittillmatchStatement(;
void EmitNotifyStatement(;
void EmitEndOnStatement(;
void EmitSwitchStatement(;
void EmitArrayVariableRef(;
void EmitClearArrayVariable(;
void EmitVariableExpressionRef(scriptInstance_t inst, sval_u expr, scr_block_s *block);
bool EmitClearVariableExpression(;
void EmitAssignmentStatement(;
void EmitIncStatement(scriptInstance_t inst, sval_u expr, sval_u sourcePos, scr_block_s *block);
void EmitDecStatement(scriptInstance_t inst, sval_u expr, sval_u sourcePos, scr_block_s *block);
void EmitBinaryEqualsOperatorExpression(;
void EmitStatement(;
// void Scr_CompileStatement(scr_block_s *a1@<edx>, scriptInstance_t inst, sval_u parseData);

//t6/code/src_noserver/clientscript/cscr_debugger.cpp
void TRACK_scr_debugger();
scrDebuggerGlob_t *Scr_FindBreakpointInfo(scriptInstance_t inst, const unsigned __int8 *codePos, int lineNum);
breakpointData_t *Scr_AddBreakpoint(;
void Scr_ForceBreakpoint(scriptInstance_t inst, unsigned __int8 *codePos);
void Scr_RemoveBreakpoint(scriptInstance_t inst, int uniqueId);
void Scr_DisableAllBreakpoint(scriptInstance_t inst);
void Scr_EnableAllBreakpoint(scriptInstance_t inst);
// void Scr_RemoveAllBreakpoint(unsigned __int8 *a1@<edx>, scriptInstance_t a2@<ecx>, scriptInstance_t inst);
void Scr_Step(scriptInstance_t inst, int step_mode);
void Scr_RemoveValue(scriptInstance_t inst, _watchNode_t *node);
void Scr_UpdateSelfName(scriptInstance_t inst);
void Scr_UpdateLocals(scriptInstance_t inst, unsigned int localVarCount);
int SortDataCompare(const void *e1, const void *e2);
int SortThreadCompare(const void *e1, const void *e2);
int SortEntCompare(const void *e1, const void *e2);
void Scr_Msg_SetBreakpoint();
void Scr_Msg_SetWatchBreakpoint();
void Scr_Msg_SetNotifyBreakpoint();
void Scr_Msg_ClearBreakpoint();
void Scr_Msg_SetBreakpointCondition();
void Scr_Msg_WatchSetData(scriptInstance_t inst);
void Scr_ExecutePendingShellCommand(scriptInstance_t inst);
void Scr_ShellCommand(scriptInstance_t inst);
void Scr_ExecCommand();
void Scr_Msg_RunToLine(scriptInstance_t inst);
void Scr_Msg_SetLine(scriptInstance_t inst);
void Scr_Msg_ChangeScope(scriptInstance_t inst);
void Scr_InitDebugger(scriptInstance_t inst);
// void Scr_ShutdownDebugger(unsigned __int8 *a1@<edx>, scriptInstance_t a2@<ecx>, scriptInstance_t inst);
void Scr_SynchronizeDebuggerFileInfo(scriptInstance_t inst);
void Scr_MonitorCommand(const char *text, scriptInstance_t inst);
void Scr_UpdateDebuggerCallStack(scriptInstance_t inst, unsigned __int8 *pos);
void Scr_DebuggerReportRuntimeError(const char *msg);
bool Scr_TestBreakpointCondition(scriptInstance_t inst, breakpointData_t *breakpointInfo, unsigned int localId);
unsigned __int8 *Scr_CheckForceJump(scriptInstance_t inst, unsigned __int8 *pos);
void Scr_EvaluateWatchChild(;
void Scr_EvaluateWatchNode(scriptInstance_t inst, _watchNode_t *node, int uniqueId);
void Scr_Msg_UpdateWatch(scriptInstance_t inst);
void Scr_Msg_ExpandWatch(scriptInstance_t inst);
void Scr_ReportThreadUsage(scriptInstance_t inst);
void Scr_ProcessDebugMessages(scriptInstance_t inst);
void Scr_WaitForDebuggerToRespond(scriptInstance_t inst);
void Scr_UpdateDebugger(scriptInstance_t inst);
unsigned __int8 Scr_HitBreakpoint(;
void Scr_TestDataBreakpoints(;
void Scr_TestNotifyBreakpoints(;

//t6/code/src_noserver/clientscript/cscr_evaluate.cpp
void TRACK_scr_evaluate();
void Scr_InitEvaluate();
void Scr_GetValueString(scriptInstance_t inst, unsigned int localId, VariableValue *value, int len, char *s);
void Scr_ClearValue(scriptInstance_t inst, VariableValue *value);
void Scr_EvalArrayVariableInternal(scriptInstance_t inst, VariableValue *parentValue, VariableValue *value);
void Scr_EvalLocalVariable(scriptInstance_t inst, sval_u expr, unsigned int localId, VariableValue *value);
unsigned int Scr_EvalObject(scriptInstance_t inst, sval_u classnum, sval_u entnum, VariableValue *value);
void Scr_EvalSelfValue(scriptInstance_t inst, VariableValue *value);
void Scr_GetValue(scriptInstance_t inst, unsigned int index, VariableValue *value);
void Scr_EvalFieldVariableInternal(;
void Scr_CompilePrimitiveExpressionList(scriptInstance_t inst, sval_u *exprlist);
void Scr_CompileCallExpressionList(scriptInstance_t inst, sval_u *exprlist);
bool Scr_CompileFunction(scriptInstance_t inst, sval_u *func_name, sval_u *params);
char Scr_CompileMethod(scriptInstance_t inst, sval_u *expr, sval_u *func_name, sval_u *params);
char Scr_CompileCallExpression(scriptInstance_t inst, sval_u *expr);
void Scr_PreEvalBuiltin(scriptInstance_t inst, sval_u params, unsigned int localId);
void Scr_PostEvalBuiltin(scriptInstance_t inst, VariableValue *value);
void Scr_EvalFunction(scriptInstance_t inst, sval_u func_name, sval_u params, unsigned int localId);
void Scr_EvalMethod(scriptInstance_t inst, sval_u expr, sval_u func_name, sval_u params, unsigned int localId);
void Scr_EvalCallExpression(scriptInstance_t inst, sval_u expr, unsigned int localId, VariableValue *value);
void Scr_EvalBoolOrExpression(;
void Scr_EvalBoolAndExpression(;
void Scr_EvalVector(;
void Scr_FreeDebugExprValue(scriptInstance_t inst, sval_u val);
unsigned int Scr_EvalPrimitiveExpressionFieldObject(;
void Scr_CompilePrimitiveExpressionFieldObject(scriptInstance_t inst, sval_u *expr);
void Scr_EvalVariableExpression(;
// void Scr_CompileVariableExpression(sval_u *a1@<edx>, scriptInstance_t inst, sval_u *expr);
void Scr_EvalPrimitiveExpression(;
void Scr_CompilePrimitiveExpression(scriptInstance_t inst, sval_u *expr);
void Scr_EvalExpression(;
void Scr_CompileExpression(scriptInstance_t inst, sval_u *expr);
void Scr_CompileTextInternal(scriptInstance_t inst, const char *text, ScriptExpression_t *scriptExpr);
void Scr_CompileText(scriptInstance_t inst, const char *text, ScriptExpression_t *scriptExpr);
char Scr_EvalScriptExpression(;
VariableValue *Scr_GetValue(scriptInstance_t inst, unsigned int index);

//t6/code/src_noserver/clientscript/cscr_instance.cpp
void Scr_ClearScrVarDebugPub(scriptInstance_t inst);
void Scr_ResetScrVarDebugPub(scriptInstance_t inst);
void Scr_ClearScrStringDebugGlob();
void Scr_ResetScrStringDebugGlob();

//t6/code/src_noserver/clientscript/cscr_main.cpp
char Scr_IsIdentifier(const char *token);
void Scr_BeginLoadAnimTrees(scriptInstance_t inst, int user);
int Scr_ScanFile(scriptInstance_t inst, char *buf, int max_size);
XAssetHeader Scr_LoadScriptInternal(scriptInstance_t inst, const char *filename);
XAssetHeader Scr_LoadScript(scriptInstance_t inst, const char *filename);
void Scr_PostCompileScripts(scriptInstance_t inst);
void Scr_EndLoadScripts(scriptInstance_t inst);
void Scr_PrecacheAnimTrees(scriptInstance_t inst, void *(*Alloc)(int), int user, bool modChecksum);
void Scr_EndLoadAnimTrees(scriptInstance_t inst);
void Scr_FreeScripts(scriptInstance_t inst, unsigned __int8 sys, bool shutdownStringSystem);
void Scr_SetGenericField(;
void Scr_BeginLoadScripts(scriptInstance_t inst, int user);
void Scr_GetGenericField(;

//t6/code/src_noserver/clientscript/cscr_memorytree.cpp
void TRACK_scr_memorytree();
void MT_GetSubTreeSize;
void MT_DumpTree(void);
int Scr_GetStringUsage();
void MT_InitBits;
void MT_GetScore;
void MT_AddMemoryNode;
void MT_RemoveMemoryNode;
void MT_RemoveHeadMemoryNode;
void MT_Init(void);
void MT_GetSize;
void MT_AllocIndex(int,int);
void MT_FreeIndex(uint,int);
void MT_Alloc(int,int);
void MT_Free(void *,int);
void MT_Realloc(int,int);

//t6/code/src_noserver/clientscript/cscr_obj_compiler.cpp
void Scr_StubErrorReport(scriptInstance_t inst);
void Scr_ServerStubFunctionUseError();
void Scr_ClientStubFunctionUseError();
void (*GetFunction(;
void (*GetMethod(;
void Scr_AutoExecFunctions(scriptInstance_t inst);
char Scr_IsBinaryObj(void *obj);
XModelPiece *Scr_GetGSCObj(scriptInstance_t inst, const char *name, bool appendExtension, bool errorIfMissing);
char Scr_ResolveScriptFunction(;
void LoadScriptGDB(scriptInstance_t inst);
void LoadScriptGDB(scriptInstance_t inst, objFileInfo_t *fileInfo);
_gscBuiltinProfileInfo_t *GscBuiltinProfileData(;
_gscBuiltinProfileInfo_t *GscBuiltinProfileData(;
const char *SL_GetCanonicalString(unsigned int canonId);
unsigned int SL_GetCanonicalString(const char *string, bool is_static);
unsigned __int8 *Scr_GetFunctionHandle(;
unsigned __int8 *Scr_GetFunctionHandle(;
unsigned __int8 *Scr_GetFunctionHandle(;
unsigned __int8 *Scr_GetDefaultFunctionHandle(scriptInstance_t inst);
gscProfileInfo_t *Scr_GetProfileInfo(scriptInstance_t inst, unsigned __int8 *addr);
objFileInfo_t *Scr_FindObjFileInfo(scriptInstance_t inst, void *addr);
void LoadScriptSource(debugFileInfo_t *fileInfo);
unsigned __int8 *Scr_FindLineAddress(scriptInstance_t __formal, objFileInfo_t *info, int lineNum);
int Scr_FindLineNum(scriptInstance_t __formal, objFileInfo_t *info, unsigned __int8 *pos);
objFileInfo_t *Scr_GetObjFileInfo(scriptInstance_t inst, const char *filename);
void Scr_SendFileList(scriptInstance_t inst);
unsigned __int8 *Scr_GetPosForFileAndLineNum(scriptInstance_t inst, const char *filename, int linenum);
void Scr_GetFileAndLineNum(;
void _ReportDeadCodeDebugger(scriptInstance_t inst);
void Scr_ReportDeadCode();
void Scr_ReportDeadCodeDebugger();
void _ReportScriptProfilerDebugger(scriptInstance_t inst);
void Scr_StopScriptProfiler();
void Scr_StopScriptProfilerDebuggerReport(scriptInstance_t inst);
void _ResetScriptProfiler(scriptInstance_t inst);
void Scr_ScriptProfilerActivate(scriptInstance_t inst);
void Scr_StartScriptProfiler(scriptInstance_t inst, int type, int threshold);
void Scr_ScriptProfileUpdateTotalTime(scriptInstance_t inst, unsigned __int64 time);
void _AdjustThreadInstructionPointers(;
unsigned __int8 *NextOpAddress(unsigned __int8 *op);
void Scr_UpdateObj(scriptInstance_t inst);
void Scr_ResetObjCompile(scriptInstance_t inst);
void ReportObjLinkError(;
int GscObjResolve(scriptInstance_t inst, GSC_OBJ *prime_obj, objFileInfo_t *objFileInfo);
int _GscObjLink(scriptInstance_t inst, GSC_OBJ *prime_obj, objFileInfo_t *objFileInfo, bool is_bin_update);
int GscObjLink(scriptInstance_t inst, GSC_OBJ *prime_obj);
void Scr_CheckPendingBinUpdate(scriptInstance_t inst);

//t6/code/src_noserver/clientscript/cscr_parser.cpp
void TRACK_scr_parser();
int Scr_GetLineNumInternal(;
char *Scr_ReadFile_FastFile(scriptInstance_t inst, const char *filename, const char *extFilename);
// char *Scr_ReadFile_LoadObj@<eax>(;
char *Scr_ReadFile(;
char *Scr_AddSourceBuffer(;
void Scr_CopyFormattedLine(char *line, const char *rawLine);
int Scr_GetLineInfo(const char *buf, unsigned int sourcePos, int *col, char *line, SourceBufferInfo *binfo);
void Scr_PrintSourcePos(;
void Scr_PrintPrevCodePosToBuf(scriptInstance_t inst, unsigned __int8 *codePos, unsigned int index, char *buf);
void Scr_PrintPrevCodePos(scriptInstance_t inst, int channel, unsigned __int8 *codePos);
const char *Scr_PrevCodePosFileName(scriptInstance_t inst, unsigned __int8 *codePos);
const char *Scr_PrevCodePosFunctionName(scriptInstance_t inst, unsigned __int8 *codePos);
bool Scr_PrevCodePosFileNameMatches(scriptInstance_t inst, unsigned __int8 *codePos, const char *fileName);
void Scr_PrintPrevCodePosSpreadSheet(;
void Scr_GetCodePos(;
void CompileError2(scriptInstance_t inst, unsigned __int8 *codePos, const char *msg, ...);
void RuntimeError(;

//t6/code/src_noserver/clientscript/cscr_parsetree.cpp
sval_u node1_(scriptInstance_t inst, int val1);
void Scr_InitAllocNode(scriptInstance_t inst);
void Scr_ShutdownAllocNode(scriptInstance_t inst);
sval_u node0(scriptInstance_t inst, unsigned __int8 type);
sval_u node1(scriptInstance_t inst, unsigned __int8 type, sval_u val1);
sval_u node2(scriptInstance_t inst, unsigned __int8 type, sval_u val1, sval_u val2);
sval_u node2_(scriptInstance_t inst, sval_u val1, sval_u val2);
sval_u node3(scriptInstance_t inst, unsigned __int8 type, sval_u val1, sval_u val2, sval_u val3);
sval_u node4(scriptInstance_t inst, unsigned __int8 type, sval_u val1, sval_u val2, sval_u val3, sval_u val4);
sval_u node5(;
sval_u node6(;
sval_u node7(;
sval_u node8(;
sval_u linked_list_end(scriptInstance_t inst, sval_u val);
sval_u prepend_node(scriptInstance_t inst, sval_u val1, sval_u val2);
sval_u append_node(scriptInstance_t inst, sval_u val1, sval_u val2);
void Scr_FreeDebugExpr(scriptInstance_t inst, ScriptExpression_t *expr);
sval_u debugger_node0(scriptInstance_t inst, unsigned __int8 type);
sval_u debugger_node1(scriptInstance_t inst, unsigned __int8 type, sval_u val1);
sval_u debugger_node2(scriptInstance_t inst, unsigned __int8 type, sval_u val1, sval_u val2);
sval_u debugger_node3(scriptInstance_t inst, unsigned __int8 type, sval_u val1, sval_u val2, sval_u val3);
sval_u debugger_node4(;
sval_u debugger_prepend_node(scriptInstance_t inst, sval_u val1, sval_u val2);
sval_u debugger_buffer(;
sval_u debugger_string(scriptInstance_t inst, unsigned __int8 type, const char *s);

//t6/code/src_noserver/clientscript/cscr_readwrite.cpp
unsigned int Scr_ReadString(scriptInstance_t inst, MemoryFile *memFile);
unsigned int Scr_ReadOptionalString(scriptInstance_t inst, MemoryFile *memFile);
const float *Scr_ReadVec3(scriptInstance_t inst, MemoryFile *memFile);
unsigned __int8 *Scr_ReadCodepos(scriptInstance_t inst, MemoryFile *memFile);
int Scr_ReadId(scriptInstance_t inst, MemoryFile *memFile, unsigned int opcode);
VariableStackBuffer *Scr_ReadStack(scriptInstance_t inst, MemoryFile *memFile);
void Scr_DoLoadEntryInternal(scriptInstance_t inst, VariableValue *value, MemoryFile *memFile);
int Scr_DoLoadEntry(scriptInstance_t inst, VariableValue *value, int isArray, MemoryFile *memFile);
unsigned int Scr_ConvertObjectFromLoad(scriptInstance_t inst, unsigned int index);
unsigned __int16 Scr_ConvertThreadFromLoad(scriptInstance_t inst, unsigned __int16 handle);
void Scr_DoLoadObjectInfo(scriptInstance_t inst, unsigned __int16 parentId, MemoryFile *memFile);
void Scr_LoadPre(scriptInstance_t inst, int sys, MemoryFile *memFile);
void Scr_LoadShutdown(scriptInstance_t inst);

//t6/code/src_noserver/clientscript/cscr_stringlist.cpp
void TRACK_scr_stringlist();
char *SL_ConvertToString(unsigned int stringValue);
char *SL_ConvertToStringSafe(unsigned int stringValue);
const char *SL_DebugConvertToString(unsigned int stringValue);
int SL_GetStringLen(unsigned int stringValue);
unsigned int GetHashCode(const char *str, unsigned int len);
unsigned int Scr_GetHashCode(const char *str);
void SL_Init();
unsigned int SL_FindStringOfSize(const char *str, unsigned int len);
unsigned int SL_FindString(const char *str);
unsigned int SL_FindLowercaseString(const char *str);
int SL_IsLowercaseString(unsigned int stringValue);
void SL_AddUserInternal(RefString *refStr, unsigned int user);
unsigned int SL_GetString(const char *str, unsigned int user);
unsigned int SL_GetLowercaseStringOfSize(const char *str, unsigned int user, unsigned int len, int type);
unsigned int SL_GetLowercaseString_(const char *str, unsigned int user, int type);
unsigned int SL_GetLowercaseString(const char *str, unsigned int user);
void SL_CheckExists(unsigned int stringValue);
void SL_AddRefToString(unsigned int stringValue);
void SL_FreeString(unsigned int stringValue, RefString *refStr, unsigned int len);
void SL_RemoveRefToString(unsigned int stringValue);
void SL_RemoveRefToStringOfSize(unsigned int stringValue, unsigned int len);
void Scr_SetStringLiveUpdateSafe(unsigned __int16 *to, const char *value);
void Scr_SetString(unsigned __int16 *to, unsigned int from);
void Scr_SetStringFromCharString(unsigned __int16 *to, const char *from);
unsigned int Scr_AllocString(const char *s, int sys);
unsigned int SL_GetStringForFloat(float f);
unsigned int SL_GetStringForInt(int i);
unsigned int SL_GetStringForVector(const float *v);
void SL_ShutdownSystem(unsigned int user);
void Scr_ShutdownGameStrings();
void SL_TransferSystem(unsigned int from, unsigned int to);
void SL_CreateCanonicalFilename(char *newFilename, const char *filename, int count);
unsigned int Scr_CreateCanonicalFilename(const char *filename);
void SL_CheckLeaks();
void SL_Shutdown();

//t6/code/src_noserver/clientscript/cscr_tempmemory.cpp
void TempMemoryReset(HunkUser *user);
unsigned __int8 *TempMalloc(int len);
unsigned __int8 *TempMallocAlignStrict(int len);
void TempMemorySetPos(unsigned __int8 *pos);

//t6/code/src_noserver/clientscript/cscr_variable.cpp
void TRACK_scr_variable();
void Scr_CheckObjectLeak(scriptInstance_t inst);
void Scr_CheckChildLeak(scriptInstance_t inst);
void Scr_CheckLeaks(scriptInstance_t inst);
int ThreadInfoCompare(const void *info1, const void *info2);
int VariableInfoFileNameCompare(const void *info1, const void *info2);
int VariableInfoFunctionCompare(const void *info1, const void *info2);
int VariableInfoCountCompare(const void *info1, const void *info2);
int VariableInfoFileLineCompare(const void *info1, const void *info2);
void Scr_InitClassMap(scriptInstance_t inst);
void Scr_InitObjectVariables(scriptInstance_t inst);
void Scr_InitVariables(scriptInstance_t inst);
int Scr_GetNumScriptVarsParent(scriptInstance_t inst);
int Scr_GetNumScriptVarsChild(scriptInstance_t inst);
int GetVariableKeyObject(scriptInstance_t inst, unsigned int id);
unsigned __int16 FindVariableIndexInternal2(;
unsigned int FindVariable(scriptInstance_t inst, unsigned int parentId, unsigned int name);
ChildVariableValue *AllocChildVariable(scriptInstance_t inst, unsigned __int16 *index);
unsigned __int16 GetNewVariableIndexInternal3(;
unsigned __int16 GetNewVariableIndexInternal2(;
unsigned __int16 GetNewVariableIndexReverseInternal2(;
unsigned __int16 GetNewVariable(scriptInstance_t inst, unsigned int parentId, unsigned int name);
unsigned __int16 GetNewVariableIndexReverseInternal(;
int GetVariable(scriptInstance_t inst, unsigned int parentId, unsigned int name);
void FreeChildValuePart1(;
void FreeChildValuePart2(scriptInstance_t inst, ChildVariableValue *value, unsigned int parentId);
void FreeChildValuePart3(scriptInstance_t inst, ChildVariableValue *value, unsigned __int16 index);
void RemoveVariableValue(scriptInstance_t inst, unsigned int parentId, unsigned int index);
void ClearObjectInternal(scriptInstance_t inst, unsigned int parentId);
void Scr_SetThreadNotifyName(scriptInstance_t inst, unsigned int startLocalId, unsigned int stringValue);
unsigned int Scr_GetThreadNotifyName(scriptInstance_t inst, unsigned int startLocalId);
void Scr_SetThreadWaitTime(scriptInstance_t inst, unsigned int startLocalId, unsigned int waitTime);
void Scr_ClearWaitTime(scriptInstance_t inst, unsigned int startLocalId);
unsigned int Scr_GetThreadWaitTime(scriptInstance_t inst, unsigned int startLocalId);
unsigned int GetParentLocalId(scriptInstance_t inst, unsigned int threadId);
unsigned int GetSafeParentLocalId(scriptInstance_t inst, unsigned int threadId);
unsigned int GetStartLocalId(scriptInstance_t inst, unsigned int threadId);
ObjectVariableValue *AllocVariable(scriptInstance_t inst, unsigned int *index);
void FreeVariable(scriptInstance_t inst, unsigned int index);
unsigned int AllocValue(scriptInstance_t inst);
unsigned int AllocObject(scriptInstance_t inst);
unsigned int AllocEntity(;
scriptInstance_t Scr_AllocArray(scriptInstance_t inst);
unsigned int AllocThread(scriptInstance_t inst, unsigned int self);
unsigned int AllocChildThread(scriptInstance_t inst, unsigned int self, unsigned int parentLocalId);
unsigned int Scr_GetSelf(scriptInstance_t inst, unsigned int threadId);
void FreeValue(;
void RemoveRefToEmptyObject(scriptInstance_t inst, unsigned int id);
float *Scr_AllocVector(scriptInstance_t inst);
vec3_t *Scr_AllocVector(scriptInstance_t inst, const vec3_t *v);
BOOL IsValidArrayIndex(scriptInstance_t inst, unsigned int unsignedValue);
unsigned int GetInternalVariableIndex(scriptInstance_t inst, unsigned int unsignedValue);
unsigned int FindArrayVariable(scriptInstance_t inst, unsigned int parentId, int intValue);
unsigned int FindObjectVariable(scriptInstance_t inst, unsigned int parentId, unsigned int id);
unsigned int GetArrayVariable(scriptInstance_t inst, unsigned int parentId, unsigned int unsignedValue);
unsigned int GetNewArrayVariable(scriptInstance_t inst, unsigned int parentId, unsigned int unsignedValue);
unsigned int Scr_GetVariableFieldIndex(scriptInstance_t inst, unsigned int parentId, unsigned int name);
unsigned int Scr_FindAllVariableField(;
unsigned int GetObjectVariable(scriptInstance_t inst, unsigned int parentId, unsigned int id);
unsigned int GetNewObjectVariable(scriptInstance_t inst, unsigned int parentId, unsigned int id);
unsigned int GetNewObjectVariableReverse(scriptInstance_t inst, unsigned int parentId);
void RemoveVariable(scriptInstance_t inst, unsigned int parentId, unsigned int unsignedValue);
void RemoveNextVariable(scriptInstance_t inst, unsigned int parentId);
void RemoveObjectVariable(scriptInstance_t inst, unsigned int parentId, unsigned int id);
void RemoveArrayVariable(scriptInstance_t inst, unsigned int parentId, unsigned int unsignedValue);
void SafeRemoveVariable(scriptInstance_t inst, unsigned int parentId, unsigned int unsignedValue);
void CopyArray(scriptInstance_t inst, unsigned int parentId);
VariableUnion *GetVariableValueAddress(scriptInstance_t inst, unsigned int id);
void SetVariableEntityFieldValue(;
void ClearVariableValue(scriptInstance_t inst, unsigned int id);
void SetVariableFieldValue(scriptInstance_t inst, unsigned int id, VariableValue *value);
void SetVariableFieldValue(scriptInstance_t inst, VariableValue *value);
VariableValue Scr_EvalVariableEntityField(scriptInstance_t inst, unsigned int entId, unsigned int fieldName);
int Scr_EvalVariableField(scriptInstance_t inst, unsigned int id);
unsigned int GetArraySize(scriptInstance_t inst, unsigned int id);
unsigned int GetObject(scriptInstance_t inst, unsigned int id);
unsigned int GetArray(scriptInstance_t inst, unsigned int id);
unsigned int FindObject(scriptInstance_t inst, unsigned int id);
BOOL IsFieldObject(scriptInstance_t inst, unsigned int id);
BOOL Scr_IsThreadAlive(scriptInstance_t inst, unsigned int thread);
void Scr_EvalBoolNot(scriptInstance_t inst, VariableValue *value);
void Scr_EvalBoolComplement(scriptInstance_t inst, VariableValue *value);
int Scr_CastBool_NonInteger(scriptInstance_t inst, VariableValue *value);
char Scr_CastString(scriptInstance_t inst, VariableValue *value);
void Scr_ClearVector(scriptInstance_t inst, VariableValue *value);
void Scr_CastVector(scriptInstance_t inst, VariableValue *value);
VariableUnion Scr_EvalFieldObject(scriptInstance_t inst, unsigned int tempVariable, VariableValue *value);
bool IsObjectFree(scriptInstance_t inst, unsigned int id);
int GetValueType(scriptInstance_t inst, unsigned int id);
unsigned int GetObjectType(scriptInstance_t inst, unsigned int id);
void Scr_FreeEntityNum(scriptInstance_t inst, int entnum, unsigned int classnum);
void Scr_SetClassMap(scriptInstance_t inst, unsigned int classnum);
void Scr_AddClassField(scriptInstance_t inst, unsigned int classnum, const char *name, unsigned int offset);
int Scr_GetOffset(scriptInstance_t inst, unsigned int classnum, const char *name);
unsigned int FindEntityId(scriptInstance_t inst, int entnum, unsigned int classnum, LocalClientNum_t clientNum);
unsigned int Scr_GetEntityId(;
unsigned int Scr_FindArrayIndex(scriptInstance_t inst, unsigned int parentId, VariableValue *index);
unsigned int Scr_FindArrayIndex2(scriptInstance_t inst, unsigned int parentId, VariableValue *index);
void SetEmptyArray(scriptInstance_t inst, unsigned int parentId);
VariableValue Scr_GetArrayValue(scriptInstance_t inst, unsigned int id);
void Scr_AddArrayKeys(scriptInstance_t inst, unsigned int parentId);
scriptInstance_t Scr_FirstArrayKey(scriptInstance_t inst, unsigned int parentId, unsigned int parentIda);
scriptInstance_t Scr_NextArrayKey(;
void Scr_AddFirstArrayKey(scriptInstance_t inst, unsigned int parentId);
void Scr_AddNextArrayKey(scriptInstance_t inst, unsigned int parentId, VariableValue *value);
void Scr_AddLastArrayKey(scriptInstance_t inst, unsigned int parentId);
void Scr_AddPrevArrayKey(scriptInstance_t inst, unsigned int parentId, VariableValue *value);
int Scr_GetEntityIdRef(scriptInstance_t inst, unsigned int entId);
void CopyEntity(scriptInstance_t inst, unsigned int parentId, unsigned int newParentId);
void Scr_CopyEntityNum(scriptInstance_t inst, int fromEntnum, int toEntnum, unsigned int classnum);
// double Scr_GetEntryUsage(scriptInstance_t inst, bitarray<24576> *visitBits, unsigned int type, VariableUnion u);
double Scr_GetEndonObjectUsage(scriptInstance_t inst, unsigned int selfNameId);
double Scr_GetEndonUsage(scriptInstance_t inst, unsigned int parentId);
unsigned int Scr_FindField(scriptInstance_t inst, const char *name, int *type);
// char *Scr_GetSourceFile_LoadObj@<eax>(const char *a1@<edx>, const char *a2@<ecx>, const char *filename);
XModelPiece *Scr_GetSourceFile_FastFile(const char *filename);
// void Scr_AddFieldsForFile(int a1@<edx>, int a2@<ecx>, scriptInstance_t inst, const char *filename);
void Scr_AddFields_LoadObj(scriptInstance_t inst, const char *path, const char *extension);
void Scr_AddFields_FastFile(scriptInstance_t inst, const char *path, const char *extension);
void Scr_AddFields();
int Scr_MakeValuePrimitive(scriptInstance_t inst, unsigned int parentId);
void Scr_AllocGameVariable(scriptInstance_t inst);
// void Scr_FreeGameVariable(ChildVariableValue *a1@<edx>, scriptInstance_t inst, int bComplete);
void Scr_GetChecksumNoAsserts(scriptInstance_t inst, int *checksum);
void Scr_GetChecksum(scriptInstance_t inst, int *checksum);
int Scr_GetClassnumForCharId(scriptInstance_t inst, char charId);
unsigned int Scr_FindAllThreads(scriptInstance_t inst, unsigned int *threads);
int Scr_FindAllThreads(scriptInstance_t inst, unsigned int selfId, unsigned int *threads, unsigned int localId);
unsigned int Scr_FindAllEndons(scriptInstance_t inst, unsigned int threadId, unsigned int *names);
void ArrayInsertVariable(;
void ArrayRegenerateKeys(scriptInstance_t inst, unsigned int arrayId);
char IsInArray(scriptInstance_t inst, unsigned int arrayId, VariableValue *value);
void Scr_DumpScriptVariables(;
void Scr_DumpScriptVariablesDefault(scriptInstance_t inst);
// void Scr_ShutdownVariables(ChildVariableValue *a1@<edx>, scriptInstance_t a2@<ecx>, scriptInstance_t inst);
void ClearObject(scriptInstance_t inst, unsigned int parentId);
void Scr_RemoveThreadNotifyName(scriptInstance_t inst, unsigned int startLocalId);
void RemoveRefToObject(scriptInstance_t inst, unsigned int id);
int Scr_FindVariableField(scriptInstance_t inst, unsigned int parentId, unsigned int name);
void ClearVariableField(scriptInstance_t inst, unsigned int parentId, unsigned int name, VariableValue *value);
void SafeRemoveArrayVariable(scriptInstance_t inst, unsigned int parentId, unsigned int unsignedValue);
void Scr_EvalSizeValue(scriptInstance_t inst, VariableValue *value);
void Scr_CastDebugString(scriptInstance_t inst, VariableValue *value);
char Scr_GetEntClassId(scriptInstance_t inst, unsigned int id);
int Scr_GetEntNum(scriptInstance_t inst, unsigned int id);
void Scr_UnmatchingTypesError(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_CastWeakerPair2(;
void Scr_CastWeakerStringPair(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalOr(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalExOr(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalAnd(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalEquality(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalInequality(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalLess(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalGreaterEqual(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalGreater(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalLessEqual(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalShiftLeft(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalShiftRight(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalPlus(;
void Scr_EvalMinus(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalMultiply(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalDivide(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalMod(scriptInstance_t inst, VariableValue *value1, VariableValue *value2);
void Scr_EvalBinaryOperator(scriptInstance_t inst, int op, VariableValue *value1, VariableValue *value2);
void Scr_FreeEntityList(scriptInstance_t inst);
void Scr_FreeObjects(scriptInstance_t inst);
void Scr_RemoveClassMap(scriptInstance_t inst, unsigned int classnum);
void Scr_EvalArray(scriptInstance_t inst, VariableValue *value, VariableValue *index);
unsigned int Scr_EvalArrayRef(scriptInstance_t inst, unsigned int id);
void ClearArray(scriptInstance_t inst, unsigned int id, VariableValue *value);
// double Scr_GetObjectUsage(scriptInstance_t inst, bitarray<24576> *visitBits, unsigned int parentId);
void Scr_FreeValue(scriptInstance_t inst, unsigned int id);
void ArrayRemoveVariable(scriptInstance_t inst, unsigned int arrayId, VariableValue *value, bool preserve_keys);
void ArrayRemoveVariable(scriptInstance_t inst, unsigned int arrayId, unsigned int index, bool preserve_keys);
void ArrayCombine(scriptInstance_t inst, unsigned int a, unsigned int b, bool allowDupes, bool preserveKeys);
void Scr_ClearThread(scriptInstance_t inst, unsigned int parentId);
void Scr_StopThread(;
void Scr_KillEndonThread(scriptInstance_t inst, unsigned int threadId);
double Scr_GetThreadUsage(scriptInstance_t inst, const VariableStackBuffer *stackBuf, float *endonUsage);
void Scr_DumpScriptThreads(scriptInstance_t inst);
void Scr_KillThread(;

//t6/code/src_noserver/clientscript/cscr_vm.cpp
void TRACK_scr_vm();
void Scr_ClearErrorMessage(scriptInstance_t inst);
void Scr_FindDataCycles(scriptInstance_t inst);
void Scr_ReportDataCycles();
void Scr_VM_Init(scriptInstance_t inst);
void Scr_Init(scriptInstance_t inst);
void Scr_Settings(scriptInstance_t inst, int developer, int developer_script, int abort_on_error);
// void Scr_Shutdown(ChildVariableValue *a1@<edx>, scriptInstance_t a2@<ecx>, scriptInstance_t inst);
void Scr_SetLoading(scriptInstance_t inst, int bLoading);
void Scr_ErrorInternal(scriptInstance_t inst);
unsigned int Scr_GetLevelObjectId(scriptInstance_t inst);
int Scr_GetNumScriptThreads(scriptInstance_t inst);
void Scr_ClearOutParams(scriptInstance_t inst);
void CodeBreakpoints_Set(scriptInstance_t inst, const char *filename, int lineNum);
void CodeBreakpoints_Init(scriptInstance_t inst);
void Scr_ReportLongCallWarning(scriptInstance_t inst, unsigned __int8 *pos);
unsigned __int8 *Scr_GetReturnPos(scriptInstance_t inst, unsigned int *localId);
void VM_CancelNotifyInternal(;
void VM_CancelNotify(scriptInstance_t inst, unsigned int notifyListOwnerId, unsigned int startLocalId);
VariableStackBuffer *VM_ArchiveStack(;
int Scr_AddLocalVars(scriptInstance_t inst, unsigned int localId);
void VM_UnarchiveStack(scriptInstance_t inst, unsigned int startLocalId, const VariableStackBuffer *stackValue);
void VM_TerminateStack(;
unsigned __int8 *Scr_GetStackThreadPos(;
void Scr_SetStackThreadPos(;
void VM_TrimStack(;
void Scr_TerminateRunningThread(scriptInstance_t inst, unsigned int localId);
unsigned __int8 *Scr_GetRunningThreadPos(scriptInstance_t inst, unsigned int localId);
void Scr_SetRunningThreadPos(scriptInstance_t inst, unsigned int localId, unsigned __int8 *codePos);
void Scr_TerminateWaitThread(scriptInstance_t inst, unsigned int localId, unsigned int startLocalId);
unsigned int Scr_GetWaitThreadStackId(;
void Scr_CancelWaittill(scriptInstance_t inst, unsigned int startLocalId);
void Scr_TerminateWaittillThread(scriptInstance_t inst, unsigned int localId, unsigned int startLocalId);
unsigned int Scr_GetWaittillThreadStackId(;
void Scr_TerminateThread(scriptInstance_t inst, unsigned int localId);
unsigned __int8 *Scr_GetThreadPos(scriptInstance_t inst, unsigned int localId);
void Scr_SetThreadPos(scriptInstance_t inst, unsigned int localId, unsigned __int8 *codePos);
void VM_Notify(;
void Scr_NotifyId(;
void Scr_NotifyNum(int entnum, unsigned int classnum, unsigned int stringValue, unsigned int paramcount);
void CScr_NotifyNum(;
void Scr_NotifyLevel(unsigned int stringValue);
void CScr_NotifyLevel(LocalClientNum_t clientNum, unsigned int stringValue);
void Scr_NotifyLevel(const char *notifyString);
void CScr_NotifyLevel(LocalClientNum_t clientNum, const char *notifyString);
void Scr_CancelNotifyList(scriptInstance_t inst, unsigned int notifyListOwnerId);
void VM_TerminateTime(scriptInstance_t inst, unsigned int timeId);
void IncInParam(scriptInstance_t inst);
void Scr_FreeThread(scriptInstance_t inst, unsigned __int16 handle);
bool Scr_IsSystemInitied(scriptInstance_t inst);
void Scr_InitSystem(scriptInstance_t inst, int sys);
BOOL Scr_IsSystemActive(scriptInstance_t inst);
int Scr_GetNumParam(scriptInstance_t inst);
void Scr_AddBool(scriptInstance_t inst, int value);
void Scr_AddInt(scriptInstance_t inst, int value);
void Scr_AddFloat(scriptInstance_t inst, float value);
void Scr_AddAnim(scriptInstance_t inst, scr_anim_s value);
void Scr_AddUndefined(scriptInstance_t inst);
void Scr_AddObject(scriptInstance_t inst, unsigned int id);
void Scr_AddEntityNum(scriptInstance_t inst, int entnum, unsigned int classnum, LocalClientNum_t clientNum);
void Scr_AddString(scriptInstance_t inst, const char *value);
void Scr_AddIString(scriptInstance_t inst, const char *value);
void Scr_AddConstString(scriptInstance_t inst, unsigned int value);
void Scr_AddVectorInternal(scriptInstance_t inst, const vec3_t *value);
void Scr_AddVector(scriptInstance_t inst, const vec3_t *value);
void Scr_AddValue(scriptInstance_t inst, VariableValue *value);
void Scr_MakeArray(scriptInstance_t inst);
void Scr_AddArray(scriptInstance_t inst);
void Scr_AddArrayStringIndexed(scriptInstance_t inst, unsigned int stringValue);
void Scr_Error(scriptInstance_t inst, const char *error, bool force_terminal);
void Scr_TerminalError(scriptInstance_t inst, const char *error);
void Scr_ParamError(scriptInstance_t inst, unsigned int index, const char *error);
void Scr_ObjectError(scriptInstance_t inst, const char *error);
char SetEntityFieldValue(;
VariableValue GetEntityFieldValue(;
void Scr_SetStructField(scriptInstance_t inst, unsigned int structId, unsigned int index);
void Scr_SetDynamicEntityField(;
void Scr_DecTime(scriptInstance_t inst);
void Scr_GetLastScriptPlace(scriptInstance_t inst, int *line, const char **filename);
void Scr_RegisterNotifyListener(scriptInstance_t inst, void (*cbFunc)(unsigned int, unsigned int));
void Scr_AddTeam(scriptInstance_t inst, int team);
int Scr_IsTrue(scriptInstance_t inst, VariableValue *value);
void Scr_GetDvar(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarInt(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarFloat(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarVector(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarColorRed(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarColorGreen(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarColorBlue(scriptInstance_t inst, VariableValue *v);
void Scr_GetDvarColorAlpha(scriptInstance_t inst, VariableValue *v);
unsigned int VM_Execute(scriptInstance_t inst);
unsigned __int8 *Scr_GetNextCodepos(;
void VM_Resume(scriptInstance_t inst, unsigned int timeId);
unsigned int VM_Execute_0(;
__int16 Scr_ExecThread(scriptInstance_t inst, int handle, unsigned int paramcount);
__int16 Scr_ExecEntThreadNum(;
void Scr_AddExecThread(scriptInstance_t inst, int handle, unsigned int paramcount);
void Scr_ExecCode(scriptInstance_t inst, unsigned __int8 *pos, unsigned int localId);
void VM_SetTime(scriptInstance_t inst);
void Scr_ShutdownSystem(scriptInstance_t inst, unsigned __int8 sys, bool bComplete);
int Scr_GetInt(scriptInstance_t inst, unsigned int index);
scr_anim_s Scr_GetAnim(scriptInstance_t inst, unsigned int index);
scr_animtree_t Scr_GetAnimTree(scriptInstance_t inst, unsigned int index, unsigned int user);
double Scr_GetFloat(scriptInstance_t inst, unsigned int index);
VariableUnion Scr_GetConstString(scriptInstance_t inst, unsigned int index);
VariableUnion Scr_GetConstLowercaseString(scriptInstance_t inst, unsigned int index);
char *Scr_GetString(scriptInstance_t inst, unsigned int index);
VariableUnion Scr_GetConstStringIncludeNull(scriptInstance_t inst, unsigned int index);
char *Scr_GetDebugString(scriptInstance_t inst, unsigned int index);
unsigned int Scr_GetConstIString(scriptInstance_t inst, unsigned int index);
char *Scr_GetIString(scriptInstance_t inst, unsigned int index);
void Scr_GetVector(scriptInstance_t inst, unsigned int index, vec3_t *vectorValue);
int Scr_GetFunc(scriptInstance_t inst, unsigned int index);
int Scr_GetEntityRef(scriptInstance_t inst, unsigned int index);
unsigned int Scr_GetObject(scriptInstance_t inst, unsigned int index);
int Scr_GetType(scriptInstance_t inst, unsigned int index);
const char *Scr_GetTypeName(scriptInstance_t inst, unsigned int index);
unsigned int Scr_GetPointerType(scriptInstance_t inst, unsigned int index);
void Scr_RunCurrentThreads(scriptInstance_t inst);
int Scr_GetTeam(scriptInstance_t inst, unsigned int index);
void Scr_IncTime(scriptInstance_t inst);

//t6/code/src_noserver/clientscript/scr_lex.h
int yy_get_previous_state();
int yy_try_NUL_trans(int yy_current_state);
void yy_flush_buffer(yy_buffer_state *b);
void __noreturn yy_fatal_error(const char *msg);
yy_buffer_state *yy_create_buffer(_iobuf *file, int size);
void yyrestart(_iobuf *input_file);
int yy_get_next_buffer();
int yylex();

//t6/code/src_noserver/clientscript/scr_lex.txt
int StringValue(char *str, int len);

//t6/code/src_noserver/clientscript/scr_stringlist.h
RefString *GetRefString(unsigned int stringValue);

//t6/code/src_noserver/clientscript/scr_variable.h
void AddRefToObject(scriptInstance_t inst, unsigned int id);
void AddRefToVector(scriptInstance_t inst, const float *vectorValue);
void RemoveRefToVector(scriptInstance_t inst, const float *vectorValue);
void AddRefToValue(scriptInstance_t inst, VariableValue *value);
void RemoveRefToValue(scriptInstance_t inst, VariableValue *value);
unsigned int FindLastSibling(scriptInstance_t inst, unsigned int parentId);
unsigned int FindFirstSibling(scriptInstance_t inst, unsigned int parentId);
unsigned int FindNextSibling(scriptInstance_t inst, unsigned int id);
// int __thiscall ChildVariableValue::GetName(ChildVariableValue *this);
void SetVariableValue(scriptInstance_t inst, unsigned int id, int type, VariableUnion u);
void SetNewVariableValue(scriptInstance_t inst, unsigned int id, int type, VariableUnion u);
void SetNewVariableValue(scriptInstance_t inst, unsigned int id, int intValue);
void SetNewVariableValue(scriptInstance_t inst, unsigned int id, float floatValue);
int Scr_EvalVariable(scriptInstance_t inst, unsigned int id);
int GetVariableName(scriptInstance_t inst, unsigned int id);
int Scr_GetArrayIndexValue(scriptInstance_t inst, unsigned int name);
int Scr_GetVariableName(scriptInstance_t inst, unsigned int id);
unsigned int FindPrevSibling(scriptInstance_t inst, unsigned int id);
void SetNewVariableValue(scriptInstance_t inst, unsigned int id, VariableStackBuffer *stackValue);

//t6/code/src_noserver/clientscript/scr_yacc.txt
unsigned int LowerCase(unsigned int stringValue);
void ScriptParse(scriptInstance_t inst, sval_u *parseData, unsigned __int8 user);

//t6/code/src_noserver/client_mp/cl_cgame_mp.cpp
void CL_GetScreenDimensions(int *width, int *height, float *aspect);
double CL_GetScreenAspectRatioDisplayPixel();
int CL_GetUserCmd(LocalClientNum_t localClientNum, int cmdNumber, usercmd_s *ucmd);
void CL_AdjustUserCmdAngles(LocalClientNum_t localClientNum, int cmdNumber, vec3_t *adjust);
int CL_GetCurrentCmdNumber(LocalClientNum_t localClientNum);
void CL_GetCurrentSnapshotNumber(LocalClientNum_t localClientNum, int *snapshotNumber, int *serverTime);
void CheckEntityNumber(const entityState_s *es, bool *foundArray);
int CL_GetSnapshot(LocalClientNum_t localClientNum, int snapshotNumber, snapshot_s *snapshot);
void CL_SetUserCmdWeapons(;
void CL_SetUserCmdAimValues(LocalClientNum_t localClientNum, const vec3_t *kickAngles);
void CL_SetUserCmdOrigin(;
void CL_SetUserCmdVehicle(LocalClientNum_t localClientNum, const PlayerVehicleState *playerVehState);
void CL_SetFOVSensitivityScale(LocalClientNum_t localClientNum, float scale);
void CL_DumpReliableCommands(LocalClientNum_t localClientNum);
void CL_SetExpectedHunkUsage(const char *mapname);
void CL_CM_LoadMap(const char *mapname);
void CL_CM_LoadAddOnMapEnts(const char *addon_mapname);
void CL_ShutdownAllClientsCGame();
int CL_DObjCreateSkelForBone(DObj *obj, int boneIndex, DObjAnimMat **pMatOut);
void CL_SubtitlePrint(LocalClientNum_t localClientNum, const char *text, int duration, int lineWidth);
char *CL_GetConfigString(int configStringIndex);
unsigned int CL_GetConfigStringChecksum(int configStringBase, int configStringIndex, int indexBits);
void CL_GetDebugViewForward(vec3_t *forward);
void CL_GetDebugViewPos(vec3_t *pos);
void CL_RenderScene(;
void CL_RenderExtraCam(const refdef_t *fd, int frameTime, const GfxExtraCamParms *extraCamParms);
void CL_SetFullScreenViewport();
void CL_SetCustomConstant(unsigned int type, const vec4_t *vec);
void CL_DrawStretchPicPhysicalInternal(;
void CL_DrawStretchPicPhysicalDPInternal(;
void CL_DrawStretchPicPhysicalDPx2Internal(;
void CL_DrawStretchPicPhysicalWInternal(;
void CL_DrawStretchPicPhysicalRotateXYInternal(;
void CL_DrawStretchPicWDPInternal(;
void CL_DrawStretchPicInternal(;
void CL_DrawStretchPicDPInternal(;
void CL_DrawStretchPicRotatedSTInternal(;
void CL_CapTurnRate(LocalClientNum_t localClientNum, float maxPitchSpeed, float maxYawSpeed);
void CL_SetViewAngles(LocalClientNum_t localClientNum, const vec3_t *angles);
void CL_AdjustViewAngles(LocalClientNum_t localClientNum, const vec3_t *adjust);
void CL_ClampViewAngle(LocalClientNum_t localClientNum, const int angle, const float min, const float max);
void CL_SetupScreenPlacements();
void CL_UpdateLevelHunkUsage();
void CL_StartLoading();
void CL_InitCGame(LocalClientNum_t localClientNum);
void CL_RestartCGame(LocalClientNum_t localClientNum);
void CL_ResetServerTimeDelta(LocalClientNum_t localClientNum);
void CL_AdjustTimeDelta(LocalClientNum_t localClientNum);
void CL_FirstSnapshot(LocalClientNum_t localClientNum);
void CL_ForceNewSnapshots();
void CL_SetCGameTime(LocalClientNum_t localClientNum);
void CL_SetADS(LocalClientNum_t localClientNum, bool ads);
void CL_DrawString(int x, int y, const char *pszString, int bShadow, int iCharHeight);
void CL_LookupColor(unsigned __int8 c, vec4_t *color);
bool CL_IsServerRestarting(LocalClientNum_t localClientNum);
void CL_FixupSmodelCullOutDists(const char *mapname);
// void CL_SetExtraButtons(LocalClientNum_t localClientNum, bitarray<64> *button_bits);
void CL_ConfigstringModified(LocalClientNum_t localClientNum);
int CL_CGameNeedsServerCommand(LocalClientNum_t localClientNum, int serverCommandNumber);
void CL_SyncTimes(LocalClientNum_t localClientNum);
int LoadWorld(const char *mapname);

//t6/code/src_noserver/client_mp/cl_input_mp.cpp
bool CG_IsRemoteGuidingMissile(LocalClientNum_t localClientNum);
void CL_FinishMove(LocalClientNum_t localClientNum, usercmd_s *cmd);
void CL_WritePacket(LocalClientNum_t localClientNum);

//t6/code/src_noserver/client_mp/cl_main_mp.cpp
void CL_AddReliableCommand(LocalClientNum_t localClientNum, const char *cmd);
// void CL_MapLoading_SetupDevmap(int a1@<ebx>);
void CL_FinishMatchHistoryForController(const ControllerIndex_t localControllerIndex);
void CL_Disconnect(LocalClientNum_t localClientNum, bool deactivateClient);
void CL_FreePerLocalClientMemory(bool restartUi);
char CL_ShouldAllowInGameMenu(LocalClientNum_t localClientNum);
void CL_ToggleMenu(LocalClientNum_t localClientNum);
void CL_PauseGame(bool state);
void CL_ResetStats_f();
void CL_ReportUser_f();
void CL_Live_DisbandPartyAfterRound();
void CL_Project_RegisterDvars();
void CL_Project_RemoveCommands();
void CL_OpenIngame_ChangeClass_f();
void AllocatePerLocalClientMemory(int maxLocalClients, int maxClients, int flags);
char CL_AllocatePerLocalClientMemory(const char *mapname, int flags);
void CL_Project_RegisterCommands();

//t6/code/src_noserver/client_mp/cl_milestone.cpp
int CL_GetMilestoneRowNum(;
int CL_GetChallengeType(const char *statsType);
int ParseItemIndex(challengeTableRow_t *challengeRow, const char *reference);
void CountNonWeaponChallenges(int challengeType);
void CountWeaponChallenges(int challengeType);
challengeTableRow_t *FindFirstChallengeRowBSearch(int startEntry, int numEntries, int statNameHash);
// challengeTableRow_t *CL_FindFirstChallengeRow@<eax>(;
challengeTableRow_t *CL_FindFirstWeaponChallengeRow(int challengeType, int statNameHash, int itemIndex);
bool CL_IsChallengeLocked(challengeTableRow_t *challengeRow, int rank, int pLevel);
challengeTableRow_t *FindNextCompletedChallenge(;
challengeTableRow_t *CL_GetNextCompletedChallenge(;
challengeTableRow_t *CL_GetChallengeRowByIndex(unsigned __int16 index);
challengeTableRow_t *CL_FindChallegeRowForWeaponOption(int itemIndex, int weaponOption);
challengeTableRow_t *CL_GetUniqueChallengeRow(unsigned int challengeIndex);
void CheckNameCollision(const char *name1, const char *name2);
const char *CL_GetChallengeRowData(challengeTableRow_t *challengeRow, milestoneTableColumns_t column);
const char *CL_GetChallengeStatNameByName(;
const char *CL_GetItemChallengeStatNameByName(const char *statName, int itemIndex);
const char *CL_GetGroupChallengeStatNameByName(const char *statName, int groupIndex);
const char *CL_GetAttachmentChallengeStatNameByName(const char *statName, int attachmentIndex);
const char *CL_GetGameTypeChallengeStatNameByName(const char *statName, int gameTypeIndex);
// const char *CL_GetChallengeStatName@<eax>(;
void ParseChallengeExceptions(;
// challengeTableRow_t *CompareChallengeEntries@<eax>(;
const char *GetChallengeStatNameSuffix(challengeTableRow_t *challengeRow);
void CheckStatNames(;
void BuildChallengeTable();

//t6/code/src_noserver/client_mp/cl_net_chan_mp.cpp
void CL_Netchan_TransmitNextFragment(netchan_t *chan);
void CL_Netchan_Transmit(netchan_t *chan, unsigned __int8 *data, int length);
void CL_Netchan_AddOOBProfilePacket(LocalClientNum_t localClientNum, int iLength);
void CL_Netchan_PrintProfileStats(LocalClientNum_t localClientNum, int bPrintToConsole);

//t6/code/src_noserver/client_mp/cl_parse_mp.cpp
int CL_DeltaEntity(;
entityState_s *CL_GetEntityStateForFrame(clientActive_t *cl, const clSnapshot_t *frame, const int index);
int CL_ParsePacketEntities(;
void CL_ReadPerformanceData(clientActive_t *cl, msg_t *msg, int numChangedEnts);
bool CL_CheckForSnapshotValidity(clientActive_t *cl, clSnapshot_t *old, int deltaNum);
void CL_ParseSnapshot(LocalClientNum_t localClientNum, msg_t *msg);

//t6/code/src_noserver/client_mp/cl_pose_mp.cpp
char *CL_AllocSkelMemory(unsigned int size);
int CL_GetSkelTimeStamp();
int CL_DObjCreateSkelForBones(const DObj *obj, int *partBits, DObjAnimMat **pMatOut);

//t6/code/src_noserver/client_mp/cl_rank.cpp
void CL_ParseUnlocks(int row, int column, const StringTable *table, unsigned __int8 *unlocks);
unsigned __int8 *CL_GetUnlocksForRankID(const int rankID);
void __thiscall CL_BuildRankXPTable(const StringTable *this);
int CL_GetMaxXP();
int CL_GetMaxPrestige();
int CL_GetMinXPForRankID(int rankID);
int CL_GetMaxXPForRankID(int rankID);
int CL_GetRankForXp(int xp);
const char *CL_GetRankData(int rank, rankTableColumns_t column);
const char *CL_GetRankIconName(int rank, int prestige);
const char *CL_GetZombieRankIconName(int rank, int lastDaysPlayed);
void CL_BuildRankTierTable();
int CL_GetZombieRank(unsigned int timePlayed, unsigned int weightedDowns, unsigned int weightedRounds);
void CL_GetRankIcon(int rank, int prestige, Material **handle);
void CL_GetZombieRankIcon(int rank, int lastDaysPlayed, Material **handle);

//t6/code/src_noserver/client_mp/cl_scrn_mp.cpp
void SCR_DrawSmallStringExt(int x, int y, const char *string, const vec4_t *setColor);
void SCR_Init();
int CL_CGameRendering(LocalClientNum_t localClientNum, unsigned int eyeToRender);
void CL_DrawScreen(LocalClientNum_t localClientNum);
void SCR_ClearScreen();
void SCR_DrawLoadingAndLogo();
void CL_CheckKeepDrawingConnectScreen(const LocalClientNum_t localClientNum);
void SCR_DrawScreenField(const LocalClientNum_t localClientNum, int refreshedUI);
long double CL_GetMenuBlurRadius(LocalClientNum_t localClientNum);
void CL_UpdateUIVisibilityBits(LocalClientNum_t localClientNum);
void SCR_UpdateFrame();
void SCR_UpdateScreen();
void SCR_UpdateLoadScreen();
void CL_CubemapShotUsage();
void CL_CubemapShot_f();
void CL_TakeHiResShot();

//t6/code/src_noserver/client_mp/cl_ui_mp.cpp
void CL_GetClientState(LocalClientNum_t localClientNum, uiClientState_s *state);
bool CL_AllowPopup(LocalClientNum_t localClientNum);
void Key_KeynumToStringBuf(LocalClientNum_t localClientNum, int keynum, char *buf, int buflen);
int CL_GetClientName(LocalClientNum_t localClientNum, int index, char *buf, int size, bool addClanName);
int CL_GetClientClanName(LocalClientNum_t localClientNum, int index, char *buf, int size);
int CL_ShutdownUI();
void CL_InitUI();

//t6/code/src_noserver/client_mp/cl_voice.cpp
int CL_CanWeConnectToClient(;
char CL_CanClientTalkToAllClientsInList(SessionData *session, const int sender, const int clientBits);
int Session_GetConnectivityBitsForAddr(;
int Session_GetConnectivityBitsForClientAddress(SessionData *session, const ClientNum_t clientNum);
int Session_GetConnectivityBitsForLocalClients(SessionData *session);
void CL_UpdateConnectivityBits(LocalClientNum_t localClientNum, SessionData *session, int connectivityBits);
void CL_WeNowCantHearSomeone(LocalClientNum_t localClientNum, SessionData *session, ClientNum_t remoteClient);
void CL_SendPeerConnectivityTest(;
void CL_SendVoiceTestPackets(ControllerIndex_t localControllerIndex);
ClientNum_t CL_FindGoodRouteForClientList(SessionData *session, int *routeList, const int clientBits);
ClientNum_t CL_FindGoodRouteForClientNum(SessionData *session, int *routeList, const ClientNum_t clientNum);
void CL_BuildRouteList(;
void CL_VoiceConnectionTestPacket(LocalClientNum_t localClientNum, msg_t *msg);
int CL_RemoveLocalClientsFromRelayList(SessionData *session, int relayList);
bool CL_ShouldIgnorePlayer(SessionData *session, LocalClientNum_t localClientNum, ClientNum_t talker);
ClientNum_t CL_FindRouteForClientNum(SessionData *session, const ClientNum_t clientNum);
bool CL_IsPlayerTalking(SessionData *session, LocalClientNum_t localClientNum, ClientNum_t talkingClientIndex);
void CL_CheckMutes(SessionData *session, LocalClientNum_t localClientNum);
void CL_TogglePlayerMuteForUI(LocalClientNum_t localClientNum, unsigned __int64 playerXuid);
bool Voice_SendVoiceData();
int Com_ClientVoiceEvent();
char CL_RebuildConnectionToClient(;
char CL_SendPeerData_Real(;
char CL_SendPeerData(;
void CL_WriteVoicePacket(LocalClientNum_t localClientNum);
void CL_VoicePacket(LocalClientNum_t localClientNum, msg_t *msg);
char CL_SendRelayPacket(;
char CL_WritePeerToPeerOOBString(;
void CL_VoiceTransmit(LocalClientNum_t localClientNum);
int Client_SendVoiceData(int bytes, char *enc_buffer);
void CL_VoiceFrame(LocalClientNum_t localClientNum);
void Com_RenderVoiceFrame();

//t6/code/src_noserver/client_mp/party.cpp
const char *Party_MemberStatusString(int status);
char *Party_LobbyFlagsString(unsigned __int8 lobbyFlags);
void Party_UpdateMostRecentPlaylistEntry(unsigned __int8 playlistEntry);
void Party_ValidateAddr(netadr_t addr);
BOOL Party_PlayerHasLoopbackAddr(PartyMember *member);
int Party_GetClientTimeout();
int Live_CurrentLocalMapPackFlags();
int Live_CurrentFullPartyMapPackFlags(PartyData_s *party);
int Live_GetPartyTotalMapPackFlags(PartyData_s *party);
int Live_GetDLC0HackContentFlag();
int Party_MemberMissingMapPacks(;
void Party_ClearLastEntries(PartyData_s *party);
void RandomPermute(int *arr, int size);
void RandomizeParty();
void Party_GetLobbyState_f();
void Party_ToggleMute_f();
BOOL Party_IsMemberDedicated(const PartyMember *partyMember);
int Party_CountMembersEvenIfInactive(const PartyData_s *party);
int PartyClient_CountMembers(const PartyData_s *party);
int PartyClient_CountLocalMembersEvenIfInactive(PartyData_s *party);
int PartyClient_CountLocalMembers(PartyData_s *party);
bool PartyClient_IsMemberLocal(PartyData_s *party, ClientNum_t slot);
int Party_CountMembersAtAddr(PartyData_s *party, netadr_t addr, int startSlot);
int PartyClient_GetLargestSplitscreenMemberCount(PartyData_s *party);
ClientNum_t Party_FindMemberByXUID(PartyData_s *party, const unsigned __int64 player);
int Party_FindMemberByController(PartyData_s *party, ControllerIndex_t controller);
void Party_SetVeto(PartyData_s *party, int vote);
void Party_ClearVotePossible(PartyData_s *party);
int Party_GetVetoCount(PartyData_s *party, voteWinner_e voteType);
int Party_GetReadyCount(PartyData_s *party);
bool Party_EnoughClientsAreReady(const int ready, const int notReady);
void Party_SetReady(PartyData_s *party, bool ready);
int Party_HowManyReadiesNeeded(PartyData_s *party);
s_mutePlayerInfo *Party_GetPlayerInfoFromMutePlayerList(;
void Party_AddXuidIntoMutePlayerList(unsigned __int64 playerXuid, bool isMuted);
bool Party_GetMuteStatusFromMutePlayerList(unsigned __int64 playerXuid);
void Party_SetMuteStatusInMutePlayerList(unsigned __int64 playerXuid, bool isMuted);
void Party_ReAddAllPlayers_Internal(PartyData_s *party);
void Party_MsgPrint(netsrc_t sock, netadr_t adr, const char *data, bool doubleSend);
bool Party_ShouldDisableLiveStream();
char Party_NetAdrToPlatformNetAdr(const netadr_t netAddr, platformNetAdr *platNetAddr);
char Party_CompareMemberAdrToPlatformNetAdr(const PartyMember *member, const platformNetAdr *platNetAddr);
int Party_FindMember(PartyData_s *party, const platformNetAdr playerAddr);
int Party_GetVoiceConnectivityBits(PartyData_s *party, ClientNum_t memberIndex);
int Party_GetAssignedTeam(PartyData_s *party, const unsigned __int64 player);
void Party_SetAssignedTeam(PartyData_s *party, const unsigned __int64 player, int team);
const char *Party_GetCustomTeamName(PartyData_s *party, int team);
void Party_SetPlaylistEntryAlways(PartyData_s *party, const int playlistEntry);
void Party_SetPreviousPlaylistEntry(PartyData_s *party, const int previousPlaylistEntry);
unsigned __int8 Party_GetPlaylistEntry(PartyData_s *party);
unsigned __int8 Party_GetPreviousPlaylistEntry(PartyData_s *party);
void Party_BlacklistSession(const bdSecurityID *sessionID);
char Party_IsSessionBlacklisted(const bdSecurityID *sessionID);
void Party_AddSessionToRecentSessionsList(const bdSecurityID *sessionID);
char Party_IsRecentlyEnteredSession(const bdSecurityID *sessionID);
BOOL Party_ConnectingToDedicated();
int Party_GetLobbySessionFlags(PartyData_s *party, ControllerIndex_t localControllerIndex);
void Party_SetDisplayMapName(const char *rawmapname);
void Party_SetDisplayGameType(const char *rawgametype);
void Party_SetMapPackFlags(PartyData_s *party, const int flags);
bool Party_IsSameNetworkAddress(PartyData_s *party, int slot1, int slot2);
int Party_CRCPartyFields(int checksum);
const char *Party_MemberFieldToString(PartyMember *a, PartyField *field);
void Party_WriteMemberField(PartyMember *partyMember, msg_t *msg, PartyField *field);
char Party_MemberEqual(PartyMember *a, PartyMember *b);
void Party_ReadMemberField(PartyMember *partyMember, msg_t *msg, PartyField *field);
char Party_WriteMember(PartyMember *partyMember, msg_t *msg);
bool Party_ReadMember(PartyMember *partyMember, msg_t *msg, bool check);
void Party_SendLeagueStats(PartyData_s *party, const ControllerIndex_t controllerIndex, int timestamp);
void Party_SetQoSProgress(PartyData_s *party, float percent, int successfulProbes, int numProbes);
void PartyClient_SwitchToLobby(;
void PartyClient_SwitchLobbiesIfNeeded(;
bool Party_HasDLCForItem(const ClientNum_t clientNum, const int itemIndex);
BOOL Party_ShouldDisplayChangelistWarning(PartyData_s *party);
void Party_CheckGivenProbation(PartyData_s *party, ControllerIndex_t localControllerIndex);
void Party_KickIfHasProbation(PartyData_s *party, ControllerIndex_t localControllerIndex);
BOOL Party_ShouldUseLobbyMerging(PartyData_s *party);
bool PartyClient_SendPartyStateAck(;
void PartyClient_PreParsePartyState(;
BOOL Party_IsRunning(PartyData_s *party);
BOOL Party_InParty(PartyData_s *party);
int Party_AreWeHost(PartyData_s *party);
BOOL Party_AreWeHostEvenIfInactive(PartyData_s *party);
bool Party_IsHostController(PartyData_s *party, ControllerIndex_t controllerIndex);
void PartyClient_MarkPacketReceived(PartyData_s *party, PartyHostDetails *partyHost);
int Party_PacketIsFromAcceptedHost(PartyData_s *party, const netadr_t from);
int Party_GetConnectivityBitsForAddr(PartyData_s *party, const netadr_t from);
int Party_GetConnectivityBitsForClientAddress(PartyData_s *party, const ClientNum_t clientNum);
char Party_RebuildConnectionToClient(PartyData_s *party, ClientNum_t destClientNum);
void PartyClient_GenerateHeartBeatAckMessage(PartyData_s *party, msg_t *msg);
void PartyClient_HandleReconnect(;
void Party_HandleVoiceFailMsg(PartyData_s *party, ControllerIndex_t localControllerIndex);
void Party_ResetReportedConnStates();
void Party_SendFinishedLoadingDemoMsg(PartyData_s *party);
void PartyClient_HandleStopDemoMsg(;
void PartyClient_HandleDemoHeartbeatMsg(;
void Party_HandleLeagueStatsRequest(PartyData_s *party, const ControllerIndex_t localControllerIndex);
void Party_HandleLeagueOutcomes(;
void PartyClient_HandleChallengeAck(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
BOOL Party_HandlePacket(;
void Party_SwitchLobbiesIfNeeded_f();
void Party_StateChanged_f();
int Party_MinLobbyTime();
char Party_UpdateLobbyStatusRequired(PartyData_s *party);
int Party_GetPreGameStartTimerLength();
int Party_GetGameStartTimerLength();
int Party_GetRestartMatchmakingTimer();
BOOL Party_IsPostGameLobby(PartyData_s *party);
void Party_GetAffinityBits(;
void Party_UpdateLocalClient(;
int FindFreeTempBanSlot();
void Party_ClearTempBannedXuidList();
int Party_IsInTempBannedXuidList(unsigned __int64 xuid);
void Party_AddToTempBannedXuidList(unsigned __int64 xuid);
;
int Party_IsGameLobbyHost();
bool Party_IsTeamAllowed(PartyData_s *party, team_t team, bool isSplitscreenClient);
PartyData_s *Party_GetPartyData();
void Party_SetWeAreHost(PartyData_s *party, bool weAreHost);
int Party_GetMaxPlayers();
int Party_GetMaxLocalPlayers();
void Party_SetMaxPlayers(PartyData_s *party, int count);
void Party_SetMaxLocalPlayers(PartyData_s *party, int count);
BOOL Party_IsUserRegistered(PartyData_s *party, ClientNum_t clientNum);
bool Party_DispatchInstantMessage(unsigned __int64 senderID, const ControllerIndex_t destIndex, msg_t *msg);
double Party_GetPartyAverageSkill(PartyData_s *party);
void Party_BroadcastLeagueEmblemChange(ControllerIndex_t controllerIndex, unsigned __int64 teamID);
int Live_CurrentDesiredLobbyMapPackFlags(const int playlistId);
char Party_PartyMembersMissingMapPack(;
char Party_IsAnyMemberMissingMapPack();
void PartyClient_RemovePartyMember(PartyData_s *party, ClientNum_t slot, bool swapped);
void PartyClient_RemoveAllPartyMembersAtSlotAddress(PartyData_s *party, ClientNum_t slot);
void Party_ReRegisterAllPlayersVoice(PartyData_s *party, ControllerIndex_t localControllerIndex);
void Party_ReAddAllPlayers(PartyData_s *party);
void PartyClient_DisconnectLocalPlayerFromHost(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyClient_ProposeNewGamestate(PartyData_s *party, ControllerIndex_t localControllerIndex);
int Party_FindMember(PartyData_s *party, const netadr_t playerAddr);
void PartyClient_HandleLocalJoinFailed(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyClient_RequestLocalJoin(PartyData_s *party, int partyId, ControllerIndex_t localControllerIndex);
void PartyClient_JoinLocalClientsToParty_Internal(;
bool Party_IsChangeTeamAllowed(PartyData_s *party, team_t team, bool isSplitscreenClient);
void Party_UpdateTeamSwitch(;
void Party_MemberProfileChanged(;
void Part_PartyState_SetMaxPlayers(PartyData_s *party);
void PartyHost_ResetState(PartyData_s *party, const ControllerIndex_t localControllerIndex);
void PartyClient_BecomePartyHost(PartyData_s *party, ControllerIndex_t localControllerIndex);
bool Party_ShowMatchBeginTimer(PartyData_s *party);
const char *Party_GetStatus_ZombiePublicSoloMatch(PartyData_s *party);
const char *Party_GetStatus(PartyData_s *party, int *timeRemaining);
void Party_ClearJoinParty(PartyData_s *party);
void PartyClient_CleanUpInviteSessions(PartyData_s *party);
void PartyClient_DisconnectFromHost(;
void Party_StopParty(PartyData_s *party, bool keepPartyTogether, bool deleteSessionImmediately);
// void Party_StopParty(bool a1@<dl>, PartyData_s *a2@<ecx>, PartyData_s *party, bool keepPartyTogether);
void Party_JoinAttemptFailed(;
char Party_CheckPlaylistRules(const ControllerIndex_t localControllerIndex);
;
void PartyClient_ParseMemberList(PartyData_s *party, ControllerIndex_t localControllerIndex, msg_t *msg);
void PartyClient_SetUpPartyForHost(;
void PartyClient_HandleBadLeague(;
void PartyClient_HandleKicked(PartyData_s *party, const ControllerIndex_t localControllerIndex, netadr_t from);
void PartyClient_PartyAwakeMsg(;
void PartyClient_LeaderLeftMsg(;
void Party_CheckPlaylistCmd();
void Party_Init();
void Party_Sleep(PartyData_s *party);
void Party_SetupPlayList(const ControllerIndex_t localControllerIndex, int entryNum);
void Party_ChooseNextPlaylist(const ControllerIndex_t localControllerIndex);
void Party_ChooseNextAndPreviousPlaylist(const ControllerIndex_t localControllerIndex);
void Party_ChoosePreviousPlaylist();
void PartyClient_HostTimedOut(;
void PartyClient_HostTimedOutMidGame(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyClient_DoneParsingPartyState(;
void PartyClient_SendHeartbeatAck(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyClient_AllLocalClientsSendHeartbeatAck(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyClient_HandleHeartbeat(;
void PartyClient_HandleNewLobby(;
void PartyClient_HandleEndParty(;
void PartyClient_HandleEndPartyKeepPartyTogether(;
bool PartyClient_ParsePartyStateMsg(;
void PartyClient_HandlePartyStateMsg(;
void PartyClient_HandleGoMsg(PartyData_s *party, const ControllerIndex_t localControllerIndex, netadr_t from);
void PartyClient_HandlePlayDemoMsg(;
void Party_Awake(PartyData_s *party, const ControllerIndex_t localControllerIndex);

//t6/code/src_noserver/client_mp/partyhost.cpp
void Party_PrintTeams(SubpartyInfo *subparties, int subpartyCount);
void PartyHost_AddAllPlayersToPresenceSession(PartyData_s *party);
void PartyHost_PrintConnectivity(PartyData_s *party, const ClientNum_t clientNum, const int bits);
void ClearMember(PartyData_s *party, const int memberIndex);
void PartyHost_ClearMembers(PartyData_s *party);
void PartyHost_SetLeagueDataState(;
int PartyHost_CountMembers(PartyData_s *party);
int PartyHost_FindOldestZombieSlot(PartyData_s *party);
int PartyHost_CountUninvitedPlayers(PartyData_s *party);
int PartyHost_CountInvitedPlayers(PartyData_s *party);
int PartyHost_CountOpenPublicSlots(PartyData_s *party);
int PartyHost_CountAnonymousPlayers(PartyData_s *party);
char PartyHost_CanFormTeams(;
bool AssignmentFitness(;
int CompareFitness(const void *a, const void *b);
bool PartyHost_FindTeams(SubpartyInfo *parties, const int partyCount, const int teamCount);
int StackRankSort(const void *_a, const void *_b);
void PartyHost_FindSubparties(PartyData_s *party, int flags, SubpartyInfo *subparties, int *subpartyCount);
void PartyHost_UpdateSubpartyIndex(PartyData_s *party);
int PartyHost_GetPlayingTeamCount(PartyData_s *party);
int PartyHost_GetSmallestTeamCount(PartyData_s *party);
int PartyHost_GetLargestTeamCount(PartyData_s *party);
team_t PartyHost_GetSmallestTeam(PartyData_s *party);
int PartyHost_BuildRandomChallengeId();
bool PartyHost_ComparePartyConnection(PartyData_s *party, int ping);
int PartyHost_CompareSubpartySkill(SubpartyInfo *setA, int setACount, SubpartyInfo *setB, int setBCount);
char PartyHost_AnyClientsPresentOrConnecting(PartyData_s *party);
bool PartyHost_MapIsAcceptable(PartyData_s *party, const char *mapname);
int PartyHost_AssignTeam(PartyData_s *party, const ClientNum_t slot);
void PartyHost_SetMatchmakingInfo(PartyData_s *party);
void PartyHost_SetAllowedTeams(PartyData_s *party, const char *gametype);
void PartyHost_SetBeginTime(PartyData_s *party, int time);
ClientNum_t PartyHost_GetFirstEmptySlot(PartyData_s *party);
int compareClientAddrs(netadr_t a, netadr_t b);
void PartyHost_RemoveLocalHost(PartyData_s *party);
char *PartyHost_GetMemberName(PartyData_s *party, const ClientNum_t clientNum);
void PartyHost_MarkMemberInfoDirty(PartyData_s *party, int dirtyMemberSlot);
void PartyHost_UpdatePlayerHiding(PartyData_s *party);
void PartyHost_MemberInfoChanged(PartyData_s *party, ClientNum_t memberSlot);
void PartyHost_ResetClientTimeouts(PartyData_s *party);
void PartyHost_SyncVoiceDataForAllPlayers(PartyData_s *party);
bool PartyHost_UpdateBitsIfNeeded(int *voiceConnectivityBits, int connectivityBits);
void PartyHost_UpdateVoiceConnectivityBits(PartyData_s *party, ClientNum_t memberIndex, int connectivityBits);
void PartyHost_AddVoiceConnectivityToAllLocalPlayers(PartyData_s *party, ClientNum_t memberIndex);
void PartyHost_SendGo(;
void PartyHost_SendPlayDemo(;
void PartyHost_SendStopDemo(PartyData_s *party, ControllerIndex_t localControllerIndex, int partyMemberSlot);
bool PartyHost_TeamsAreReady(PartyData_s *party, int memberCount);
char PartyHost_MakeTeams(PartyData_s *party);
void PartyHost_StartDemo(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_StopDemo(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_RemoveTestClient(PartyData_s *party, ClientNum_t slot);
void Party_RemoveTestClient_f();
void Party_CloseDWConnectionIfDone(PartyData_s *party, netadr_t addr);
void PartyHost_WritePartyStateMembers(PartyData_s *party, int destinationMemberSlot, msg_t *msg);
void PartyHost_WritePartyState(PartyData_s *party, int destinationMemberSlot, msg_t *msg);
void recordBadFlags(int oldFlags, int newFlags);
void recordBadSlots(int maxplayers, int privateslots);
void PartyHost_SendDemoHeartbeats(PartyData_s *party, const ControllerIndex_t localControllerIndex);
void PartyHost_CloseDWConnectionOnDvar(PartyData_s *party, netadr_t addr);
void PartyHost_TellClientToRejoin(PartyData_s *party, netadr_t from);
void Party_GenerateNewLobbyMessage(;
void Party_SendNewLobbyToAddr(;
void PartyHost_SetupParty(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_CreatePartyPresenceComplete(ControllerIndex_t localControllerIndex, PartyData_s *party);
void PartyHost_HandleEchoRequest(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
int PartyHost_GenerateClientBitfield(PartyData_s *party);
bool PartyHost_AreAllClientsUpToDate(PartyData_s *party, int sinceMS);
bool PartyHost_IsJoinInProgressAllowed(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_ValidateTeams(PartyData_s *party);
void PartyHost_HandleIHearMsg(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
void PartyHost_HandleCantHearMsg(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
char PartyHost_SendPartyAwakeMsgToParty(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_HandleProfileMsg(;
void PartyHost_HandleProfilesAckMsg(;
int PartyHost_HashLeagueValues(int visiblePoints, int hiddenPoints, float skill, unsigned __int64 teamID);
void PartyHost_HandleLeagueOutcomesAck(;
void PartyHost_HandleLeagueEmblemUpdate(;
void PartyHost_RequestLeagueStats(PartyData_s *party, int memberIndex);
void PartyHost_SendLeagueOutcomes(PartyData_s *party, int memberIndex);
void PartyHost_HandleChallenge(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
int PartyHost_CanHandlePacket(PartyData_s *party, const char *c);
int PartyHost_HandlePacket(;
void PartyHost_CalculateLeagueOutcomes(PartyData_s *party);
bool PartyHost_EnforceLeagueTeams(PartyData_s *party);
void PartyHost_UpdateLeague(PartyData_s *party);
bool PartyHost_LeaguesReady(PartyData_s *party);
void PartyHost_InitLeagueState(PartyData_s *party);
void PartyHost_ClearReadies(PartyData_s *party);
void PartyHost_ClearVetoes(PartyData_s *party);
void PartyHost_SanityCheck(PartyData_s *party);
int PartyHost_DetermineVoteWinner(PartyData_s *party);
void PartyHost_StoreMapVoteStats(const ControllerIndex_t localControllerIndex, const char *mapName);
void PartyHost_UpdateLocalClient(PartyData_s *party, const ControllerIndex_t localControllerIndex);
void PartyHost_PrintDetails(PartyData_s *party);
int PartyHost_GetMaxFreeSlots(PartyData_s *party, int memberCount);
void PartyHost_ClearConnectivityBitForClient(PartyData_s *party, const ClientNum_t slot);
int PartyHost_AddLocalPlayer(;
void PartyHost_RemovePlayer(;
void PartyHost_RemoveLocalPlayer(PartyData_s *party, const ClientNum_t memberIndex, bool removePartyToNotify);
void PartyHost_GamestateChanged(PartyData_s *party);
void PartyHost_SetRoundScores(PartyData_s *party, const int memberIndex, const int score, const int deaths);
void PartyHost_SwapPlayer(;
void PartyHost_StartTeamMatch(PartyData_s *party);
void PartyHost_TimeoutMembers(PartyData_s *party);
void PartyHost_SendPartyStateToPlayer(PartyData_s *party, ClientNum_t clientNum);
void PartyHost_SendPartyStates(PartyData_s *party);
void PartyHost_AddLocalClientsToNewLobby(;
void PartyHost_AddLocalClientsToNewLobby(PartyData_s *party, const ControllerIndex_t ignoreControllerIndex);
void PartyHost_AddMissingLocalClientsToLobby(PartyData_s *party);
void PartyHost_RefreshParty(PartyData_s *party);
void PartyHost_SendHeartbeats(PartyData_s *party);
void PartyHost_DropPlayersToMatchSlots(PartyData_s *party, const int publicSlots);
void PartyHost_StartParty(;
void PartyHost_HandleClientPartyStateAck(;
void PartyHost_HandleClientDisconnect(;
void PartyHost_HandleClientLeaderDisconnect(;
void PartyHost_HandleProposedGamestate(;
void PartyHost_UpdateLeague_Private(const ControllerIndex_t controllerIndex, PartyData_s *party);
void PartyHost_StartLeagueMatch(PartyData_s *party, ControllerIndex_t controllerIndex);
void PartyHost_EnterStartReadyState(;
bool PartyHost_ClientsAreReady(PartyData_s *party);
void PartyHost_AddAnonymousMemberAtSlot(;
bool PartyHost_AddAnonymousMember(;
bool PartyHost_AnonymousAddRequest(;
bool PartyHost_PlayerJustConnected(PartyData_s *party, const ClientNum_t slot);
int PartyHost_AddPlayerAtSlot(;
int PartyHost_AddPlayer(PartyData_s *party, const netadr_t addr, PartyMember *newMember);
PartyMemberAddResult PartyHost_ClaimAnonymousSpot(;
void PartyHost_RemoveAllPartyMembersAtSlotAddress(;
void PartyHost_MarkPacketReceivedForClients(PartyData_s *party, const netadr_t from);
void PartyHost_HandleFinishedLoadingDemoMsg(;
void PartyHost_SortParty(PartyData_s *party, SessionData *session);
void PartyHost_PreMatch(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_StartMatch(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_AddTestClient(PartyData_s *party, ClientNum_t slot, int privatePartyId);
void Party_AddTestClients_f();
char PartyHost_SwitchLobby(PartyData_s *party);
void PartyHost_StartPartyComplete(ControllerIndex_t localControllerIndex, SessionData *session);
bool PartyHost_ShouldAutoStart(PartyData_s *party, ControllerIndex_t localControllerIndex, int memberCount);
void PartyHost_AutoStart(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyHost_HandleHeartbeatAck(;
bool PartyHost_AttemptJoinParty(;
void PartyHost_HandleJoinPartyRequest(;
void PartyHost_HandleLocalJoin(;
void PartyHost_KickPlayer(PartyData_s *party, const ClientNum_t memberIndex, const char *reason);
void Party_TestTeamCreation_f();
void PartyHost_HandleMemberMsg(;
void PartyHost_HandleProposedKick(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
void PartyHost_HandleLeagueStats(;
void PartyHost_CheckForInsufficientWagerFunds(const ControllerIndex_t localControllerIndex, PartyData_s *party);
void PartyHost_UpdateWagerCheckFundsState(const ControllerIndex_t localControllerIndex, PartyData_s *party);
void PartyHost_Frame(;
void PartyHost_HandleClientHandshake(;

//t6/code/src_noserver/client_mp/partymigrate.cpp
bool PartyMigrate_CanAnyoneTalkToThisGuy(SessionData *session, int destClientNum);
bool PartyMigrate_CanWeTalkToAllClients(PartyData_s *party, ControllerIndex_t localControllerIndex);
unsigned int PartyMigrate_GetClientConnectivity(PartyData_s *party, ControllerIndex_t localControllerIndex);
bool PartyMigrate_DoWeHaveNecessaryMapPacks(PartyData_s *party, ControllerIndex_t localControllerIndex);
bool PartyMigrate_CanWeHost(;
bool PartyMigrate_IsEnabled(PartyData_s *party);
void PartyMigrate_SendSessionInfo(PartyData_s *party, const ClientNum_t clientNum);
void PartyMigrate_RestartServer(PartyData_s *party, const int oldHost);
ClientNum_t Party_FindNextMemberAtAddrInternal(;
void Party_UpdateHostAddr(PartyData_s *party, netadr_t addr);
void PartyMigrate_CheckBeforeContinuingToHost(PartyData_s *party);
void migrateClient_UpdateState(migrateClientState_t newState);
BOOL PartyMigrate_MigrateActive(PartyData_s *party);
void Party_SetMigrateActive(PartyData_s *party, bool state);
int parseBandwidthTestPacketSyn(;
void sendTestPacketAck(ControllerIndex_t localControllerIndex, const netadr_t from, int fromMS, int seq);
void updateMeanForPeer(peerResults_t *peerResults, unsigned int latency);
float getStdDevForPeer(peerResults_t *peerResults);
void handleTestPacketAck(__int64 localControllerIndex, __int64 from_8, int from_16, msg_t *msga, msg_t *msg);
void PartyMigrate_HandleTestPacket(ControllerIndex_t localControllerIndex, const netadr_t from, msg_t *msg);
int peerResultCompare(const void *a, const void *b);
void recalculateNominees(PartyData_s *party);
void PartyMigrate_HostRead(;
void PartyMigrate_HostWrite(PartyData_s *party, ControllerIndex_t localControllerIndex, msg_t *msg);
void PartyMigrate_ClientRead(PartyData_s *party, ControllerIndex_t localControllerIndex, msg_t *msg);
void PartyMigrate_ClientWrite(PartyData_s *party, ControllerIndex_t localControllerIndex, msg_t *msg);
void PartyMigrate_ClearData(PartyData_s *party);
void PartyMigrate_HandleFindBestCommand(PartyData_s *party);
void PartyMigrate_SwapHostAndClient(PartyData_s *party, ClientNum_t clientNum);
void PartyMigrate_RequestFindBestHost(PartyData_s *party);
void PartyMigrate_ComErrorCleanup();
bool PartyMigrate_IsDebugEnabled();
void PartyMigrate_HandleHostAnnounce(PartyData_s *party, ControllerIndex_t localControllerIndex, netadr_t from);
char PartyMigrate_HandlePacket(;
char *PartyMigrate_GetDebugInfoAsString(PartyData_s *party);
int PartyMigrate_GetLastNomineeCalcTime();
void PartyMigrate_MatchStarted();
void PartyMigrate_HandleSessionInfoMsg(;
void PartyMigrate_To(PartyData_s *party, const ClientNum_t newHost);
void PartyMigrate_HandleToMsg(PartyData_s *party, ControllerIndex_t localControllerIndex);
void PartyMigrate_HostFrame(PartyData_s *party);
void PartyMigrate_Test();
void PartyMigrate_Init();

//t6/code/src_noserver/client_mp/partyprober.cpp
void PartyInfo_SetFlag(PartyInfo *party, int flag, bool enable);
bool PartyInfo_GetFlag(PartyInfo *party, int flag);
int PartyInfo_GetGeoMatch(const PartyInfo *host);
char *PrettyFlags(int flags);
void PartyProber_SetState(PartyProber *prober, ProberState state, const char *reason);
const char *PartyProber_GetStateAsString(PartyProber *prober);
void PartyProber_SetAcceptInfo(PartyProber *prober, int partyId, int challenge, int hostNum);
void PartyProber_MarkReceived(PartyProber *prober);
int PartyProber_GetHostCount(PartyProber *prober, int matchingFlags);
void PartyProber_ClearHosts(PartyProber *prober);
void PartyProber_Clear(PartyProber *prober);
void PartyProber_StartInvite(;
void PartyProber_StartNewlobby(;
int PartyProber_FindByXNAddr(PartyProber *prober, const XNADDR *key);
void PartyProber_AddHost(;
char PartyProber_StoreQoSResult(;
bool PartyProber_Connect(XSESSION_INFO *info, bool dedicated, netadr_t *addr);
bool PartyProber_HandlePartyAccept(PartyProber *prober, int partyId, netadr_t from, msg_t *msg);
bool PartyProber_HandlePartyJoinFailed(PartyProber *prober, int partyId, netadr_t from, msg_t *msg);
bool PartyProber_HandleEchoReply(PartyProber *prober, int partyId, netadr_t from, msg_t *msg);
bool PartyProber_HandleMasterRequest(PartyProber *prober, const int partyId, netadr_t from, msg_t *msg);
char PartyProber_HandleMasterReply(PartyProber *prober, int partyId, netadr_t from, msg_t *msg);
char PartyProber_HandlePacket(;
PartyProberStatus PartyProber_GetStatus(PartyProber *prober, int partyId);
int PartyProber_GetSearchStartUTC(PartyProber *prober);
BOOL PartyProber_IsSearching(PartyProber *prober);
void PartyProber_StartQoS(PartyProber *prober);
// void PartyProber_QoSComplete(ProberState a1@<edx>, PartyProber *a2@<ecx>, PartyProber *prober);

//t6/code/src_noserver/client_mp/partyui.cpp
void PartyUI_HandleEliteClanTag(;
char *PartyUI_NameWithClan(int feature, char *clanAbbrev, char *gamertag, bool clanAbbrev_IsEliteValidated);
int PartyUI_CountTeamMembers(PartyData_s *party, int team);
void Party_SetUIPlayerCount(PartyData_s *party);
bool Party_ShouldShowInviteWarning(PartyData_s *party);

//t6/code/src_noserver/client_mp/party_local.h
BOOL Party_PacketIsFromHost(PartyData_s *party, const netadr_t from);
BOOL Party_PacketIsFromPotentialHost(PartyData_s *party, const netadr_t from);
void SetLobbyState(PartyData_s *party, unsigned __int8 lobbyState);

//t6/code/src_noserver/database/db_assetlist_load.h
XAsset *AllocLoad_XAsset();
void Mark_XAssetHeader();
void Mark_XAsset();
void Load_XAssetHeader(bool atStreamStart);
void Load_XAsset(bool atStreamStart);

//t6/code/src_noserver/database/db_assetnames.cpp
const char *DB_ImageGetName(const XAssetHeader *header);
void DB_ImageSetName(XAssetHeader *header, const char *name);
const char *DB_LocalizeEntryGetName(const XAssetHeader *header);
void DB_LocalizeEntrySetName(XAssetHeader *header, const char *name);
const char *DB_ZBarrierDefGetName(const XAssetHeader *header);
void DB_ZBarrierDefSetName(XAssetHeader *header, const char *name);
const char *DB_GetEmblemSetName();
const char *DB_GetXAssetHeaderName(int type, const XAssetHeader *header);
const char *DB_GetXAssetName(const XAsset *asset);
void DB_SetXAssetName(XAsset *asset, const char *name);
int DB_GetXAssetTypeSize(int type);
const char *DB_GetXAssetTypeName(int type);
// unsigned int __thiscall bdLeagueSubdivisionResult::sizeOf(bdLeagueSubdivisionResult *this);
// unsigned int __thiscall bdLeagueSubdivisionInfo::sizeOf(bdStatsInfo *this);
// int CCallback<CSteamAchievements,UserAchievementStored_t,0>::GetCallbackSizeBytes();
// unsigned int __thiscall bdMatchMakingInfo::sizeOf(bdMatchMakingInfo *this);
// unsigned int __thiscall bdBoolResult::sizeOf(bdYouTubeRegistrationResult *this);

//t6/code/src_noserver/database/db_auth_sha1.cpp
void SHA1_Transform(unsigned int *state, const unsigned __int8 *buffer);

//t6/code/src_noserver/database/db_file_load.cpp
void DB_Init_Reading();
double DB_GetLoadedFraction();
int DB_Reliable_FsOpen_ReadOnly(const char *path, unsigned int *outClumpSize);
void DB_FileReadCompletionCallback(int id, stream_status result, unsigned int numBytesRead, void *user);
void DB_SetZoneSizeLevelCount(int levelZoneCount);
void DB_ResetZoneSize(int trackLoadProgress);
bool DB_IsMinimumFastFileLoaded();
void DB_ResetMinimumFastFileLoaded();
int DB_ReadData();
void RecomputeLocks();
void DB_WaitXFileStage(int buffer_index);
void DB_CancelLoadXFile();
void DB_DecompressIOStream(DBDecompressCmd_t *cmd);
void DB_WaitWorkerCmd(DB_LOAD_STREAM *stream);
char TestBoundryCondition(unsigned __int8 *pos, int len);
void AdvanceRead(bool advance);
void CopyFromDecompressBufferNullTerminal(unsigned __int8 *pos, int *size_copied);
void DB_LoadXFileData(unsigned __int8 *pos, int size);
int DB_LoadXFileDataNullTerminated(unsigned __int8 *pos);
char *ValidateFileHeader(bool *fileIsSecure, int *fileVersion);
void DB_LoadedExternalData(int size);
int DB_DecompressIOStreamWorkerCallback(jqBatch *batch);
BOOL DB_LoadXFile(;

//t6/code/src_noserver/database/db_gump.cpp
void DB_GumpPrint(const char *fmt, ...);
unsigned int DB_GumpSizeForBlockIndex(int bi);
unsigned int DB_GetGumpUnused(unsigned int budget);
void DB_GumpBeginAlloc(const char *name, unsigned int allocType, EMemTrack memTrack);
void DB_GumpEndAlloc(const char *name, unsigned int allocType);
unsigned __int8 *DB_GumpMemAlloc(;
void DB_GumpMemFreeAll();
bool DB_GumpShouldFree(XBlock *blocks);
void DB_GumpMemFree(unsigned __int8 *data, unsigned int blockIndex);
char *DB_GetGumpZoneName(int flags);
int DB_AllocZoneForSlot(int slot);
void DB_FlushGump(int slot);
void DB_FlushGumps();
void DB_LoadGump(const char *fastfileName, unsigned int slot, int sync);

//t6/code/src_noserver/database/db_memory.cpp
void DB_InitFFOTDMem();
unsigned __int8 *DB_FFOTDMemAlloc(;
unsigned __int8 *DB_MemAlloc(;
void DB_GetMemoryBudgets(unsigned int *common, unsigned int *level, unsigned int *weapon);
unsigned int DB_GetLevelFree();
int DB_GetFactionFree();
void DB_UpdateUsage(XBlock *blocks, int flags, bool add);
void DB_AllocXBlocks(;
void DB_FreeXBlocks(const char *filename, XBlock *blocks, int flags);

//t6/code/src_noserver/database/db_primtypes_load.h
void Load_ScriptStringArray(bool atStreamStart, int count);
void Load_TempStringArray(bool atStreamStart, int count);
void Load_XString(bool atStreamStart);
void Load_XStringArray(bool atStreamStart, int count);
void Load_ScriptStringList(bool atStreamStart);

//t6/code/src_noserver/database/db_registry.cpp
void TRACK_db_registry();
void DB_InitSingleton(void *pool, int size);
void DB_RemoveXModel(XAssetHeader header);
void DB_RemoveFX(XAssetHeader header);
void DB_RemoveMaterial(XAssetHeader header);
void DB_RemoveTechniqueSet(XAssetHeader header);
void DB_RemoveImage(XAssetHeader header);
void DB_RemoveSound(XAssetHeader header);
void DB_RemoveSndDriverGlobals(XAssetHeader header);
void DB_RemoveSoundPatch(XAssetHeader header);
;
;
;
void DB_DynamicCloneMenu(const XAssetHeader from, XAssetHeader to, DBCloneMethod cloneMethod);
void DB_RemoveKeyValuePairs(XAssetHeader header);
char DB_CompareReorderEntries(const DBReorderAssetEntry *e0, const DBReorderAssetEntry *e1);
void DB_SetReorderIncludeSequence();
void DB_AddReorderAsset(const char *typeString, const char *assetName);
char DB_NextZoneCsvToken(const char **parse, char *token, unsigned int tokenSize, bool allowNewLine);
void DB_BeginReorderZone(const char *zoneName);
void DB_PrintAssetName(XAssetHeader header, void *data);
void DB_MarkAssetTypeUsageDirty();
void DB_GetAssetTypeUsageInfo(XAssetType assetType, const char **outName, int *outUsed, int *outPool);
void DB_PrintXAssetsForType_FastFile(XAssetType type, void *inData, bool includeOverride);
XAssetHeader DB_AllocXAssetHeader(XAssetType type);
unsigned int DB_Init();
XAssetEntry *DB_AllocXAssetEntry(XAssetType type, unsigned int zoneIndex);
void DB_FreeXAssetEntry(XAssetEntry *assetEntry);
void DB_LogMissingAsset(XAssetType type, const char *name);
void DB_EnumXAssets_FastFile(;
char DB_EnumXAssetsTimeout_FastFile(;
void DB_LoadDelayedImages();
void DB_CloneXAsset(const XAsset *from, XAsset *to, DBCloneMethod cloneMethod);
void DB_SwapXAsset(XAsset *from, XAsset *to);
void DB_DelayedCloneXAsset(XAssetEntry *newEntry);
XAssetEntry *DB_FindXAssetEntry(XAssetType type, const char *name);
// XAssetHeader DB_FindXAssetDefaultHeaderInternal@<eax>(XAssetType a1@<edx>, XAssetType type);
XAssetEntry *DB_CreateDefaultEntry(XAssetType type, const char *name);
void DB_ListDefaultEntries_f();
void DB_ListAssetPool(XAssetType type);
void DB_ListAssetPool_f();
void DB_DumpMaterialList_f();
void DB_DumpModels_f();
bool IsConfigFile(const char *name);
void PrintWaitedError(XAssetType type, const char *name, int waitedMsec);
char DB_DoesXAssetExist(XAssetType type);
char DB_DoesXAssetExist(const char *typeName, const char *name);
void DB_SetInitializing(bool inUse);
// bool DB_IsXAssetDefault@<al>(XAssetType a1@<edx>, XAssetType type, const char *name);
int DB_GetAllXAssetOfType_FastFile(XAssetType type, XAssetHeader *assets, int maxCount);
void DB_SyncLostDevice();
int DB_GetZonePriority(int zone);
int DB_OverrideAsset(unsigned int newZoneIndex, unsigned int existingZoneIndex, XAssetType type);
XAssetEntry *DB_LinkXAssetEntry(XAssetEntry *newEntry, int allowOverride);
void DB_EnableInUseCache(unsigned __int16 *data);
void DB_GetXAsset(XAssetType type, XAssetHeader header);
void DB_BuildOSPath(const char *zoneName, const char *ext, int size, char *filename);
void DB_BuildOSPath_FromSource(const char *zoneName, FF_DIR source, int size, char *filename);
void DB_LoadXZone(XZoneInfo *zoneInfo, unsigned int zoneCount);
int DB_PostLoadPerXZone();
// void DB_UpdateDebugZone(int a1@<ebp>);
// void DB_LoadZone_f(int a1@<ebp>);
char DB_IsZoneLoaded(const char *name);
bool DB_IsZoneTypeLoading(int zoneType);
char DB_IsZoneTypeLoaded(int zoneType);
char DB_IsZoneTypeComplete(int zoneType);
char DB_ZoneLoadsOverlays(const char *zoneName);
char DB_CompareLoadXZoneInfos(const XZoneInfo *zone0, const XZoneInfo *zone1);
int DB_TryLoadXFileInternal(const char *zoneName, int zoneFlags, int requiredVersion, const char *contentDir);
void DB_InitFastFileNames();
void DB_UnloadXZoneInternal(unsigned int zoneIndex, bool createDefault);
void DB_UnloadXZoneMemory(XZone *zone);
BOOL DB_FreeDefaultEntries();
void DB_ReleaseXAssets();
void DB_UnloadXAssetsMemory(XZone *zone);
void DB_UnloadXAssetsMemoryForZone(int zoneFreeFlags, int zoneFreeBit);
char DB_ArchiveAssets();
void DB_FreeUnusedResources(int fast_free);
char DB_UnarchiveAssets();
void DB_Cleanup();
// XAssetPoolEntry<GfxImage> *DB_GetImageAtIndex(unsigned int index);
unsigned int DB_GetImagePartPoolSize();
GfxStreamedPartInfo *DB_GetImagePartAtIndex(unsigned int index);
char *DB_ReferencedFFChecksums();
char *DB_ReferencedFFNameList();
// char DB_FileExists@<al>(FF_DIR a1@<edx>, const char *zoneName, FF_DIR source);
unsigned int DB_GetGfxWorldChecksum();
void Load_PhysPresetAsset(PhysPreset **physPreset);
void Mark_PhysPresetAsset(PhysPreset *physPreset);
void Load_PhysConstraintsAsset(PhysConstraints **physConstraints);
void Mark_PhysConstraintsAsset(PhysConstraints *physConstraints);
void Load_DestructibleDefAsset(DestructibleDef **destructibleDef);
void Mark_DestructibleDefAsset(DestructibleDef *destructibleDef);
void Load_XAnimPartsAsset(XAnimParts **parts);
void Mark_XAnimPartsAsset(XAnimParts *parts);
void Load_XModelAsset(XModel **model);
void Mark_XModelAsset(XModel *model);
void Load_MaterialAsset(Material **material);
void Mark_MaterialAsset(Material *material);
void Load_MaterialTechniqueSetAsset(MaterialTechniqueSet **techniqueSet);
void Mark_MaterialTechniqueSetAsset(MaterialTechniqueSet *techniqueSet);
void Load_GfxImageAsset(GfxImage **image);
void Mark_GfxImageAsset(GfxImage *image);
void Load_SndBankAsset(SndBank **sound);
void Mark_SndBankAsset(SndBank *sound);
void Load_SndDriverGlobalsAsset(SndDriverGlobals **sndDriverGlobals);
void Mark_SndDriverGlobalsAsset(SndDriverGlobals *sndDriverGlobals);
void Load_SndPatchAsset(SndPatch **soundPatch);
void Mark_SndPatchAsset(SndPatch *soundPatch);
void Load_ClipMapAsset(clipMap_t **clipMap);
void Mark_ClipMapAsset(clipMap_t *clipMap);
void Load_ComWorldAsset(ComWorld **comWorld);
void Mark_ComWorldAsset(ComWorld *comWorld);
void Load_GameWorldSpAsset(GameWorldSp **gameWorldSp);
void Mark_GameWorldSpAsset(GameWorldSp *gameWorldSp);
void Load_GameWorldMpAsset(GameWorldMp **gameWorldMp);
void Mark_GameWorldMpAsset(GameWorldMp *gameWorldMp);
void Load_MapEntsAsset(MapEnts **mapEnts);
void Mark_MapEntsAsset(MapEnts *mapEnts);
void Load_DDLAsset(ddlRoot_t **ddlRoot);
void Mark_DDLAsset(ddlRoot_t *ddlRoot);
void Load_GfxWorldAsset(GfxWorld **gfxWorld);
void Mark_GfxWorldAsset(GfxWorld *gfxWorld);
void Load_LightDefAsset(GfxLightDef **lightDef);
void Mark_LightDefAsset(GfxLightDef *lightDef);
void Load_FontAsset(Font_s **font);
void Mark_FontAsset(Font_s *font);
void Load_FontIconAsset(FontIcon **fontIcon);
void Mark_FontIconAsset(FontIcon *fontIcon);
void Load_MenuListAsset(MenuList **menuList);
void Mark_MenuListAsset(MenuList *menuList);
void Load_MenuAsset(menuDef_t **menu);
void Mark_MenuAsset(menuDef_t *menu);
void Load_LocalizeEntryAsset(LocalizeEntry **localize);
void Mark_LocalizeEntryAsset(LocalizeEntry *localize);
void Load_WeaponVariantDefAsset(WeaponVariantDef **weapon);
void Mark_WeaponVariantDefAsset(WeaponVariantDef *weapon);
void Load_WeaponAttachmentAsset(WeaponAttachment **attachment);
void Mark_WeaponAttachmentAsset(WeaponAttachment *attachment);
void Load_WeaponAttachmentUniqueAsset(WeaponAttachmentUnique **attachmentUnique);
void Mark_WeaponAttachmentUniqueAsset(WeaponAttachmentUnique *attachmentUnique);
void Load_WeaponCamoAsset(WeaponCamo **weaponCamo);
void Mark_WeaponCamoAsset(WeaponCamo *weaponCamo);
void Load_FxEffectDefAsset(const FxEffectDef **fx);
void Mark_FxEffectDefAsset(FxEffectDef *fx);
void Load_FxImpactTableAsset(FxImpactTable **impactFx);
void Mark_FxImpactTableAsset(FxImpactTable *impactFx);
void Load_RawFileAsset(RawFile **rawfile);
void Mark_RawFileAsset(RawFile *rawfile);
void Load_StringTableAsset(StringTable **stringTable);
void Mark_StringTableAsset(StringTable *stringTable);
void Load_LeaderboardDefAsset(LeaderboardDef **leaderboardDef);
void Mark_LeaderboardDefAsset(LeaderboardDef *leaderboardDef);
void Load_XGlobalsAsset(XGlobals **xGlobals);
void Mark_XGlobalsAsset(XGlobals *xGlobals);
void Load_GlassesAsset(Glasses **glasses);
void Mark_GlassesAsset(Glasses *glasses);
void Load_EmblemSetAsset(EmblemSet **emblemSet);
void Mark_EmblemSetAsset(EmblemSet *emblemSet);
void Load_ScriptParseTreeAsset(ScriptParseTree **scriptParseTree);
void Mark_ScriptParseTreeAsset(ScriptParseTree *scriptParseTree);
void Load_QdbAsset(Qdb **qdb);
void Mark_QdbAsset(Qdb *qdb);
void Load_SlugAsset(Slug **slug);
void Mark_SlugAsset(Slug *slug);
void Load_KeyValuePairsAsset(KeyValuePairs **keyValuePairs);
void Mark_KeyValuePairsAsset(KeyValuePairs *keyValuePairs);
void Load_VehicleDefAsset(VehicleDef **vehicleDef);
void Mark_VehicleDefAsset(VehicleDef *vehicleDef);
void Load_MemoryBlockAsset(MemoryBlock **memoryBlock);
void Mark_MemoryBlockAsset(MemoryBlock *memoryBlock);
void Load_AddonMapEntsAsset(AddonMapEnts **addonMapEnts);
void Mark_AddonMapEntsAsset(AddonMapEnts *addonMapEnts);
void Load_TracerDefAsset(TracerDef **tracerDef);
void Mark_TracerDefAsset(TracerDef *tracerDef);
void Load_SkinnedVertsDefAsset(SkinnedVertsDef **skinnedVertsDef);
void Mark_SkinnedVertsDefAsset(SkinnedVertsDef *skinnedVertsDef);
void Load_FootstepTableDefAsset(FootstepTableDef **footstepTableDef);
void Mark_FootstepTableDefAsset(FootstepTableDef *footstepTableDef);
void Load_FootstepFXTableDefAsset(FootstepFXTableDef **footstepFXTableDef);
void Mark_FootstepFXTableDefAsset(FootstepFXTableDef *footstepFXTableDef);
void Load_ZBarrierDefAsset(ZBarrierDef **zbarrierDef);
void Mark_ZBarrierDefAsset(ZBarrierDef *zbarrierDef);
XAssetHeader DB_AllocMaterial(void *pool);
XAssetHeader DB_AllocGfxImage(void *pool);
void DB_FreeMaterial(void *pool, XAssetHeader header);
void DB_FreeMenu(void *pool, XAssetHeader header);
void DB_FreeXGlobals(void *pool, XAssetHeader header);
char DB_PostLoadXZone();
void DB_SyncXAssets();
void DB_ShutdownXAssets();
void DB_Update();
void DB_EndReorderZone();
bool DB_RegisterAllReorderAssetsOfType(int type, XAssetEntry *assetEntry);
void DB_RegisteredReorderAsset(int type, const char *assetName, XAssetEntry *assetEntry);
XAssetHeader DB_FindXAssetHeader(XAssetType type, const char *name, bool errorIfMissing, int waitTime);
void DB_LoadXAssets(XZoneInfo *zoneInfo, unsigned int zoneCount, int sync);
void __noreturn DB_Thread(unsigned int threadContext);
void DB_InitThread();
void DB_ReplaceModel(const char *original, const char *replacement);
void DB_LoadGraphicsAssetsForPC();
void DB_InitFrontendXAssets(bool uiOnly);
void Load_FxEffectDefFromName(const char **name);
void DB_LoadLoadFastfilesForNewContent();

//t6/code/src_noserver/database/db_registry.h
unsigned int DB_HashForName_Inline(const char *name, XAssetType type);

//t6/code/src_noserver/database/db_stream.cpp
void DB_InitStreams(XBlock *blocks);
void DB_PushStreamPos(unsigned int index);
void DB_PopStreamPos();
unsigned __int8 *DB_GetStreamPos();
unsigned __int8 *DB_AllocStreamPos(int alignment);
void DB_IncStreamPos(int size);
const void **DB_InsertPointer();

//t6/code/src_noserver/database/db_stream_load.cpp
bool Load_Stream(bool atStreamStart, const void *ptr, int size);
void Load_DelayStream();
void DB_ConvertOffsetToAlias(void *data);
void DB_ConvertOffsetToPointer(void *data);
void Load_XStringCustom(const char **str);
void Load_TempStringCustom(const char **str);

//t6/code/src_noserver/database/db_stringtable_load.cpp
void Load_ScriptStringCustom(unsigned __int16 *var);
void Mark_ScriptStringCustom(unsigned __int16 *var);

//t6/code/src_noserver/ddl/ddl_api.cpp
int DDL_GetTotalBufferBitSize(ddlDef_t *ddl);
int DDL_IsStateReadyForIO(ddlState_t *state, unsigned __int8 *buffer);
int DDL_GetStateForCmdPath(ddlState_t *state, int startArg, int endArg);
void DDL_ResetBufferInternal(unsigned __int8 *buffer, int bufferSize, ddlDef_t *ddl);
int DDL_GetBufferSize(ddlDef_t *ddl);
ddlDef_t *DDL_LoadAssetWithVersion(const char *fileName, int version);
ddlDef_t *DDL_LoadAsset(const char *fileName);
void DDL_ResetAndAssociateBuffer(unsigned __int8 *buffer, int bufferSize, ddlDef_t *ddl);
int DDL_BitwiseCopy(;
int DDL_BitwiseCopy(ddlState_t *fromState, ddlState_t *toState, unsigned __int8 *buffer);
char DDL_IsStateZero(const ddlState_t *state, unsigned __int8 *buffer);
int DDL_Buffer_Check(int offset, int size);
int DDL_AreStateValuesSame(;
BOOL DDL_AreValuesEqual(ddlState_t *state, ddlValue_t *valueA, ddlValue_t *valueB);
void DDL_Reset(ddlState_t *searchState, const ddlDef_t *ddl);
int DDL_MoveTo(const ddlState_t *searchState, ddlState_t *resultState, int numArgs, ...);
int DDL_MoveToPath(const ddlState_t *searchState, ddlState_t *resultState, int depth, const char **ddlPath);
int DDL_IterateNext(const ddlState_t *searchState, ddlState_t *resultState);
int DDL_IterateFirst(const ddlState_t *searchState, ddlState_t *resultState);
ddlIntValueChanged_e DDL_WriteUIntValueIfChanged(;
int DDL_SetRawBytes(unsigned __int8 *buffer, int offset, int size, const char *valueToInsert);
int DDL_WriteUIntValueInternal(ddlState_t *state, int absoluteOffset, unsigned int valueToInsert);
int DDL_WriteIntValueInternal(;
int DDL_WriteInt64ValueInternal(;
int DDL_WriteFloatValueInternal(ddlState_t *state, int absoluteOffset, float value, unsigned __int8 *buffer);
int DDL_WriteFixedPointValueInternal(;
int DDL_WriteStringValueInternal(;
int DDL_WriteValueInternal(ddlState_t *state, int absoluteOffset, ddlValue_t value, unsigned __int8 *buffer);
int DDL_GetState(const ddlDef_t *ddl, ddlState_t *searchState, int numArgs, char *args);
int DDL_SetInt(ddlState_t *searchState, int value, unsigned __int8 *buffer);
int DDL_SetUInt(ddlState_t *searchState, unsigned int value, unsigned __int8 *buffer);
int DDL_SetInt64(ddlState_t *searchState, unsigned __int64 value, unsigned __int8 *buffer);
int DDL_SetFloat(ddlState_t *searchState, float value, unsigned __int8 *buffer);
int DDL_SetFloat(ddlDef_t *ddl, float value, unsigned __int8 *buffer, int numArgs, ...);
int DDL_SetFixedPoint(ddlState_t *searchState, float value, unsigned __int8 *buffer);
int DDL_SetFixedPoint(ddlDef_t *ddl, float value, unsigned __int8 *buffer, int numArgs, ...);
int DDL_SetString(ddlState_t *searchState, const char *value, unsigned __int8 *buffer);
int DDL_SetValue(ddlState_t *searchState, ddlValue_t value, unsigned __int8 *buffer);
int DDL_SetValue(ddlState_t *searchState, const char *value, unsigned __int8 *buffer);
int DDL_SetBits(unsigned __int8 *buffer, int bitOffset, int bitSize, unsigned int value);
unsigned int DDL_ReadUIntValueInternal(ddlState_t *state, int absoluteOffset, unsigned __int8 *buffer);
unsigned int DDL_GetUInt(ddlState_t *searchState, unsigned __int8 *buffer);
int DDL_ReadIntValueInternal(ddlState_t *state, int absoluteOffset, unsigned __int8 *buffer);
int DDL_GetInt(ddlState_t *searchState, unsigned __int8 *buffer);
unsigned int DDL_ReadInt64ValueInternal(ddlState_t *state, int absoluteOffset, unsigned __int8 *buffer);
unsigned int DDL_GetInt64(ddlState_t *searchState, unsigned __int8 *buffer);
float DDL_ReadFloatValueInternal(ddlState_t *state, int absoluteOffset, unsigned __int8 *buffer);
// float DDL_GetFloat@<st0>(ddlState_t *a1@<xmm0>, ddlState_t *searchState, unsigned __int8 *buffer);
// double DDL_GetFloat@<st0>(ddlState_t *a1@<xmm0>, ddlDef_t *ddl, unsigned __int8 *buffer, int numArgs, ...);
float DDL_ReadFixedPointValueInternal(ddlState_t *state, int absoluteOffset, unsigned __int8 *buffer);
// float DDL_GetFixedPoint@<st0>(ddlState_t *a1@<xmm0>, ddlState_t *searchState, unsigned __int8 *buffer);
// double DDL_GetFixedPoint@<st0>(;
bool DDL_GetBool(ddlState_t *searchState, unsigned __int8 *buffer);
bool DDL_GetBool(ddlDef_t *ddl, unsigned __int8 *buffer, int numArgs, ...);
char DDL_LoadStringValueInternal(;
char *DDL_ReadStringValueInternal(ddlState_t *state, int absoluteOffset, unsigned __int8 *buffer);
char *DDL_GetString(ddlState_t *searchState, unsigned __int8 *buffer);
char DDL_LoadString(ddlState_t *searchState, unsigned __int8 *buffer, char *outBuffer, int outBufferLength);
int DDL_ReadValueInternal(;
int DDL_GetValue(ddlState_t *searchState, ddlValue_t *result, unsigned __int8 *buffer);
unsigned int DDL_GetBits(unsigned __int8 *buffer, int bitOffset, int bitSize);
void DDL_CheckArrayBindings();
;
void DDL_ZeroState(ddlState_t *state, unsigned __int8 *buffer);
int DDL_SetBool(ddlState_t *searchState, bool value, unsigned __int8 *buffer);
int DDL_SetUpdatedChecksum(unsigned __int8 *buffer, int bufferSize);
unsigned int DDL_GetHeaderVersion(unsigned __int8 *buffer);
int DDL_FixBufferVersion(;
int DDL_ValidateHeader(;
int DDL_AssociateBufferNonDestructive(;
int DDL_AssociateBuffer(;
int DDL_SetBool(ddlDef_t *ddl, bool value, unsigned __int8 *buffer, int numArgs, ...);

//t6/code/src_noserver/ddl/ddl_buffer.cpp
void DDL_Buffer_SwapHeader(const ddlBufferHeader_t *src, ddlBufferHeader_t *dest);
void DDL_Buffer_WriteHeader(unsigned __int8 *buffer, const ddlBufferHeader_t *header);
void DDL_Buffer_ReadHeader(unsigned __int8 *buffer, ddlBufferHeader_t *header);
int DDL_Buffer_ReadBits(unsigned __int8 *buffer, int offset, int size);
void DDL_Buffer_WriteBits(unsigned __int8 *buffer, int offset, int size, unsigned int value);

//t6/code/src_noserver/ddl/ddl_buffer.h
void DDL_Buffer_ClearBytes(unsigned __int8 *buffer, int offset, int size);

//t6/code/src_noserver/ddl/ddl_cmd.cpp
void DDL_Cmd_GetAsset_f();
void DDL_Cmd_Show_f();
void DDL_Cmd_ShowMember_f();
void DDL_Cmd_ShowPaths_f();
void DDL_Cmd_Init();

//t6/code/src_noserver/ddl/ddl_converter.cpp
void DDL_Converter_CopyStates(;
void DDL_Converter_ProcessStates(;
void DDL_Converter_TraverseStruct(;
// int DDL_Converter_Versions@<eax>(;
char *DDL_PathStackPrint();
void DDL_Converter_ProcessStateForPaths(;
void DDL_Converter_TraverseStructForPaths(;
int DDL_Converter_GetPathsInBytes(ddlDef_t *ddlDef, int startByte, int endByte);

//t6/code/src_noserver/ddl/ddl_load_db.h
void Load_ddlMemberDef_tArray(bool atStreamStart, int count);
void Load_ddlStructDef_tArray(bool atStreamStart, int count);
void Load_ddlEnumDef_tArray(bool atStreamStart, int count);
void Mark_ddlRoot_ptr();
void Load_ddlDef_t(bool atStreamStart);
void Load_ddlRoot_t(bool atStreamStart);
void Load_ddlRoot_ptr(bool atStreamStart);

//t6/code/src_noserver/ddl/ddl_lookup.cpp
ddlMemberDef_t *DDL_Lookup_FindInStruct(;
void DDL_Lookup_ClearState(ddlState_t *searchState);
ddlMemberDef_t *DDL_Lookup_FindMemberDefByLName(;
ddlMemberDef_t *DDL_Lookup_FindMemberDef(const char *memberName, ddlStructDef_t *structDef);
ddlMemberDef_t *DDL_Lookup_MoveToIndex(;
int DDL_Lookup_FindEnumIndexByName(ddlEnumDef_t *enumDef, int hashStartIndex, const char *memberName);
int DDL_Lookup_MoveTo(const ddlState_t *searchState, const char *name, ddlState_t *resultState);
int DDL_Lookup_MoveNext(const ddlState_t *searchState, ddlState_t *resultState);
BOOL DDL_Lookup_MoveToStart(ddlState_t *resultState, ddlDef_t *ddl);

//t6/code/src_noserver/demo/demo_camera.cpp
AIDemoLockOnValues *Demo_GetAILockOnValues(centity_t *cent);
int Demo_GetAILockOnViewIndex(centity_t *cent);
demoFreeCameraMode Demo_GetCurrentFreeCameraMode();
demoFreeCameraMode Demo_GetNextFreeCameraMode(demoFreeCameraMode currentCameraMode, bool direction);
void Demo_UpdateVisibilityBitsForCameraMode(LocalClientNum_t localClientNum, int cameraMode);
void Demo_FreeCameraCalcView(LocalClientNum_t localClientNum);
void Demo_SaveView(LocalClientNum_t localClientNum);
bool Demo_IsThirdPersonCamera();
bool Demo_IsAnyFreeMoveCamera();
bool Demo_IsMovieCamera();
bool Demo_IsDollyCamera();
bool Demo_IsCameraEditMode();
int Demo_GetHighlightedDollyCamMarker();
bool Demo_IsRepositioningDollyCamMarker();
int Demo_GetDollyCamMarkerCount();
int Demo_GetDollyCamMarkerForTime(int serverTime);
void Demo_GetOriginForDollyCamMarker(int index, vec3_t *result);
void Demo_GetAnglesForDollyCamMarker(int index, vec3_t *result);
demoDollyCameraTimeScaleMode Demo_GetTimeScaleModeForDollyCamMarker(int marker);
double Demo_GetTimeScaleForDollyCamMarker(int marker);
double Demo_GetInterpolatedTimeScaleForDollyCamMarker(LocalClientNum_t localClientNum, int marker);
bool Demo_IsFreeCameraEntityLockOnAllowed();
int Demo_GetHighlightedFreeCameraLockOnEntity();
void Demo_LerpClipCameraValues(LocalClientNum_t localClientNum);
void Demo_RegisterDollyCameraFX();
int Demo_GetTimeForDollyCamMarker(int index);
void Demo_GetInterpolatedSplinePointAndAngles(;
void Demo_GetDollyCamMarkerParameters(int marker, demoDollyCamFX *glowFXValue);
void Demo_ClearDollyCamMarkerFX(LocalClientNum_t localClientNum, int markerIndex);
void Demo_DrawDollyCamPoint(LocalClientNum_t localClientNum, int markerIndex);
void Demo_DrawDollyCamTrack();
void Demo_UpdateDollyCamera(LocalClientNum_t localClientNum);
void Demo_WriteDollyCamKeyFrameInformation(LocalClientNum_t localClientNum, int markerIndex);
void Demo_JumpToDollyCamKeyFrame(LocalClientNum_t localClientNum, int markerIndex);
void Demo_ClearGhostDollyCam(LocalClientNum_t localClientNum);
// void Demo_DrawGhostDollyCam(int a1@<edx>, LocalClientNum_t localClientNum);
bool Demo_ShouldUpdateFreeCamera(LocalClientNum_t localClientNum);
bool Demo_DoesEntitySupportFreeCameraLockOn(centity_t *cent);
unsigned int Demo_GetRenderFxFlagsForEntity(centity_t *cent);
float Demo_GetLockOnHighlightThresholdDistanceForEntity(centity_t *cent);
void Demo_UpdateLockOnCamera(LocalClientNum_t localClientNum, usercmd_s *cmd);
void Demo_UpdateHighlightReelKillcamValues(LocalClientNum_t localClientNum);
void Demo_SwitchCameraMode(LocalClientNum_t localClientNum, demoCameraMode newCamMode);
void Demo_SwitchCamera(LocalClientNum_t localClientNum);
void Demo_SwitchFreeCamMode(LocalClientNum_t localClientNum, demoFreeCameraMode anticlockwise);
bool Demo_IsFreeCameraLockedOnEntity();
bool Demo_IsTimeScaleAdjustmentEnabled(LocalClientNum_t localClientNum);
void Demo_RefreshAllDollyCamFX(LocalClientNum_t localClientNum);
void Demo_DrawDollyCamInformation(LocalClientNum_t localClientNum, int infoEnum);
void Demo_JumpToDollyCamMarkerTime(LocalClientNum_t localClientNum, int markerNum);
void Demo_ApplyNewDollyCamMarkerPosition(LocalClientNum_t localClientNum, bool discardChanges);
void Demo_ClampViewAngleForLockedOnEntity(LocalClientNum_t localClientNum);
void Demo_UpdateLockOnCameraHighlight(LocalClientNum_t localClientNum);
;
void Demo_FreeCameraMove(LocalClientNum_t localClientNum, usercmd_s *cmd);

//t6/code/src_noserver/demo/demo_common.cpp
void Demo_RegisterDvars();
void Demo_SwitchPlayer_f();
void Demo_SaveAndUploadClip_f();
void Demo_SwitchTransition_f();
void Demo_Keyboard_f();
void Demo_DownloadAndPlay_f();
int Demo_CompareDollyCamMarkersBasedOnTime(const void *marker1, const void *marker2);
int Demo_CompareDollyCamMarkersBasedOnKeyframeBufferStart(const void *marker1, const void *marker2);
void Demo_ClearRenderFlag_f();
void Demo_AbortFileshareDownload_f();
bool Demo_IsEnabled();
void Demo_SetDemoState(demoState state);
demoState Demo_GetDemoState();
BOOL Demo_IsIdle();
BOOL Demo_IsRecording();
BOOL Demo_IsPlaying();
demoMain *Demo_GetDemoName();
int Demo_GetTotalSize();
void Demo_Printf(int channel, const char *fmt, ...);
void Demo_Init();
bool Demo_InitWrite();
void Demo_Frame(int msec, int scaledMsec);
void Demo_End();
;
char Demo_WriteToSpawnDebugBuffer(unsigned __int8 *buf, int bufSize);
void Demo_Play_f();
void Demo_Stop_f();
void Demo_Forward_f();
void Demo_Back_f();
void Demo_JumpToStart_f();
void Demo_StartClipRecord_f();
void Demo_PreviewClip_f();
void Demo_DeleteClip_f();
void Demo_SaveSegment_f();
void Demo_MoveSegment_f();
void Demo_DeleteSegment_f();
void Demo_PreviewSegment_f();
void Demo_MergeSegments_f();
void Demo_Screenshot_f();
void Demo_SaveScreenshot_f();
void Demo_CaptureSegmentThumbnail_f();
void Demo_RegenerateHighlightReel_f();
void Demo_RebuildHighlightReelTimeline_f();
void Demo_SwitchControls_f();
void Demo_AddDollyCamMarker_f();
void Demo_RemoveDollyCamMarker_f();
void Demo_SwitchDollyCamMarker_f();
void Demo_RepositionDollyCamMarker_f();
void Demo_UpdateDollyCamMarkerParameters_f();
void Demo_SetLagFlag_f();
void Demo_RegisterCommands();

//t6/code/src_noserver/demo/demo_contentserver.cpp
void Demo_StartStreaming(const ControllerIndex_t controllerIndex);
void Demo_SetUploadFileID();
unsigned __int64 Demo_GetUploadFileID();
void Demo_BBPostDemoStreamStatsForGame();
void Demo_BBPostDemoStreamStatsForInterval();
void Demo_StopStreaming();
void Demo_SetupDWStreamingSocketParams(int sendSocketBuffSize);
void Demo_SetLeagueTags(ControllerIndex_t controllerIndex, int *numTags);
void Demo_SetTags(;
void Demo_SetStreamingParameters(int svTotalBytesSent, int svMaxBytesPerFrame);
int Demo_GetCurrUsedBuffer();
int Demo_CurrAvailableBuffer();
int Demo_GetMaxBufferSize();
bool Demo_IsStreamingActive();
bool Demo_IsStreamingOverflowed();
bool Demo_IsStreamingFinished();
void Demo_BBPostDemoStreamStatsForRound(int roundNumber);
int Demo_GetEstimatedTimeToFinishStreaming(LocalClientNum_t localClientNum);
bool Demo_SetMetaData(;
void Demo_WriteSummary_SuccessCallback(ControllerIndex_t controllerIndex, unsigned __int64 fileID);
void Demo_StreamingSuccessCallback(ControllerIndex_t controllerIndex, unsigned __int64 fileID);
void Demo_StreamingFailureCallback();
void Demo_UploadMatchRecordData();
unsigned int Demo_ThrottleStream(unsigned int dataSize);
void Demo_AppendToStreamingHistory(int val, bool isAdded);
void Demo_RecordSentPacket(unsigned int size);
unsigned int Demo_WriteToStream(void *data, unsigned int dataSize);
void Demo_SetupStreamingForRecording(ControllerIndex_t controllerIndex, char *demoName);
void Demo_SaveToStreamBuffer(const void *data, int dataSize);
void Demo_SaveScreenshotSummarySuccess(ControllerIndex_t controllerIndex);
void Demo_SaveScreenshotFailure();
void Demo_SaveScreenshotSuccessful(ControllerIndex_t controllerIndex, unsigned __int64 fileID);
void Demo_SaveScreenshotToContentServer(LocalClientNum_t localClientNum, int fileSlot);
void Demo_UploadClipSummarySuccess(ControllerIndex_t controllerIndex);
void Demo_UploadClipFailure();
void Demo_UploadClipSuccess(ControllerIndex_t controllerIndex, unsigned __int64 fileID);
int Demo_MoveToNextClipStreamingPhase();
int Demo_SetupClipStreamingState();
int Demo_SendClipToStreamingBuffer(void *data, unsigned int dataSize, unsigned int bytesUploaded);
void Demo_WriteRecordedClipToContentServer(LocalClientNum_t localClientNum, int slot);
bool Demo_IsDemoDownloading();
void Demo_DownloadFileCallback(;
unsigned __int8 Demo_DownloadNextFileSegment();
bool Demo_ShouldRetryDownloadOfFileSegment();
void Demo_RetryDownloadOfFileSegment();
void Demo_SetNextDownloadPhase(bool success);
void Demo_DownloadFileSuccess();
void Demo_DownloadFileFailure();
void Demo_DownloadFile(;
double Demo_GetStreamedDownloadProgress();
bool Demo_IsReadyForStreamedDemoPlayback();
void Demo_ResetReadyForStreamedDemoPlayback();
bool Demo_HaveWeDownloadedNextFileSegmentData();
bool Demo_AreWeStreamingFileDownload();
void Demo_DownloadAndPlaySuccess();
void Demo_DownloadAndPlay(ControllerIndex_t controllerIndex, unsigned __int64 fileID);
bool Demo_ShouldResumeAbortedDemoDownload();
void Demo_ResumeAbortedDemoDownload();

//t6/code/src_noserver/demo/demo_files.cpp
void Demo_InitFileHandlerSystem();
void Demo_AllocateMemoryFromStreamBuffer(int size);
void Demo_ReturnStreamBufferMemory();
bool Demo_IsStreamBufferAllocated();
int Demo_GetCurrentAllocatedFileSize();
char *Demo_GetStreamAllocatedBuffer();
int Demo_GetFileReadOffset();
void Demo_GetDemoPath();
int Demo_OpenFileWrite(const char *filename, const char *dir, bool supressErrors);
int Demo_OpenFileRead(const char *filename, const char *dir, bool supressErrors);
int Demo_Write(const void *buffer, int len, int handle);
int Demo_Read(void *buffer, int len, int handle);
void Demo_CloseFile(int handle);
int Demo_SeekFile(int handle, int offset, int origin);

//t6/code/src_noserver/demo/demo_highlightreel.cpp
demoPlayback *Demo_SetupHighlightReelInformationDefines();
demoPlayback *Demo_SetupHighlightReelStarLevels();
void Demo_InitializeHighlightReelSystem();
demoHighlightReelInformationDefine *Demo_GetHighlightReelInformationDefine(;
demoHighlightReelInformationDefine *Demo_GetHighlightReelInformationDefineFromBookmarkType(;
int Demo_GetEntityLookAtForBookmark(const demoDefaultBookmark *bookmark);
bool Demo_BookmarkMatchesForClientNum(ClientNum_t clientNum, const demoDefaultBookmark *bookmark);
int Demo_CompareHighlightReelTimelineEventsByStartTime(const void *event1, const void *event2);
int Demo_CompareHighlightReelTimelineEventsByMultipleParameters(const void *event1, const void *event2);
void Demo_HighlightReelFinalizePlayerDeathInformation(;
void Demo_HighlightReelPrepareFirstPersonInformation(;
void Demo_HighlightReelPrepareSingleEventInformation(;
int Demo_FinishPendingHighlightReelTimelineUpdates();
bool Demo_HighlightReelShouldFilterPlayer(;
bool Demo_HighlightReelShouldFilterByStyle_MP(;
void Demo_SetupHighlightReelKillcam(;
void Demo_UpdateHighlightReelKillcamEntityValidity(;
void Demo_ResetHighlightReelKillcam(LocalClientNum_t localClientNum);
void Demo_UpdateHighlightReelTimeScale(;
void Demo_SetHighlightReelTransition(demoClipTransition *transition);
const cpose_t *Ragdoll_HandleBody(const cpose_t *pose);
double Demo_GetHighlightReelStarsForPriority(int priority);
void Demo_CancelHighlightReelCreation();
void Demo_ProcessAndFinalizeHighlightReelMoments(int numberOfSegmentsToRetain);
void Demo_SetupHighlightReelTimeline(LocalClientNum_t localClientNum);
void Demo_HighlightReelUpdate(LocalClientNum_t localClientNum);

//t6/code/src_noserver/demo/demo_party.cpp
void Demo_PartyPlayDemo_f();
void Demo_PartyStopDemo_f();
void Demo_SetDemoLoadedTime();
bool Demo_WasDemoJustLoaded();
void Demo_PartyFinishedLoadingDemo();
void Demo_InitFileShareTaskHandler();
void Demo_ResetFileShareAbort();
bool Demo_IsFileShareAbortInProcess();
ControllerIndex_t Demo_GetFileShareTaskControllerIndex();
char Demo_HaveAllPlayersFinishedDownloading(PartyData_s *party);
char Demo_AreAllPlayersReadyToLoadDemo(PartyData_s *party);
bool Demo_IsStereo3D();
char Demo_HaveAllPlayersFinishedLoadingDemo();
bool Demo_IsHostControlsEnabled();
bool Demo_IsClipAndScreenshotsEnabled();
bool Demo_IsWatchingWithParty();
void Demo_WriteHeartbeat(LocalClientNum_t localClientNum, PartyData_s *party, msg_t *msg);
void Demo_ReadHeartbeat(LocalClientNum_t localClientNum, PartyData_s *party, msg_t *msg);
void Demo_ToggleScoreboard();
bool Demo_DisplayingPartyScoreboard();
void Demo_AbortFileShareDownload(ControllerIndex_t controllerIndex);
bool Demo_CanRenderClip();
void Demo_PartyUpdateDemo_f();
void Demo_FreeDemoMemory_f();
void Demo_RegisterPartyCommands();

//t6/code/src_noserver/demo/demo_playback.cpp
void Demo_DeallocatePlaybackMemory();
void Demo_TagPlayer(demoTaggedPlayers *players, int playerIndex);
void Demo_TagPlayers(LocalClientNum_t localClientNum, demoTaggedPlayers *players);
void Demo_PopulateDefaultMetaInformation(;
// void Demo_HiResScreenshot(char *a1@<edx>, LocalClientNum_t localClientNum);
void Demo_SaveScreenshot(LocalClientNum_t localClientNum, unsigned int fileSlot);
void Demo_EnableSnapshotProcessing();
void Demo_SetWorldFogSnapTransition(LocalClientNum_t localClientNum);
void Demo_SetWorldFogUseSystemTime(LocalClientNum_t localClientNum, bool useSystemTime);
bool Demo_IsPlaybackInited();
bool Demo_IsPaused();
void Demo_SetCompleted(bool flag);
bool Demo_IsShutdownInProgress();
double Demo_GetTimeScale();
double Demo_GetMaxTimeScale();
bool Demo_IsClipPlaying();
void Demo_SetJumpTimeFlag(bool flag);
bool Demo_GetJumpTimeFlag();
void Demo_SetSwitchedPlayersFlag(bool flag);
bool Demo_GetSwitchedPlayersFlag();
__int64 Demo_GetPlayerXUID(ControllerIndex_t controllerIndex);
double Demo_GetAnimTimeAtJump(int entNum);
bool Demo_IsActorCorpseOutOfSync(int corpseIndex, int useCount);
BOOL Demo_ShouldEntityBeVisibleToClient(int entNum);
void Demo_SetupForPlayerSwitch(LocalClientNum_t localClientNum);
void Demo_Pause();
bool Demo_SwitchPlayerInternal(;
bool Demo_ShouldUpdateViewAngles(LocalClientNum_t localClientNum);
int Demo_GetKeyFrameTime(int index);
int Demo_GetSegmentCount();
bool Demo_IsInformationScreenActive();
void Demo_ActivateInformationScreen(LocalClientNum_t localClientNum, demoInformationScreenTypes screen);
void Demo_ResetSnapshotData();
void Demo_ResetTimeValues(LocalClientNum_t localClientNum, int time);
void Demo_ResetSequenceNumbers(LocalClientNum_t localClientNum, int sequence);
void Demo_ResetWorldInformation(LocalClientNum_t localClientNum, int time);
bool Demo_IsGameHudHidden();
bool Demo_IsCapturingScreenshot(LocalClientNum_t localClientNum);
int Demo_IsRenderingMovie();
void Demo_ClearRenderingMovieFlag();
int Demo_IsHighlightReelMode();
bool Demo_IsCreatingHighlightReel();
bool Demo_IsCreatingHighlightReelKillcam();
int Demo_IsShoutcastMode();
void Demo_SetClipState(demoClipState state);
demoClipState Demo_GetClipState();
bool Demo_IsClipPreviewRunning();
void Demo_CancelPreview();
int Demo_GetClipTime();
int Demo_GetTotalClipDuration();
void Demo_SetClipModified(bool flag);
bool Demo_IsClipModified();
void Demo_PopulateClipPlayerTags();
bool Demo_IsWaitingForDownloadData();
void Demo_WriteConfigStrings(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_UpdateConfigStrings(LocalClientNum_t localClientNum);
void Demo_WriteCustomSnapshotInformation_Actors(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_WriteCustomSnapshotInformation(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_ReadCustomSnapshotInformation_Actors(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_ReadCustomSnapshotInformation(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_GenerateUncompressedSnapshot(;
bool Demo_ShouldGenerateKeyFrameSnapshot(LocalClientNum_t localClientNum, int serverTime);
void Demo_WriteKeyFrameInformation(LocalClientNum_t localClientNum);
char *Demo_AdjustTimeForConfigString(int configStringIndex, const char *string);
char *Demo_AdjustTimeForReliableCommand(const char *cmd);
void Demo_AdjustTimeForMatchState(int currentTime, int clipTime, MatchState *matchstate);
void Demo_AdjustTimeForPlayerStateHudElement(int currentTime, int clipTime, int index, hudelem_s *hudElem);
void Demo_AdjustTimeForPlayerState(int currentTime, int clipTime, playerState_s *ps);
void Demo_AdjustTimeForEntityState(int currentTime, int clipTime, entityState_s *state);
void Demo_WriteClipGameState(LocalClientNum_t localClientNum);
char Demo_CaptureThumbnailForSegment();
unsigned int Demo_WriteTransitionClipCommandBlockToBuffer(;
void Demo_SaveClipRecordMessageToMainMemory(;
void Demo_OpenManageSegments(LocalClientNum_t localClientNum);
void Demo_ReadHeader();
void Demo_SetDefaultVisionSet(LocalClientNum_t localClientNum);
void Demo_InitPlaybackData(LocalClientNum_t localClientNum);
void Demo_RestorePreDemoSettings();
void Demo_ParseServerCommands(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_ReadMatchState(LocalClientNum_t localClientNum, msg_t *msg, int time);
playerState_s *Demo_ReadPlayerStates(;
int Demo_ReadPacketEntities(LocalClientNum_t localClientNum, msg_t *msg, int time, int deltaNum);
int Demo_ReadPacketClients(LocalClientNum_t localClientNum, msg_t *msg, int time, int deltaNum);
int Demo_ReadPacketActors(LocalClientNum_t localClientNum, msg_t *msg, int time, int deltaNum);
void Demo_ParseClientPackets(msg_t *msg);
void Demo_ParseReliableCmdSizes(msg_t *msg);
char Demo_ReadFooter(char *name, int handle);
bool Demo_ShouldIgnoreScoreboardToggle(LocalClientNum_t localClientNum);
void Demo_ActivateHoldInput(LocalClientNum_t localClientNum);
void Demo_AllocatePlaybackMemory(int location);
void Demo_Load();
void Demo_SetDefaultClient(LocalClientNum_t localClientNum, ClientNum_t defaultClient);
bool Demo_IsCompleted();
void Demo_SetTimeScale(float timeScale);
char Demo_IsClipRecording();
bool Demo_GetClipPausedState();
unsigned int Demo_GetCurrentControllerConfig();
int Demo_GetKeyFrameForJumpBack(LocalClientNum_t localClientNum, int newServerTime);
int Demo_GetKeyFrameForJumpForward(LocalClientNum_t localClientNum, int currentTime);
void Demo_ActivateTransitionScreen(LocalClientNum_t localClientNum, int transition);
void Demo_UpdateInformationScreen(LocalClientNum_t localClientNum);
bool Demo_ShouldFilterHudElement(hudelem_s *elem);
bool Demo_IsDemoHudHidden();
void Demo_UpdateClipTime(int msec);
void Demo_StoreConfigString(int index, const char *s);
void Demo_ReadConfigStrings(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_InitClipRecord(LocalClientNum_t localClientNum, bool newClip);
void Demo_WriteClipCommandsInternal(LocalClientNum_t localClientNum, msg_t *msg, bool setClipRecordParams);
void Demo_WriteClipCommands(LocalClientNum_t localClientNum, msg_t *msg, bool setClipRecordParams);
void Demo_WriteUncompressedClipSnapshot(LocalClientNum_t localClientNum);
bool Demo_CanStartClipRecord(LocalClientNum_t localClientNum);
void Demo_PreviewSegment(LocalClientNum_t localClientNum, int segmentIndex);
void Demo_WriteDemoPreviewPoint(LocalClientNum_t localClientNum, demoRestorePoint restorePoint);
void Demo_SetupPlaybackForClient(LocalClientNum_t localClientNum, playerState_s *ps);
void Demo_UpdateCurrentSnapshot(LocalClientNum_t localClientNum, playerState_s *ps);
void Demo_HandleInputForControllerConfig(;
void Demo_HandleHoldInput(LocalClientNum_t localClientNum, int key, bool holdResult);
BOOL Demo_IsTimeStopped();
void Demo_SwitchPlayer(LocalClientNum_t localClientNum, bool anticlockwise);
void Demo_GenerateKeyFrameSnapshot(LocalClientNum_t localClientNum, demoSnapshotData *snapshotData);
char Demo_StartClipRecord(LocalClientNum_t localClientNum);
void Demo_PauseClipRecord(LocalClientNum_t localClientNum);
void Demo_WriteClipCommandsWhenPaused(LocalClientNum_t localClientNum);
demoClipCommand Demo_ParseClipCommand(LocalClientNum_t localClientNum, msg_t *msg, bool setClipPlaybackParams);
void Demo_ParseSnapshot(LocalClientNum_t localClientNum, msg_t *msg);
void Demo_ParseServerMessage(LocalClientNum_t localClientNum, msg_t *msg, int msgType, int msgSequence);
void Demo_HandleInput(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex, int key, int pressed);
void Demo_ProcessKeyFrameJump(LocalClientNum_t localClientNum, int keyframeIndex);
void Demo_JumpForward(LocalClientNum_t localClientNum, int serverTime);
void Demo_JumpBack(LocalClientNum_t localClientNum, int serverTime);
void Demo_RestoreDemoPreviewPoint(LocalClientNum_t localClientNum, demoRestorePoint restorePoint);
void Demo_RestoreUIStateAfterPreview(LocalClientNum_t localClientNum);
void Demo_ReadGamestate(LocalClientNum_t localClientNum);
void Demo_ProcessPlayback(ControllerIndex_t controllerIndex);
char Demo_ReadDemoMessage(LocalClientNum_t localClientNum);

//t6/code/src_noserver/demo/demo_profile.cpp
bool Demo_GetAnalyzePrintDataType(int fieldBit);
void Demo_RecordProfileData(demoProfileData profileDataType, int size);
void Demo_PrintProfileData();
void Demo_DrawDebugInformation(LocalClientNum_t localClientNum);
void Demo_DrawProfile();

//t6/code/src_noserver/demo/demo_recording.cpp
void Demo_PopulateStaticFooterInformation(demoFooter *footer);
unsigned __int8 *Demo_GetActiveMemoryBuffer();
int Demo_WriteMemoryBlockDataToFile();
int Demo_WriteMemoryBlockDataToBuffer(demoMemBlock *memBlock, unsigned __int8 *to, int maxBufferSize);
void Demo_SetIntermissionPoint(vec3_t *origin, vec3_t *angles);
void Demo_RecordPlayerSessionState(ClientNum_t clientNum, int state);
bool Demo_IsInFinalKillcam();
void Demo_ClientConnected(ClientNum_t clientNum);
ClientNum_t Demo_GetDefaultClient();
bool Demo_IsGameStateWritten();
void Demo_WriteHeader(msg_t *msg, bool isDemoClip);
bool Demo_ShouldFilterServerCommand(ClientNum_t clientNum, const char *cmd);
void Demo_WriteServerCommands(msg_t *msg, bool liveStreamNoDelta);
void Demo_WriteSnapshotStartData(;
void Demo_WriteMatchState(msg_t *msg, bool liveStreamNoDelta);
void Demo_WritePlayerStates(msg_t *msg, bool liveStreamNoDelta);
void Demo_WritePacketEntities(msg_t *msg, bool liveStreamNoDelta);
void Demo_InfoPlayerConnected(ClientNum_t clientNum);
void Demo_UpdatePlayerDisconnectInformation(ClientNum_t clientNum, int playerIndex);
void Demo_InfoPlayerDisconnected(ClientNum_t clientNum);
void Demo_WritePacketClients(msg_t *msg, bool liveStreamNoDelta);
void Demo_WritePacketActors(msg_t *msg, bool liveStreamNoDelta);
void Demo_WriteSpawnDebugBuffer(msg_t *msg, bool liveStreamNoDelta);
void Demo_LogClientPacket(netchan_t *pChan, int iSize, int bFragment);
void Demo_LogReliableCmd(ClientNum_t cl, int iSize, char cmdChar);
void Demo_WriteExtraNetworkProfileData(msg_t *msg);
void Demo_BuildDemoSnapshotInternal(msg_t *msg, bool liveStreamNoDelta);
void Demo_WriteFooterInternal(msg_t *msg, demoFooter *footer, bool isClip);
unsigned int Demo_WriteClipFooterToBuffer(;
void Demo_WriteFooter(int handle, demoFooter *footer);
void Demo_AddBookmark(;
void Demo_SetLagFlag(demoLagFlag_e flag);
demoLagFlag_e Demo_GetLagFlag();
void Demo_StartRecord();
void Demo_SaveInternal(unsigned __int8 *data, int size, bool writeFooter, bool gameState);
void Demo_Save(unsigned __int8 *data, int size, unsigned __int8 *writeFooter, bool gameState);
bool Demo_ShouldBuildDemoSnapshot();
void Demo_StartSaveProcess(bool gameState);
int Demo_SaveCallback(jqBatch *batch);
void Demo_WriteGamestateToBuffer(ClientNum_t clientNum, msg_t *msg, int msgSequence);
void Demo_BuildDemoSnapshot();

//t6/code/src_noserver/demo/demo_ui.cpp
const char *Demo_GetKeyboardTitle();
const char *Demo_GetKeyboardDefaultText();
int Demo_GetKeyboardTextSize();
void Demo_GetStartAndEndTime(int *startTime, int *endTime);
void Demo_GetDuration(char *outputText, int duration);
char *Demo_GetAuthor();
char *Demo_GetTitleName();
char *Demo_GetTitleDescription();
char *Demo_GetTimeInfo();
char *Demo_GetDuration();
char *Demo_GetSaveScreenName(const char *type);
char *Demo_GetSaveScreenDescription(const char *type);
void Demo_GetConnectionTimeInfoForPlayer(;
int Demo_GetPlayerIndexForClientNum(ClientNum_t clientNum, int serverTime);
int Demo_GetNextDefaultBookmarkForPlayer(int playerIndex, ClientNum_t clientNum, int index);
int Demo_GetNextDefaultBookmarkForPlayer(;
const char *Demo_GetDebugNameForBookmarkType(demoBookmarkType type);
const char *Demo_GetFreeCamModeName();
int Demo_GetNextDollyCamMarker(LocalClientNum_t localClientNum, int index, int *time, vec4_t *color);
const char *Demo_GetTimeScaleModeNameForDollyCamMarker(int marker);
void Demo_OpenDollyCamMarkerPopUp(LocalClientNum_t localClientNum);
bool Demo_IsDollyCamMarkerDialogOpen(LocalClientNum_t localClientNum);
void Demo_GetActivatedColorForButton(demoControlsButton demoControlButtonType, vec4_t *color);
void Demo_DrawVerticalLine(;
char *Demo_GetSegmentTransition(int index);
clipSegment *Demo_GetSegmentInformation(int index, const char *s);
char Demo_IsPauseMenuOpen(LocalClientNum_t localClientNum);
void Demo_OpenSavePopUp(LocalClientNum_t localClientNum, demoSavePopup type);
bool Demo_IsSaveDialogOpen(LocalClientNum_t localClientNum);
void Demo_Error(LocalClientNum_t localClientNum, const char *errorTitle, const char *errorMessage);
bool Demo_IsErrorDialogOpen(LocalClientNum_t localClientNum);
bool Demo_ShouldDrawDemoControlsHUD(LocalClientNum_t localClientNum);
void Demo_KeyboardComplete(;

//t6/code/src_noserver/demo/demo_version.cpp
int Demo_GetVersion();
bool Demo_IsVersionAtLeast(int version);
const NetFieldList *Demo_GetNetFieldListForType(netFieldTypes_t fieldType);
const NetFieldList *Demo_GetStateFieldListForEntityType(const int eType);

//t6/code/src_noserver/devgui/devgui.cpp
void TRACK_devgui();
const dvar_t *DevGui_RegisterDvars();
DevMenuItem *DevGui_GetMenu(unsigned __int16 handle);
unsigned __int16 DevGui_GetMenuParent(unsigned __int16 handle);
bool DevGui_EditableMenuItem(const DevMenuItem *menu);
void DevGui_FreeMenu_r(unsigned __int16 handle);
unsigned __int16 DevGui_FindMenu(unsigned __int16 parentHandle, const char *label);
int DevGui_PathToken(const char **pathInOut, char *label, __int16 *sortKeyOut);
unsigned __int16 DevGui_ConstructPath_r(unsigned __int16 parent, const char *path);
bool DevGui_IsValidPath(const char *path);
void DevGui_AddDvar(const char *path, const dvar_t *dvar);
void DevGui_AddDvarList(const char *path, const dvar_t *dvar);
void DevGui_AddCommand(const char *path, const char *command);
bool DevGui_DoesMenuExist(const char *path);
void DevGui_RemoveMenu(const char *path);
void DevGui_OpenMenu(const char *path);
int DevGui_MaxChildMenuWidth(LocalClientNum_t localClientNum, const DevMenuItem *menu);
void DevGui_DrawMenuVertically(;
void DevGui_DrawMenuHorizontally(;
void DevGui_DrawMenu(;
void DevGui_ChooseOrigin(LocalClientNum_t localClientNum, int *origin);
unsigned int DevGui_GetSliderPath(unsigned __int16 menuHandle, char *path, int pathLen);
void DevGui_DrawSliderTitle(int x, int y, const DevMenuItem *menu);
void DevGui_DrawSingleSlider(;
;
int DevGui_MenuRowCount(const DevMenuItem *menu);
const dvar_t *DevGui_SelectedDvarFromMenu(const DevMenuItem *menu);
void DevGui_DrawSliders(const DevMenuItem *menu);
void DevGui_DrawBindNextKey();
void DevGui_DrawGraph(const DevMenuItem *menu, LocalClientNum_t localClientNum);
void DevGui_Draw(LocalClientNum_t localClientNum);
void DevGui_AdvanceChildNum(int numberToAdvance);
void DevGui_SelectTopLevelChild();
void DevGui_Init();
void DevGui_Shutdown();
void DevGui_KeyPressed(int key);
void DevGui_Toggle();
bool DevGui_IsActive();
void DevGui_AddGraph(const char *path, DevGraph *graph);

//t6/code/src_noserver/devgui/devgui_input.cpp
void DevGui_InputInit();
void DevGui_InputShutdown();
void DevGui_SelectGamepad(ControllerIndex_t gamePadIndex);
void DevGui_MouseEvent(int dx, int dy);
bool DevGui_IsButtonDown(DevGuiInputButton button);

//t6/code/src_noserver/devgui/devgui_util.cpp
int DevGui_GetScreenXPad();
void DevGui_DrawBevelBox(int x, int y, int w, int h);
void DevGui_DrawLine(vec2_t *start, vec2_t *end, int width, const unsigned __int8 *color);

//t6/code/src_noserver/dw/dwmatchmaking.cpp
void checkForBadGeoInfo(MatchMakingInfo *sessionInfo, TaskRecord *task);
void dwCreateSession(TaskRecord *task, MatchMakingInfo *const sessionInfo);
void dwUpdateSession(TaskRecord *task, MatchMakingInfo *const sessionInfo);
void dwDeleteSession(ControllerIndex_t controllerIndex, TaskRecord *task);

//t6/code/src_noserver/dw/dwmessaging.cpp
char dwInstantHandleTestMessage(unsigned __int64 senderID, const ControllerIndex_t controllerIndex, msg_t *msg);
bool dwInstantHandlePartyMessage(;
bool dwInstantHandleFriendMessage(;
bool dwInstantDispatchMessage_Internal(;
// void __thiscall dwLobbyEventHandler::onNewNotification(dwLobbyEventHandler *this);
// void __thiscall dwLobbyEventHandler::onTeamProposal(dwLobbyEventHandler *this);
// void __thiscall dwLobbyEventHandler::onPlayerBanned(;
// void __thiscall dwLobbyEventHandler::onMultipleLogon(dwLobbyEventHandler *this, unsigned __int64 userID);
// void __thiscall dwLobbyEventHandler::onYouTubeRegistration(;
// void __thiscall dwLobbyEventHandler::onGlobalInstantMessage(;
void dwInitMessaging(ControllerIndex_t controllerIndex);
TaskRecord *dwInstantSendMessage(;
void dwInstantSendTestMessage();
char dwProcessNotifications(TaskRecord *task);
// void __thiscall dwLobbyEventHandler::onChallengesReceived(;

//t6/code/src_noserver/dw/dwnet.cpp
bdSecurityID *FindCommonAddrGroup(const bdSecurityID *id);
unsigned int CommonAddrToInAddr(CommonAddrGroup *group, CommonAddr *addr);
const char *PacketSummaryString(const void *dataVoid, int length);
bool InAddrToCommonAddr(unsigned int inaddr, CommonAddrGroup **resultGroup, CommonAddr **resultAddr);
int dwCheckConnections();
// bdReference<bdAddrHandle> *dwNetadrToAddrHandle(;
char dwNetadrToCommonAddr(;
unsigned int dwCommonAddrToString(;
in_addr dwCommonAddrToInAddr(const unsigned __int8 *commonAddrBuf, const unsigned int commonAddrBufSize);
int dwGetConnectionTaskStatus(netadr_t *const netadr);
void dwPrintAddrGroups();
void dwNetInit();
const char *RegisterCommonAddrGroup(const bdSecurityID *id);
const char *UnregisterCommonAddrGroup(const bdSecurityID *id);
unsigned int RegisterEndpoint(const bdEndpoint *endpoint, const char **errorMsg);
const char *DeregisterEndpoint(const bdEndpoint *endpoint);
bool dwRegisterSecIDAndKey(const bdSecurityID *id, const bdSecurityKey *key);
int dwSendTo(const unsigned int length, const void *data, const netadr_t to);
int dwRecvFrom(netadr_t *const from, void *const data, const unsigned int size);
char dwCommonAddrToNetadr(;
void dwUnregisterSecIDAndKey(const bdSecurityID *id);
char dwCloseConnection(netadr_t *const netadr);
void ClearCommonAddrGroups();
void dwNetStop();
void dwNetPump();
void dwNetStart(const bool online);

//t6/code/src_noserver/dw/dwqos.cpp
// LocalTaskState __thiscall dwQoSMultiProbeListener::complete(dwQoSMultiProbeListener *this);
void dwClearQoSProbes();
// void __thiscall dwQoSMultiProbeListener::onQoSProbeFail(dwQoSMultiProbeListener *this, bdReference<bdCommonAddr> addr);
// void __thiscall dwQoSMultiProbeListener::clean(dwQoSMultiProbeListener *this);
// void __thiscall dwQoSMultiProbeListener::dwQoSMultiProbeListener(dwQoSMultiProbeListener *this);
// void __thiscall dwQoSMultiProbeListener::addProbe(dwQoSMultiProbeListener *this, const bdQoSRemoteAddr addr);
// void __thiscall dwQoSMultiProbeListener::onQoSProbeSuccess(dwQoSMultiProbeListener *this, const bdQoSProbeInfo *info);
void dwStartQoSProbes(;

//t6/code/src_noserver/dw/dwrecordevent.cpp
bdRemoteTask *dwRecordEventMixed(;
bdRemoteTask *dwRecordEvent(;
bdRemoteTask *dwRecordEventString(ControllerIndex_t controllerIndex, RecordEventType type, const char *event);
bdRemoteTask *dwRecordEventFormat(ControllerIndex_t controllerIndex, RecordEventType type, const char *fmt, ...);

//t6/code/src_noserver/dw/dwstats.cpp
TaskRecord *dwWriteStats(;
TaskRecord *dwReadStatsByRank(;
TaskRecord *dwReadStatsForUsersFromLbs(;

//t6/code/src_noserver/dw/dwstorage.cpp
void dwFileShareGetProgress(;
void dwFileShareAbortOperation(ControllerIndex_t localControllerIndex, fileShareLocation location);
bool dwFileShareIsReady(const ControllerIndex_t localControllerIndex);
int dwFileShareGetLastHTTPError(ControllerIndex_t localControllerIndex, fileShareLocation location);
TaskRecord *dwGetFileMetadata(const ControllerIndex_t controllerIndex, dwFileMetadata *metadata);
char dwReadFileFailure(TaskRecord *task);
char dwReadFileSuccess(TaskRecord *task);
TaskRecord *dwReadFileInternal(;
// TaskRecord *dwReadFile@<eax>(;
// TaskRecord *dwReadUserFile@<eax>(;
TaskRecord *dwReadUserFileByUserID(;
char dwDeleteFileFailure(TaskRecord *task);
char dwWriteFileFailure(TaskRecord *task);
TaskRecord *dwWriteFile(;
TaskRecord *dwFileShareGetListing(ControllerIndex_t localControllerIndex, dwFileShareListTask *const fsTask);
TaskRecord *dwFileShareGetDescriptorsFromPooledStorage(;
TaskRecord *dwFileShareGetDescriptorsFromUserStorage(;
// TaskRecord *dwFileShareGetDescriptors@<eax>(;
TaskRecord *dwFileShareReadPooledStorageFile(;
TaskRecord *dwFileShareReadUserStorageFile(;
TaskRecord *dwFileShareReadPublisherStorageFile(;
// TaskRecord *dwFileShareReadFile@<eax>(;
TaskRecord *dwFileShareRemoveFile(ControllerIndex_t controllerIndex, dwFileShareRemoveTask *const fsTask);
TaskRecord *dwFileShareTransferFile(ControllerIndex_t controllerIndex, dwFileShareTransferTask *const fsTask);
TaskRecord *dwFileShareGetPooledSummary(;
TaskRecord *dwFileShareGetUserSummary(;
// TaskRecord *dwFileShareGetSummary@<eax>(;
TaskRecord *dwFileShareSetPooledSummary(;
TaskRecord *dwFileShareSetUserSummary(ControllerIndex_t controllerIndex, dwFileShareSummaryTask *const fsTask);
TaskRecord *dwFileShareSetSummary(ControllerIndex_t controllerIndex, dwFileShareSummaryTask *const fsTask);
TaskRecord *dwFileShareWritePooledStorageFile(;
TaskRecord *dwFileShareWriteUserStorageFile(;
// TaskRecord *dwFileShareWriteFile@<eax>(;
TaskRecord *dwKeyArchiveRead(;

//t6/code/src_noserver/dw/dwteam.cpp
TaskRecord *dwTeamClanLeave(const ControllerIndex_t localControllerIndex, dwTeamClanLeaveTask *const teamTask);
TaskRecord *dwTeamClanCreate(;
TaskRecord *dwTeamSetPublicProfile(;
TaskRecord *dwTeamSetPrivateProfile(;

//t6/code/src_noserver/dw/dwtwitch.cpp
TaskRecord *dwTwitchRegisterAccount(ControllerIndex_t localControllerIndex, dwTwitchRegisterTask *const twTask);
TaskRecord *dwTwitchUnregisterAccount(ControllerIndex_t localControllerIndex);

//t6/code/src_noserver/dw/dwutils.cpp
bool dwGetOnlineUserID(const ControllerIndex_t controllerIndex, unsigned __int64 *userID);
bool dwGetOnlineUserName(ControllerIndex_t controllerIndex, char *buf, const unsigned int bufsize);
bdLobbyService *dwGetLobby(ControllerIndex_t controllerIndex);
bdMatchMaking *dwGetMatchmaking(ControllerIndex_t controllerIndex);
bdGroup *dwGetGroup(ControllerIndex_t controllerIndex);
bdContentStreaming *dwGetContentStreaming(ControllerIndex_t controllerIndex);
bdPooledStorage *dwGetPooledStorage(ControllerIndex_t controllerIndex);
bdTwitch *dwGetTwitchService(ControllerIndex_t controllerIndex);
bdLeague *dwGetLeagueService(ControllerIndex_t controllerIndex);
bdVoteRank *dwGetVoteRankService(ControllerIndex_t controllerIndex);
bdYouTube *dwGetYouTubeService(ControllerIndex_t controllerIndex);
bdStorage *dwGetStorage(ControllerIndex_t controllerIndex);
bdAntiCheat *dwGetAntiCheat(ControllerIndex_t controllerIndex);
bdKeyArchive *dwGetKeyArchive(ControllerIndex_t controllerIndex);
bdStats *dwGetStats(ControllerIndex_t controllerIndex);
bdTeams *dwGetTeams(ControllerIndex_t controllerIndex);
bdAuthService *dwGetAuthService(;
bdTitleUtilities *dwGetTitleUtilities(ControllerIndex_t controllerIndex);
bdEventLog *dwGetEventLog(ControllerIndex_t controllerIndex);
bdMessaging *dwGetMessaging(ControllerIndex_t controllerIndex);
const char *dwLobbyErrorCodeToString(const bdLobbyErrorCode code);
void dwConnectionErrorHandler(int error_context);
bool dwRecordIPAddressSuccess(TaskRecord *task);
bool dwRecordIPAddressComplete();
char dwRecordIPAddressFailure(TaskRecord *task);
void dwCreateLobby(ControllerIndex_t controllerIndex);
// void dwCloseRemoteTask(bdReference<bdRemoteTask> *remoteTask);
void dwLobbyErrorCodeToString(const bdLobbyErrorCode code, char *const buffer, const unsigned int bufferSize);
void dwRecordIPAddressRequest(const ControllerIndex_t controllerIndex, unsigned __int8 *ipArray);
void dwRecordIPAddress(const ControllerIndex_t controllerIndex);
bdSocketRouter *dwGetSocketRouter();
bdAddressMap *dwGetAddressMap();
bdQoSProbe *dwGetQoSProbe();
// bdReference<bdCommonAddr> *dwGetLocalCommonAddr(bdReference<bdCommonAddr> *result);
bdSecurityKeyMap *dwGetSecurityKeyMap();

//t6/code/src_noserver/dw/dwvote.cpp
bool dwVoteGetRatio(;
TaskRecord *dwVoteSubmitRating(;

//t6/code/src_noserver/dw/dwyoutube.cpp
TaskRecord *dwYouTubeRegisterAccount(;
TaskRecord *dwYouTubeUnregisterAccount(const ControllerIndex_t localControllerIndex);
TaskRecord *dwYouTubeIsRegistered(;
TaskRecord *dwYouTubeUpload(const ControllerIndex_t localControllerIndex, dwYouTubeUploadTask_t *ytTask);

//t6/code/src_noserver/dw/leaderboardinfo.cpp
// void __thiscall LeaderboardFileShareRow::LeaderboardFileShareRow(LeaderboardFileShareRow *this);
// char LeaderboardFileShareRow::setColumnCount(int columnCount);
// unsigned int __thiscall LeaderboardFileShareRow::sizeOf(LeaderboardFileShareRow *this);
// bool __thiscall LeaderboardFileShareRow::deserialize(LeaderboardFileShareRow *this, bdReference<bdByteBuffer> buffer);

//t6/code/src_noserver/dw/leaderboardinfo.h
// void __thiscall LeaderboardRow<10>::serialize(LeaderboardRow<10> *this, bdByteBuffer *buffer);
// unsigned int __thiscall bdLeagueStatsInfo::sizeOf(bdLeagueStatsInfo *this);
// bool __thiscall LeaderboardRow<10>::deserialize(LeaderboardRow<10> *this, bdReference<bdByteBuffer> buffer);

//t6/code/src_noserver/dw/matchmakinginfo.cpp
// void __thiscall MatchMakingInfo::MatchMakingInfo(MatchMakingInfo *this);
// void __thiscall MatchMakingInfo::serialize(MatchMakingInfo *this, bdByteBuffer *buffer);
// char __thiscall MatchMakingInfo::setSecurityID(MatchMakingInfo *this, const bdSecurityID *secID);
// char __thiscall MatchMakingInfo::getSecurityID(MatchMakingInfo *this, bdSecurityID *secID);
// char __thiscall MatchMakingInfo::setSecurityKey(MatchMakingInfo *this, const bdSecurityKey *secKey);
// char __thiscall MatchMakingInfo::getSecurityKey(MatchMakingInfo *this, bdSecurityKey *secKey);
// unsigned int __thiscall MatchMakingInfo::sizeOf(MatchMakingInfo *this);
// bool __thiscall MatchMakingInfo::doUpdate(;
// bool __thiscall MatchMakingInfo::deserialize(MatchMakingInfo *this, bdReference<bdByteBuffer> buffer);

//t6/code/src_noserver/dw/matchrecorder.cpp
void MatchRecorderDDLSetFloat(ddlState_t *searchState, const char *name, float value);
void MatchRecorderDDLSetInt(ddlState_t *searchState, const char *name, unsigned int value);
unsigned int MatchRecorderDDLGetInt(ddlState_t *searchState, const char *name);
void MatchRecorderDDLSetInt64(ddlState_t *searchState, const char *name, unsigned __int64 value);
unsigned __int64 MatchRecorderDDLGetInt64(ddlState_t *searchState, const char *name);
void MatchRecorderDDLSetString(ddlState_t *searchState, const char *name, const char *value);
void MatchRecordCopyExternalIP(ddlState_t playerState, ClientNum_t clientNum);
int GetCurrentMapIndexByUIMapname();
int GetCurrentMapIndex();
void setWeaponHashValue(const char *statName, int limit, int index);
char isTrackableWeapon(int index, int currentMapIndex);
bool MatchRecord_IsHeatMapDataGenerated();
int GetMaxLivesOrDowns();
unsigned int MatchRecord_GetMapIndex();
void MatchRecord_SetPlayerCount(__int16 currentPlayers);
unsigned int MatchRecord_GetLifeCount();
void MatchRecord_SetLifeCount(__int16 currentLives);
void MatchRecord_SetDownCount(__int16 currentLives);
bool MatchRecord_GetPlayerInSlot(int playerSlot, ddlState_t *playerSlotState);
int MatchRecord_SearchForPlayerSlotByXUID(unsigned __int64 xuid);
unsigned __int64 MatchRecord_GetXUIDForPlayerSlot(int playerSlot);
bool MatchRecord_GetLifeInSlot(int lifeSlot, ddlState_t *lifeSlotState);
bool MatchRecord_GetDownInSlot(int downSlot, ddlState_t *downSlotState);
void MatchRecorder_UpdateSubparties();
int MatchRecord_SearchCreateForPlayer(gclient_t *client, ddlState_t *playerState);
;
void FindBitchForPlayer(int attackingPlayerSlot);
void FindNemesisForPlayer(int attackingPlayerSlot);
void SaveTeamScores();
void MatchRecorder_RecordGameResult(team_t winner, bool isDraw);
void GetWorldLocation(;
void MatchRecord_ReviveZombie(gclient_t *client, gclient_t *reviver);
void MatchRecordSpawn(gclient_t *client);
void MatchRecordSetHitStat(;
void MatchRecordHit(gclient_t *attackerClient, hitLocation_t hitLocation);
void MatchRecordDeath(;
void MatchRecordEnd(gclient_t *client);
void MatchRecordBegin();
void MatchRecordPlayerDetails(gclient_t *client, const char *reason);
void MatchRecordSetPlayerStat(gclient_t *client, const char *statName, int statValue);
char MatchRecordEventFailure();
void MatchRecorder_TagXuids(int *numTags, bdTag *tags, int maxTags);
void MatchRecorder_RecordKillstreakEvent(;
void MatchRecorder_RecordKillstreakEndEvent(;
void MatchRecorder_RecordGameEvent(;
void MatchRecorder_RecordKillModifier(;
void MatchRecorder_RecordScoreEvent(;
void MatchRecorder_RecordLoadoutAndPerks(;
void MatchRecorder_RecordNumZombieRounds(ddlState_t *a1, const char *a2);
void MatchRecorder_RecordMultiKill(;
void MatchRecord_WriteItemStats(;
// void MatchRecorder_IncrementHeaderStat(const char *a1@<edx>, ddlState_t *a2@<ecx>, const char *statName);
void MatchRecorder_RecordZombieGameInfoEnd(;
void MatchRecorder_RecordZombiePlayerDeath();
// void MatchRecorder_RecordZombiePlayerDown(float a1@<ebx>, unsigned __int8 *a2@<edi>, gclient_t *client);
bool IsPlayerInRound(unsigned __int64 xuid, ddlState_t *roundState);
bool GetPlayerRoundSlot(unsigned __int64 xuid, ddlState_t *playerRoundSlot);
void MatchRecord_ZombieRoundStart(ddlState_t *a1, const char *a2);
void MatchRecord_ZombieRoundEnd(ddlState_t *a1, const char *a2);
void MatchRecorder_IncrementPlayerStat(gclient_t *client, const char *statName);
int MatchRecord_InitMatchDataInternal(char *inputBuffer, int buffSize);
void MatchRecord_InitMatchData();
void GenerateBinaryMatchSummary(unsigned int titleID, const char *gameMode, unsigned __int64 fileID);
void GenerateRecordedMatchData(;
// BOOL MatchRecord_ParseDownloadedMatchData@<eax>(;
void MatchRecordPointsSpent(;
char MatchRecordEventSuccess(TaskRecord *task);

//t6/code/src_noserver/dw/teamprofile.cpp
// void __thiscall PublicTeamProfile::PublicTeamProfile(PublicTeamProfile *this);
// void __thiscall PublicTeamProfile::serialize(PublicTeamProfile *this, bdByteBuffer *buffer);
// void __thiscall PrivateTeamProfile::PrivateTeamProfile(PrivateTeamProfile *this);
// void __thiscall PrivateTeamProfile::serialize(PrivateTeamProfile *this, bdByteBuffer *buffer);
// unsigned int __thiscall PublicTeamProfile::sizeOf(PublicTeamProfile *this);
// unsigned int __thiscall PrivateTeamProfile::sizeOf(PrivateTeamProfile *this);
// bool __thiscall PublicTeamProfile::deserialize(PublicTeamProfile *this, bdReference<bdByteBuffer> buffer);
// bool __thiscall PrivateTeamProfile::deserialize(PrivateTeamProfile *this, bdReference<bdByteBuffer> buffer);

//t6/code/src_noserver/dynentity/dynentity_client.cpp
void DynEntCl_RegisterDvars();
XModel *DynEntCl_GetCurrentXModel(const DynEntityDef *dynEntDef, const DynEntityClient *dynEntClient);
;
;
void DynEntCl_LinkBrush(unsigned __int16 dynEntId);
void DynEntCl_UnlinkEntity(unsigned __int16 dynEntId, DynEntityDrawType drawType);
void DynEnt_DestroyPhysics(PhysWorld worldIndex, const DynEntityDef *dynEntDef, DynEntityClient *dynEntClient);
void DynEntCl_UpdateBounds();
void DynEnt_FixupLightConstraints(LocalClientNum_t localClientNum, int entnum, int primaryLightIndex);
void DynEnt_UpdateLightConstraint(;
void DynEnt_UpdateConstraints(;
int DynEnt_GetSurfaceType(const DynEntityDef *dynEntDef);
void DynEntCl_PointTrace_r(;
void DynEntCl_PointTrace(const pointtrace_t *clip, trace_t *results);
void DynEntCl_AreaEntities_r(;
unsigned __int16 DynEntCl_AreaEntities(;
void DynEntCl_PlayEventFx(const FxEffectDef *def, const vec3_t *origin, const vec3_t *axis);
void DynEntCl_PlayImpactEffects(;
void DynEntCl_TurnOffLight(const DynEntityDef *dynEntDef);
void DynEntCl_Enable(unsigned __int16 absId, const bool enable);
void DynEntCl_Damage(;
bool DynEntCl_IsLocalClient(LocalClientNum_t localClientNum, int sourceEntityNum);
unsigned int DynEntCl_PlayBoltedFX(const FxEffectDef *fx, unsigned __int16 absDynEntId);
void DynEntCl_RemoveFromFadeList(unsigned __int16 absDynEntId);
void DynEntCl_SetBurnFrac(unsigned __int16 dynEntId, DynEntityDrawType drawType, float frac);
double DynEntCl_GetBurnTime(unsigned __int16 dynEntId, DynEntityDrawType drawType);
BOOL DynEntCl_CompareDynEntsForExplosion(const DynEntSortStruct *ent1, const DynEntSortStruct *ent2);
void DynEntCl_DestroyEvent(;
void CreateRopes(LocalClientNum_t localClientNum);
unsigned __int16 DynEnt_GetDynEntity(int targetname);
void SCR_DynEnt_GetDynEntityArray(int targetname);
void MapHitLocationToRagdollBoneName(hitLocation_t hitLoc, unsigned int *boneName);
void CheckDynEnts();
void DynEntCl_Shutdown(LocalClientNum_t localClientNum);
;
int DynEntCl_CreatePhysObj(;
void DynEntCl_Launch(unsigned __int16 absId, const vec3_t *dir, const vec3_t *hitp);
void DynEntCl_SetBurning(unsigned __int16 dynEntId, DynEntityDrawType drawType, bool burning);
LocalClientNum_t DynEnt_UpdateBurning();
void DynEntCl_FlameDamage(;
void DynEntCl_EntityImpactEvent(;
;
;
char DynEntCl_DynEntBulletImpactEvent(;
void DynEntCl_InitEntities(LocalClientNum_t localClientNum);
void DynEntCl_DestroyEntityModel(unsigned __int16 id);
void DynEntCl_CleanUpOldModels();
unsigned __int16 DynEntCl_AddEntityModel();
unsigned __int16 DynEntCl_CreateEntityModel(;
void DynEntCl_SetFadeOut(unsigned __int16 dynEntId, DynEntityDrawType drawType);
void DynEnt_UpdateFading(int currentTime);
void DynEntCl_MeleeEvent(LocalClientNum_t localClientNum, int attackerEntNum);
void DynEntCl_ProcessEntities(LocalClientNum_t localClientNum, int time);
unsigned int DynEntCl_GetClosestEntities(;
void DynEntCl_ExplosionEvent(;
void DynEntCl_JetThrustEvent(;

//t6/code/src_noserver/dynentity/dynentity_coll.cpp
void TRACK_DynEntityCollWorld();
DynEntityCollSector *DynEnt_GetCollSector(DynEntityCollType collType, unsigned int sectorIndex);
void DynEnt_ClearCollWorld(DynEntityCollType collType);
unsigned __int16 DynEnt_AllocCollSector(DynEntityCollType collType, const vec2_t *mins, const vec2_t *maxs);
void DynEnt_AddToCollSector(;
void DynEnt_UnlinkEntity(DynEntityCollType collType, unsigned __int16 dynEntId);
int DynEnt_GetContents(const DynEntityDef *dynEntDef);
void DynEnt_GetLocalBounds(const DynEntityDef *dynEntDef, vec3_t *mins, vec3_t *maxs);
double DynEnt_GetRadiusDistSqr(const DynEntityColl *dynEntColl, const vec3_t *origin);
bool DynEnt_IsInCone(;
double DynEnt_GetCylindricalRadiusDistSqr(const DynEntityColl *dynEntColl, const vec3_t *origin);
bool DynEnt_EntityInArea(;
void DynEnt_PointTraceToModel(;
void DynEnt_PointTraceToBrush(;
void DynEnt_SortCollSector(;
void DynEnt_LinkEntity(;

//t6/code/src_noserver/dynentity/dynentity_gamestate.cpp
void DynEnt_WriteGameState(msg_t *msg);
void DynEnt_ReadGameState(msg_t *msg, LocalClientNum_t localClientNum);

//t6/code/src_noserver/dynentity/dynentity_load_db.h
void Mark_DynEntityDefArray(int count);
void Load_DynEntityDefArray(bool atStreamStart, int count);

//t6/code/src_noserver/dynentity/dynentity_load_obj.cpp
DynEntityType DynEnt_GetType(const char *typeName);
void DynEnt_GetEntityCountFromString(const char *entityString, int *entCount, int *constraintCount);
const char *LoadRopeParams();
bool DynEnt_CreateConstraint(PhysConstraint *constraint, DynEntityConstraintCreateParams *params);
void DynEnt_GetEntityConstraintParams(;
void *DynEnt_AllocXModel(int size);
void *DynEnt_AllocXModelColl(int size);
XModel *DynEnt_XModelPrecache(const char *modelName);
void *DynEnt_AllocPhysPreset(int size);
void *DynEnt_AllocXModelPieces(int size);
PhysPreset *DynEnt_PhysPresetPrecache(const char *name);
XModelPieces *DynEnt_XModelPiecesPrecache(const char *name);
bool FindConstraints(;
PhysPreset *DynEnt_AutoCreatePhysPreset(const DynEntityDef *dynEntDef, const DynEntityCreateParams *params);
int DynEnt_CompareEntities(const void *arg0, const void *arg1);
void GetAttachPointsInWorldSpace(PhysConstraint *constraint, vec3_t *p0, vec3_t *p1);
const DynEntityProps *DynEnt_GetEntityProps(DynEntityType dynEntType);
unsigned __int16 DynEnt_GetId(const DynEntityDef *dynEntDef, DynEntityDrawType drawType);
__int16 DynEnt_GetAbsId(const DynEntityDef *dynEntDef);
unsigned __int16 DynEnt_GetEntityCount(DynEntityCollType collType);
DynEntityPose *DynEnt_GetClientModelPoseList();
DynEntityPose *DynEnt_GetClientPose(unsigned __int16 dynEntId, DynEntityDrawType drawType);
DynEntityServer *DynEnt_GetServerEntity(unsigned __int16 dynEntId, DynEntityDrawType drawType);
void DynEnt_GetClientIdDrawType(unsigned __int16 absId, unsigned __int16 *outId, DynEntityDrawType *drawType);
int DynEnt_GetClientAbsId(unsigned __int16 dynEntId, DynEntityDrawType drawType);
bool DynEnt_Create(;
void DynEnt_LoadEntities();
bool DynEnt_Valid(const unsigned __int16 absDynEntId);
DynEntityPose *DynEnt_GetClientPose(unsigned __int16 absDynEntId);

//t6/code/src_noserver/dynentity/dynentity_load_obj.h
const DynEntityDef *DynEnt_GetEntityDef(unsigned __int16 dynEntId, DynEntityDrawType drawType);
DynEntityClient *DynEnt_GetClientEntity(unsigned __int16 dynEntId, DynEntityDrawType drawType);
DynEntityColl *DynEnt_GetEntityColl(DynEntityCollType collType, unsigned __int16 dynEntId);
DynEntityClient *DynEnt_GetClientEntity(unsigned __int16 id);
const DynEntityDef *DynEnt_GetEntityDef(unsigned __int16 absDynEntId);

//t6/code/src_noserver/dynentity/dynentity_pieces.cpp
void DynEntPieces_RegisterDvars();
void DynEntPieces_AddDrawSurfs();
int DynEntPieces_SpawnPhysObj(;
void DynEntPieces_SpawnPieces(;

//t6/code/src_noserver/dynentity/dynentity_server.cpp
void DynEntSv_RegisterDvars();
;
;
void DynEntClSv_ShouldCullEntitiesForSplitscreen();
void DynEntSv_InitEntities();
void DynEntSv_PointTrace_r(;
void DynEntSv_PointTrace(const pointtrace_t *clip, trace_t *results);
void DynEntSv_PointTrace(;
void DynEntSv_ClipMoveTrace_r(;
void DynEntSv_ClipMoveTrace(const moveclip_t *clip, trace_t *results);
void DynEntSv_AreaEntities_r(;
unsigned __int16 DynEntSv_AreaEntities(;
void DynEntSv_Damage(;
unsigned int DynEntSv_GetClosestEntities(;
void DynEntSv_RadiusDamage(;

//t6/code/src_noserver/effectscore/fxcurve.cpp
void FxCurveIterator_Create(FxCurveIterator *createe, const FxCurve *master);
void FxCurveIterator_Release(FxCurveIterator *releasee);

//t6/code/src_noserver/effectscore/fxcurve.h
double FxCurve_Interpolate1d(const float *key, float intermediateTime);
void FxCurveIterator_MoveToTime(FxCurveIterator *source, float time);

//t6/code/src_noserver/effectscore/fxcurve_load_obj.cpp
const FxCurve *FxCurve_AllocAndCreateWithKeys(const float *keyArray, int dimensionCount, int keyCount);

//t6/code/src_noserver/effectscore/fx_actions.cpp
void FX_ProcessActionsPPU(FxSystem *system);
FxPPUAction *FxAction_AllocPPUAction(const FxSystem *system, unsigned __int8 actionType, int *outAllocIndex);
char FX_AddPlaySoundAction(const FxSystem *system, const char *soundName, const vec3_t *origin);

//t6/code/src_noserver/effectscore/fx_beam.cpp
void Float4x4ForViewer(const vec3_t *origin3, const vec3_t *axis3);
void CreateClipMatrix(vector4 *clipMtx, const vec3_t *vieworg, const vec3_t *viewaxis);
bool Vec4HomogenousClipZW(__m128 *pt0, __m128 *pt1, const __m128 *coeffZW);
;
void FX_Beam_Begin();
void FX_Beam_Add(FxBeam *beam);
FxBeamInfo *FX_Beam_GetInfo();
;

//t6/code/src_noserver/effectscore/fx_convert.cpp
void FX_InterpolateSamples(;
float FX_SampleCurve1D(const FxCurve *curve, float scale, float time);
int FX_DecideSampleCount(int curveCount, const FxCurve **curves, int intervalLimit);
int FX_DecideVelocitySampleCount(const FxEditorElemDef *edElem, int intervalLimit);
void FX_GetVisualSampleRouting(const FxEditorElemDef *edElem, FxSampleChannel *routing);
int FX_DecideVisualSampleCount(;
void FX_SampleVelocityInFrame(;
void FX_SampleVisualStateScalar(;
void FX_SampleVisualState(FxElemDef *elemDef, const FxEditorElemDef *edElemDef);
bool FX_ValidateAtlasSettings(const FxEditorEffectDef *editorEffect, const FxEditorElemDef *edElemDef);
void FX_ConvertAtlas(FxElemDef *elemDef, const FxEditorElemDef *edElemDef);
void FX_ReserveElemDefMemory(FxElemDef *elemDef, unsigned __int8 **memPool);
void FX_BoundFloatRange(FxFloatRange *range, float lower, float upper);
void FX_ConvertTrail_CompileVertices(;
void FX_ConvertTrail(FxTrailDef **outTrailDef, const FxEditorElemDef *edElemDef, unsigned __int8 **mempool);
void FX_ConvertSpotLight(;
int FX_FindEmission(const FxEffectDef *emission, const FxEditorEffectDef *editorEffect);
// int FX_CopyEmittedElemDefs@<eax>(;
int FX_AdditionalBytesNeededForEmission(const FxEffectDef *emission);
bool FX_ValidateVisuals(const FxEditorEffectDef *editorEffect, const FxEditorElemDef *edElemDef);
void FX_ConvertElemDef(;
int FX_ConvertElemDefsOfType(;
const FxEffectDef *FX_Convert(const FxEditorEffectDef *editorEffect, void *(*Alloc)(int));

//t6/code/src_noserver/effectscore/fx_dpvs.cpp
int FX_DpvsIsBoxVisible(FxSystem *system, const vec3_t *mins, const vec3_t *maxs);

//t6/code/src_noserver/effectscore/fx_draw.cpp
void FX_PrepareGenericLookupTables();
void FX_SetupVisualState(;
void FX_EvaluateSize(;
__m128 *FX_GetExposureFloat4(LocalClientNum_t localClientNum);
void FX_ApplyLightingFrac(const FxEffect *effect, FxColor4b *outColor);
double FX_EvaluateRotation(;
void FX_PrepareAtlasLookupTables();
void FX_GetSpriteTexCoords(;
;
void FX_GenTrail_IndsForSegment(;
;
bool FX_CullElementForDraw_Sprite(const FxDrawState *draw, const FxElemRenderState *elemState);
void FX_DrawElem_BillboardSprite_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_BillboardSprite(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_OrientedSprite_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_OrientedSprite(const FxDrawState *draw, FxElemRenderState *elemState);
bool FX_CullCylinder(;
bool FX_CullElementForDraw_Tail(;
void FX_DrawElem_CalculateVelDirWorld(;
bool FX_CullElementForDraw_Tail_Wrapper(const FxDrawState *draw, const FxElemRenderState *elemState);
void FX_DrawElem_Tail_Main(const FxDrawState *draw, FxElemRenderState *elemState, const vec3_t *velDirWorld);
void FX_DrawElem_Tail_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_Tail(const FxDrawState *draw, FxElemRenderState *elemState);
bool FX_CullElement_Line(;
bool FX_CullElement_Line_Wrapper(const FxDrawState *draw, const FxElemRenderState *elemState);
void FX_DrawElem_Line_Main(const FxDrawState *draw, FxElemRenderState *elemState, const vec3_t *velDirWorld);
void FX_DrawElem_Line_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_Line(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_RotatedSprite_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_RotatedSprite(const FxDrawState *draw, FxElemRenderState *elemState);
float FX_EvaluateDistanceFade(const FxDrawState *draw, const vec3_t *elemPosWorld);
void FX_DrawElem_Cloud_Main(;
void FX_DrawElem_Cloud_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
bool FX_CullElementForDraw_Cloud(const FxDrawState *draw, const FxElemRenderState *elemState, float scale);
bool FX_CullElement_Cloud(const FxDrawState *draw, const FxElemRenderState *elemState);
// void FX_DrawElem_Cloud(vec3_t *a1@<edi>, const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_Model(const FxDrawState *draw, FxElemRenderState *elemState);
bool FX_CullElementForDraw_Light(const FxDrawState *draw, const FxElemRenderState *elemState);
void FX_DrawElem_Light(;
void FX_DrawElem_SpotLight_NoCull(const FxDrawState *draw, FxElemRenderState *elemState);
void FX_DrawElem_SpotLight(const FxDrawState *a1, const FxElemRenderState *a2);
float FX_EvaluateVisAlpha(const FxElemPreVisualState *preVisState);
__m128 *FX_InterpolateColor4b(;
void FX_EvaluateBaseColor(;
void FX_DrawTrail_SubmitGfxDrawSurfs(;
double FX_OcclusionQuery_UpdateOverTime(;
FxSmpDrawBuffer *FX_InitSmpDrawBuffer();
void FX_CloudElemAllocParticleClouds(EffectElementDraw *elemDraw, unsigned __int16 numElems);
int EffectCountInfoSort(const void *elem1, const void *elem2);
int FX_FindAllTrailEffects(;
int FX_AllocAllTrailResource(;
void FX_TrailGeoWorkers_Start(;
void FX_LaunchElemSetupWorkers(FxGenerateVertsCmd *generateVertsCmd);
void FX_LaunchSpriteGeoWorkers(;
void FX_AllocSpriteDrawData(;
void FX_FillGenerateVertsCmd(LocalClientNum_t localClientNum, FxGenerateVertsCmd *cmd);
void FX_WaitForFXDrawWorkers();
void FX_LaunchFXMarksWorkers(GfxViewInfo *viewInfo);
void FX_WaitForFXMarksWorkers();
void FX_DrawElement(const FxElemDef *elemDef, const FxElem *elem, FxDrawState *draw);
;
char FX_DrawTrail_CalcRequiredResources(;
void FX_DrawTrailsForEffect(;
void FX_DrawSpotLightEffect(FxSystem *system, FxEffect *effectEA, int drawTime);
void FX_DrawNonSpriteEffect(;
void FX_DrawNonSpriteElems(FxSystem *system, unsigned int cameraType, bool isInfraredDraw);
void FX_DrawSpotLight(FxSystem *system);
bool FX_ShouldDrawElement(const FxElemDef *elemDef, FxElem *elem, FxDrawState *draw);
;
;
void FX_SpriteElemMakeQuads(;
void FX_SpriteElemMakeGfxDrawSurfs(;
void FX_CloudElemMakeParticleClouds(;
void FX_CloudElemMakeGfxDrawSurfs(;
void FX_SMPDraw_MakeSpriteGeo(FxDrawSpriteGeoCmd *cmd);
void FX_SMPDraw_MakeTrailGeo(FxDrawTrailGeoCmd *cmd);
void FX_ElemSetupWorker(FxElemSetupCmd *cmd);
;
void FX_AllocTrailDrawData(;
void FX_GenerateSpriteDrawSurfs(FxSystem *system, unsigned int cameraType, FxSmpDrawBuffer *smpBuffer);
void FX_GenerateTrailDrawSurfs(FxSystem *system, FxSmpDrawBuffer *smpBuffer);
int fx_allocCallback(jqBatch *batch);
int fx_add_surfsCallback(jqBatch *batch);
void FX_DrawSpriteElems(;
void FX_GenerateVerts(FxGenerateVertsCmd *cmd);
int fx_draw_sprite_geoCallback(jqBatch *batch);
int fx_draw_trail_geoCallback(jqBatch *batch);
int fx_elemsetupCallback(jqBatch *batch);

//t6/code/src_noserver/effectscore/fx_draw.h
FxElemVisuals FX_GetElemVisuals(const FxElemDef *elemDef, int randomSeed);
double FX_InterpolateSize(;

//t6/code/src_noserver/effectscore/fx_dvars.cpp
void FX_RegisterDvars();
void FX_CreateDevGui();

//t6/code/src_noserver/effectscore/fx_effect_load_db.h
void Load_FxTrailDef(bool atStreamStart);
void Load_FxElemExtendedDefPtr();
void Mark_FxElemMarkVisualsArray(int count);
void Mark_FxElemVisuals();
void Mark_FxElemVisualsArray(int count);
void Mark_FxElemDefArray(int count);
void Load_FxElemMarkVisualsArray(bool atStreamStart, int count);
void Load_FxElemVisuals(bool atStreamStart);
void Load_FxElemVisualsArray(bool atStreamStart, int count);
void Load_FxElemDefVisuals(bool atStreamStart);
void Load_FxElemDefArray(bool atStreamStart, int count);
void Load_FxEffectDef(bool atStreamStart);
void Mark_FxEffectDefHandle();
void Mark_FxEffectDefHandleArray(int count);
void Load_FxEffectDefHandle(bool atStreamStart);
void Load_FxEffectDefHandleArray(bool atStreamStart, int count);

//t6/code/src_noserver/effectscore/fx_effect_types.h
void FX_TrailElem_CompressBasis(const vec3_t *inBasis, char (*outBasis)[3]);

//t6/code/src_noserver/effectscore/fx_load_obj.cpp
void FX_UnregisterAll();
char FX_ParseFlagsField(const char **parse, FxFlagOutputSet *flagOutputSet);
void *FX_AllocMem(int size);
void *Hunk_AllocPhysPresetPrecache(int size);
PhysPreset *FX_RegisterPhysPreset(const char *name);
bool FX_RegisterAsset_LightDef(const char *name, FxElemVisuals *visuals);
bool FX_RegisterAsset_Material(const char *name, FxElemVisuals *visuals);
bool FX_RegisterAsset_Model(const char *name, FxElemVisuals *visuals);
char FX_RegisterAsset_SoundAliasName(const char *name, FxElemVisuals *visuals);
bool FX_ParseElemSpawnSoundAsset(const char **parse, FxEditorElemDef *edElemDef);
bool FX_ParseCurve(const char **parse, int dimCount, float minValue, float maxValue, const FxCurve **shape);
bool FX_ParseGraphRange(;
char FX_ParseName(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseNonAtlasFlags(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnRange(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseFadeInRange(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseFadeOutRange(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnFrustumCullRadius(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnDefLooping(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnDefOneShot(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnDelayMsec(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseLifeSpanMsec(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnOrgX(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnOrgY(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnOrgZ(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnOffsetRadius(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnOffsetHeight(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnAnglePitch(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnAngleYaw(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSpawnAngleRoll(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAngleVelPitch(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAngleVelYaw(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAngleVelRoll(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseInitialRot(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseGravity(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseElasticity(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseWindinfluence(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasBehavior(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasIndex(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasIndexRange(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasFps(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasLoopCount(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasColIndexBits(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasRowIndexBits(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAtlasEntryCount(const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseVelGraph0X@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseVelGraph0Y@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseVelGraph0Z@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseVelGraph1X@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseVelGraph1Y@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseVelGraph1Z@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseRotGraph@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseSizeGraph0@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseSizeGraph1@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseScaleGraph@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseColorGraph@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseAlphaGraph@<al>(int a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseCollOffset(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseLightingFrac(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseCollRadius(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseSortOrder(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParsePriority(const char **parse);
char FX_ParseAlphaFadeTimeMsec(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseMaxWindMagnitude(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseMaxWindLife(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseMaxWindInterval(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseEmitDist(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseEmitDistVariance(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseTrailRepeatTime(const char **parse);
char FX_ParseTrailSplitDist(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseTrailScrollTime(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseTrailRepeatDist(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseTrailDef(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseLight(const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseElemSpawnSound@<al>(FxEditorElemDef *a1@<edx>, const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseBillboardTopWidth(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseBillboardBottomWidth(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseRotationAxis(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseCloudDensityRange(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseEffectBoundMin(const char **parse, FxEditorEffectDef *edEffectDef);
char FX_ParseEffectBoundMax(const char **parse, FxEditorEffectDef *edEffectDef);
char FX_ParseEffectDummyVector(const char **parse);
char FX_ParseEffectFlags(const char **parse, FxEditorEffectDef *edEffectDef);
char FX_ParseEffectPriority(const char **parse, FxEditorEffectDef *edEffectDef);
char FX_ParseBillboardPivot(const char **parse, FxEditorElemDef *edElemDef);
bool FX_ParseEditorElemField(const char **parse, FxEditorElemDef *edElemDef, const char *token);
bool FX_ParseEditorEffectField(const char **parse, FxEditorEffectDef *edEffectDef, const char *token);
char FX_ParseEditorElem(int version, const char **parse, FxEditorElemDef *edElemDef);
bool FX_ParseEditorEffect(const char **parse, FxEditorEffectDef *edEffectDef);
bool FX_LoadEditorEffectFromBuffer(;
bool FX_LoadEditorEffect(const char *name, FxEditorEffectDef *edEffectDef);
int FX_HashName(const char *name);
int FX_GetHashIndex(const char *name, bool *exists);
const FxEffectDef *FX_Register_FastFile(const char *name);
bool FX_RegisterMarkMaterials(const char *materialName, Material **materials);
bool FX_RegisterAsset_DecalMaterials(const char *name, FxElemMarkVisuals *visuals);
// bool FX_ParseBillboardSprite@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseOrientedSprite@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseRotatedSprite@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseCloud@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseTail@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseLine@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseTrail@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseDecal@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseModel@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseSpotLight@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseSound@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
const FxEffectDef *FX_LoadFailed(const char *name);
const FxEffectDef *FX_Load(const char *name);
// const FxEffectDef *FX_Register_LoadObj@<eax>(bool *a1@<edx>, const char *a2@<ecx>, const char *name);
const FxEffectDef *FX_Register();
void FX_RegisterDefaultEffect();
bool FX_RegisterAsset_EffectDef(const char *name, FxElemVisuals *visuals);
char FX_ParseFxOnImpact(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseFxOnDeath(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseEmission(const char **parse, FxEditorElemDef *edElemDef);
char FX_ParseAttachment(const char **parse, FxEditorElemDef *edElemDef);
// bool FX_ParseRunner@<al>(unsigned __int8 a1@<dl>, const char **parse, FxEditorElemDef *edElemDef);
unsigned __int8 *Hunk_AllocPhysPresetPrecache(int size);

//t6/code/src_noserver/effectscore/fx_marks.cpp
void TRACK_fx_marks();
void FX_InitMarksSystem(FxMarksSystem *marksSystem);
void FX_ClearMarks(LocalClientNum_t localClientNum);
void FX_FreeMarkTriGroups(FxMarksSystem *marksSystem, FxMark *mark);
void FX_FreeMarkPointGroups(FxMarksSystem *marksSystem, FxMark *mark);
void FX_FreeMarkFromList(FxMarksSystem *marksSystem, FxMark *mark, unsigned __int16 *listHead);
// void FX_FreeMark(FxMark *a1@<edx>, FxMarksSystem *a2@<ecx>, FxMarksSystem *marksSystem, FxMark *mark);
void FX_FreeLruMark(FxMarksSystem *marksSystem);
int FX_AllocMarkTris(FxMarksSystem *marksSystem, const FxMarkTri *markTris, int triCount);
int FX_AllocMarkPoints(FxMarksSystem *marksSystem, int pointCount);
void FX_LinkMarkIntoList(FxMarksSystem *marksSystem, unsigned __int16 *head, FxMark *mark, FxMark *markEA);
void FX_CopyMarkTris(FxMarksSystem *marksSystem, const FxMarkTri *srcTris, int dstGroupHandle, int triCount);
void FX_CopyMarkPoints(;
unsigned __int16 FX_FindModelHead(FxMarksSystem *marksSystem, unsigned __int16 modelIndex, int type);
int FX_MarkContextsCompare(const GfxMarkContext *context0, const GfxMarkContext *context1);
bool FX_CompareMarkTris(const FxMarkTri *tri0, const FxMarkTri *tri1);
;
void FX_ImpactMark_Generate_AddEntityModel(;
void FX_ImpactMark_Generate_AddViewmodel(;
void FX_BeginMarks(LocalClientNum_t clientIndex);
void FX_MarkEntDetachAll(LocalClientNum_t localClientNum, int entnum);
void FX_MarkEntDetachAllViewmodel(LocalClientNum_t localClientNum);
void FX_MarkGlassDetachAll(LocalClientNum_t localClientNum, int glassIndex);
void FX_MarkEntDetachAllOfType(LocalClientNum_t localClientNum, int entnum, int markType);
void FX_MarkEntDetachMatchingBones(;
void FX_MarkEntUpdateHidePartBits(;
void FX_MarkEntUpdateBegin(;
void FX_MarkEntDetachModel(FxMarksSystem *marksSystem, int entnum, int oldModelIndex);
void FX_MarkEntUpdateEndDObj(;
void FX_MarkEntUpdateEnd(;
void FX_ClearViewmodelMarks(LocalClientNum_t localClientNum);
void FX_EmitMarkTri(;
void FX_DrawMarkTris(;
char FX_GenerateMarkVertsForMark_Begin(;
void FX_GenerateMarkVertsForMark_SetLightHandle(;
void FX_GenerateMarkVertsForMark_SetReflectionProbeIndex(;
void FX_GenerateMarkVertsForMark_MatrixFromPlacement(vec3_t *outTransform);
void FX_GenerateMarkVertsForMark_MatrixFromAnim(const FxMark *mark, const DObj *dobj);
void FX_BeginGeneratingMarkVertsForEntModels(LocalClientNum_t localClientNum, unsigned int *indexCount);
void FX_EndGeneratingMarkVertsForEntModels(LocalClientNum_t localClientNum);
void FX_MarkUpdateClientTime(LocalClientNum_t localClientNum, int frameTime);
void FX_MarksGridCellFromPosition(FxMarksGridCell *cell, const vec3_t *position);
unsigned int FX_MarksGridHashFromCell(const FxMarksGridCell *cell);
bool FX_MarksGrid_TooManyMarksInVicinity(LocalClientNum_t localClientNum, const vec3_t *pos);
void FX_Marks_GridDebugText(LocalClientNum_t localClientNum);
void FX_MarkDrawSpatialHashDebug(FxMarksSystem *marksSystem);
void FX_MarksGridUpdate(LocalClientNum_t localClientNum);
void FX_GenerateMarkVertsForMark_FinishNonAnimated(;
void FX_GenerateMarkVertsForMark_FinishAnimated(;
bool FX_GenerateMarkVertsForList_EntDObj(;
bool FX_GenerateMarkVertsForList_EntXModel(;
bool FX_GenerateMarkVertsForList_EntBrush(;
bool FX_GenerateMarkVertsForList_WorldBrush(;
void FX_GenerateMarkVertsForEntXModel(;
void FX_GenerateMarkVertsForEntDObj_internal(;
void FX_GenerateMarkVertsForEntDObj(;
void FX_GenerateMarkVertsForEntBrush(;
void FX_GenerateMarkVertsForStaticModels(;
void FX_GenerateMarkVertsForWorld(LocalClientNum_t localClientNum, const GfxLight *visibleLights);
void FX_GenerateMarkVertsForDynamicModels(;
void FX_AllocAndConstructMark(;
void FX_ImpactMark_Generate_Callback(;
void FX_ImpactMark_Generate(;
void FX_ImpactMark(;
void FX_CreateImpactMarkInternal(;
void FX_CreateImpactMark(;
int fx_add_markCallback(jqBatch *batch);

//t6/code/src_noserver/effectscore/fx_marks.h
__int16 FX_MarkToHandle(FxMarksSystem *marksSystem, FxMark *mark);
FxMark *FX_MarkFromHandle(FxMarksSystem *marksSystem, unsigned __int16 handle);
int FX_TriGroupToHandle(FxMarksSystem *marksSystem, FxTriGroup *group);
int FX_PointGroupToHandle(FxMarksSystem *marksSystem, FxPointGroup *group);

//t6/code/src_noserver/effectscore/fx_postlight.cpp
void FX_PostLight_GenerateVerts(FxPostLightInfo *postLightInfoAddr, const FxSystem *system);
void FX_PostLight_Begin();
void FX_PostLight_Add(FxPostLight *postLight);
FxPostLightInfo *FX_PostLight_GetInfo();

//t6/code/src_noserver/effectscore/fx_profile.cpp
FxProfileEntry *FX_GetProfileEntry(const FxEffectDef *effectDef, FxProfileEntry *entryPool, int *entryCount);
int FX_CompareProfileEntries(const void *e0, const void *e1);
int FX_ComparePriorityDebugEntries(const void *e0, const void *e1);
void FX_DrawPriorityDebug(;
int FX_CompareOccQueryDebugEntries(const void *e0, const void *e1);
void FX_DrawOccQueryDebug(;
const char *typeAsString(unsigned __int8 type);
void FX_DrawMarkProfile_MarkPrint(;
void FX_DrawMarkProfile(;
void FX_DebugShowNamesInWorld(LocalClientNum_t localClientNum);
void FX_ProfileSingleEffect(FxSystem *system, const FxEffect *effect, FxProfileEntry *entry);
void FX_DrawProfile(;

//t6/code/src_noserver/effectscore/fx_random.cpp
void TRACK_fx_random();
void FX_RandomDir(int seed, vec3_t *dir);

//t6/code/src_noserver/effectscore/fx_random.h
double FX_RandomInFloatRange(int seed, FxRandKey key, const FxFloatRange *range);

//t6/code/src_noserver/effectscore/fx_sort.cpp
int FX_CalcRunnerParentSortOrder(FxEffect *effect);
void FX_SortEffects(FxSystem *system);
void FX_GetInsertSortElem(;
bool FX_ExistingElemSortsBeforeNewElem(;
void FX_SortSpriteElemIntoEffect(const FxSystem *system, FxEffect *effect, FxElem *remoteElem, FxElem *elem);
void FX_SortNewElemsInEffect(const FxSystem *system, FxEffect *effect);

//t6/code/src_noserver/effectscore/fx_sprite.cpp
void FX_BuildQuadStampCodeMeshVerts(;
bool FX_HeightScreenToWorld(;
bool FX_HeightWorldToScreen(;
void FX_SpriteBegin();
void FX_SpriteAdd(FxSprite *sprite);
FxSpriteInfo *FX_SpriteGetInfo();
// void FX_SpriteGenerateVerts_Internal<1>(float *a1@<edx>, Material *a2@<ecx>, FxGenerateVertsCmd *cmd);
// void FX_SpriteGenerateVerts(float *a1@<edx>, Material *a2@<ecx>, FxGenerateVertsCmd *cmd);

//t6/code/src_noserver/effectscore/fx_system.cpp
void TRACK_fx_system();
FxSystemContainer *FX_GetSystem(LocalClientNum_t localClientNum);
void FX_LinkSystemBuffers(FxSystem *system, FxSystemBuffers *systemBuffers);
int FX_PrintMatchingEffects(LocalClientNum_t clientNum, unsigned int testOffset, unsigned int testValue);
bool FX_CullElemForSpawn(const FxCamera *camera, const FxElemDef *elemDef, const vec3_t *origin);
bool FX_EffectHasSideEffects(const FxElemDef *elemDef);
void FX_DelRefToOwnerEffect(const FxSystem *system, unsigned int ownerEffect, unsigned int stackCount);
void FX_RunGarbageCollection_FreeSpotLight(const FxSystem *system, unsigned __int16 effectHandle);
char FX_RingBufferAllocate(;
void FX_RingBufferCommit(volatile int *firstNew, const volatile int *firstFree, int allocIndex);
char FX_EffectAffectsGameplay(const FxEffectDef *remoteEffectDef);
void FX_SetEffectRandomSeed(FxEffect *effect, const FxEffectDef *remoteDef);
bool FX_SpawnEffect_AllocSpotLightEffect(;
void FX_SetWarningPriority(const FxSystem *system, unsigned __int8 priority);
void FX_InvalidateFrameWarningPriority(const FxSystem *system);
int FX_GetFrameWarningPriority(const FxSystem *system);
void FX_Priority_Begin(FxSystem *system);
void FX_AddRefToOwnerEffect(const FxSystem *system, unsigned int owner, FxEffect *newEffect);
void FX_InitEffectGroundEntity(;
unsigned int FX_SpawnEffectDeferred(const FxSystem *system, FxSpawnEffectCmd *cmd);
BOOL FX_SpawnWorkerShouldBeHeld(const FxSpawnEffectCmd *cmd);
void FX_AssertAllocatedEffect(LocalClientNum_t localClientNum, unsigned int hEffect, const char *error_msg);
int FX_GetEffectPlayedTime(LocalClientNum_t localClientNum, unsigned int hEffect);
BOOL FX_IsEffectDone(LocalClientNum_t localClientNum, unsigned int hEffect);
void FX_HideEffectInExtracam(LocalClientNum_t localClientNum, unsigned int hEffect, bool hide);
void FX_RandomlyRotateAxis(const vec3_t *axisIn, int randomSeed, vec3_t *axisOut);
void FX_SpawnRunner(;
void FX_GetOriginForElem(;
void FX_SpawnSound(;
unsigned __int8 FX_ElemSpawnVisBits(const FxSystem *system, const FxElemDef *elemDef, const vec3_t *origin);
bool FX_ImpactMarkWithinRange(const FxSystem *system, const vec3_t *markLocation);
double FX_GetClientVisibility(LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end);
bool FX_ClientVisibilityTest(LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end);
BOOL FX_FxSpawnWorkersAreOnHold(LocalClientNum_t localClientNum);
BOOL FX_ShouldHideMatureContent();
void FX_ResetSystem(FxSystem *system);
void FX_InitSystem(LocalClientNum_t localClientNum);
void FX_ShutdownSystem(LocalClientNum_t localClientNum);
bool FX_CullEffectForSpawn(const FxCamera *camera, const FxEffectDef *effectDef, const vec3_t *origin);
void FX_RunGarbageCollection_FreeTrails(const FxSystem *system, FxEffect *effect);
void FX_EffectRemoveBaseRef(const FxSystem *system, FxEffect *remoteEffect);
void FX_RunGarbageCollection(const FxSystem *system);
void FX_SpawnEffect_AllocTrails(const FxSystem *system, FxEffect *effect, FxEffect *remoteEffect);
unsigned int FX_SpawnEffect(;
void FX_WaitForFxSpawnWorkers(LocalClientNum_t localClientNum);
unsigned int FX_SpawnOrientedEffect(;
unsigned int FX_PlayOrientedEffectWithMarkEntity(;
unsigned int FX_PlayOrientedEffectWithMarkViewmodel(;
unsigned int FX_PlayOrientedEffect(;
unsigned int FX_PlayOrientedEffectWithLightingParams(;
bool FX_NeedsBoltUpdate(const FxEffectDef *def);
unsigned int FX_SpawnBoltedEffect(;
unsigned int FX_SpawnBoltedEffect(;
unsigned int FX_SpawnBoltedEffectBoltRelative(;
unsigned int FX_PlayBoltedEffect_DynEnt(;
unsigned int FX_PlayBoltedEffect(;
unsigned int FX_PlayBoltedEffect(;
unsigned int FX_PlayBoltedEffectBoltRelative(;
void FX_GetTrailHandleList_Last(;
void FX_StopEffectNonRecursive(const FxSystem *system, FxEffect *effect);
bool FX_SpawnModelPhysics(int randomSeed, FxElem *elem);
void FX_SpawnTrailElem_NoCull(;
void FX_SpawnTrailElem_Cull(;
void FX_SpawnSpotLightElem(const FxSystem *system, FxElem *elem);
void FX_FreeTrailElem(;
void FX_FreeSpotLightElem(const FxSystem *system, unsigned __int16 elemHandle, FxEffect *effect);
void FX_ProcessCmd_SpawnEffect(FxSpawnEffectCmd *data);
void FX_StopEffect(const FxSystem *system, FxEffect *effect);
void FX_RemoveAllEffectElems(;
void FX_KillEffect(;
void FX_KillEffectDef(LocalClientNum_t localClientNum, const FxEffectDef *def);
void FX_KillAllEffects(LocalClientNum_t localClientNum);
void FX_RetriggerEffect(LocalClientNum_t localClientNum, FxEffect *effect, int msecBegin);
void FX_RetriggerEffect(LocalClientNum_t localClientNum, unsigned int hEffect, int msecBegin);
void FX_ThroughWithEffect(const FxSystem *system, FxEffect *effect, bool forcekill);
void FX_FreeElem(;
void FX_ThroughWithEffect(LocalClientNum_t localClientNum, unsigned int hEffect, bool forcekill);
void FX_SpawnElem(;
void FX_RunPrioritySorting(const FxSystem *system);

//t6/code/src_noserver/effectscore/fx_system.h
FxEffect *FX_EffectFromHandle(FxSystem *system, unsigned __int16 handle);
// FxElem *FX_PoolFromHandle_Generic<FxElem,FxElemContainer,2048>(;
FxElem *FX_ElemFromHandle(const FxSystem *system, unsigned __int16 handle);
unsigned int FX_IndexFromElemHandle(unsigned __int16 handle);
// void __thiscall EffectDefGetter::EffectDefGetter(EffectDefGetter *this, const FxEffect *effect);
void FX_AcquireEffectLock(FxEffect *effect);
void FX_BeginIteratingOverEffects_Cooperative(const FxSystem *system);
FxTrailElem *FX_TrailElemFromHandle(const FxSystem *system, unsigned __int16 handle);
FxTrail *FX_TrailFromHandle(const FxSystem *system, unsigned __int16 handle);
// void __thiscall ElemDefGetter::ElemDefGetter(ElemDefGetter *this, const FxEffectDef *effectDef, int index);
void FX_WaitBeginIteratingOverEffects_Exclusive(FxSystem *system);
int FX_ElemToHandle(const FxSystem *system, FxElem *elem);
int FX_EffectToHandle(const FxSystem *system, FxEffect *effect);
FxEffect *FX_EffectFromHandle_ConstSystem(const FxSystem *system, unsigned __int16 handle);
const FxEffect *FX_EffectFromHandle(const FxSystem *system, unsigned __int16 handle);
void FX_AddRefToEffect(FxEffect *effect);
BOOL FX_BeginIteratingOverEffects_Exclusive(const FxSystem *system);
int FX_TrailElemToHandle(const FxSystem *system, FxTrailElem *trailElem);
int FX_TrailToHandle(const FxSystem *system, FxTrail *trail);
void FX_DelRefToEffect(const FxSystem *system, FxEffect *effect, unsigned int stackCount);

//t6/code/src_noserver/effectscore/fx_unique_handle.cpp
FxEffect *UniqueHandleToEffect(const FxSystem *system, unsigned int handle);
unsigned int UniqueHandleAlloc(const FxSystem *system);
void UniqueHandleAssignEffect(;
void UniqueHandleReleaseHandle(const FxSystem *system, unsigned int handle);
void UniqueHandleRelease(const FxSystem *system, FxEffect *effect);
void UniqueHandleInit(FxUniqueHandleDb *uniqueHandleDb);
FxEffect *UniqueHandleToEffect(LocalClientNum_t localClientNum, unsigned int h);

//t6/code/src_noserver/effectscore/fx_update.cpp
bool FX_IsDemoPlaying();
void FX_SpawnTrailLoopingElems(;
int FX_LimitStabilizeTimeForEffectDef_Recurse(const FxEffectDef *remoteEffectDef, int originalUpdateTime);
int FX_LimitStabilizeTimeForElemDef_Recurse(;
void FX_SpawnLoopingElems(;
void FX_SpawnAllFutureLooping(;
void FX_TriggerOneShot(;
void FX_IntegrateVelocityAcrossSegments(;
void FX_IntegrateVelocityInSegment(;
// void FX_IntegrateVelocity(int a1@<edx>, vec3_t *a2@<ecx>, float a3@<xmm0>, const vec3_t *t1);
void FX_NextElementPosition_NoExternalForces(;
// double FX_GetAtRestFraction@<st0>(int a1@<eax>, float a2@<xmm0>);
void FX_GetQuatForOrientation(;
bool FX_UpdateElement_SetupUpdate(;
void FX_PlayElementSpawnSound(const FxSystem *system, const FxElemDef *elemDef, const vec3_t *origin);
bool FX_UpdateElement_TruncateToElemBegin(FxUpdateElem *update, FxUpdateResult *outUpdateResult);
int FX_GetBoltTemporalBits(LocalClientNum_t localClientNum, int dobjHandle, unsigned int ignoreTeleporting);
bool FX_GetBoneOrientation_IsDObjEntityValid(LocalClientNum_t localClientNum, int dobjHandle);
char FX_GetBoneOrientation(;
bool FX_CanKillImmediate(const FxEffectDef *def);
int FX_UpdateEffectBolt(;
void FX_GetWorldBoundingBox(;
int FX_TestEffectBoundingBoxMinMaxAgainstFrustum(;
bool FX_ShouldProcessEffect(FxSystem *system, FxEffect *remoteEffect, FxUpdateEffectType updateEffectType);
void FX_BeginUpdate(LocalClientNum_t localClientNum);
void FX_EndUpdate(LocalClientNum_t localClientNum);
void FX_SaveGfxCloudCount(LocalClientNum_t localClientNum, int count);
void FX_SortEffectsForDraw(FxSystem *system);
void FX_AddNonSpriteDrawSurfs(FxCmd *cmd);
void DB_RestartEffects_Begin();
void FX_SetupCamera(;
void FX_GetCameraUpdateFromRefdefAndZFar(FxCameraUpdate *cameraUpdate, const refdef_t *refdef, float zfar);
void FX_SetExtraCamera(LocalClientNum_t localClientNum, const FxCameraUpdate *cameraUpdate);
void FX_SetNextUpdateCamera(LocalClientNum_t localClientNum, const FxCameraUpdate *cameraUpdate);
void FX_SetNextUpdateTime(LocalClientNum_t localClientNum, int time, int timeDelta);
void FX_FillUpdateCmd(LocalClientNum_t localClientNum, FxCmd *cmd);
void FX_InitFxSpawnEffectCmd(;
void FX_ProcessLooping(;
void FX_BeginLooping(;
void FX_StartNewEffect(;
unsigned __int8 FX_ProcessEmitting(;
void FX_NextElementPosition(FxUpdateElem *update, int msecUpdateBegin, int msecUpdateEnd);
void FX_SpawnImpactEffect(;
int FX_CollisionResponse(;
;
;
FxUpdateResult FX_UpdateElementPosition_Local(FxUpdateElem *update);
FxUpdateResult FX_UpdateElementPosition(FxSystem *system, FxUpdateElem *update);
void FX_SpawnDeathEffect(FxSystem *system, FxUpdateElem *update);
void FX_UpdateElement_HandleEmitting(;
void FX_UpdateElement_HandleAttachedEffect(;
FxUpdateResult FX_UpdateTrailElement(;
bool FX_UpdateEffectPartialTrail(;
void FX_RewindTo(LocalClientNum_t localClientNum, int time);
void DB_RestartEffects_Finish();
void FX_UpdateSpotLightEffectPartial(;
unsigned int FX_UpdateEffectPartialForClass(;
// void FX_UpdateEffectPartial<1>(;
// void FX_UpdateEffectPartial<0>(;
void FX_UpdateCulledEffect(;
void FX_UpdateEffect(FxSystem *system, FxEffect *effect, FxEffect *remoteEffect);
void FX_UpdateSpotLightEffect(FxSystem *system, FxEffect *effect, FxEffect *remoteEffect);
void FX_UpdateBatch(;
void FX_UpdateSpotLight(FxCmd *cmd);
void FX_UpdateNonSprite(FxCmd *cmd);
void FX_UpdateNonDependent(FxCmd *cmd);
void FX_UpdatePortalled(FxCmd *cmd);
void FX_UpdateRemaining(FxCmd *cmd);

//t6/code/src_noserver/effectscore/fx_update_util.cpp
void FX_OffsetSpawnOrigin(;
void FX_GetSpawnOrigin(;
void FX_SpatialFrameToOrientation(const FxSpatialFrame *frame, orientation_t *orient);
void FX_OrientationToSpatialFrame(const orientation_t *orient, FxSpatialFrame *frame);
void FX_GetOrientation_RunRelativeToOffset(;
void FX_GetOrientation(;
void FX_GetVelocityAtTime(;
void FX_OrientationPosToWorldPos(const orientation_t *orient, const vec3_t *pos, vec3_t *out);
void FX_OrientationPosFromWorldPos(const orientation_t *orient, const vec3_t *pos, vec3_t *out);
void FX_AddVisBlocker(FxSystem *system, const vec3_t *posWorld, float radius, float opacity);
void FX_ToggleVisBlockerFrame(FxSystem *system);
char FX_CullSphere(;
char FX_CullBox(const FxCamera *camera, unsigned int frustumPlaneCount, const vec3_t *mins, const vec3_t *maxs);
void FX_AnglesToOrientedAxis(const vec3_t *anglesInRad, const orientation_t *orient, vec3_t *axisOut);
void FX_GetElemAxis(;
int FX_GetElemLifeSpanMsec(int elemRandomSeed, float elemWindInterpolate, const FxElemDef *elemDef);
void FX_GetOriginForTrailElem(;

//t6/code/src_noserver/effectscore/fx_wind.cpp
void FX_SetGlobalWind(const FX_WindInfo *windInput);
FX_WindInfo *FX_GetGlobalWind();

//t6/code/src_noserver/flame/flame_class_chunk.cpp
void Flame_Class_Chunk_Allocate(int max_flame_chunks);
void Flame_Class_Chunk_Release();
void Flame_Class_Chunk_Init();
flameChunk_s *Flame_Class_Chunk_Alloc(bool is_server);
void Flame_Class_Chunk_Free(bool is_server, flameChunk_s *chunk);
void Flame_Phys_Spawn_Items(bool is_server, int curTime, flameChunk_s *trav);
void Flame_Class_Chunk_Age(bool is_server, int time, LocalClientNum_t localClientNum);
flameChunk_s *Flame_Class_Chunk_Spawn(;
void Flame_Class_Chunk_Render_All(LocalClientNum_t localClientNum);

//t6/code/src_noserver/flame/flame_class_drips.cpp
void Flame_Class_Drips_Allocate(int max_flame_drips);
void Flame_Class_Drips_Release();
void Flame_Class_Drips_Init();
flameDrips_t *Flame_Class_Drips_Alloc(bool is_server);
void Flame_Class_Drips_Free_If_Stream(bool is_server, flameStream_s *stream);
void Flame_Class_Drips_Age(bool is_server, int time, LocalClientNum_t localClientNum);
void Flame_Class_Drips_Render_All(LocalClientNum_t localClientNum);
void Flame_Class_Drips_Render_Local_List(LocalClientNum_t localClientNum, flameDrips_t *start);
flameDrips_t *Flame_Class_Drips_Spawn(bool is_server, flameChunk_s *fromChunk, int curTime, float minLifeFrac);

//t6/code/src_noserver/flame/flame_class_fire.cpp
void Flame_Class_Fire_Allocate(int max_flame_fire);
void Flame_Class_Fire_Release();
void Flame_Class_Fire_Init();
flameFire_t *Flame_Class_Fire_Alloc();
void Flame_Class_Fire_Age(bool is_server, int time, LocalClientNum_t localClientNum);
void Flame_Class_Fire_Render_All(LocalClientNum_t localClientNum);
void Flame_Class_Fire_Render_Local_List(LocalClientNum_t localClientNum, flameFire_t *start);
flameFire_t *Flame_Class_Fire_Spawn(bool is_server, flameChunk_s *fromChunk, int curTime, float minLifeFrac);

//t6/code/src_noserver/flame/flame_class_smoke.cpp
void Flame_Class_Smoke_Allocate(int max_flame_smoke);
void Flame_Class_Smoke_Release();
void Flame_Class_Smoke_Init();
void Flame_Class_Smoke_Age(bool is_server, int time, LocalClientNum_t localClientNum);
flameSmoke_t *Flame_Class_Smoke_Spawn(flameChunk_s *fromChunk, int curTime);
void Flame_Class_Smoke_Render_All(LocalClientNum_t localClientNum);

//t6/code/src_noserver/flame/flame_class_stream.cpp
void Flame_Class_Stream_Allocate(int max_flame_streams);
void Flame_Class_Stream_Release();
void Flame_Class_Stream_Init();
flameStream_s *Flame_Class_Stream_Alloc(bool is_server);
void Flame_Class_Stream_Age(bool is_server);
void Flame_Class_Stream_Fire_Chunks(;
void Flame_Class_Stream_Render_Item(;
void Flame_Class_Stream_Render_All(LocalClientNum_t localClientNum);
void CG_Flame_Render_Lights_Only(LocalClientNum_t localClientNum);

//t6/code/src_noserver/flame/flame_cull.cpp
void Flame_Cull_Stream_Chunk(bool is_server, flameChunk_s *cull, flameChunk_s *keep);
void Flame_Cull_Stream_Chunks(bool is_server, flameStream_s *stream);

//t6/code/src_noserver/flame/flame_damage.cpp
void SV_Flame_Apply_Damage(gentity_t *ent);

//t6/code/src_noserver/flame/flame_physics.cpp
void trace_sphere(trace_t *trace, const vec3_t *start, const vec3_t *end, float radius, col_context_t *context);
void Flame_Phys_Collision_Response(bool is_server, trace_t *trace, flameGeneric_s *gen);
void Flame_Impact_Process(bool is_server, flameGeneric_s *gen, trace_t *trace);
void Flame_Phys_Update_Item_Stream(flameGeneric_s *gen, int time);
void Flame_Phys_Update_Item_Fire(flameGeneric_s *gen, int time);
void Flame_Phys_Update_Item_Smoke(flameGeneric_s *gen, int time);
;
void Flame_Phys_Update_Item_Chunk(;
void Flame_Phys_Update_Item_Drip(;
;
void Flame_Phys_Collision(;
;
void Flame_Phys_Update_Items(bool is_server);

//t6/code/src_noserver/flame/flame_sound.cpp
void Flame_Class_Source_Sound_Init(flameSource_t *source);
void Flame_Class_Source_Sound(;

//t6/code/src_noserver/flame/flame_system.cpp
unsigned __int8 *FlameAlloc(unsigned int size, const char *name);
void FlameFree(void *ptr, const char *name);
void Flame_Init_FlameVars();
void Flame_Init_DVars();
void Flame_CMD_PrintDVarsToConsol();
void Flame_CMD_Test_Toggle();
void Flame_CMD_Use_Dvars_Toggle();
void Flame_DVarsToFlameVars(flameTable *fTable);
flameTable *Flame_FindFlameTable(const char *tableName);
long double Flame_SwayRand(float x, float y, int time);
flameSource_t *SV_Flame_Source_Get(int entityNum);
flameSource_t *Flame_Source_Get(int entityNum);
flameRender_s *Flame_Get_FlameRender(const char *name);
void Flame_Item_Init(flameGeneric_s *item, int itemSize);
void Flame_List_Init(flameGeneric_s *list, int itemSize, int listSize);
void Flame_List_Move_Global(flameGeneric_s *item, flameGeneric_s **fromList, flameGeneric_s **toList);
void Flame_List_Add_Local(flameGeneric_s *item, flameGeneric_s **localList);
void Flame_List_Sub_Local(flameGeneric_s *item, flameGeneric_s **localList);
flameSource_t *Flame_Source_Alloc(int entityNum);
flameSource_t *SV_Flame_Source_Alloc(int entityNum);
void Flame_Render_Sprite(;
void Flame_Render_Sprites(;
int Flame_GetLocalClientFlameSource(LocalClientNum_t localClientNum, int EntNum);
char Flame_GetLocalClientSourceRange(LocalClientNum_t localClientNum, int EntNum);
int Flame_GetTrueFlameSourceEntityNum(int EntNum);
void SV_Flame_Update_Source_Internal(;
void SV_Flame_Update_Source(int entityNum, flameWeaponConfig_t *weaponConfig, int time);
void Flame_Generate_Verts(LocalClientNum_t localClientNum);
void CG_Flame_Update_ViewModel(LocalClientNum_t localClientNum, centity_t *cent);
double Flame_Random(bool is_server);
double Flame_CRandom(bool is_server);
double Flame_CalcTimeScale(int startTime, int endTime);
double Flame_CalcInvStartSpeed(float invInitialSpeed, float speedScale);
void Flame_System_Allocate(int max_flame_sources);
void Flame_System_Release();
void Flame_Init_Sources();
void Flame_InitDevGui();
void Flame_Init();
void Flame_Reset();
void CG_Flame_Age_All_Objects(int time, LocalClientNum_t localClientNum);
void SV_Flame_Age_All_Objects(int time);
;
void Flame_Enable_And_Allocate(;
void Flame_System_Disable();

//t6/code/src_noserver/from_common/brush_edges.cpp
float RepresentativeTriangleFromWinding(;
int GetPointListAllowDupes(;
char PlaneInCommonExcluding(;
int ThirdPlane(const SimplePlaneIntersection *point, int plane1, int plane2);
int NumberOfOccurancesOfPlane(int planeIndex, const SimplePlaneIntersection **pts, int ptCount);
bool FindCycleBFS(;
int RemovePtsWithPlanesThatOccurLessThanTwice(const SimplePlaneIntersection **pts, int ptsCount);
int GetPtsFormedByPlane(;
float CyclePerimiter(const SimplePlaneIntersection **pts, int ptsCount);
bool IsConvex(const vec3_t *pts, unsigned int ptCount);
bool TestConvexWithoutNearPoints(const SimplePlaneIntersection **pts, unsigned int ptCount);
int ChooseEdgeToRemove(;
int PartitionEdges(;
int ReduceToACycle(int basePlane, const SimplePlaneIntersection **pts, int ptsCount);
int NumberOfUniquePoints(const SimplePlaneIntersection **pts, int ptsCount);
adjacencyWinding_t *BuildBrushdAdjacencyWindingForSide(;

//t6/code/src_noserver/game/actor.cpp
void TRACK_actor();
void VisCache_Update(vis_cache_t *pCache, bool bVisible);
void SentientInfo_Clear(sentient_info_t *pInfo);
;
;
void G_InitActors();
int G_GetActorIndex(actor_t *actor);
XAnimTree_s *G_GetActorAnimTree(actor_t *actor);
void Actor_FinishSpawning(actor_t *self);
void Actor_InitAnimScript(actor_t *self);
actor_t *Actor_FirstActor(const int iTeamFlags);
actor_t *Actor_NextActor(actor_t *pPrevActor, const int iTeamFlags);
int Actor_NumFreeActors();
int Actor_NumActors(const int iTeamFlags);
void Actor_ClearArrivalPos(actor_t *self);
int Actor_UpdateActorInfo(gentity_t *ent);
void SV_UpdateMoverRecord(gentity_t *self);
void Spawner_Think(gentity_t *ent);
void Actor_Touch(gentity_t *self, gentity_t *other);
bool Actor_InScriptedState(const actor_t *self);
void Actor_Die(;
bool Actor_IsDying(const actor_t *self);
BOOL usingCodeGoal(actor_t *actor);
void Actor_DebugDrawNodesInVolume(actor_t *self);
gentity_t *Actor_GetTargetEntity(actor_t *self);
sentient_t *Actor_GetTargetSentient(actor_t *self);
char Actor_AllSecondaryTargetsForward(const actor_t *self);
void Actor_GetTargetPosition(actor_t *self, vec3_t *position);
void Actor_GetTargetLookPosition(actor_t *self, vec3_t *position);
gentity_t *Actor_GetScriptTargetEntity(actor_t *self);
BOOL Actor_IsDodgeEntity(actor_t *self, int entnum);
int Actor_Physics_GetLeftOrRightDodge(actor_t *self, bool dodgeRight, float length);
void Actor_PhysicsRestoreInputs(actor_t *self, PhysicsInputs *inputs);
float Actor_CalcultatePlayerPushDelta(const actor_t *self, const gentity_t *pusher, vec2_t *pushDir);
bool Actor_ShouldMoveAwayFromCloseEnt(actor_t *self);
void actor_controller(const gentity_t *self, int *partBits);
bool Actor_PointNear(const vec3_t *vPoint, const vec3_t *vGoalPos);
bool Actor_PointNearNode(const vec3_t *vPoint, const pathnode_t *node);
bool Actor_PointNearClaimNode(const actor_t *self, const vec3_t *vPoint);
bool Actor_PointAtGoal(const vec3_t *vPoint, const actor_goal_s *goal);
bool Actor_PointNearPoint(const vec3_t *vPoint, const vec3_t *vGoalPos, float buffer);
bool Actor_PointNearPointSqDist(const vec3_t *vPoint, const vec3_t *vGoalPos, float bufferSq);
bool Actor_PointAt(const vec3_t *vPoint, const vec3_t *vGoalPos);
bool Actor_ExitingClaimNode(actor_t *self);
void Actor_HandleInvalidPath(actor_t *self, vec3_t goal);
void Actor_GetNodeOffset(actor_t *self, const pathnode_t *node);
bool Actor_ShouldHoldGroundAgainstEnemy(actor_t *self);
bool Actor_EnemyInPathFightDist(actor_t *self, sentient_t *enemy);
gentity_t *Actor_IsKnownEnemyInRegion(;
bool Actor_HasPath(actor_t *self);
BOOL Actor_HadPath(actor_t *self);
void Actor_InitPath(actor_t *self);
void Actor_ClearPath(actor_t *self);
void Actor_GetAnimDeltas(actor_t *self, vec2_t *rotation, vec3_t *translation);
BOOL Actor_IsMovingToMeleeAttack(actor_t *self);
bool Actor_SkipPathEndActions(actor_t *self);
void Actor_PathEndActions(actor_t *self);
;
BOOL Actor_AtClaimNode(actor_t *self);
BOOL Actor_AtClaimNodeAndAngle(actor_t *self);
BOOL Actor_NearClaimNode(actor_t *self, float dist);
int Actor_IsValidClaimNode(actor_t *self, const pathnode_t *node);
void Actor_PredictAnim(actor_t *self);
BOOL Actor_UseChokePoints(actor_t *self);
void Actor_CheckCollisions(actor_t *self);
void Actor_ClearPileUp(actor_t *self);
void Actor_ClipPathToGoal(actor_t *self);
void Actor_BeginTrimPath(actor_t *self);
int Actor_TrimPathToAttack(actor_t *self);
BOOL Actor_MayReacquireMove(actor_t *self);
void Actor_ClearMoveHistory(actor_t *self);
void Actor_GetMoveHistoryAverage(actor_t *self, vec3_t *vDir);
void Actor_UpdateMoveHistory(actor_t *self);
void Path_UpdateLeanAmount(actor_t *self, vec2_t *vWishDir);
float Path_UpdateMomentum(actor_t *self, vec2_t *vWishDir, float fMoveDist);
;
void Actor_AddStationaryMoveHistory(actor_t *self);
BOOL Actor_IsMoving(actor_t *self);
void Actor_SetFlashed(actor_t *self, int flashed, float strength);
void Actor_SetGoalRadius(actor_goal_s *goal, float radius);
void Actor_SetGoalHeight(actor_goal_s *goal, float height);
bool Actor_IsInsideArc(;
void SentientInfo_Copy(actor_t *pTo, const actor_t *pFrom, int index);
void Actor_InitActorState(gentity_t *ent);
actor_t *Actor_Alloc();
void Actor_Free(actor_t *actor);
void Actor_FreeExpendable();
void Actor_FinishSpawningAll(bool bRestart);
void Actor_DissociateSentient(actor_t *self, sentient_t *other);
void Actor_NodeClaimRevoked(actor_t *self, int invalidTime);
void Actor_CheckClearNodeClaimCloseEnt(actor_t *selfa);
char Actor_KeepClaimedNode(actor_t *self);
void Actor_ClearKeepClaimedNode(actor_t *self);
void Actor_CheckNodeClaim(actor_t *self);
void Actor_PreThink(actor_t *self);
void Actor_UpdatePlayerPush(actor_t *self, gentity_t *player);
void Actor_UpdateCloseEnt(actor_t *self);
actor_think_result_t Actor_CallThink(actor_t *self);
void Actor_UpdatePathNodes(actor_t *self);
void Actor_Pain(;
void Actor_EntInfo(gentity_t *self, vec3_t *source);
int Actor_MoveAwayNoWorse(actor_t *self);
int Actor_PhysicsCheckMoveAwayNoWorse(;
int Actor_PhysicsMoveAway(actor_t *self);
bool Actor_IsAtScriptGoal(actor_t *self);
bool Actor_ShouldKeepClaimedNode(actor_t *self);
bool Actor_IsNearClaimedNode(actor_t *self);
void Actor_ResetLookahead(actor_t *self);
pathnode_t *Actor_FindClaimedNode(actor_t *self);
bool Actor_IsAlongPath(actor_t *self, vec2_t *origin, vec2_t *pathPoint);
bool Actor_CheckStopOnGoalChange(actor_t *self, checkStopParams_t *params);
bool Actor_IsFixedNodeUseable(actor_t *self);
bool Actor_FindPath(;
void Actor_RecalcPath(actor_t *self);
bool Actor_FindPathToNode(actor_t *self, pathnode_t *pGoalNode, int bSuppressable, int bIgnoreBadplaces);
bool Actor_FindPathToSentient(actor_t *self, sentient_t *pGoalEnt, int bSuppressable);
void Actor_FindPathInGoalWithLOS(;
void Actor_BadPlacesChanged();
void Actor_UpdateAnglesAndDelta(actor_t *self);
void Actor_UpdatePileUp(actor_t *self);
void Actor_UpdateGoalPos(actor_t *self);
void Actor_ClearUseEnemyGoal(actor_t *self);
bool Actor_CheckGoalNotify(actor_t *self);
void Actor_CheckNotify(actor_t *self);
void Actor_Think(gentity_t *self);
int Actor_PhysicsAndDodge(actor_t *self);
void Actor_DoMove(actor_t *self);
bool Actor_IsAtGoal(actor_t *self);
bool Actor_FindPathToGoalDirectInternal(actor_t *self);
void Actor_FindPathToGoalDirect(actor_t *self);
bool Actor_FindPathToClaimNode(;
bool Actor_CheckStop(actor_t *self, int canUseEnemyGoal, pathnode_t *node);
void Actor_TryPathToArrivalPos(actor_t *self);
void Actor_FindPathToFixedNode(actor_t *self);
bool Actor_SetupFindPathToGoal(actor_t *self, int *canUseEnemyGoal);
bool Actor_TryPathToNode(actor_t *self, pathnode_t *node);
void Actor_FindPathToGoal(actor_t *self);
void Actor_FixedLinkPhysicsFallback(actor_t *self, vec3_t *targetOrigin);
void Actor_UpdateOriginAndAngles(actor_t *self);
void Actor_PredictOriginAndAngles(actor_t *self);
void Actor_PostThink(actor_t *self);
void Actor_InitMove(actor_t *self);
int SP_actor(gentity_t *ent, SpawnVar *spawnVar);

//t6/code/src_noserver/game/actor_aim.cpp
void Actor_FillWeaponParms(actor_t *self, weaponParms *wp);
gentity_t *Actor_Melee(actor_t *self, const vec3_t *direction, const vec3_t *offset);

//t6/code/src_noserver/game/actor_animapi.cpp
void Actor_InitAnim(actor_t *self);
BOOL Actor_IsAnimScriptAlive(actor_t *self);
void Actor_KillAnimScript(actor_t *self);
void Actor_SetMoveMode(actor_t *self, unsigned __int8 moveMode);
void Actor_SetAnimScript(;
void Actor_AnimMoveAway(actor_t *self, scr_animscript_t *pAnimScriptFunc);
void Actor_AnimStop(actor_t *self, scr_animscript_t *pAnimScriptFunc);
void Actor_AnimStopOrCombat(actor_t *self);
scr_animscript_t *Actor_GetStopAnim(actor_t *self);
void Actor_AnimTryWalk(actor_t *self, scr_animscript_t *a2);
void Actor_AnimTryRun(actor_t *self, scr_animscript_t *a2);
void Actor_AnimCombat(actor_t *self);
void Actor_AnimPain(actor_t *self);
void Actor_AnimDeath(actor_t *self);
void Actor_AnimSpecific(actor_t *self, scr_animscript_t *func, ai_animmode_t eAnimMode, bool bUseGoalWeight);
void Actor_AnimScripted(actor_t *self);
void Actor_AnimSetCompleteGoalWeight(;

//t6/code/src_noserver/game/actor_animscripted.cpp
char Actor_ScriptedAnim_Start(actor_t *self, ai_state_t ePrevState);
void Actor_ScriptedAnim_Finish(actor_t *self, ai_state_t eNextState);
int Actor_ScriptedAnim_Think(actor_t *self);
char Actor_CustomAnim_Start(actor_t *self, ai_state_t ePrevState);
int Actor_CustomAnim_Think(actor_t *self);

//t6/code/src_noserver/game/actor_badplace.cpp
void TRACK_actor_badplace();
void Path_UpdateBadPlaceCount(badplace_t *place, int delta);
badplace_t *Path_AllocBadPlace(unsigned int name, int duration, badplace_parms_t *params);
char Path_CheckLineSegmentIntersectsAnyBadPlaceCylinder(const vec3_t *start, const vec3_t *end, int teamflags);
void Path_MakeBadPlaceEx(unsigned int name, int duration, int teamflags, int type, badplace_parms_t *parms);
void Path_DrawBadPlaces();
void Path_InitBadPlaces();
void Path_ShutdownBadPlaces();
char Actor_IsInAnyBadPlace(actor_t *self);
// actor_t *Actor_BadPlace_UpdateFleeingActors@<eax>(unsigned int a1@<ebp>);
void Actor_BadPlace_GetMaximumFleeRadius();
bool Actor_BadPlace_HasPotentialNodeDuplicates(;
int Actor_BadPlace_IsPointInAnyBadPlace(vec3_t *point);
char Actor_BadPlace_IsNodeInAnyBadPlace(pathnode_t *node);
pathnode_t *Actor_BadPlace_FindSafeNodeAlongPath(actor_t *self);
void Path_UpdateBadPlaces();
int Actor_BadPlace_FindSafeNodeOutsideBadPlace(actor_t *self, pathsort_t *potentialNodes, float maxFleeDist);
bool Actor_BadPlace_AttemptEscape(actor_t *self);
bool Actor_BadPlace_Flee_Start(actor_t *self, ai_state_t ePrevState);
int Actor_BadPlace_Flee_Think(actor_t *self);

//t6/code/src_noserver/game/actor_bigdog_exposed.cpp
char Actor_BigDog_Exposed_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Dog_Exposed_Finish(actor_t *self, ai_state_t eNextState);
void Actor_BigDog_Attack(actor_t *self);
actor_think_result_t Actor_BigDog_Exposed_Think(actor_t *self);

//t6/code/src_noserver/game/actor_corpse.cpp
int G_GetActorCorpseIndex(gentity_t *ent);
int G_GetFreeActorCorpseIndex(int reuse);
void G_RemoveOneActorCorpse();
void G_RemoveAllActorCorpses();
void G_RemoveActorCorpses(int allowedCorpseCount);
// void G_UpdateActorCorpses(int a1@<esi>);
void ActorCorpse_Free(gentity_t *ent);
;
void Actor_GetBodyPlantAngles(;
void Actor_OrientCorpseToGround(gentity_t *self, int bLerp);
void Actor_OrientPitchToGround(gentity_t *self, int bLerp);
int Actor_BecomeCorpse(gentity_t *self);

//t6/code/src_noserver/game/actor_death.cpp
char Actor_Death_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Death_Cleanup(actor_t *self);
// int Actor_Death_Think@<eax>(actor_t *self@<ecx>, int a2@<ebp>);

//t6/code/src_noserver/game/actor_dog_exposed.cpp
char Actor_Dog_Exposed_Start(actor_t *self, ai_state_t ePrevState);
int Actor_Dog_IsInSyncedMelee(actor_t *self, sentient_t *enemy);
void Actor_Dog_Attack(actor_t *self);
void Actor_FindPathToGoalNearestNode(actor_t *self);
void Actor_UpdateMeleeGoalPos(actor_t *self, const vec3_t *goalPos);
bool Actor_Dog_IsTurnScriptRunning(actor_t *self);
float Actor_Dog_GetEnemyPos(actor_t *self, sentient_t *enemy, vec3_t *enemyPos);
char Actor_Dog_ObstacleInPath(int a1);
double Actor_Dog_GetDeltaTurnYaw(actor_t *self);
bool Actor_Dog_ShouldTurn(actor_t *self);
void Actor_Dog_PredictPosition(const gentity_t *ent, vec3_t *vPos);
bool Actor_Dog_ShouldAttack(const actor_t *self, const sentient_t *enemy);
;
int Actor_Dog_IsEnemyInAttackRange(actor_t *self, sentient_t *enemy, int *goalPosSet);
actor_think_result_t Actor_Dog_Exposed_Think(actor_t *self);

//t6/code/src_noserver/game/actor_events.cpp
double Actor_EventDefaultRadiusSqrd(ai_event_t eType);
void Actor_DumpEvents(actor_t *self, ai_event_t event, gentity_t *originator);
void Actor_WasAttackedBy(actor_t *self, sentient_t *pOther);
bool Actor_IsOnSameTeam(gentity_t *originator, actor_t *pActor, int teamFlags);
void Actor_EventFootstep(actor_t *self, sentient_t *originator, const vec3_t *vOrigin);
void Actor_EventNewEnemy(actor_t *self, sentient_t *originator);
void Actor_EventPain(actor_t *self, sentient_t *pCasualty, sentient_t *pAttacker);
void Actor_EventDeath(actor_t *self, sentient_t *pCasualty, sentient_t *pAttacker);
void Actor_EventExplosion(actor_t *self, gentity_t *originator, const vec3_t *vOrigin);
void Actor_EventGrenadePing(actor_t *self, gentity_t *originator);
void Actor_EventGunshot(actor_t *self, sentient_t *originator, const vec3_t *vOrigin);
void Actor_EventBullet(;
bool Actor_ShouldKnowAboutPainDeathEvent(actor_t *self, gentity_t *originator, const vec3_t *vOrigin);
void Actor_ReceivePointEvent(;
void Actor_ReceiveLineEvent(;
void Actor_BroadcastPointEvent(;
void Actor_BroadcastLineEvent(;
void Actor_BroadcastTeamEvent(sentient_t *sentient, ai_event_t eType);

//t6/code/src_noserver/game/actor_event_listeners.cpp
void TRACK_actor_event_listener();
void Actor_EventListener_RemoveEntity(int entIndex);
int Actor_EventListener_Next(int index, ai_event_t event, int teamFlags);
gentity_t *Actor_EventListener_GetEntity(int index);
void Actor_EventListener_NotifyToListener(;
int Actor_EventListener_First(ai_event_t event, int teamFlags);

//t6/code/src_noserver/game/actor_exposed.cpp
void Actor_Exposed_CheckLockGoal(actor_t *self);
void Actor_Exposed_Combat(actor_t *self);
char Actor_Exposed_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Exposed_Finish(actor_t *self, ai_state_t eNextState);
bool Actor_Exposed_Resume(actor_t *self, ai_state_t ePrevState);
void Actor_Exposed_Reacquire_Move(actor_t *self, AI_MOVE_MODE moveMode);
void Actor_ReacquireDoneBehavior(actor_t *self);
bool Actor_Exposed_CheckStopMovingAndStartCombat(actor_t *self);
void Actor_Exposed_DecideSubState(actor_t *self);
void Actor_Exposed_FindReacquireNode(actor_t *self);
pathnode_t *Actor_Exposed_GetReacquireNode(actor_t *self);
char Actor_Exposed_UseReacquireNode(actor_t *self, pathnode_t *pNode);
BOOL Actor_IsDoingReacquire(actor_t *self);
char Actor_Exposed_ReacquireStepMove(actor_t *self, float fDist);
void Actor_Exposed_FindReacquireDirectPath(actor_t *self, bool ignoreSuppression);
void Actor_Exposed_FindReacquireProximatePath(actor_t *self, bool ignoreSuppression);
char Actor_Exposed_StartReacquireMove(actor_t *self);
void Actor_Exposed_MoveToGoal_Move(actor_t *self);
bool Actor_Exposed_IsShortMove(actor_t *self);
void Actor_Exposed_NonCombat_Anim(actor_t *self);
void Actor_Exposed_NonCombat_Think(actor_t *self);
void Actor_Exposed_FlashBanged(actor_t *self);
void Actor_Exposed_Reaction(actor_t *self);
actor_think_result_t Actor_Exposed_Think(actor_t *self);
void Actor_Exposed_Touch(actor_t *self, gentity_t *pOther);

//t6/code/src_noserver/game/actor_fields.cpp
unsigned __int8 *BaseForFields(actor_t *actor, const actor_fields_s *fields);
const actor_fields_s *FindFieldForName(const actor_fields_s *fields, const char *pszFieldName);
void ActorScr_SetSpecies(actor_t *pSelf);
void ActorScr_GetSpecies(actor_t *pSelf);
void ActorScr_GetStairsState(actor_t *pSelf);
void ActorScr_GetIsDog(actor_t *pSelf);
void ActorScr_GetIsBigDog(actor_t *pSelf);
void ActorScr_Clamp_0_1(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_Clamp_0_Positive(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetSqr(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetSqrt(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_ReadOnly(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetGoalRadius(actor_t *pSelf);
void ActorScr_SetGoalHeight(actor_t *pSelf);
void ActorScr_SetTime(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetTime(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetAlertLevel(actor_t *pSelf);
void ActorScr_GetAlertLevel(actor_t *pSelf);
void ActorScr_SetCombatMode(actor_t *pSelf);
void ActorScr_GetCombatMode(actor_t *pSelf);
void ActorScr_GetGroundType(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetIgnoreTriggerBit(actor_t *pSelf);
void ActorScr_GetIgnoreTriggerBit(actor_t *pSelf);
void ActorScr_SetPushableBit(actor_t *pSelf);
void ActorScr_GetPushableBit(actor_t *pSelf);
void ActorScr_SetNoPlayerMeleeBloodBit(actor_t *pSelf);
void ActorScr_GetNoPlayerMeleeBloodBit(actor_t *pSelf);
void ActorScr_SetIkPriorityBit(actor_t *pSelf);
void ActorScr_GetIkPriorityBit(actor_t *pSelf);
void ActorScr_SetLastEnemySightPos(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetLastEnemySightPos(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_GetPathGoalPos(actor_t *self, const actor_fields_s *field);
void ActorScr_GetPathStartPos(actor_t *self, const actor_fields_s *field);
void ActorScr_SetFixedNode(actor_t *self, const actor_fields_s *field);
void ActorScr_GetMoveMode(actor_t *pSelf, const actor_fields_s *pField);
void ActorScr_SetPathRandomPercent(actor_t *self, const actor_fields_s *field);
void ActorScr_GetLookaheadNextNodePos(actor_t *pSelf);
void PrintFieldUsage(const actor_fields_s *fields);
void Cmd_AI_PrintUsage();
void Cmd_AI_DisplayInfo(actor_t *actor);
void Cmd_AI_Delete(actor_t *actor);
void Cmd_AI_DisplayValue(actor_t *pSelf, unsigned __int8 *pBase, const actor_fields_s *pField);
void Cmd_AI_SetValue(actor_t *pSelf, int argc, unsigned __int8 *pBase, const actor_fields_s *pField);
void Cmd_AI_Dispatch(int argc, actor_t *pSelf, const actor_fields_s *fields, const actor_fields_s *pField);
void Cmd_AI_EntityNumber(;
void Cmd_AI_Team(;
void Cmd_AI_Name(;
void Cmd_AI_f();
void GScr_AddFieldsForActor();
void Scr_SetActorField(actor_t *actor, int offset);
void Scr_GetActorField(actor_t *actor, int offset);

//t6/code/src_noserver/game/actor_generic.cpp
void Actor_Generic_Suspend(actor_t *self, ai_state_t eNextState);
int Actor_Generic_Resume(actor_t *self, ai_state_t ePrevState);
void __thiscall Actor_Generic_Pain(;
void Actor_Generic_Touch(actor_t *self, gentity_t *pOther);

//t6/code/src_noserver/game/actor_lookat.cpp
void Actor_InitLookAt(actor_t *self);
void Actor_SetLookAtAnimNodes(;
void Actor_SetLookAt(actor_t *self, const vec3_t *vPosition, float fTurnAccel);
void Actor_SetLookAtYawLimits(actor_t *self, float fAnimYawLimit, float fYawLimit, float fBlendTime);
void Actor_StopLookAt(actor_t *self, float fTurnAccel);
void Actor_UpdateLookAt(actor_t *self);

//t6/code/src_noserver/game/actor_navigation.cpp
float Path_GetPathDir(vec2_t *delta, const vec2_t *vFrom, const vec2_t *vTo);
void Path_IncrementNodeUserCount(path_t *pPath);
void Path_DecrementNodeUserCount(path_t *pPath);
void Path_Backup(const path_t *path);
float Path_GetDistToPathSegment(const vec2_t *vStartPos, const pathpoint_t *pt);
BOOL Path_LookaheadNeedsReset(path_t *pPath);
void Path_AddTrimmedAmount(path_t *pPath, const vec3_t *vStartPos);
void Path_SubtractTrimmedAmount(;
void Path_SetLookaheadToStart(path_t *pPath, const vec3_t *vStartPos, int bTrimAmount);
bool Path_NearDangerousNode(const pathnode_t *pNode, const team_t team);
void Path_SmoothPath(pathnode_t *pNodeFrom, pathnode_t *pNodeTo, team_t team);
bool Path_NodeOccupiedByOther(int searchEntNum, const pathnode_t *node);
BOOL Path_CheckFromAndToNodesNoHeightCheck(PathFindInput *pathFindInput);
int Path_CheckFromAndToNodes(PathFindInput *pathFindInput, PathBlockPlanes *blockPlanes);
// void __thiscall CustomSearchInfo_FindPath::CustomSearchInfo_FindPath(;
void Path_InitFindInput(PathFindInput *pathFindInput, actor_t *actor);
int Path_GetPathRandomness(PathFindInput *pathFindInput);
void Path_TrimLastNodes(path_t *pPath, const int iNodeCount, bool bMaintainGoalPos);
int Path_ClipToGoal(path_t *pPath, const actor_goal_s *goal);
void Path_BeginTrim(path_t *pPath, path_trim_t *pTrim);
int Path_TrimToSeePoint(;
void Path_Begin(path_t *pPath);
void Path_Clear(path_t *pPath);
BOOL Path_Exists(const path_t *pPath);
int Path_CompleteLookahead(const path_t *pPath);
unsigned int Path_AttemptedCompleteLookahead(const path_t *pPath);
BOOL Path_UsesObstacleNegotiation(const path_t *pPath);
bool Path_HasNegotiationNode(const path_t *path);
unsigned int Path_AllowsObstacleNegotiation(const path_t *pPath);
void Path_GetObstacleNegotiationScript(const path_t *pPath, scr_animscript_t *animscript);
int Path_CurrentLinkDisconnected(const path_t *pPath);
bool Path_NeedsReevaluation(const path_t *pPath);
BOOL Path_GoingDown(const path_t *pPath);
int Path_DistanceGreaterThan(path_t *pPath, float fDist);
void Path_ReduceLookaheadAmount(path_t *pPath, float maxLookaheadAmountIfReduce);
BOOL Path_FailedLookahead(path_t *pPath);
void Path_IncreaseLookaheadAmount(path_t *pPath);
BOOL skip_avoidance_ents(int entnum);
BOOL Path_IsTrimmed(path_t *pPath);
void Path_RemoveCompletedPathPoints(path_t *pPath, int pathPointIndex);
void Path_TrimCompletedPath(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vStartPosa);
void Path_BackTrack(path_t *pPath, int newPathLength, float lookaheadIncreaseAmount);
void Path_BacktrackCompletedPath(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vStartPosa);
void PathCalcLookahead_CheckMinLookaheadNodes(path_t *pPath, const pathpoint_t *pt, int currentNode);
int Path_GetForwardStartPos(path_t *pPath, const vec2_t *vStartPos, vec2_t *vForwardStartPos);
void Path_DebugDraw(;
bool Path_WithinApproxDist(path_t *pPath, float checkDist);
ai_stance_e Path_AllowedStancesForPath(path_t *pPath);
void Path_CheckNodeCountForDodge(path_t *pPath, int numNeeded, pathpoint_t **pt, int *startIndex);
void Path_DodgeDrawRaisedLine(const vec3_t *start, const vec3_t *end, const vec4_t *color);
BOOL Path_MayFaceEnemy(path_t *pPath, vec3_t *vEnemyDir, vec3_t *vOrg);
double Path_GetStepHeightForRadius(const float radius);
void Path_TrimToBadPlaceLink(path_t *pPath, team_t eTeam);
// double __thiscall BotSearchInfo::GetNodeCost(BotSearchInfo *this, const pathnode_t *pSuccessor, const vec3_t *vGoalPos);
void Path_Restore(path_t *path);
int Path_FindPath(PathFindInput *pathFindInput);
;
int Path_PredictionTraceCheckForEntities(;
int Path_LookaheadPredictionTrace(path_t *pPath, const vec3_t *vStartPos, const vec3_t *vEndPos);
void Path_UpdateLookaheadAmount(;
void Path_CalcLookahead_Completed(;
void Path_CalcLookahead(;
void Path_UpdateLookahead(;
void Path_TransferLookahead(path_t *pPath, const vec3_t *vStartPos);
BOOL Path_GeneratePath(;
void Path_UpdateLookahead_NonCodeMove(path_t *pPath, const vec3_t *vPrevPos, const vec3_t *vStartPos);
char Path_AttemptDodge(;
pathnode_t *Path_FindCloseNode(team_t eTeam, pathnode_t *pNodeFrom, const vec3_t *vGoalPos);
int Path_FindPathWithWidth(PathFindInput *pathFindInput, float width, vec2_t *perp);
int Path_FindPathNotCrossPlanes(PathFindInput *pathFindInput, PathBlockPlanes *blockPlanes);
int Path_FindPathInCylinderWithLOS(;
pathnode_t *Path_FindFacingNode(pathnode_t *node, sentient_t *pOther, sentient_info_t *pInfo);
int Path_FindPathGetCloseAsPossible(PathFindInput *pathFindInput);
int Bot_FindPath(PathFindInput *pathFindInput);

//t6/code/src_noserver/game/actor_negotiation.cpp
bool Actor_Negotiation_Start(actor_t *pSelf, ai_state_t ePrevState);
int Actor_Negotiation_Think(actor_t *pSelf);

//t6/code/src_noserver/game/actor_orientation.cpp
void Actor_SetDesiredBodyAngle(ai_orient_t *pOrient, const float fAngle);
void Actor_SetDesiredAngles(ai_orient_t *pOrient, const float fPitch, const float fYaw);
void Actor_SetLookAngles(actor_t *self, const float fPitch, const float fYaw);
void Actor_SetBodyAngle(actor_t *self, const float fAngle);
void Actor_ChangeAngles(actor_t *self, const float fPitch, const float fYaw);
void Actor_UpdateLookAngles(actor_t *self);
void StepYaw(float dt, float *yaw, float *yawVeloc, float targetYaw, float targetVeloc);
void Actor_UpdateBodyAngle(actor_t *self);
bool Actor_CheckGunBlockedByWallWhileMoving(;
void Actor_FaceVectorSnapToMovementQuadrant(;
void Actor_FaceVector(ai_orient_t *pOrient, const vec3_t *v);
void Actor_FaceMotion(actor_t *self, ai_orient_t *pOrient);
void Actor_SetAnglesToLikelyEnemyPath(actor_t *self);
char Actor_GetAnglesToLikelyEnemyPath(actor_t *self);
void Actor_FaceLikelyEnemyPath(actor_t *self, ai_orient_t *pOrient);
void Actor_FaceEnemy(actor_t *self, ai_orient_t *pOrient);
bool Actor_ShouldFaceMotion(actor_t *self);
void Actor_FaceEnemyOrMotion(actor_t *self, ai_orient_t *pOrient);
void Actor_FaceEnemyOrMotionSidestep(actor_t *self, ai_orient_t *pOrient);
void Actor_DecideOrientation(actor_t *self);
void Actor_SetOrientMode(actor_t *self, ai_orient_mode_t eMode);
void Actor_ClearScriptOrient(actor_t *self);

//t6/code/src_noserver/game/actor_pain.cpp
bool Actor_InPain(const actor_t *self);
char Actor_Pain_Start(actor_t *self, ai_state_t ePrevState);
void Actor_Pain_Finish(actor_t *self, ai_state_t eNextState);
int Actor_Pain_Think(actor_t *self);

//t6/code/src_noserver/game/actor_physics.cpp
void TRACK_actor_physics();
void AIPhys_AddTouchEnt(actor_physics_t *pPhys, int entityNum);
void AIPhys_ClipVelocity(;
void setup_gjkcc_input(actor_physics_t *pPhys, gjkcc_input_t *gjkcc_in);
void AIPhys_Footsteps(actor_physics_t *pPhys);
void ai_physics_trace(;
// ;
;
;
void Actor_PostPhysics(actor_physics_t *pPhys);
;
void AdjustBigDog(actor_physics_t *pPhys);
;
int AIPhys_AirMove(actor_physics_t *pPhys);
int AIPhys_WalkMove(actor_physics_t *pPhys);
int Actor_Physics_1(actor_physics_t *pPhys);
int Actor_Physics(actor_physics_t *pPhys);
int Actor_Physics_z(actor_physics_t *pPhys);
void setup_gjkcc_input(pmove_t *pm, gjkcc_input_t *gjkcc_in);
void setup_gjkcc_input(;

//t6/code/src_noserver/game/actor_script_cmd.cpp
actor_t *Actor_Get(scr_entref_t entref);
void Actor_SetScriptGoalPos(actor_t *self, vec3_t *vGoalPos, pathnode_t *node, vec3_t *ang);
void Actor_StartArrivalState(actor_t *self, ai_state_t newState);
void ActorCmd_StartCoverArrival(scr_entref_t entref);
void ActorCmd_StartTraverseArrival(scr_entref_t entref);
void ActorCmd_Melee(scr_entref_t entref);
void ActorCmd_MeleeWithOffset(scr_entref_t entref);
void ActorCmd_ReacquireStep(scr_entref_t entref);
void ActorCmd_FindReacquireNode(scr_entref_t entref);
void ActorCmd_GetReacquireNode(scr_entref_t entref);
void ActorCmd_UseReacquireNode(scr_entref_t entref);
void ActorCmd_FindReacquireDirectPath(scr_entref_t entref);
void ActorCmd_FindReacquireProximatePath(scr_entref_t entref);
void ActorCmd_TrimPathToAttack(scr_entref_t entref);
void ActorCmd_ReacquireMove(scr_entref_t entref);
void ActorCmd_FlagEnemyUnattackable(scr_entref_t entref);
void ActorCmd_ClearPitchOrient(scr_entref_t entref);
void ActorCmd_SetPitchOrient(scr_entref_t entref);
void ActorCmd_SetLookAtAnimNodes(scr_entref_t entref);
void ActorCmd_SetLookAt(scr_entref_t entref);
void ActorCmd_SetLookAtYawLimits(scr_entref_t entref);
void ActorCmd_StopLookAt(scr_entref_t entref);
void ActorCmd_CanSee(scr_entref_t entref);
void ActorCmd_SeeRecently(scr_entref_t entref);
void ActorCmd_LastKnownTime(scr_entref_t entref);
void ActorCmd_LastKnownPos(scr_entref_t entref);
void ActorCmd_Teleport(scr_entref_t entref);
void ActorCmd_ForceTeleport(scr_entref_t entref);
void ActorCmd_WithinApproxPathDist(scr_entref_t entref);
void ActorCmd_IsPathDirect(scr_entref_t entref);
void ActorCmd_AllowedStances(scr_entref_t entref);
void ActorCmd_IsStanceAllowed(scr_entref_t entref);
void ActorCmd_Knockback(scr_entref_t entref);
void ActorCmd_TraverseMode(scr_entref_t entref);
void ActorCmd_AnimMode(scr_entref_t entref);
void ActorCmd_OrientMode(scr_entref_t entref);
void ActorCmd_GetOrientMode(scr_entref_t entref);
void ActorCmd_GetMotionAngle(scr_entref_t entref);
void ActorCmd_ShouldFaceMotion(scr_entref_t entref);
void ActorCmd_ClearMoveHistory(scr_entref_t entref);
void ActorCmd_GetMoveHistoryAverage(scr_entref_t entref);
void ActorCmd_GetAnglesToLikelyEnemyPath(scr_entref_t entref);
void ActorCmd_LerpPosition(scr_entref_t entref);
void ActorCmd_PredictOriginAndAngles(scr_entref_t entref);
void ActorCmd_PredictAnim(scr_entref_t entref);
void ActorCmd_GetHitEntType(scr_entref_t entref);
void ActorCmd_GetHitYaw(scr_entref_t entref);
void ActorCmd_GetGroundEntType(scr_entref_t entref);
void ActorCmd_IsDeflected(scr_entref_t entref);
void ScrCmd_animcustom(scr_entref_t entref);
void ScrCmd_CanAttackEnemyNode(scr_entref_t entref);
void ScrCmd_CanSeePathGoal(scr_entref_t entref);
void ScrCmd_GetPathLength(scr_entref_t entref);
void ScrCmd_CalcPathLength(scr_entref_t entref);
void ScrCmd_GetNegotiationStartNode(scr_entref_t entref);
void ScrCmd_GetNegotiationEndNode(scr_entref_t entref);
void ActorCmd_CheckProne(scr_entref_t entref);
void ActorCmd_PushPlayer(scr_entref_t entref);
void Actor_SetScriptGoalVolume(actor_t *self, gentity_t *volume);
void ActorCmd_SetGoalNode(scr_entref_t entref);
void Actor_SetScriptGoalEntity(actor_t *self, gentity_t *pGoalEnt);
void ActorCmd_SetGoalPos(scr_entref_t entref);
void ActorCmd_SetGoalEntity(scr_entref_t entref);
void ActorCmd_SetGoalVolume(scr_entref_t entref);
void ActorCmd_SetGoalVolumeAuto(scr_entref_t entref);
void ActorCmd_GetGoalVolume(scr_entref_t entref);
void ActorCmd_ClearGoalVolume(scr_entref_t entref);
void ActorCmd_SetFixedNodeSafeVolume(scr_entref_t entref);
void ActorCmd_GetFixedNodeSafeVolume(scr_entref_t entref);
void ActorCmd_ClearFixedNodeSafeVolume(scr_entref_t entref);
void ActorCmd_IsInGoal(scr_entref_t entref);
void ActorCmd_SetOverrideRunToPos(scr_entref_t entref);
void ActorCmd_ClearOverrideRunToPos(scr_entref_t entref);
void ActorCmd_NearNode(scr_entref_t entref);
void ActorCmd_NearClaimNode(scr_entref_t entref);
void ActorCmd_NearClaimNodeAndAngle(scr_entref_t entref);
void ActorCmd_AtDangerousNode(scr_entref_t entref);
void ActorCmd_GetEnemyInfo(scr_entref_t entref);
void ActorCmd_ClearEnemy(scr_entref_t entref);
void ActorCmd_SetEntityTarget(scr_entref_t entref);
void ActorCmd_ClearEntityTarget(scr_entref_t entref);
void ActorCmd_SetPotentialThreat(scr_entref_t entref);
void ActorCmd_ClearPotentialThreat(scr_entref_t entref);
void ActorCmd_GetPerfectInfo(scr_entref_t entref);
void ActorCmd_SetFlashBanged(scr_entref_t entref);
void ActorCmd_SetFlashbangImmunity(scr_entref_t entref);
void ActorCmd_GetFlashBangedStrength(scr_entref_t entref);
void ActorCmd_IsKnownEnemyInRadius(scr_entref_t entref);
void ActorCmd_IsKnownEnemyInVolume(scr_entref_t entref);
void ActorCmd_SetTalkToSpecies(scr_entref_t entref);
void ActorCmd_AllowPitchAngle(scr_entref_t entref);
void ActorCmd_GetDeltaTurnYaw(scr_entref_t entref);
void ActorCmd_SetAnimState(scr_entref_t entref);
void ActorCmd_StartScriptedAnim(scr_entref_t entref);
void ActorCmd_PopAIState(scr_entref_t entref);
void ActorCmd_SetAimAnimWeights(scr_entref_t entref);
void ActorCmd_CalcLookaheadPos(scr_entref_t entref);
void ActorCmd_IsInScriptedState(scr_entref_t entref);
void ActorCmd_SetAnimStateFromASD(scr_entref_t entref);
void ActorCmd_HasAnimStateFromASD(scr_entref_t entref);
void ActorCmd_GetAnimStateFromASD(scr_entref_t entref);
void ActorCmd_GetAnimSubStateFromASD(scr_entref_t entref);
void ActorCmd_GetAnimSubStateCountFromASD(scr_entref_t entref);
void ActorCmd_GetAnimFromASD(scr_entref_t entref);
void ActorCmd_GetAnimLengthFromASD(scr_entref_t entref);
void ActorCmd_GetAnimHasNotetrackFromASD(scr_entref_t entref);
void ActorCmd_SetFreeCameraLockOnAllowed(scr_entref_t entref);
void (*Actor_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
;
void ActorCmd_MayMoveToPoint(scr_entref_t entref);
void ActorCmd_MayMoveFromPointToPoint(scr_entref_t entref);
void ActorCmd_ClearEntityOwner(scr_entref_t entref);
void ActorCmd_SetEntityOwner(scr_entref_t entref);
void ActorCmd_finishActorDamage(scr_entref_t entref);

//t6/code/src_noserver/game/actor_senses.cpp
bool Actor_SightTrace(actor_t *self, const vec3_t *start, const vec3_t *end, int passEntNum);
bool Actor_CanSeePointFrom(;
void Actor_UpdateVisCache(actor_t *self, const gentity_t *ent, sentient_info_t *pInfo, bool bVisible);
bool Actor_ShouldDoFOVCheck(actor_t *self, sentient_t *sentient);
bool Actor_KnowAboutEnemy(actor_t *self);
int compare_sentient_sort(const void *pe1, const void *pe2);
void Actor_UpdateLastKnownPos(actor_t *self, sentient_t *other, const vec3_t *pos);
void Actor_UpdateLastEnemySightPos(actor_t *self);
void Actor_GetLastKnownEnemyPosWithDuration(;
void Actor_GetLastKnownEnemyPos(actor_t *self, const gentity_t *enemy, vec3_t *lastKnownPos);
void Actor_UpdateEyeInformation(actor_t *self);
void Actor_GetEyePosition(actor_t *self, vec3_t *vEyePosOut);
void Actor_GetDebugEyePosition(actor_t *self, vec3_t *vEyePosOut);
void Actor_GetEyeDirection(actor_t *self, vec3_t *vEyeDir);
void Actor_GetEyeOffset(actor_t *self, vec3_t *vEyePosOut);
BOOL Actor_PointInFov(actor_t *self, const vec3_t *vPoint);
int Actor_GetMuzzleInfo(actor_t *self, vec3_t *vOrigin, vec3_t *vForward);
bool Actor_CanSeePointExInternal(;
bool Actor_CanSeePointEx(;
char Actor_CanSeeEntityEx(actor_t *self, const gentity_t *ent, float fovDot, float fMaxDistSqrd);
;
bool Actor_CanShootEnemy(actor_t *self, const int cacheDuration);
char Actor_CanSeeEntity(actor_t *self, const gentity_t *ent);
char Actor_RecentlySeeSentient(actor_t *self, sentient_t *sentient, int latency);
char Actor_CanSeeSentient(actor_t *self, sentient_t *sentient, int iMaxLatency);
char Actor_CanSeeEnemy(actor_t *self);
char Actor_CanSeeEnemyExtended(actor_t *self);
void Actor_CheckSurprisedBySentient(actor_t *self, sentient_t *other);
void Actor_GetPerfectInfo(actor_t *self, sentient_t *other);
char Actor_RecentlySeeEnemy(actor_t *self);
void Actor_UpdateNearbyEnemyInfo(actor_t *self, sentient_sort_t *enemyList, int enemyCount);
void Actor_UpdateSight(actor_t *self);

//t6/code/src_noserver/game/actor_spawner.cpp
int SpotWouldTelefrag(gentity_t *spot);
int PointCouldSeeSpawn(const vec3_t *vEyePos, const vec3_t *vSpawnPos, int iIgnoreEnt1, int iIgnoreEnt2);
gentity_t *SpawnActor(;
void G_DropActorSpawnersToFloor();
int SP_actor_spawner(gentity_t *pEnt, SpawnVar *spawnVar);

//t6/code/src_noserver/game/actor_state.cpp
void Actor_SetDefaultState(actor_t *actor);
bool Actor_StartState(actor_t *self, ai_state_t eStartedState);
bool Actor_ResumeState(actor_t *self, ai_state_t ePrevState);
void Actor_ResumePopedState(actor_t *self, ai_state_t state);
void Actor_ThinkStateTransitions(actor_t *self);
void Actor_SetSubState(actor_t *self, ai_substate_t eSubState);
int Actor_IsStateOnStack(const actor_t *self, ai_state_t eState);
void Actor_SimplifyStateTransitions(actor_t *self);
int Actor_AllowedToPushState(actor_t *self, ai_state_t eState);
void Actor_SetState(actor_t *self, ai_state_t eState);
void Actor_PopState(actor_t *self);
void Actor_ForceState(actor_t *self, ai_state_t eState);
void Actor_PrepareToPushState(actor_t *self, ai_state_t eState);
int Actor_PushState(actor_t *self, ai_state_t eState);

//t6/code/src_noserver/game/actor_team_move.cpp
void Actor_TeamMoveBlocked(actor_t *self);
void Actor_TeamMoveBlockedClear(actor_t *self);
bool Actor_TeamMoveCheckWaitTimer(actor_t *self);
bool Actor_TeamMoveNeedToCheckWait(unsigned __int8 moveMode, path_t *pPath);
char Actor_TeamMoveCalcMovementDir(team_move_context_t *context, ai_teammove_t *result);
void Actor_AddToList(int *dodgeEntities, int *dodgeEntityCount, int arraysz, actor_t *pOtherActor);
void Actor_TeamMoveGetEntVelocity(gentity_t *other, vec2_t *velocity);
bool Actor_TeamMoveCheckDontDodgeSentient(actor_t *self, sentient_t *other);
// char Actor_TeamMoveShouldTryDodgeSentient@<al>(;
bool Actor_TeamMoveTryDodge(team_move_context_t *context, team_move_other_context_t *context_other);
bool Actor_TeamMoveConsiderSlowDown(team_move_context_t *context, ai_teammove_t *eResult);
ai_teammove_t Actor_TeamMoveNoDodge(team_move_context_t *context, ai_teammove_t eResult);
void Actor_TeamMoveInitializeContext(;
int Actor_TeamMoveTrimPath(path_t *pPath, const team_move_context_t *context);
void Actor_TeamMoveTooCloseMoveAway(const actor_t *self, int mask, team_move_context_t *context);
bool Actor_TeamMoveCheckPileup(actor_t *self, actor_t *pOtherActor);
BOOL Actor_WaitBeforeMoveStart(actor_t *self, team_move_context_t *context, vec2_t *velOther);
ai_teammove_t Actor_GetTeamMoveStatus(;
void Actor_MoveAlongPathWithTeam(;

//t6/code/src_noserver/game/actor_threat.cpp
void Actor_InitThreatBiasGroups();
int Actor_GetThreatBias(int groupSelf, int groupEnemy);
void Actor_FlagEnemyUnattackable(actor_t *self);
BOOL Actor_CaresAboutInfo(actor_t *self, sentient_t *pOther);
// int Actor_ThreatFromScariness@<eax>(float a1@<xmm0>);
int Actor_ThreatFromCover(actor_t *self, sentient_t *enemy, float distance);
int Actor_ThreatFromDistance(const float fDistance);
double Sentient_GetScarinessForDistance(sentient_t *self, sentient_t *enemy, float fDist);
bool Actor_CanBePathedTo(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
bool Actor_ShouldIgnoreFromAttackerCount(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
int Actor_IsFullyAware(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
int Actor_ThreatFromVisibilityAndAwareness(int friendlyTimingOut, int isFullyAwarea, int friendlyTimingOuta);
int Actor_ThreatFromAttackerCount(actor_t *self, sentient_t *enemy, int isCurrentEnemy);
int Actor_ThreatBonusForCurrentEnemy(;
int Actor_ThreatCoveringFire(actor_t *self, sentient_t *enemy);
int Actor_ThreatFlashed(sentient_t *enemy);
int Actor_UpdateSingleThreat(float enemyDist, sentient_t *enemya, float enemyDista);
void Actor_InitThreatUpdateInterval(actor_t *self);
void Actor_IncrementThreatTime(actor_t *self);
void Actor_InitPotentialTarget(;
void Actor_InitSecondaryTarget(;
bool Actor_IsSimilarTarget(;
int Actor_GetClosestDirectionSecondary(const actor_t *self, const PotentialTargetData *potential);
void Actor_UpdateSecondaryTargets(;
BOOL Actor_FullyAwareOfEnemy(actor_t *self);
// void Actor_SetPotentialThreat(potential_threat_t *self@<ecx>, float a2@<esi>, float yaw);
void Actor_ClearPotentialThreat(potential_threat_t *self);
void Actor_PotentialThreat_Debug(actor_t *self);
void Actor_EnterAlertState(actor_t *self);
void Actor_EnterCombatState(actor_t *self);
BOOL Actor_CheckIgnore(sentient_t *self, sentient_t *enemy);
void Actor_UpdateThreat(actor_t *self);

//t6/code/src_noserver/game/actor_zombie.cpp
;
;
int Actor_Zombie_Scripted_Think(actor_t *pSelf);
;
int Actor_Zombie_Custom_Think(actor_t *pSelf);

//t6/code/src_noserver/game/avoid.cpp
void Avoid_Init();
void Avoid_Init(int index, vec3_t origin, float radius, float timeHorizon, float maxSpeed, bool stubborn);
unsigned __int8 Avoid_Allocate(int entnum, vec3_t origin, float radius, float timeHorizon, float maxSpeed);
void Avoid_Free(int index);
int Avoid_GetNeighbors(Avoid *avoid, Avoid **neighbors, int team);
void Avoid_UpdateNoGoal(int index, vec3_t origin, vec3_t vel);
void Avoid_Disable(int index);
void Avoid_SetRadius(int index, const float radius);
void Avoid_SetPriority(int index, const int priority);
void Avoidance_DebugRender();
void CalcStaticORCAs(Avoid *curr, float invT, OrcaPlane *orcas, int *orcaCount);
// void AvoidUpdateOne(float a1@<edi>, Avoid *curr, Avoid **inRange, int inRangeCount);
void Avoid_UpdateGoal(;

//t6/code/src_noserver/game/bullet.cpp
void Bullet_RandomDir(unsigned int *randSeed, float *x, float *y);
void Bullet_Endpos(;
int Bullet_GetDamage(;
void Bullet_NofifyActor(;
void SetTempEventEntNormal(gentity_t *ent, const vec3_t *normal);
unsigned __int8 EncodeShieldHitPos(int entNum, const vec3_t *hitPos, const vec3_t *startPos);
bool Bullet_IgnoreHitEntity(const BulletFireParams *bp, const BulletTraceResults *br, gentity_t *attacker);
bool Bullet_Trace(;
void CalcRicochet(const vec3_t *incoming, const vec3_t *normal, vec3_t *result);
char BG_BulletCalcBounce(const vec3_t *incoming, const vec3_t *normal, vec3_t *result);
bool BG_WeaponBulletFire_ShouldBounce(const Weapon weapon);
bool BG_WeaponBulletFire_ShouldPenetrate(const Weapon weapon);
void Bullet_AddBBInfo(BulletTraceResults *br);
void Bullet_ReportBBInfo(int time);
void BroadcastShieldHitEvent(;
void BroadcastShieldHitEventToVictim(;
void Bullet_ImpactEffect(;
void BulletRicochet(;
bool Bullet_ProcessShieldHit(;
bool Bullet_Process(;
void Bullet_HitNothing(;
bool G_WeaponBounceShot(;
;
;
void Bullet_Fire(;

//t6/code/src_noserver/game/enthandle.cpp
void TRACK_enthandle();
void Cmd_EntHandle_PrintInfo_f();
// void EntHandle::Init();
// void EntHandle::Shutdown();
// void SentientHandle::Init();
void EntHandleDissociateInternal(EntHandleList *entHandleList);
void EntHandleDissociate(gentity_t *ent);
void SentientHandleDissociate(sentient_t *sentient);
void RemoveEntHandleInfo(EntHandleList *entHandleList, unsigned int oldInfoIndex);
unsigned int AddEntHandleInfo(EntHandleList *entHandleList, void *handle);
// void __thiscall EntHandle::setEnt(EntHandle *this, gentity_t *ent);
// void __thiscall SentientHandle::setSentient(SentientHandle *this, sentient_t *sentient);

//t6/code/src_noserver/game/gamerprofile.cpp
int GamerProfile_GetSettingByName(const char *settingName);
bool GamerProfile_LookupKey(;
void GamerProfile_Get_f();
bool GamerProfile_IsValidProfileVariable(const char *settingName);
// unsigned int GamerProfile_GetInt@<eax>(ControllerIndex_t a1@<edx>, profile_setting setting);
// BOOL GamerProfile_GetBool@<eax>(ControllerIndex_t a1@<edx>, profile_setting setting);
// double GamerProfile_GetFloat@<st0>(ControllerIndex_t a1@<edx>, profile_setting setting);
// const GfxViewParms *GamerProfile_GetString@<eax>(ControllerIndex_t a1@<edx>, profile_setting setting);
unsigned int GamerProfile_GetInt(const char *settingName);
double GamerProfile_GetFloat(const char *setting);
const GfxViewParms *GamerProfile_GetString(const char *settingName);
const GfxViewParms *GamerProfile_GetArrayString(;
unsigned int GamerProfile_GetArrayInt(const char *settingName, ControllerIndex_t controllerIndex, int index);
bool GamerProfile_GetGlobalProfileBool(profile_setting setting);
unsigned int GamerProfile_GetTeamIndicator(int a1, ControllerIndex_t a2);
char GamerProfile_GetColorBlindAssist(int a1, ControllerIndex_t a2);
void GamerProfile_UpdateButtonConfig(ControllerIndex_t controllerIndex, int gpadButtonsConfig);
void GamerProfile_UpdateStickConfig(ControllerIndex_t controllerIndex, int gpadSticksConfig);
void GamerProfile_ExecuteFloatCallback(;
bool GamerProfile_SetFloat_Internal(;
bool GamerProfile_SetString_Internal(;
void GamerProfile_SetString(;
// void GamerProfile_CopyProfileEntry(ControllerIndex_t a1@<edx>, profile_setting setting);
char *GamerProfile_GetVariableAsString(const char *settingName, ControllerIndex_t controllerIndex);
void TRACK_gamerprofile();
bool GamerProfile_IsProfileLoggedIn(ControllerIndex_t controllerIndex);
bool GamerProfile_IsProfileInitialized(ControllerIndex_t controllerIndex);
bool GamerProfile_WasErrorOnRead(ControllerIndex_t controllerIndex);
void DebugReportProfileVars(ControllerIndex_t controllerIndex, const char *headerMsg);
void GamerProfile_SetLocClassCmd();
void GamerProfile_SetClassVersion(const ControllerIndex_t controllerIndex);
void GamerProfile_SetupInitialClasses(const ControllerIndex_t controllerIndex);
// void GamerProfile_ExecControllerBindings(ControllerIndex_t a1@<edx>, ControllerIndex_t controllerIndex);
bool GamerProfile_AreBothBuffersInitialized(const ControllerIndex_t controllerIndex);
void GamerProfile_InitAllProfiles();
const CACRoot *GamerProfile_GetCACRoot(const CACRoot *result, const ControllerIndex_t controllerIndex);
const CACRoot *GamerProfile_GetCACRoot(const CACRoot *result, unsigned __int8 *buffer);
int GamerProfile_GetExeSettingsSize();
unsigned __int8 *GamerProfile_GetExeSettingsBuffer(const ControllerIndex_t controllerIndex);
void GamerProfile_ExecuteIntCallback(;
bool GamerProfile_SetInt_Internal(;
void GamerProfile_SetInt(;
void GamerProfile_SetBool(profile_setting setting, ControllerIndex_t controllerIndex, bool newValue);
bool GamerProfile_SetVariableFromString_Internal(;
// bool GamerProfile_SetVariableFromString@<al>(;
// bool GamerProfile_SetArrayVariableFromString@<al>(;
void GamerProfile_ResetCommonVarsToDefault(ControllerIndex_t controllerIndex);
void GamerProfile_ResetExeVarsToDefault(ControllerIndex_t controllerIndex);
void GamerProfile_SaveChanges(ControllerIndex_t controllerIndex);
void GamerProfile_SaveChangesCmd();
// void GamerProfile_RunCallbacks(int a1@<edi>, ControllerIndex_t controllerIndex);
void GamerProfile_ResetProfile(ControllerIndex_t controllerIndex);
// void GamerProfile_InitProfileWithoutSignin(int a1@<edi>, ControllerIndex_t controllerIndex);
void GamerProfile_Set_f();
void GamerProfile_Reset_f();
void GamerProfile_InitOnce();

//t6/code/src_noserver/game/gamerprofile_pc.cpp
bool GamerProfile_CheckForErrors(int error, ControllerIndex_t controllerIndex, char *ioMode);
DWORD GamerProfile_WriteExeProfile();
DWORD GamerProfile_WriteCommonProfile();
void GamerProfile_WriteSettings(ControllerIndex_t controllerIndex, GamerProfileBuffer *profileBuffer);

//t6/code/src_noserver/game/g_active.cpp
int GetFollowPlayerState(ClientNum_t clientNum, playerState_s *ps, bool allowLastActive);
int StuckInClient(gentity_t *self);
void G_PlayerEvent(int clientNum, int event);
void P_DamageFeedback(gentity_t *player);
void Player_WaterUpdate(gentity_t *ent);
void G_TouchEnts(gentity_t *ent, int numtouch, int *touchents);
void ClientImpacts(gentity_t *ent, pmove_t *pm);
void G_DoTouchTriggers(gentity_t *ent);
BOOL G_ClientCanSpectateTeam(gclient_t *client, team_t team);
int G_ClientCanSpectateAnyTeams(gclient_t *client, int teamsMask);
BOOL G_ClientCanSpectateDead(gclient_t *client);
void NotifyGrenadePullback(gentity_t *ent, Weapon weapon);
bool IsLiveGrenade(gentity_t *ent);
void AttemptLiveGrenadePickup(gentity_t *clientEnt);
void NotifyWeaponSwitchStarted(gentity_t *ent, const Weapon weapon);
void G_SetLastServerTime(ClientNum_t clientNum, int lastServerTime);
void G_SetClientContents(gentity_t *pEnt);
void SpectatorClientEndFrame(gentity_t *ent);
void ClientThink(ClientNum_t clientNum);
void G_PlayerController(const gentity_t *self, int *partBits);
gentity_t *G_GetPlayer(ClientNum_t clientNum);
int ClientInactivityTimer(gclient_t *client);
void ClientEvents(gentity_t *ent, int oldEventSequence);
void SpectatorThink(gentity_t *ent, usercmd_s *ucmd);
void ClientIntermissionThink(gentity_t *ent);

//t6/code/src_noserver/game/g_actor_prone.cpp
void G_InitActorProneInfo(actor_t *actor);

//t6/code/src_noserver/game/g_animscripted.cpp
void CalcDeltaOriginAndAngles(;
void G_AnimScripted_ClearAnimWeights(;
char G_ReduceOriginError(;
void G_ReduceAnglesError(vec3_t *angles, vec3_t *anglesError, const vec3_t *anglesErrorReduction);
;
void G_AnimScripted_UpdateEntityOriginAndAngles(gentity_t *ent, const vec3_t *origin, const vec3_t *angles);
void G_Animscripted_Think(gentity_t *ent);
;
void G_Animscripted(;

//t6/code/src_noserver/game/g_bsp_load_db.h
void Mark_GameWorldSpPtr();
void Mark_GameWorldMpPtr();
void Load_PathData(bool atStreamStart);
void Load_GameWorldSp(bool atStreamStart);
void Load_GameWorldMp(bool atStreamStart);
void Load_GameWorldSpPtr(bool atStreamStart);
void Load_GameWorldMpPtr(bool atStreamStart);

//t6/code/src_noserver/game/g_client_common.cpp
void InitClientDeltaAngles(gclient_t *client);
void SetClientViewAngle(gentity_t *ent, const vec3_t *angle);
void ClientCleanName(const char *in, char *out, int outSize);
void ClientUserinfoChanged(ClientNum_t clientNum);
void ClientBegin(ClientNum_t clientNum);
void ClientDisconnect(ClientNum_t clientNum);
unsigned int G_GetNonPVSPlayerInfo(gentity_t *pSelf, vec3_t *vPosition, int iLastUpdateEnt);
BOOL OnSameTeam(gentity_t *ent1, gentity_t *ent2);
void G_GetViewOriginMissingTag(const playerState_s *ps, vec3_t *origin, const char *type);
float G_Player3rdPersonVehicle_GetDampedSpringDistance(;
void G_GetPlayerVehicleViewOrigin_Internal(const playerState_s *ps, vec3_t *origin);
void G_Player3rdPersonVehicle_GetViewAngles(;
void G_Player3rdPersonVehicle_GetLookAtPosition(;
const char *ClientConnect(ClientNum_t clientNum, unsigned __int16 scriptPersId);
;
void G_GetPlayerVehicleViewOrigin(const playerState_s *ps, vec3_t *origin);
void ClientSpawn(gentity_t *ent, const vec3_t *spawn_origin, const vec3_t *spawn_angles);

//t6/code/src_noserver/game/g_client_fields.cpp
void ClientScr_ReadOnly(gclient_t *pSelf, const client_fields_s *pField);
void ClientScr_SetSessionTeam(gclient_t *pSelf);
void ClientScr_SetFFATeam(gclient_t *pSelf);
void ClientScr_GetFFATeam(gclient_t *pSelf);
void ClientScr_GetName(gclient_t *pSelf);
void ClientScr_GetGroundType(gclient_t *pSelf);
void ClientScr_GetSessionTeam(gclient_t *pSelf);
scoreboardColumnType_t CScr_GetColumnTypeByName(const char *typeName);
const char *CScr_GetColumnNameByType(scoreboardColumnType_t columnType);
void ClientScr_SetSessionState(gclient_t *pSelf);
void ClientScr_GetSessionState(gclient_t *pSelf);
void ClientScr_SetMaxHealth(gclient_t *pSelf);
void ClientScr_SetScore(gclient_t *pSelf);
void ClientScr_SetKills(gclient_t *pSelf);
void ClientScr_SetDeaths(gclient_t *pSelf);
void ClientScr_SetAssists(gclient_t *pSelf);
void ClientScr_SetDowns(gclient_t *pSelf);
void ClientScr_SetRevives(gclient_t *pSelf);
void ClientScr_SetDefends(gclient_t *pSelf);
void ClientScr_SetPlants(gclient_t *pSelf);
void ClientScr_SetDefuses(gclient_t *pSelf);
void ClientScr_SetReturns(gclient_t *pSelf);
void ClientScr_SetCaptures(gclient_t *pSelf);
void ClientScr_SetDestructions(gclient_t *pSelf);
void ClientScr_SetSurvived(gclient_t *pSelf);
void ClientScr_SetStabs(gclient_t *pSelf);
void ClientScr_SetTomahawks(gclient_t *pSelf);
void ClientScr_SetHumiliated(gclient_t *pSelf);
void ClientScr_SetX2Score(gclient_t *pSelf);
void ClientScr_SetHeadshots(gclient_t *pSelf);
void ClientScr_SetAGRKills(gclient_t *pSelf);
void ClientScr_SetHacks(gclient_t *pSelf);
void ClientScr_SetPointsToWin(gclient_t *pSelf);
void ClientScr_SetKillsConfirmed(gclient_t *pSelf);
void ClientScr_SetKillsDenied(gclient_t *pSelf);
void ClientScr_SetForceSpectatorClient(gclient_t *pSelf);
void ClientScr_GetSpectatorClient(gclient_t *pSelf);
void ClientScr_SetKillCamEntity(gclient_t *pSelf);
void ClientScr_SetKillCamTargetEntity(gclient_t *pSelf);
void ClientScr_SetStatusIcon(gclient_t *pSelf);
void ClientScr_GetStatusIcon(gclient_t *pSelf);
void ClientScr_SetHeadIcon(gclient_t *pSelf);
void ClientScr_GetHeadIcon(gclient_t *pSelf);
void ClientScr_GetHeadIconTeam(gclient_t *pSelf);
void ClientScr_SetArchiveTime(gclient_t *pSelf);
void ClientScr_GetArchiveTime(gclient_t *pSelf);
void ClientScr_SetPSOffsetTime(gclient_t *pSelf);
void ClientScr_GetEntityFromIndex(gclient_t *pSelf, const client_fields_s *pField);
void ClientScr_GetPSOffsetTime(gclient_t *pSelf);
void GScr_AddFieldsForClient();
void Scr_SetClientField(gclient_t *client, int offset);
void Scr_GetClientField(gclient_t *client, int offset);
void ClientScr_SetHeadIconTeam(gclient_t *pSelf);

//t6/code/src_noserver/game/g_cmds.cpp
int CheatsOkInternal(gentity_t *ent);
char *ConcatArgs(int start);
void G_setfog(ClientNum_t clientNum, const char *fogstring);
void Cmd_SetSoundLength_f();
void Cmd_Take_f(gentity_t *ent);
void Cmd_God_f(gentity_t *ent);
void Cmd_DemiGod_f(gentity_t *ent);
void Cmd_UFO_f(gentity_t *ent);
void Cmd_Kill_f(gentity_t *ent);
void Cmd_Notarget_f(gentity_t *ent);
void Cmd_Noclip_f(gentity_t *ent);
int CompareClient(const void *_a, const void *_b);
void UpdateTeamSortedClients();
ClientNum_t CycleClient(ClientNum_t current, int dir);
int Cmd_FollowCycle_f(gentity_t *ent, int dir);
void Cmd_Where_f(gentity_t *ent);
void Cmd_PrintClientFields_f();
void Cmd_CallVote_f(gentity_t *ent);
void Cmd_Vote_f(gentity_t *ent);
void Cmd_SetViewpos_f(gentity_t *ent);
void Cmd_EntityCount_f();
void Cmd_MenuResponse_f(gentity_t *pEnt);
void Cmd_VisionSetNaked_f();
void Cmd_VisionSetNight_f();
BOOL G_IsPlaying(gentity_t *ent);
void G_SpectatorsSendServerCommand(ClientNum_t clientNum, svscmd_type type, const char *text);
void G_SayTo(;
void G_Say(gentity_t *ent, gentity_t *target, int mode, const char *chatText);
void Cmd_Give_f(gentity_t *ent);
;
void ClientCommand(ClientNum_t clientNum);

//t6/code/src_noserver/game/g_debug.cpp
void G_DebugLine(;
void CG_DebugLine(;
// void CG_DebugStar(clientDebugLineInfo_t *a1@<edi>, const vec3_t *point, const vec4_t *color, int duration);
void G_DebugStarWithText(;
void G_DebugSphere(;
void CG_DebugCircle(;
void G_DebugArc(;
void DrawBrushPoly(int numPoints, vec3_t *points, const vec4_t *color);
void G_DebugDrawBrush_r(cLeafBrushNode_s *node, const vec4_t *color);
void G_DebugDrawBrushModel(gentity_t *entity, const vec4_t *color, int depthTest, int duration);
void G_DebugCircle(;

//t6/code/src_noserver/game/g_helicopter.cpp
void Helicopter_RegisterDvars();
void HELI_CmdScale(const char *move, vec4_t *outFracs);
void HELI_UpdateJitter(VehicleJitter *jitter);
void HELI_CalcAccel(gentity_t *ent, char *move, vec3_t *bodyAccel, vec3_t *rotAccel, vec3_t *viewangles);
void HELI_CancelAIMove(gentity_t *ent);
void HELI_SoftenCollisions(gentity_t *ent, vec3_t *worldAccel);
;
int VEH_HandleHeliLockHeight(gentity_t *ent);
double Vehicle_AdjustRollForInputDeadZone(float rollPercent);
void Vehicle_AddRotate(vehicle_physic_t *phys, float fRoll, float fPitch, float fYaw);
;
void VEH_UpdateClientChopper(gentity_t *ent);
void VEH_UpdateClientPlane(gentity_t *ent);

//t6/code/src_noserver/game/g_hudelem.cpp
int GetField(const void *i, int size);
void TRACK_g_hudelem();
void HudElem_SetDefaults(game_hudelem_s *hud);
void HudElem_DebugPrintScriptSource(int clientNum, const char *prefix);
game_hudelem_s *HudElem_Alloc(ClientNum_t clientNum, int teamNum);
void HudElem_Free(game_hudelem_s *hud);
void HudElem_ClientDisconnect(gentity_t *ent);
void HudElem_DestroyAll();
void HudElem_SetEnumString(;
void HudElem_GetEnumString(;
void HudElem_SetLocalizedString(game_hudelem_s *hud, int offset);
void HudElem_SetFlagForeground(game_hudelem_s *hud, int offset);
void HudElem_GetFlagForeground(game_hudelem_s *hud, int offset);
void HudElem_SetFontStyle3d(game_hudelem_s *hud, int offset);
void HudElem_GetFontStyle3d(game_hudelem_s *hud, int offset);
void HudElem_SetFont3dUseGlowColor(game_hudelem_s *hud, int offset);
void HudElem_GetFont3dUseGlowColor(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenDead(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenDead(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInKillCam(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInKillCam(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInDemo(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInDemo(game_hudelem_s *hud, int offset);
void HudElem_SetFlagImmuneToDemoGameHudSettings(game_hudelem_s *hud, int offset);
void HudElem_GetFlagImmuneToDemoGameHudSettings(game_hudelem_s *hud, int offset);
void HudElem_SetFlagImmuneToDemoFreeCamera(game_hudelem_s *hud, int offset);
void HudElem_GetFlagImmuneToDemoFreeCamera(game_hudelem_s *hud, int offset);
void HudElem_SetFlagShowPlayerTeamHudelemToSpectator(game_hudelem_s *hud, int offset);
void HudElem_GetFlagShowPlayerTeamHudelemToSpectator(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhileRemoteControlling(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhileRemoteControlling(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInMenu(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInMenu(game_hudelem_s *hud, int offset);
void HudElem_SetFlagHideWhenInScope(game_hudelem_s *hud, int offset);
void HudElem_GetFlagHideWhenInScope(game_hudelem_s *hud, int offset);
void HudElem_SetFlagFadeWhenTargeted(game_hudelem_s *hud, int offset);
void HudElem_GetFlagFadeWhenTargeted(game_hudelem_s *hud, int offset);
void HudElem_SetBoolean(game_hudelem_s *hud, int offset);
void HudElem_SetColor(game_hudelem_s *hud, int offset);
void HudElem_GetColor(game_hudelem_s *hud, int offset);
void HudElem_SetAlpha(game_hudelem_s *hud, int offset);
void HudElem_GetAlpha(game_hudelem_s *hud, int offset);
void HudElem_SetGlowColor(game_hudelem_s *hud, int offset);
void HudElem_GetGlowColor(game_hudelem_s *hud, int offset);
void HudElem_SetGlowAlpha(game_hudelem_s *hud, int offset);
void HudElem_GetGlowAlpha(game_hudelem_s *hud, int offset);
void HudElem_SetFontScale(game_hudelem_s *hud, int offset);
void HudElem_SetFont(game_hudelem_s *hud, int offset);
void HudElem_GetFont(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void HudElem_SetAlignX(game_hudelem_s *hud, int offset);
void HudElem_GetAlignX(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void HudElem_SetAlignY(game_hudelem_s *hud, int offset);
void HudElem_GetAlignY(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void HudElem_SetHorzAlign(game_hudelem_s *hud, int offset);
void HudElem_GetHorzAlign(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void HudElem_SetVertAlign(game_hudelem_s *hud, int offset);
void HudElem_GetVertAlign(game_hudelem_s *a1, const game_hudelem_field_t *a2);
void HudElem_SetUI3DWindow(game_hudelem_s *hud, int offset);
void HudElem_GetUI3DWindow(game_hudelem_s *hud, int offset);
void Scr_GetHudElemField(int entnum, int offset);
void Scr_SetHudElemField(int entnum, int offset);
void Scr_FreeHudElemConstStrings(game_hudelem_s *hud);
void GScr_NewHudElem();
void GScr_NewDebugHudElem();
void GScr_NewDamageIndicatorHudElem();
void GScr_NewClientHudElem();
void GScr_NewScoreHudElem();
void GScr_NewTeamHudElem();
void GScr_AddFieldsForHudElems();
game_hudelem_s *HECmd_GetHudElem(scr_entref_t entref);
void HECmd_ClearAllTextAfterHudElem(scr_entref_t entref);
void HECmd_ClearTargetEnt(scr_entref_t entref);
void HECmd_SetValue(scr_entref_t entref);
void HECmd_Reset(scr_entref_t entref);
void HECmd_Destroy(scr_entref_t entref);
void HECmd_SetPlayerNameString(scr_entref_t entref);
void HECmd_SetGameTypeString(scr_entref_t entref);
void HECmd_SetMapNameString(scr_entref_t entref);
void HECmd_GetTextWidth(scr_entref_t entref);
void (*HudElem_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
void HudElem_UpdateClient(gclient_t *client, ClientNum_t clientNum, hudelem_update_t which);
void HudElem_ClearClientSingle(hudelem_s *elems, int max);
void HudElem_ClearClient(gclient_t *client, hudelem_update_t which);
void HECmd_SetText(scr_entref_t entref);
void HECmd_SetMaterial(scr_entref_t entref);
void HECmd_SetTargetEnt(scr_entref_t entref);
void HECmd_SetTimer_Internal(scr_entref_t entref, he_type_t type);
void HECmd_SetClock_Internal(scr_entref_t entref, he_type_t type);
void HECmd_SetTimer(scr_entref_t entref);
void HECmd_SetTimerUp(scr_entref_t entref);
void HECmd_SetTenthsTimer(scr_entref_t entref);
void HECmd_SetTenthsTimerUp(scr_entref_t entref);
void HECmd_SetClock(scr_entref_t entref);
void HECmd_SetClockUp(scr_entref_t entref);
void HECmd_SetWaypoint(scr_entref_t entref);
void HECmd_SetPerks(scr_entref_t entref);
void HECmd_FadeOverTime(scr_entref_t entref);
void HECmd_ChangeFontScaleOverTime(scr_entref_t entref);
void HECmd_ScaleOverTime(scr_entref_t entref);
void HECmd_MoveOverTime(scr_entref_t entref);
void HECmd_SetPulseFX(scr_entref_t entref);
void HECmd_SetCOD7DecodeFX(scr_entref_t entref);
void HECmd_SetRedactFX(scr_entref_t entref);
void HECmd_SetTypewriterFX(scr_entref_t entref);

//t6/code/src_noserver/game/g_items.cpp
void Fill_Clip(playerState_s *ps, Weapon weapon);
Weapon CurrentPrimaryWeapon(playerState_s *ps);
int G_ItemClipMask(gentity_t *ent);
void PrintPlayerPickupMessage(gentity_t *player, Weapon weapon);
Weapon WeaponPickup_GetCompatibleWeapon(gentity_t *player, Weapon weapon);
void WeaponPickup_Notifies(;
void PrintMessage_CannotGrabItem(gentity_t *ent, gentity_t *player, int touched, Weapon weapon);
int GetFreeDropCueIdx();
void DroppedItemClearOwner(gentity_t *pSelf);
void G_GetItemClassname(const Weapon item, unsigned __int16 *out);
bool PlayerHasAnyAmmoToTransferToWeapon(gentity_t *player, Weapon transferWeapon);
int TransferPlayerAmmoToWeaponEntity(gentity_t *player, gentity_t *weaponEnt, Weapon transferWeapon);
int TransferRandomAmmoToWeaponEntity(gentity_t *weaponEnt, Weapon transferWeapon);
int TransferSpecifiedAmmoToWeaponEntity(gentity_t *weaponEnt, Weapon transferWeapon);
;
void ClearRegisteredItems();
void DumpWeaponConfigStrings();
void SaveRegisteredWeapons();
void SaveRegisteredItems();
void RegisterWeaponRumbles(const WeaponDef *weapDef);
void G_RegisterWeapon(unsigned int weapIndex);
int IsItemRegistered(int iItemIndex);
void G_SpawnItem(gentity_t *ent, const Weapon item);
void G_OrientItemToGround(gentity_t *ent, trace_t *trace);
;
int Add_Ammo(gentity_t *ent, Weapon weapon, int count, int fillClip);
bool WeaponPickup_LeechFromWeaponEnt(;
void WeaponPickup_AddAmmoForNewWeapon(gentity_t *weaponEnt, gentity_t *player);
int WeaponPickup_Touch(gentity_t *weaponEnt, gentity_t *player, Weapon weapon, int *pickupEvent);
gentity_t *LaunchItem(const Weapon item, vec3_t *origin, vec3_t *angles, vec3_t *velocity, int ownerNum);
gentity_t *Drop_Item(gentity_t *ent, const Weapon item, float angle, int novelocity);
gentity_t *ThrowClientWeapon(gentity_t *ent, const Weapon item, float heightIncrease, float velocityIncrease);
;
gentity_t *Drop_Weapon(gentity_t *ent, Weapon weapon, unsigned __int8 weaponModel, unsigned int tag);
;
int WeaponPickup_Grab(gentity_t *weaponEnt, gentity_t *player, Weapon weapon, int *pickupEvent);
int WeaponPickup(gentity_t *weaponEnt, gentity_t *player, int *pickupEvent, int touched);
void Touch_Item(gentity_t *ent, gentity_t *other, int touched);
void Touch_Item_Auto(gentity_t *ent, gentity_t *other, int bTouched);

//t6/code/src_noserver/game/g_load_utils.cpp
void G_SetEntityParsePoint(const char *beginParsePoint);
void G_ResetEntityParsePoint();
const char *G_GetEntityParsePoint();
int G_EntityParseToken(char *buffer, int bufferSize);
int G_GetEntityToken(char *buffer, int bufferSize);
int G_ParseSpawnVars(SpawnVar *spawnVar);
int G_SpawnString(const SpawnVar *spawnVar, const char *key, const char *defaultString, const char **out);
unsigned int G_NewString(const char *string);
char *vtos(const vec3_t *v);

//t6/code/src_noserver/game/g_main_common.cpp
void TRACK_g_main();
int G_GetSavePersist();
void G_SetSavePersist(int savepersist);
int G_GetClientScore(ClientNum_t clientNum);
int G_GetClientDeaths(ClientNum_t clientNum);
int G_GetClientArchiveTime(ClientNum_t clientNum);
void G_SetClientArchiveTime(ClientNum_t clientNum, int time);
clientState_s *G_GetClientState(ClientNum_t clientNum);
gclient_t *G_GetPlayerState(ClientNum_t clientNum);
void *Hunk_AllocActorXAnimServer(int size);
actorState_s *G_GetActorState(int actorNum);
int G_GetClientSize();
int G_GetActorSize();
void G_CreateDObj(;
DObj *G_GetDObj(int handle, LocalClientNum_t unusedLocalClientNum);
void G_SafeDObjFree(int handle, LocalClientNum_t unusedLocalClientNum);
void *Hunk_AllocXAnimServer(int size);
int G_IsServerGameSystem(ClientNum_t clientNum);
unsigned __int16 G_AttachWeapon(;
int SortRanks(const void *a, const void *b);
bool G_ExitAfterConnectPaths();
bool G_ExitOnComError(int code);
void CalculateRanks();
BOOL G_IsEntWalkable(LocalClientNum_t localClientNum, int entityNum);
bool G_GetEntityOriginAngles(LocalClientNum_t localClientNum, int entityNum, vec3_t *origin, vec3_t *angles);
char G_GetVelocity(LocalClientNum_t localClientNum, int entIndex, vec3_t *outVelocity);
void G_EntityLinkFromPMove(int entityNum, int parentEntityNum, const int tagName);
void G_LogPrintf(const char *fmt, ...);
void ExitLevel();
void G_SafeDObjFree(gentity_t *ent);

//t6/code/src_noserver/game/g_mem_track.cpp
void G_track_init();

//t6/code/src_noserver/game/g_missile.cpp
void G_RegisterMissileDvars();
BOOL IsZombiesValuableItem(const WeaponDef *weapDef);
BOOL G_IsClientControlledMissile(const playerState_s *ps);
int IsMissileClientControlled(const gentity_t *missile);
int G_ClearMissileClientControlled(const gentity_t *missile);
void MissileLandAngles(gentity_t *ent, trace_t *trace, vec3_t *vAngles, int bForceAlign, int bKeepSpeed);
;
;
int CheckCrumpleMissile(gentity_t *ent, trace_t *trace);
void CheckGrenadeDanger(gentity_t *grenadeEnt);
BOOL skip_horses(int entnum);
void G_MissileTrace(;
char GrenadeBounceVelocity(;
bool GrenadeDud(gentity_t *ent, const WeaponDef *weapDef);
bool JavelinProjectile(gentity_t *ent, const WeaponDef *weapDef);
bool JavelinDud(gentity_t *ent, const WeaponDef *weapDef);
int GetSplashMethodOfDeath(gentity_t *ent);
bool isDud(gentity_t *ent, const WeaponDef *weapDef);
void G_UnlinkPlayerToRocket(gentity_t *ent);
void AttachMissileToEntity(gentity_t *missile, int entnum, int boneName, int hitLocation, vec3_t *velocity);
int StickMissile(;
bool isBounceProjectile(gentity_t *ent);
void createRetrieveableProjectile(;
bool GrenadeCanApplyImpactDamage(gentity_t *missile, gentity_t *hitEnt, const WeaponDef *weapDef);
void G_TimedObjectThink(gentity_t *ent);
int GetSurfaceType(gentity_t *ent, bool inWater);
void Missile_PenetrateGlass(;
void DrawMissileDebug(vec3_t *start, vec3_t *end);
void TRACK_missile_attractors();
void Missile_InitAttractors();
void Missile_FreeAttractorRefs(gentity_t *ent);
int Missile_GetFreeAttractor();
void Scr_MissileCreateAttractorEnt();
void Scr_MissileCreateAttractorOrigin();
void Scr_MissileCreateRepulsorEnt();
void Scr_MissileCreateRepulsorOrigin();
void Scr_MissileDeleteAttractor();
void Missile_ApplyAttractorsRepulsors(gentity_t *missile);
void RunMissile_Destabilize(gentity_t *missile);
void RunMissile_BroadcastActorEvents(gentity_t *missile);
bool IsMissileLockedOn(gentity_t *ent);
void GetTargetPosition(gentity_t *ent, vec3_t *result);
void MissileVerticalSteerToTarget(;
void MissileVerticalSteering(;
bool MissileIsReadyForSteering(gentity_t *ent);
bool DroneClimbExceededAngle(gentity_t *ent, const vec3_t *targetPos);
bool DroneClimbExceededDistance(gentity_t *ent, const vec3_t *targetPos);
void DroneClimbOffset(gentity_t *ent, vec3_t *targetPos);
float DroneMaxDPS(gentity_t *ent, bool impactAvoidance);
float DroneRotateDir(;
;
float DroneClimbCeiling(gentity_t *ent);
bool DroneClimbIsAboveCeiling(gentity_t *ent, const vec3_t *targetPos);
void DroneSteering(gentity_t *ent, const WeaponDef *weapDef);
bool JavelinClimbExceededAngle(gentity_t *ent, const vec3_t *targetPos);
bool JavelinClimbWithinDistance(gentity_t *ent, const vec3_t *targetPos);
void JavelinClimbOffset(gentity_t *ent, vec3_t *targetPos);
float JavelinMaxDPS(gentity_t *ent);
float JavelinRotateDir(gentity_t *ent, const vec3_t *currentDir, const vec3_t *targetDir, vec3_t *resultDir);
void JavelinRotateVelocity(;
float JavelinClimbCeiling(gentity_t *ent);
bool JavelinClimbIsAboveCeiling(gentity_t *ent, const vec3_t *targetPos);
void JavelinSteering(gentity_t *ent, const WeaponDef *weapDef);
void HeatSeekingSteering(gentity_t *ent, const WeaponDef *weapDef);
void G_MakeMissilePickupItem(gentity_t *ent);
void PredictBounceMissile(;
;
void G_InitGrenadeEntity(gentity_t *parent, gentity_t *grenade);
void G_InitGrenadeMovement(;
void InitGrenadeTimer(const gentity_t *parent, gentity_t *grenade, const WeaponDef *weapDef, int time);
gentity_t *G_FireGrenade(;
int G_SetMissileClientControlled(const gentity_t *missile);
;
void G_LinkPlayerToRocket(gentity_t *ent, gentity_t *player);
void AttachBoltGrenade(gentity_t *ent, gentity_t *hitEnt, trace_t *trace, hitLocation_t hitLocation);
void MissileImpact(gentity_t *ent, trace_t *trace, vec3_t *dir, vec3_t *endpos);
;
void RunMissile_CreateWaterSplash(const gentity_t *missile, const vec3_t *hitPos, const trace_t *trace);
void MissileHorzSteerToTarget(;
void MissileTrajectoryClientControlled(gentity_t *ent, vec3_t *result, gentity_t *owner);
void TVMissileTrajectoryClientControlled(gentity_t *ent, vec3_t *result);
;
void MissileTrajectory(gentity_t *ent, vec3_t *result);
bool CheckForMissileClientControlledDetonation(gentity_t *ent);
bool UpdateGuidedMissileFuelTime(gentity_t *ent, bool initTimer);
;
void G_RunMissile(gentity_t *ent);
void InitRocketTimer(gentity_t *bolt, const WeaponDef *weapDef);
gentity_t *G_FireRocket(;
gentity_t *G_DropBomb(;

//t6/code/src_noserver/game/g_mover.cpp
void TRACK_g_mover();
void G_PushEntity(;
char IsEntityLinkedToMe(gentity_t *self, gentity_t *other);
int GetRopeIndex(unsigned int targetname);
void DeleteConstraint(int rope_index);
void G_UpdatePhysicsPose(gentity_t *ent);
void G_MoverSlide(gentity_t *ent);
void trigger_use_shared(gentity_t *self, SpawnVar *spawnVar);
void trigger_use_touch(gentity_t *a1, SpawnVar *a2);
void G_MoverPush(gentity_t *pusher, const mover_info_t *mi);
void G_CreatePhysicsObject(gentity_t *ent);
void G_CalcEntityPhysicsPositions(gentity_t *ent);
// void G_MoverTeam(const mover_info_t *a1@<edx>, gentity_t *ent, const mover_info_t *mi);
void G_MoverTeam_New(gentity_t *ent);
void G_RunMover(gentity_t *ent);

//t6/code/src_noserver/game/g_player_corpse.cpp
int G_GetPlayerCorpseIndex(gentity_t *ent, const char *error_msg);
int G_GetFreePlayerCorpseIndex();
void PlayerCorpse_Free(gentity_t *ent);
bool G_GetAnimDeltaForCorpse(gentity_t *ent, vec3_t *originChange);
void G_RunCorpseAnimate(gentity_t *ent);
void G_BounceCorpse(gentity_t *ent, corpseInfo_t *corpseInfo, trace_t *trace, vec3_t *endpos);
;
void G_RunCorpse(gentity_t *ent);

//t6/code/src_noserver/game/g_scr_main.cpp
void Scr_NetworkOriginError(const char *entityName, const vec3_t *origin);
void GScr_Throw();
void GScr_CreatePrintChannel();
void GScr_getEnterButton();
void GScr_printChannelSet();
void Scr_MakeGameMessage(int iClientNum, const char *pszCmd);
void iprintln();
void iprintlnbold();
void GScr_print3d();
void GScr_line();
void GScr_box();
// void GScr_debugstar(clientDebugLineInfo_t *a1@<edi>);
void GScr_circle();
void GScr_sphere();
void Scr_GetReflectionLocs();
void Scr_GetReflectionOrigin();
void GScr_AddDebugCommand();
void GScr_BBPostDemoStreamStatsForRound();
void GScr_GetWeaponFuseTime();
void GScr_GetWeaponProjExplosionSound();
void GScr_DoesWeaponReplaceSpawnWeapon();
void GScr_IsFloat();
void GScr_IsInt();
void GScr_IsVec();
void GScr_IsString();
void Scr_isPC();
void GScr_IsArray();
void GScr_IsAlive();
void GScr_IsSpawner();
void GScr_TableLookupFindCoreAsset();
void GScr_TableLookupRowNum();
void GScr_TableLookupColumnForRow();
void GScr_TableLookup();
void GScr_TableLookupIString();
void GScr_IsPlayer();
void GScr_IsSentient();
void GScr_IsGodMode();
void GScr_GetGametypeSetting();
bool GScr_SetGametypeSetting();
void CleanDvarValue(const char *dvarValue, char *outString, int size);
void GScr_SetDvar();
void GScr_SetDvarInt();
void GScr_MakeDvarServerInfo();
void GScr_SendAIScriptKeys();
void GScr_GetTime();
void Scr_isWiiU();
void Scr_RandomInt();
void Scr_RandomFloat();
void Scr_RandomIntRange();
void Scr_RandomFloatRange();
void GScr_log();
void GScr_sin();
void GScr_cos();
void GScr_tan();
void GScr_asin();
void GScr_acos();
void GScr_atan();
void GScr_CastInt();
void GScr_CastFloat();
void GScr_CastIString();
void GScr_min();
void GScr_max();
void GScr_floor();
void GScr_ceil();
void GScr_sqrt();
void GScr_pow();
void GScr_LerpFloat();
void GScr_LerpVector();
void GScr_DiffTrack();
void GScr_DiffTrackAngle();
void GScr_GetMinBitCountForNum();
void GScr_VectorFromLineToPoint();
void GScr_PointOnSegmentNearestToPoint();
void GScr_GetArrayKeys();
void GScr_GetFirstArrayKey();
void GScr_GetNextArrayKey();
void GScr_GetLastArrayKey();
void GScr_GetPrevArrayKey();
int GScr_MoveToStatPath(ddlState_t *resultState, int numParams, ddlState_t *searchState);
statAddValue_t *GScr_AddStatFromState(;
statValue_t GetStatValueFromParams(int numParam);
gunLevelRow_t *CheckWeaponChallengeForStatValue(int weaponStatIndex, statAddValue_t statValue);
bool CheckPrerequisiteChallengeComplete(;
challengeTableRow_t *CheckChallengeForStatValue(;
bool IsChallengeCompleted(;
bool GScr_IsItemPurchasedForClientNum(ClientNum_t clientNum, int itemIndex);
void SetStatAddValueToChallengeMax(statAddValue_t *statAddValue, int maxValue);
void GScr_CallGunChallengeCallback(;
float GetStatFromState(ClientNum_t clientNum, ddlState_t *searchState);
float GetPlayerStatValue(ClientNum_t clientNum, const char *statName);
float GetGameTypeStatValue(ClientNum_t clientNum, const char *statName);
void SetStatFromState(ClientNum_t clientNum, ddlState_t *searchState, float value);
void SetPlayerStatValue(ClientNum_t clientNum, const char *statName, float value);
void SetGameTypeStatValue(ClientNum_t clientNum, const char *statName, float value);
int GScr_GetWeaponStatIndex(int argNum, int *attachmentBits, int *weaponIdx);
// const char *RegisterNewScore@<eax>(;
const char *GScr_RegisterXP();
void Scr_ClearScoreInfo();
void Scr_LoadScoreInfo(MemoryFile *memFile);
scoreInfo_t *FindScoreInfo(int nameHash);
int GScr_GetXPScaled(const ClientNum_t clientNum, statValue_t addValue);
int GScr_GetGunXPScaled(const ClientNum_t clientNum, statValue_t addValue);
;
void GScr_AddGameTypeStatMoreInternal(;
;
;
;
;
int GScr_AddWeaponStatMoreInternal(;
int GScr_AddSpecialWeaponStatInternal(;
;
void GScr_AddBonusCardStatInternal(;
int GScr_AddWeaponStatInternal(;
void GScr_UploadStats();
char Scr_Distance();
char Scr_Distance2D();
void Scr_Distance2DSquared();
void Scr_DistanceSquared();
void Scr_Length();
void Scr_LengthSquared();
void Scr_Closer();
char Scr_VectorDot();
char Scr_VectorCross();
char Scr_VectorNormalize();
void Scr_VectorLerp();
void Scr_CombineAngles();
void Scr_AbsAngleClamp180();
void Scr_AbsAngleClamp360();
void Scr_AngleLerp();
void Scr_RotatePoint();
void Scr_IsSubStr();
void Scr_GetSubStr();
void Scr_ToLower();
void Scr_ToUpper();
void Scr_StrTok();
void Scr_SoundFade();
gentity_t *Scr_PlaySoundAtPosition();
void GScr_GetLocalProfileInt();
void GScr_GetLocalProfileFloat();
void GScr_GetLocalProfileArrayInt();
void GScr_GetLocalProfileString();
void GScr_SetLocalProfileVar();
void GScr_SetLocalProfileArrayVar();
void GScr_OpenFile();
void GScr_CloseFile();
void Scr_FPrint_internal(bool commaBetweenFields);
void GScr_FPrintln();
void GScr_FPrintFields();
void __thiscall GScr_FReadLn(const char *this);
void GScr_FGetArg();
void GScr_ExecDevgui();
void Scr_CreateNewArray();
void Scr_ArrayRemoveValue();
void Scr_ArrayRemoveIndex();
void Scr_ArrayInsert();
void Scr_ArrayCombine();
void Scr_ArrayCopy();
void Scr_IsInArray();
int Scr_SortAscending(const void *v1, const void *v2);
int Scr_SortDescending(const void *v1, const void *v2);
void Scr_ArraySort();
void Scr_SessionModeIsOnlineGame();
void Scr_SessionModeIsPrivateOnlineGame();
void Scr_SessionModeIsPrivate();
void Scr_SessionModeIsSystemlink();
void Scr_SessionModeIsZombiesGame();
void Scr_GameModeIsMode();
void Scr_GameModeIsUsingXP();
void Scr_GameModeIsUsingStats();
int Scr_GetTeamFlags(unsigned int i);
AISpecies Scr_GetSpecies(unsigned __int16 speciesString);
void Scr_GetFreeActorCount();
actor_t *Scr_GetAIArray();
actor_t *Scr_GetAISpeciesArray();
void Scr_GetSpawnerArray();
void Scr_GetScriptMoverArray();
void Scr_GetZBarrierArray();
void Scr_GetItemArray();
void Scr_GetCorpseArray();
void Scr_GetSpawnerTeamArray();
void Scr_GetVehicleSpawnerArray();
void Scr_GetVehicleArray();
void GScr_LUINotifyEvent_Internal(const ClientNum_t clientNum, bool sendToSpectators);
void GScr_LUINotifyEvent();
void Scr_ActivateClientExploder();
void Scr_DeactivateClientExploder();
void GScr_GetMissileOwner();
void GScr_GetStartOrigin();
void GScr_GetStartAngles();
void GScr_DisableGrenadeSuicide();
void GScr_EnableGrenadeSuicide();
unsigned int GScr_PrecacheLeaderboards();
void GScr_GetClassIndexFromName();
void GScr_DeployRiotshield();
void Scr_GetNumExpectedPlayers();
void Scr_GetNumConnectedPlayers();
void (*Scr_GetCommonFunction(const char **pName, int *type, int *min_args, int *max_args))();
gentity_t *GetEntity(scr_entref_t entref);
gentity_t *GetPlayerEntity(scr_entref_t entref);
void G_EntityStateSetPartBits(gentity_t *ent, const unsigned int *partBits);
void G_EntityStateGetPartBits(const gentity_t *ent, unsigned int *partBits);
void ScrCmd_RunScriptOnEnt(scr_entref_t entref);
void ScrCmd_hidepart(scr_entref_t entref);
void ScrCmd_showpart(scr_entref_t entref);
void ScrCmd_showallparts(scr_entref_t entref);
void ScrCmd_SendAIScriptVals(scr_entref_t entref);
gentity_t *GScr_SetupLightEntity(scr_entref_t entref);
void GScr_GetLightColor(scr_entref_t entref);
void GScr_SetLightColor(scr_entref_t entref);
void GScr_GetLightIntensity(scr_entref_t entref);
void GScr_SetLightIntensity(scr_entref_t entref);
void GScr_GetLightRadius(scr_entref_t entref);
void GScr_SetLightRadius(scr_entref_t entref);
void GScr_GetLightFovInner(scr_entref_t entref);
void GScr_GetLightFovOuter(scr_entref_t entref);
void GScr_SetLightFovRange(scr_entref_t entref);
void GScr_GetLightExponent(scr_entref_t entref);
void GScr_SetLightExponent(scr_entref_t entref);
void ScrCmd_PlaySoundToPlayer(scr_entref_t entref);
void GScr_SetSpawnerTeam(scr_entref_t entref);
void GScr_Launch(scr_entref_t entref);
void GScr_SetMovingPlatformEnabled(scr_entref_t entref);
void GScr_IsMovingPlatform(scr_entref_t entref);
void GScr_SetViewModelRenderFlag(scr_entref_t entref);
void GScr_SetDrawInfrared(scr_entref_t entref);
void ScrCmd_Unlink(scr_entref_t entref);
void ScrLinkTo_Internal(scr_entref_t entref, bool blendToTag);
void ScrCmd_LinkTo(scr_entref_t entref);
void ScrCmd_LinkToBlendToTag(scr_entref_t entref);
void ScrCmd_EnableLinkTo(scr_entref_t entref);
void ScrCmd_LinkToUpdateOffset(scr_entref_t entref);
void ClientmaskSetFlagVisible(int *mask, int clientNum);
void PlayerLinkTo_Internal(scr_entref_t entref, PlayerLinkToType linkType);
void ScrCmd_PlayerLinkTo(scr_entref_t entref);
void ScrCmd_PlayerLinkToDelta(scr_entref_t entref);
void ScrCmd_PlayerLinkWeaponViewToDelta(scr_entref_t entref);
void CheckTimes(float *totalTime, float accelTime, float decelTime);
void ScrCmd_PlayerLinkToBlend(scr_entref_t entref);
void ScrCmd_PlayerLinkToAbsolute(scr_entref_t entref);
void ScrCmd_PlayerCamLinkTo(scr_entref_t entref);
void ScrCmd_PlayerCamUnlink(scr_entref_t entref);
void ScrCmd_LerpViewAngleClamp(scr_entref_t entref);
char AttachCmd(gentity_t *ent, unsigned int *tagNameResult);
void ScrCmd_attachShieldModel(scr_entref_t entref);
void ScrCmd_RefreshShieldAttachment(scr_entref_t entref);
void DetachCmd(gentity_t *ent);
void ScrCmd_detachShieldModel(scr_entref_t entref);
void ScrCmd_PlayerLinkedOffsetEnable(scr_entref_t entref);
void ScrCmd_PlayerLinkedOffsetDisable(scr_entref_t entref);
void ScrCmd_PlayerLinkedSetUseBaseAngleForViewClamp(scr_entref_t entref);
void ScrCmd_DontInterpolate(scr_entref_t entref);
void ScrCmd_MagicGrenadeType(scr_entref_t entref);
void GScr_StartFadingBlur(scr_entref_t entref);
void GScr_WorldToLocalCoords(scr_entref_t entref);
void GScr_SetTurretSpinning(scr_entref_t entref);
void GScr_SetScriptMoverFlag(scr_entref_t entref);
void ScrCmd_SetVisionSetForPlayer(scr_entref_t entref);
void ScrCmd_UseServerVisionset(scr_entref_t entref);
void ScrCmd_SetInfraredVision(scr_entref_t entref);
void GScr_SetCharacterIndex(scr_entref_t entref);
void GScr_UsePlayerFootstepTable(scr_entref_t entref);
void ScrCmd_attach(scr_entref_t entref);
void ScrCmd_detach(scr_entref_t entref);
void ScrCmd_detachAll(scr_entref_t entref);
void ScrCmd_GetAttachSize(scr_entref_t entref);
void ScrCmd_GetAttachModelName(scr_entref_t entref);
void ScrCmd_GetAttachTagName(scr_entref_t entref);
void ScrCmd_GetAttachIgnoreCollision(scr_entref_t entref);
void ScrCmd_ResetFov(scr_entref_t entref);
void (*BuiltIn_GetCommonMethod(;
int Scr_GetArrayValues_Vector(;
void GScr_linelist();
void GScr_AreAllMissionsAtScore(scr_entref_t entref);
void GScr_GetNumChallengesComplete(scr_entref_t entref);
void GScr_HasCompletedAllGameChallenges(scr_entref_t entref);
void GScr_GetDStat(scr_entref_t entref);
void GScr_GetDStatArrayCount(scr_entref_t entref);
void GScr_SetDStat(scr_entref_t entref);
char IsItemLockedForChallenge(scr_entref_t entref, int itemIndex, bool purchaseRequired);
int GScr_AddChallengeStat(gentity_t *playerEnt, int itemIndex, challengeTableRow_t *challengeRow);
// int GScr_CallChallengeCallback@<eax>(;
void GScr_UpdateStatRatio(scr_entref_t entref);
void GScr_GameHistoryStartMatch(scr_entref_t entref);
void GScr_GameHistoryFinishMatch(scr_entref_t entref);
void GScr_CheckWeaponMastery(gentity_t *playerEnt, ClientNum_t clientNum, int weaponStatIndex);
void GScr_AddRankXPValue(scr_entref_t entref);
void GScr_HasSeasonPass(scr_entref_t entref);
void GScr_AddPlayerStatInternal(;
void GScr_AddPlayerStat(scr_entref_t entref);
void GScr_AddPlayerStatWithGameTypeInternal(scr_entref_t entref, bool setGlobalStat);
void GScr_AddPlayerStatWithGameType(scr_entref_t entref);
void GScr_AddGameTypeStat(scr_entref_t entref);
void GScr_AddDStat(scr_entref_t entref);
void GScr_AddBonusCardStat(scr_entref_t entref);
void GScr_AddWeaponStat(scr_entref_t entref);
void GScr_SetEMPJammed(scr_entref_t entref);
void GScr_IsEMPJammed(scr_entref_t entref);
void GScr_LUINotifyEventPlayer(scr_entref_t entref);
void GScr_TrackWeaponFireNative(scr_entref_t entref);
void ScrCmd_SetActorWeapon(scr_entref_t entref);
void GScr_AddRankXP(scr_entref_t entref);

//t6/code/src_noserver/game/g_scr_mover.cpp
int ScriptMover_UpdateMove(trajectory_t *pTr, vec3_t *vCurrPos, const mover_positions_t *positionControl);
// void Reached_ScriptMover(vec3_t *a1@<edx>, trajectory_t *a2@<ecx>, gentity_t *pEnt);
void ScriptMover_SetupMove(;
void ScriptMover_SetupPhysicsLaunch(;
void ScriptMover_SetupMoveSpeed(;
void ScriptMover_Move(;
void ScriptMover_GravityMove(gentity_t *mover, const vec3_t *velocity, const float totalTime);
void InitScriptMover(gentity_t *pSelf);
void SP_script_brushmodel(gentity_t *self);
void SP_script_model(gentity_t *pSelf);
void SP_script_origin(gentity_t *pSelf);
void ScriptEntCmdGetCommandTimes(float *pfTotalTime, float *pfAccelTime, float *pfDecelTime);
void ScriptEntCmd_MoveTo(scr_entref_t entref);
void ScriptEntCmd_GravityMove(scr_entref_t entref);
void ScriptEntCmd_MoveSlide(scr_entref_t entref);
void ScriptEntCmd_StopMoveSlide(scr_entref_t entref);
void ScriptEnt_MoveAxis(scr_entref_t entref, int iAxis);
void ScriptEntCmd_MoveX(scr_entref_t entref);
void ScriptEntCmd_MoveY(scr_entref_t entref);
void ScriptEntCmd_MoveZ(scr_entref_t entref);
void ScriptEntCmd_RotateTo(scr_entref_t entref);
void ScriptEnt_DevAddRotate(scr_entref_t entref, int iAxis);
void ScriptEntCmd_DevAddPitch(scr_entref_t entref);
void ScriptEntCmd_DevAddYaw(scr_entref_t entref);
void ScriptEntCmd_DevAddRoll(scr_entref_t entref);
void ScriptEnt_RotateAxis(scr_entref_t entref, int iAxis);
void ScriptEntCmd_RotatePitch(scr_entref_t entref);
void ScriptEntCmd_RotateYaw(scr_entref_t entref);
void ScriptEntCmd_RotateRoll(scr_entref_t entref);
void ScriptEntCmd_Vibrate(scr_entref_t entref);
void ScriptEntCmd_RotateVelocity(scr_entref_t entref);
void ScriptEntCmd_SetCanDamage(scr_entref_t entref);
void ScriptEntCmd_SetCheapFlag(scr_entref_t entref);
void ScriptEntCmd_IgnoreCheapEntityFlag(scr_entref_t entref);
void ScriptEntCmd_PhysicsLaunch(scr_entref_t entref);
void ScriptEntCmd_Solid(scr_entref_t entref);
void ScriptEntCmd_NotSolid(scr_entref_t entref);
void (*ScriptEnt_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);

//t6/code/src_noserver/game/g_stepslide.cpp
;
;

//t6/code/src_noserver/game/g_svcmds.cpp
int StringToFilter(char *s, ipFilter_s *f);
void UpdateIPBans();
// void AddIP(ipFilter_s *a1@<edx>, char *str);
void G_ProcessIPBans();
void Svcmd_AddIP_f();
void Svcmd_RemoveIP_f();
void Svcmd_EntityList_f();
int ConsoleCommand();

//t6/code/src_noserver/game/g_targets.cpp
void G_InitTargets();
void G_LoadTargets();
void Scr_Target_SetShader();
void Scr_Target_SetOffscreenShader();
void Scr_Target_GetArray();
int Target_GetTargetIndex(gentity_t *ent);
void Scr_Target_IsTarget();
void Scr_Target_SetTurretAquire();
void Scr_Target_Set();
char Targ_Remove(gentity_t *ent);
void Targ_RemoveAll();
void Scr_Target_Remove();
bool G_WorldDirToScreenPos(;
bool ScrGetTargetScreenPos(vec2_t *screenPos, bool relativeToReticle);
void Scr_Target_IsInCircle();
void Scr_Target_IsInRect();
void Scr_Target_StartLockOn();
void Scr_Target_ClearLockOn();
bool G_TargetGetOffset(const gentity_t *targ, vec3_t *result);
bool G_TargetAttackProfileTop(const gentity_t *ent);
void Scr_Target_SetAttackMode();
void Scr_Target_SetJavelinOnly();
$580888C0E76BEA18C0DDD064E36B47DD *Target_GetTargetArray();
void Scr_Target_GetOffset();

//t6/code/src_noserver/game/g_vehicle.cpp
void Vehicle_RegisterDvars();
void VEH_Strdup(unsigned __int8 *pMember, const char *str);
void VEH_DebugCapsule(vec3_t *pos, float rad, float height, float r, float g, float b);
gentity_t *VEH_GetVehicle(int entNum);
BOOL VEH_IsSeatPresent(gentity_t *ent, int seatIdx, const VehicleDef *info);
Weapon VEH_GetSeatWeapon(gentity_t *const vehicle, const int seatIndex);
VehicleSeat *VEH_GetSeat(vehicle_t *veh, int seatIdx);
VehicleSeat *VEH_GetSeat(gentity_t *vehEnt, int seatIdx);
int VEH_GetSeatOccupantEntNum(vehicle_t *veh, int seatIdx);
int VEH_GetSeatOccupantEntNum(gentity_t *vehEnt, int seatIdx);
int VEH_SetSeatOccupantEntNum(vehicle_t *veh, int seatIdx, int occEntNum);
gentity_t *VEH_GetSeatOccupantEntity(vehicle_t *veh, int seatIdx);
gentity_t *VEH_GetSeatOccupantEntity(gentity_t *vehEnt, int seatIdx);
void VEH_GetWheelOrigin(gentity_t *ent, int idx, vec3_t *origin);
bool VEH_DObjHasRequiredTags(gentity_t *ent, int defIndex);
void VEH_InitEntity(gentity_t *ent, vehicle_t *veh, int defIndex);
void VEH_UpdatePhysics(gentity_t *ent, const PlayerVehicleState *vehicleState);
void VEH_JoltBody(gentity_t *ent, const vec3_t *dir, float intensity, float speedFrac, float decel);
void VEH_CalcAccel(gentity_t *ent, char *move, vec3_t *bodyAccel, vec3_t *rotAccel);
void VEH_ClipVelocity(const vec3_t *in, const vec3_t *normal, vec3_t *out);
int VEH_CorrectAllSolid(gentity_t *ent, trace_t *trace);
void VEH_ClearGround();
;
;
BOOL VEH_SlideMove(gentity_t *ent, int gravity, float frameTime, unsigned int *bumpEntityNum);
// void VEH_StepSlideMove(int *a1@<edx>, float a2@<xmm0>, int gravity);
void VEH_SlideMoveAndNotify(gentity_t *ent, int gravity, float frameTime);
void VEH_GroundMove(gentity_t *ent, float frameTime);
void VEH_AirMove(gentity_t *ent, int gravity, float frameTime);
;
void VEH_BackupPosition(gentity_t *ent);
bool AttachedStickyMissile(gentity_t *vehicle, gentity_t *missile);
void PushAttachedStickyMissile(;
void VEH_GetBoundingBoxFromCollmap(vec3_t *bbMins, gentity_t *vehicle, vec3_t *bbMaxs);
// bool VEH_ClampPointToBoundingBox@<al>(;
void VEH_PushEntity(;
void VEH_TouchEntities(gentity_t *ent);
void VEH_DebugAim(gentity_t *ent, const vec4_t *color, int duration);
void VEH_PredictPlayerPosition(const gentity_t *ent, const playerState_s *ps, vec3_t *vPos);
;
void VEH_UpdateGunnerAim(gentity_t *ent, int gunnerIndex);
bool Veh_GunnerBurstFirePending(const Weapon weapon, int weaponShotCount);
void VEH_UpdateBody(gentity_t *ent, const VehicleDef *info);
void VEH_UpdateSteering(gentity_t *ent);
void VEH_UpdateQuadrotor(gentity_t *ent);
bool VEH_ShouldEjectOccupants(gentity_t *ent);
void VEH_UpdateAvoidance(vec3_t *pos, vec3_t *goal, float radius, float height, vec3_t *newGoalPos);
bool VEH_IsHovering(vehicle_t *veh);
void VEH_UpdateAngleAndAngularVel(;
void VEH_SetHoverGoal(gentity_t *ent);
float VEH_UpdateMove_GetDesiredYaw(vehicle_t *veh, vec3_t *desiredDir);
void VEH_UpdateYawAndNotify(gentity_t *ent, float desiredYaw);
void VEH_UpdateVelocityWithRotation(gentity_t *ent);
void VEH_UpdateMoveOrientation(;
void VEH_CheckHorizontalVelocityToGoal(;
void VEH_CheckVerticalVelocityToGoal(vehicle_t *veh, float verticalDist, vec3_t *accelVec);
float VEH_UpdateMove_CheckStop(vehicle_t *veh, float distToGoal);
void VEH_GetNewSpeedAndAccel(;
void VEH_UpdateYawAngularVel(gentity_t *ent, float desiredYaw);
void VEH_UpdateAngle(int index, float desiredAngle, float acceleration, vehicle_physic_t *phys);
void VEH_DebugPlaneOnCurve(gentity_t *ent);
void VEH_UpdatePlaneRoll(gentity_t *ent);
void VEH_UpdatePlaneOnCurve(gentity_t *ent);
void VEH_UpdatePlaneFree(gentity_t *ent);
void VEH_UpdatePathOffset(vehicle_t *veh, const VehicleDef *info, vec3_t *origin, vec3_t *angles);
bool VEH_DoAutoTilt(vehicle_t *veh);
void VEH_UpdatePathTransition(vehicle_t *veh, vec3_t *origin, vec3_t *angles);
double VEH_GetMaxSpeed(gentity_t *ent, bool useGDT);
void VEH_SetLinkAngleClamps(const VehicleDef *info, gentity_t *player, int seatIndex, vec3_t *playerAngles);
void VEH_SetPlayerVehicle(gentity_t *ent, bool enable);
char VEH_ShouldLinkPlayer(gentity_t *ent, gentity_t *player, int seatIndex);
void VEH_LinkPlayer(gentity_t *ent, gentity_t *player, int seatIndex, bool changingSeats);
;
BOOL VEH_IsHorse(gentity_t *ent);
int VEH_GetNextSeat(const VehicleDef *info, int currentSeat);
void G_ParseScrVehicleDef();
void VEH_UpdateViewClampsOnPlayer(gentity_t *ent, const VehicleDef *info);
void G_ReloadVehicleDef();
void G_InitScrVehicles();
void __thiscall G_SetupScrVehicles(void *this);
void G_FreeScrVehicles();
void GScr_GetVehicleArray(int teamFlags, bool spawner);
void G_MakeVehicleUsable(gentity_t *ent, bool usable);
void G_UpdateVehicleTags(gentity_t *ent);
int G_GetNumVehicles();
team_t VEH_GetOccupantsTeam(gentity_t *vehEnt);
bool VEH_IsSeatOccupied(gentity_t *ent, int seatIndex);
int VEH_GetSeatPlayerOccupies(gentity_t *ent, gentity_t *player);
int VEH_GetSeatToEnter(gentity_t *ent, gentity_t *player, bool scriptUse, int *entryPoint);
VehicleMantlePoints VEH_GetPlayerMantlePoint(gentity_t *ent, gentity_t *player);
int VEH_IsUsable(gentity_t *ent, gentity_t *player);
double VEH_GetRadius(vehicle_physic_t *phys);
bool VEH_IsPlayerDriving(const gentity_t *player);
void Scr_Vehicle_Controller(const gentity_t *pSelf, int *partBits);
;
void VEH_UpdateLink(gentity_t *pSelf);
void Scr_Vehicle_Touch(gentity_t *pSelf, gentity_t *pOther);
vehicle_t *G_GetVehicleTypeString(ClientNum_t clientNum, int entityNum, VehicleDef **vehDef);
void Scr_Vehicle_Use(gentity_t *pEnt, gentity_t *pOther);
int VEH_GetVehicleDefIndex(const gentity_t *vehicle);
const VehicleDef *VEH_GetVehicleDef(const gentity_t *vehicle);
bool VEH_GetWheelBone(gentity_t *vehEnt, int wheelIndex, int *wheelBone);
void VEH_GetBoneOrigin(gentity_t *vehEnt, int boneIndex, vec3_t *result);
// int VEH_CanPlayerPlaceVehicle@<eax>(;
char VEH_IsOccupied(gentity_t *ent);
int G_LoadVehicle(const char *name);
int VEH_GetDefFromName(const char *name);
// char VEH_ValidatePosition@<al>(gentity_t *ent, const vec3_t *origin);
void VEH_SetPosition(gentity_t *ent, const vec3_t *origin, const vec3_t *vel, const vec3_t *angles);
void VEH_InitFromInfo(gentity_t *ent, const VehicleDef *info);
void VEH_InitPhysics(gentity_t *ent, int defIndex);
void VEH_InitVehicle(gentity_t *ent, vehicle_t *veh, int defIndex);
gentity_t *VEH_FireGunnerWeapon(gentity_t *ent, int gunnerIndex, gentity_t *attacker);
bool ShouldCoolDown(;
bool ShouldHeatUp(;
void VEH_UpdateGunnerWeapon(gentity_t *ent, int gunnerIndex, int msec);
;
void VEH_UpdateClient(gentity_t *ent);
void VEH_UpdatePathPosition(gentity_t *ent, vehicle_pathpos_t *vpp, vec3_t *origin, vec3_t *angles);
void VEH_CheckPathEnd(gentity_t *ent);
int VEH_UpdateMove_CheckGoalAndNearGoal(gentity_t *ent, vec3_t *goalPosition);
void VEH_UpdateMoveToGoal(gentity_t *ent, const vec3_t *goalPos);
vec3_t *VEH_UpdateMoveToGoalAircraft(gentity_t *ent, const vec3_t *goalPos);
void VEH_UpdateMoveToGoalBoat(gentity_t *ent, const vec3_t *goalPos);
void VEH_UpdateHover(gentity_t *ent);
void VEH_UpdateAIMove(gentity_t *ent);
void VEH_UpdatePath(gentity_t *ent);
void VEH_Update(gentity_t *ent);
void VEH_GetSeatExitPositionAndAngles(;
void VEH_UnseatPlayer(;
void VEH_PlayerExit(;
void VEH_UnlinkPlayer(gentity_t *player, int unlinkReasonFlag, const char *error_msg);
void VEH_FinishedAnimating(gentity_t *player, pmoveVehAnimState_t vehAnimState);
void VEH_SwitchClientToSeat(gentity_t *ent, gentity_t *player, int seatIndex);
int VEH_NextAvailableSeat(gentity_t *player);
void VEH_SwitchClientToNextSeat(gentity_t *ent, gentity_t *player);
void VEH_RinitVehiclesUsingInfo(int defIndex);
char VEH_UpdateField(const char *vehicleDefName, const char *keyValue);
void G_FreeVehicle(gentity_t *ent);
void G_HideVehicle(gentity_t *ent);
int G_GetVehicleDefIndex(const char *name);
bool VEH_IsRemoteControl(gentity_t *vehEnt);
void VEH_Teleport(gentity_t *pSelf, vec3_t *origin, vec3_t *angles, vec3_t *vel);
void VEH_UpdateDebug(gentity_t *pSelf);
void Scr_Vehicle_Init(gentity_t *pSelf);
void VEH_AvoidUpdate(;
;
void Scr_Vehicle_Think(gentity_t *pSelf);
void Launch_Vehicle(gentity_t *ent, int damage, const vec3_t *point, const vec3_t *dir, int mod);
void Scr_Vehicle_Pain(;
void Scr_Vehicle_Die(;
void SP_script_vehicle(gentity_t *pSelf, SpawnVar *spawnVar);

//t6/code/src_noserver/game/g_vehicle_path.cpp
void VP_AddDebugLine(const vec3_t *start, const vec3_t *end, int forceDraw);
void VP_DebugArrow(const vec3_t *pos, const vec3_t *angles);
void VP_SetScriptVariable(const char *key, const char *value, vehicle_node_t *node);
void VP_ParseFields(vehicle_node_t *node, const SpawnVar *spawnVar, const bool setScriptVariable);
void VP_ClearNode(vehicle_node_t *node);
void VP_InitNode(vehicle_node_t *node, __int16 nodeIdx);
void VP_CopyNode(const vehicle_node_t *src, vehicle_node_t *dst);
vehicle_node_t *VP_GetNodeByIndex(__int16 index);
int VP_GetNextNodeIndex(int index);
__int16 VP_GetNodeIndex(unsigned __int16 name, vec3_t *origin);
void VP_CalcNodeSpeed(__int16 nodeIdx);
void VP_CalcNodeTension(__int16 nodeIdx);
void VP_CalcNodeLookAhead(__int16 nodeIdx);
void VP_CalcNodeRadius(__int16 nodeIdx);
void VP_CalcNodeAngles(__int16 nodeIdx, vec3_t *angles);
float VP_GetSlide(const vehicle_pathpos_t *vpp);
void VP_GetAngles(const vehicle_pathpos_t *vpp, vec3_t *angles);
void VP_GetLookAheadXYZCustom(const vehicle_pathpos_t *vpp, vec3_t *lookXYZ);
void VP_GetLookAheadXYZ(const vehicle_pathpos_t *vpp, vec3_t *lookXYZ);
int VP_UpdatePathPosCustom(vehicle_pathpos_t *vpp);
int VP_UpdatePathPos(vehicle_pathpos_t *vpp, const vec3_t *dir);
int VP_FindClosestPathNode(const vec3_t *pos);
path_t *VP_GetFreeAIPath(int entityNum);
void VP_FreeAIPath(path_t *path);
path_t *VP_GetAIPath(int index);
void VP_UpdateAIPath(const vec3_t *origin, vehicle_pathpos_t *vpp);
void VP_DrawAIPath(const vec3_t *origin, const vehicle_pathpos_t *vpp);
vehicle_custom_path_t *VP_GetFreeCustomPath();
void VP_FreeCustomPath(vehicle_custom_path_t *path);
vehicle_custom_path_t *VP_GetCustomPath(int index);
void VP_DrawCustomPath(vehicle_custom_path_t *customPath);
void G_LoadVehiclePaths(MemoryFile *memFile);
void G_LoadVehicleHeightMeshes(MemoryFile *memFile);
vehicle_node_t *GetCurrNode(vehicle_pathpos_t *vpp);
void VP_CalcPos(vehicle_pathpos_t *vpp);
void VP_Advance(vehicle_pathpos_t *vpp, float dt, int use_spline_speed, int drivePath);
// void VP_DrawPath(vec3_t *p_origin@<edi>, vehicle_pathpos_t *vpp);
void G_InitVehiclePaths();
void G_FreeVehiclePaths();
void G_FreeVehiclePathsScriptInfo();
// void G_SetupSplinePaths(float speed@<xmm0>, bool scriptConnect);
void G_ConnectVehiclePaths();
// void G_SetupVehiclePaths(float a1@<xmm0>, bool scriptConnect);
void G_VehInitPathPos(vehicle_pathpos_t *vpp);
void G_VehFreePathPos(vehicle_pathpos_t *vpp);
void G_VehSetUpPathPos(vehicle_pathpos_t *vpp, __int16 nodeIdx);
int G_VehUpdatePathPos(vehicle_pathpos_t *vpp);
void G_VehSetSwitchNode(vehicle_pathpos_t *vpp, __int16 srcNodeIdx, __int16 dstNodeIdx);
void TRACK_g_vehicle_path();
void SP_info_vehicle_node(const SpawnVar *spawnVar, int rotated, int radiantLiveUpdate);
void G_ClearSelectedVehicleNode();
vehicle_node_t *G_FindVehicleNode(int guid);
__int16 GScr_GetVehicleNodeIndex(unsigned int index);
void GScr_AddFieldsForVehicleNode();
void GScr_GetVehicleNodeField(int entnum, int offset);
void GScr_GetVehicleNode();
void GScr_GetVehicleNodeArray();
void GScr_GetAllVehicleNodes();
void GScr_GetTimeFromVehicleNodeToNode();
// void GScr_ReconnectVehicleNodes(float a1@<xmm0>);
void GScr_SetVehicleNodeEnabled();
void G_SpawnHeliHeightLock(SpawnVar *spawnVar);
int VP_FindAIPath(;
int VP_FindCustomPath(const vec3_t *start, const vec3_t *end, vehicle_pathpos_t *vpp);
double VP_TraversePath(const vehicle_pathpos_t *vpp, const bool draw);
void VP_DrawRaceTrack(__int16 nodeIdx);
// void G_DrawVehiclePaths(vec3_t *a1@<edi>);
// void G_ProcessVehicleNodeCommand(float a1@<xmm0>, const RadiantCommand *command, SpawnVar *spawnVar);
void GScr_CreateTrack();

//t6/code/src_noserver/game/g_vehicle_phys.cpp
void VEH_ClampAcceleration(vec3_t *acceleration, float maxAcceleration);
BOOL G_IsVehicleHelicopter(const VehicleDef *info);
BOOL G_IsVehiclePlane(const VehicleDef *info);
BOOL G_IsVehicleBoat(const VehicleDef *info);
void VEH_UpdateTiltForAcceleration(;
void VEH_UpdatePathFollow(;

//t6/code/src_noserver/game/g_vehicle_script_cmd.cpp
void TRACK_g_scr_vehicle();
gentity_t *GScr_GetVehicle(scr_entref_t entref);
int VEH_GetSeatFiringOriginAngles(;
void VEH_ResetWheels(gentity_t *ent, vehicle_physic_t *phys);
// long double GScr_Vehicle_DamageScale@<st0>(;
void GScr_GetNumVehicles();
void GScr_SetHeliHeightPatchEnabled();
void GScr_PrecacheVehicle();
void GScr_GetVehicleTreadFXArray();
bool VEH_IsImmune(gentity_t *ent, int mod, int damageFlags, Weapon weapon);
void (*ScriptVehicle_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
void CMD_VEH_AttachPath(scr_entref_t entref);
void CMD_VEH_GetModel(scr_entref_t entref);
void CMD_VEH_GetAttachPos(scr_entref_t entref);
void CMD_VEH_StartPath(scr_entref_t entref);
void CMD_VEH_DrivePath(scr_entref_t entref);
void CMD_VEH_PathMove(scr_entref_t entref);
void CMD_VEH_PathMoveClear(scr_entref_t entref);
void CMD_VEH_PathFixedOffset(scr_entref_t entref);
void CMD_VEH_PathFixedOffsetClear(scr_entref_t entref);
void CMD_VEH_PathVariableOffset(scr_entref_t entref);
void CMD_VEH_PathVariableOffsetClear(scr_entref_t entref);
void CMD_VEH_GetPathFixedOffset(scr_entref_t entref);
void CMD_VEH_GetPathVariableOffset(scr_entref_t entref);
void CMD_VEH_SetDrivePathPhysicsScale(scr_entref_t entref);
void CMD_VEH_SetSwitchNode(scr_entref_t entref);
void CMD_VEH_Script_SetSpeed(gentity_t *ent);
void CMD_VEH_SetSpeed(scr_entref_t entref);
void CMD_VEH_SetSpeedImmediate(scr_entref_t entref);
void CMD_VEH_GetSpeed(scr_entref_t entref);
void CMD_VEH_GetSpeedMPH(scr_entref_t entref);
void CMD_VEH_GetGoalSpeedMPH(scr_entref_t entref);
void CMD_VEH_SetBrake(scr_entref_t entref);
void CMD_VEH_GetBrake(scr_entref_t entref);
void CMD_VEH_GetHandBrake(scr_entref_t entref);
void CMD_VEH_GetScriptBrake(scr_entref_t entref);
void CMD_VEH_SetAcceleration(scr_entref_t entref);
void CMD_VEH_SetDeceleration(scr_entref_t entref);
void CMD_VEH_ResumeSpeed(scr_entref_t entref);
void CMD_VEH_SetYawSpeed(scr_entref_t entref);
void CMD_VEH_SetMaxPitchRoll(scr_entref_t entref);
void CMD_VEH_SetAirResitance(scr_entref_t entref);
void CMD_VEH_GetSteering(scr_entref_t entref);
void CMD_VEH_GetThrottle(scr_entref_t entref);
void CMD_VEH_SetPhysAngles(scr_entref_t entref);
void CMD_VEH_SetTurningAbility(scr_entref_t entref);
void CMD_VEH_SetJitterParams(scr_entref_t entref);
void CMD_VEH_SetHoverParams(scr_entref_t entref);
void CMD_VEH_JoltBody(scr_entref_t entref);
void CMD_VEH_FreeVehicle(scr_entref_t entref);
void CMD_VEH_GetWheelSurface(scr_entref_t entref);
void CMD_VEH_GetVehicleOwner(scr_entref_t entref);
void CMD_VEH_IsVehicleUsable(scr_entref_t entref);
void CMD_VEH_MakeVehicleUsable(scr_entref_t entref);
void CMD_VEH_MakeVehicleUnusable(scr_entref_t entref);
void CMD_VEH_UseVehicle(scr_entref_t entref);
void CMD_VEH_SetViewClamp();
void CMD_VEH_ResetViewClamp(scr_entref_t entref);
void CMD_VEH_SetVehicleLookatText(scr_entref_t entref);
void CMD_VEH_NearGoalNotifyDist(scr_entref_t entref);
void VEH_GenerateCurveForPlane(gentity_t *ent, vec3_t *goals, int numGoals, const vec3_t *goalAngles);
void CMD_VEH_SetPlaneGoalPos(scr_entref_t entref);
void CMD_VEH_SetPlaneBarrelRoll(scr_entref_t entref);
void CMD_VEH_SetGoalYaw(scr_entref_t entref);
void CMD_VEH_ClearGoalYaw(scr_entref_t entref);
void CMD_VEH_SetTargetYaw(scr_entref_t entref);
void CMD_VEH_ClearTargetYaw(scr_entref_t entref);
void CMD_VEH_SetDefaultPitch(scr_entref_t entref);
void CMD_VEH_ClearDefaultPitch(scr_entref_t entref);
void CMD_VEH_GetAngularVelocity(scr_entref_t entref);
void CMD_VEH_SetAngularVelocity(scr_entref_t entref);
void CMD_VEH_SetVehVelocity(scr_entref_t entref);
void CMD_VEH_SetTurretTargetVec(scr_entref_t entref);
void CMD_VEH_SetTurretTargetEnt(scr_entref_t entref);
void CMD_VEH_ClearTurretTarget(scr_entref_t entref);
void CMD_VEH_SetGunnerTargetVec(scr_entref_t entref);
void CMD_VEH_GetGunnerTargetVec(scr_entref_t entref);
void CMD_VEH_SetGunnerTargetEnt(scr_entref_t entref);
void CMD_VEH_ClearGunnerTarget(scr_entref_t entref);
void CMD_VEH_SetGunnerTurretOnTargetRange(scr_entref_t entref);
void CMD_VEH_GetGunnerTargetEnt(scr_entref_t entref);
void CMD_VEH_GetGunnerAnimPitch(scr_entref_t entref);
void CMD_VEH_GetGunnerAnimYaw(scr_entref_t entref);
void CMD_VEH_SetLookAtEnt(scr_entref_t entref);
void CMD_VEH_ClearLookAtEnt(scr_entref_t entref);
void CMD_VEH_CancelAIMove(scr_entref_t entref);
void CMD_VEH_SetVehicleType(scr_entref_t entref);
void CMD_VEH_GetPhysAcceleration(scr_entref_t entref);
void CMD_VEH_SetPhysAcceleration(scr_entref_t entref);
void CMD_VEH_DrawTrajectory(scr_entref_t entref);
void CMD_VEH_SetRotorSpeed(scr_entref_t entref);
void CMD_VEH_GetMaxSpeed(scr_entref_t entref);
void CMD_VEH_TakePlayerControl(scr_entref_t entref);
void CMD_VEH_ReturnPlayerControl(scr_entref_t entref);
void CMD_VEH_SetWeapon(scr_entref_t entref);
void CMD_VEH_FireWeapon(scr_entref_t entref);
void CMD_VEH_FireGunnerWeapon(scr_entref_t entref);
void CMD_VEH_StopFireWeapon(scr_entref_t entref);
void CMD_VEH_IsTurretReady(scr_entref_t entref);
void CMD_VEH_SetMaxSpeed(scr_entref_t entref);
void CMD_VEH_GetOccupants(scr_entref_t entref);
void CMD_VEH_GetSeatOccupant(scr_entref_t entref);
void CMD_VEH_GetOccupantSeat(scr_entref_t entref);
void CMD_VEH_SetSeatOccupied(scr_entref_t entref);
void CMD_VEH_SeatGetWeapon(scr_entref_t entref);
void CMD_VEH_GetSeatFiringOrigin(scr_entref_t entref);
void CMD_VEH_GetSeatFiringAngles(scr_entref_t entref);
void CMD_VEH_IsGunnerFiring(scr_entref_t entref);
void CMD_VEH_DisableGunnerFiring(scr_entref_t entref);
void CMD_VEH_finishVehicleDamage(scr_entref_t entref);
void CMD_VEH_finishVehicleRadiusDamage(scr_entref_t entref);
void CMD_VEH_IsVehicleImmuneToDamage(scr_entref_t entref);
void CMD_VEH_SetMantleEnabled(scr_entref_t entref);
void CMD_VEH_SetVehicleAvoidance(scr_entref_t entref);
void CMD_VEH_GetVehicleAvoidance(scr_entref_t entref);
void CMD_VEH_CanSee(scr_entref_t entref);
void CMD_VEH_SeenRecently(scr_entref_t entref);
void CMD_VEH_ClearEnemy(scr_entref_t entref);
void CMD_VEH_SetEntityTarget(scr_entref_t entref);
void CMD_VEH_ClearEntityTarget(scr_entref_t entref);
void CMD_VEH_GetTurretHeatValue(scr_entref_t entref);
void CMD_VEH_IsVehicleTurretOverheating(scr_entref_t entref);
void CMD_VEH_SetPathTransitionTime(scr_entref_t entref);
void CMD_VEH_GetVehicleAvoidanceNodes(scr_entref_t entref);
void CMD_VEH_MakeSentient(scr_entref_t entref);
void CMD_VEH_SetGoalPos(scr_entref_t entref);
void CMD_VEH_ClearGoalPos(scr_entref_t entref);

//t6/code/src_noserver/game/g_weapon.cpp
void Weapon_SetWeaponParamsWeapon(weaponParms *wp, Weapon weapon);
void G_AntiLagRewindClientPos(int gameTime, AntilagClientStore *antilagStore);
void G_AntiLagRewindClientIndexPos(int clientNum, AntilagClientStore *antilagClients);
void G_AntiLag_RestoreClientPos(AntilagClientStore *antilagStore);
actorAntilagFrame_t *G_GetActorAntilagFrame(int *time);
void G_GetActorPositionsFromCache(actorAntilagFrame_t *frame, vec3_t **pos, vec3_t **angles, bool *success);
bool G_GetActorPositionsAtTime(int gametime, vec3_t *pos, vec3_t *angles, bool *success);
void G_AntiLag_RewindActorPos(int gameTime, antilagActorStore_t *antilagStore);
void G_AntiLag_RestoreActorPos(antilagActorStore_t *antilagStore);
void G_ArchiveActorAntilagFrame();
vehicleAntilagFrame_t *G_GetVehicleAntilagFrame(int *time);
void G_GetVehiclePositionsFromCache(vehicleAntilagFrame_t *frame, vec3_t **pos, vec3_t **angles, bool *success);
bool G_GetVehiclePositionsAtTime(int gametime, vec3_t *pos, vec3_t *angles, bool *success);
void G_AntiLag_RewindVehiclePos(int gameTime, antilagVehicleStore_t *antilagStore);
void G_AntiLag_RestoreVehiclePos(antilagVehicleStore_t *antilagStore);
void G_ArchiveVehicleAntilagFrame();
gentity_t *Weapon_Throw_Grenade(;
gentity_t *Weapon_GrenadeLauncher_Fire(;
gentity_t *Weapon_RocketLauncher_Fire(;
gentity_t *Weapon_BombDrop_Fire(;
void Weapon_Overheat_Update(gentity_t *ent);
void Weapon_Flamethrower_Update(gentity_t *ent, weaponParms *wp);
void Weapon_Flamethrower_Fire(gentity_t *ent, weaponParms *wp);
BOOL LogAccuracyHit(gentity_t *target, gentity_t *attacker);
void G_CalcMuzzlePoints(const gentity_t *ent, weaponParms *wp, int shotCount);
Weapon G_GetWeaponDefBasedOnNumberOfBullets(int numBulletsQueued, Weapon weapon);
void FireWeapon(gentity_t *ent, int gametime, int shotCount);
;
void BreakDownWeapon(gentity_t *ent);
void G_UseOffHand(gentity_t *ent);
void G_UpdatePlayerWeaponOptions(playerState_s *pPS, Weapon weapon, renderOptions_s weaponOptions);
Weapon G_GetWeaponForName_Internal(const char *name);
Weapon G_GetWeaponForName(const char *name);
int G_GetBaseWeaponItemIndex(const char *pszWeaponName, int *attachmentBits, int *weaponIdx);
void G_SelectWeapon(ClientNum_t clientNum, Weapon weapon);
void G_SetEquippedOffHand(ClientNum_t clientNum, Weapon offHandWeapon);
Weapon G_PlayerTurretWeapon(const playerState_s *ps);
Weapon G_GetPlayerVehicleWeapon(const playerState_s *ps);
Weapon G_GetPlayerWeapon(const playerState_s *ps);
unsigned int G_GetShieldTagName(const gentity_t *ent);
char G_GetShieldTagMatrix(const gentity_t *ent, vec3_t *resultMatrix);
void G_AddShieldSplashDamageEvent(;
;
void Weapon_Melee_NotifyClient(;
;
gentity_t *Weapon_Melee(gentity_t *ent, weaponParms *wp, float range, float width, float height, int gametime);
void Weapon_Napalm_Flame(gentity_t *ent, trace_t *trace, int count);
void FireWeaponMelee(gentity_t *ent, int gametime);
int G_GivePlayerWeapon(;
void G_SetupWeaponDef();
double G_GetShieldCosOfAngleToPoint(const gentity_t *shieldHolder, const vec3_t *point);
void G_GetShieldTagNormal(const gentity_t *ent, vec3_t *resultNormal);
double G_GetShieldBlastDamageProtection(gentity_t *ent, const vec3_t *blastOrigin);

//t6/code/src_noserver/game/g_weapon_load_obj.cpp
bool G_ParseAIWeaponAccurayGraphFile(;
bool G_ParseWeaponAccurayGraphInternal(;
char G_ParseWeaponAccurayGraphs(WeaponDef *weaponDef);

//t6/code/src_noserver/game/g_zbarrier.cpp
void G_RunZBarrier(gentity_t *ent);
void ZBarrier_SetCollisionState(gentity_t *ent, int pieceIndex, bool onOff);
void ZBarrier_SetPieceState(gentity_t *pSelf, int pieceIndex, int state, float scalar);
void ZBarrier_Think(gentity_t *pSelf);
void G_ZBarrier_FinishSpawningAll();
int SP_ZBarrier(gentity_t *ent);

//t6/code/src_noserver/game/linkto.cpp
int G_EntLinkToUpdateOffset(gentity_t *ent, const vec3_t *originOffset, const vec3_t *anglesOffset);
BOOL G_EntIsLinked(gentity_t *ent);
BOOL G_EntIsLinkedTo(gentity_t *ent, gentity_t *parent);
void G_UpdateTagInfoOfChildren(gentity_t *parent, int bHasDObj);
void G_CalcTagParentAxis(gentity_t *ent, vec3_t *parentAxis);
void G_CalcTagParentRelAxis(gentity_t *ent, vec3_t *parentRelAxis);
void G_CalcTagAxis(gentity_t *ent, int bAnglesOnly);
void G_CalcFixedLinkTargetAxis(gentity_t *ent, vec3_t *axis);
int G_SetFixedLinkNonPlayer(gentity_t *ent, const int eAngles, const int contentMask, vec3_t *outTargetOrigin);
void G_DefaultViewAngleClampGoal(viewClampState *clamp);
void G_SnapToViewAngleClampGoal(viewClampState *clamp);
// __int64 CalcLerpFraction@<xmm0>(float a1@<xmm1>, __int64 a2@<xmm3>, float a3@<xmm6>, float startTime);
void G_UpdateViewAngleClamp(gclient_t *client, const vec3_t *worldAnglesCenter);
void G_InitPlayerLinkAngles(gentity_t *ent);
void G_GeneralLink(gentity_t *ent);
bool SetPlayerVehicleLinkViewAngles(gentity_t *ent);
void SetPlayerFixedLinkViewAngles(gentity_t *ent, const vec3_t *worldAxis, float lerpFraction);
void SetPlayerFixedLinkOrigin(gentity_t *ent, const vec3_t *worldAxis, float lerpFraction);
void G_SetFixedLinkPlayer(gentity_t *ent);
void G_TransferLinkedEntities(gentity_t *from, gentity_t *to);
char G_ShouldClientLinkTo();
;
int EntLinkTo_Internal(gentity_t *ent, gentity_t *parent, unsigned int tagName);
int G_EntLinkTo(gentity_t *ent, gentity_t *parent, unsigned int tagName);
int G_EntLinkToWithOffset(;
void G_EntUnlink(gentity_t *ent);

//t6/code/src_noserver/game/pathnode.cpp
vec3_t *Path_GetPillarStandOverOffset();
void TRACK_pathnode();
int Node_DangerousCount(const pathnode_t *pNode, const team_t team);
BOOL Node_IsDangerous(const pathnode_t *pNode, const team_t team);
BOOL Node_IsFriendly(const pathnode_t *pNode, const team_t team);
void Node_MarkDangerous(pathnode_t *pNode, const team_t team, const int dangerous);
void Scr_FindPath();
void Path_GetType(pathnode_t *node);
void Scr_SetPathnodeField(int entnum, int offset);
void Scr_GetPathnodeField(int entnum, int offset);
void Path_CallFunctionForNodes(scriptInstance_t inst, void (*function)(scriptInstance_t, pathnode_t *));
void PathNode_UpdateStringField(;
void PathNode_UpdateFloatField(const char *destKey, float *destFloat, const char *key, const char *value);
void parented_pathnode_list_delete(gentity_t *gent);
void G_UpdateTrackExtraNodes();
void GScr_AddFieldsForPathnode();
void ScrCmd_SetDangerousNode(scr_entref_t entref);
void ScrCmd_IsDangerousNode(scr_entref_t entref);
pathnode_t *Scr_GetPathnode(scriptInstance_t inst, unsigned int index);
void G_FreePathnodesScriptInfo();
bool Path_CompareNodesIncreasing(const pathsort_t *ps1, const pathsort_t *ps2);
unsigned int Path_ConvertNodeToIndex(const pathnode_t *node);
pathnode_t *Path_ConvertIndexToNode(int index);
void Path_Init(int restart);
int NodeSmoothCacheEntry(int i, int j);
BOOL Path_NodesSmooth(const pathnode_t *node0, const pathnode_t *node1);
void Path_NodesInCylinder_process(pathnode_t *pnode);
int Path_IsDynamicBlockingEntity(gentity_t *ent);
int Path_IsBadPlaceLink(int nodeNumFrom, int nodeNumTo, team_t eTeam);
void Path_InitLinkCounts();
int Path_InitLinkInfoArray();
GameWorldMp *Path_InitNodesDynamic();
void Path_PreSpawnInitPaths();
void Path_CheckSpawnExitNodesConnectivity();
void Path_DrawDebugNoLinks(const pathnode_t *node, const vec4_t *color, int duration);
void Path_DrawDebugLink(;
void Path_GetCornerNodeCheckOffset(const pathnode_t *node, vec3_t *offset);
void Path_GetPeekOutLine(const pathnode_t *node, const vec3_t *offset, vec3_t *start, vec3_t *end);
void Path_DrawDebugPeekOuts(const pathnode_t *node);
void Path_DrawDebugFindPath(const vec3_t *vOrigin);
double Path_NodeActorAngle(const pathnode_t *node);
BOOL Path_NodesVisible(const pathnode_t *node0, const pathnode_t *node1);
BOOL Path_ExpandedNodeVisible(const pathnode_t *node0, const pathnode_t *node1);
BOOL Path_NodeSafeFrom(const pathnode_t *node0, const pathnode_t *node1);
pathnode_t *Path_FirstNode(int typeFlags);
bool Path_IsDynamicallySpawnedNode(pathnode_t *node);
pathnode_t *Path_NextNode(pathnode_t *prevNode, int typeFlags);
int Path_IsOnlyOwner(const pathnode_t *node, const sentient_t *owner);
sentient_t *Path_GetNodeOwner(const pathnode_t *node);
int Path_CanStealPriorityNode(const pathnode_t *node, sentient_t *claimer);
bool Path_CanStealNode(const pathnode_t *node, sentient_t *claimer);
void Path_ClaimNodeInternal(pathnode_t *node, sentient_t *claimer);
void Path_MarkNodeOverlap(pathnode_t *node);
void Path_ClaimNode(pathnode_t *node, sentient_t *claimer);
void Path_RevokeClaim(pathnode_t *node, sentient_t *pNewClaimer);
void Path_RelinquishNode(sentient_t *claimer, int timeUntilRelinquished);
BOOL Path_IsReallyDangerousNode(const pathnode_t *node, team_t eTeam);
unsigned int Path_IsNodeNegotiationHint(const pathnode_t *node);
int Path_AllowedStancesForNode(pathnode_t *node);
pathnode_t *Path_LoadNode(unsigned int index);
void Path_ValidateNode(pathnode_t *node);
void Path_ValidateAllNodes();
void Path_CheckLinkLeaks();
void Path_CheckUserCountLeaks();
void Path_DisconnectPath(pathnode_t *node, pathlink_s *link);
void Path_ConnectPath(pathnode_t *node, pathlink_s *link);
void Path_UpdateBadPlaceCountForLink(pathlink_s *link, int teamflags, int delta);
void Path_UpdateHasBadPlaceLink(pathnode_t *node);
// void Path_UpdateArcBadPlaceCount(float a1@<esi>, badplace_arc_t *arc, int teamflags, int delta);
void Path_CheckForInwardLinks(;
int Path_IsNodeInArc(;
void ReadEntityDisconnectedLinks(gentity_t *ent, MemoryFile *memFile);
BOOL IsNodeEnabled(const pathnode_t *pNode);
void G_DeleteRunTimePathnode(pathnode_t *node);
pathnode_t *G_FindPathNode(int guid);
void G_ClearSelectedPathNode();
void Scr_SetNodePriority();
void Scr_IsNodeOccupied();
void Scr_GetNodeOwner();
void Scr_SetTurretNode();
void Scr_UnsetTurretNode();
void parented_pathnode_list_add(pathnode_parent_t *node_parent);
void parented_pathnode_list_update(;
void parented_pathnode_lists_reset_position(generic_avl_map_node_t *gamn);
bool pathnode_is_resized(pathnode_t *node);
pathnode_parent_t *get_pathnode_parent(const pathnode_t *node);
int get_pathnode_parent_entity(const unsigned int pathnode_i);
int Node_DoesLink(const pathnode_t *nodeA, const pathnode_t *nodeB);
int G_NodeValidLink(const pathnode_t *pNode);
void G_MarkBadPathnodes();
void Scr_AddPathnode(scriptInstance_t inst, pathnode_t *node);
void Scr_GetNode();
void Scr_GetNodeArray();
void Scr_GetAllNodes();
void Scr_GetVisibleNode();
void Scr_NodesVisible();
void Scr_GetVisibleNodes();
void Scr_NodesCanPath();
void Scr_CanClaimNode();
void Scr_SetEnableNode();
void Scr_DeletePathNode();
void Path_Shutdown();
void Path_NodesInCylinder_r(pathnode_tree_t *tree);
void Path_MovingNodesInCylinder();
int Path_NodesInCylinder(;
int Path_NodesInRadius(;
void Path_InitPaths();
void Path_DrawDebugNodeBox(const pathnode_t *node, float size, const vec4_t *color_, int depthTest);
void Path_DrawDebugNodeBox(;
void Path_DrawDebugNode(const vec3_t *cameraPos, const pathnode_t *node);
void Path_DrawVisData();
void Path_RelinquishNodeNow(sentient_t *claimer);
void Path_MarkNodeInvalid(pathnode_t *node, team_t eTeam, int invalidTime);
void Path_MarkAllConnectedNodesDangerous(pathnode_t *node, team_t eTeam);
void Path_ConnectPathsForEntity(gentity_t *ent);
void Path_DisconnectPathsForEntity(gentity_t *ent);
void Path_UpdateBrushBadPlaceCount(gentity_t *brushEnt, int teamflags, int delta);
void G_SetPathnodeScriptVariable(const char *key, const char *value, pathnode_t *ent);
void G_ParsePathnodeScriptFields(pathnode_t *node, SpawnVar *spawnVar);
void parented_pathnode_lists_construct();
void destroy_pathnode_resized_links(void *prl_);
pathnode_resized_links_t *pathnode_resized_links_get(pathnode_t *node);
int Path_AreNodesLinked(pathnode_t *node_from, pathnode_t *node_to);
void pathnode_resized_links_add(pathnode_t *node_from, pathnode_t *node_to, bool bWarnAboutDupeLinks);
void pathnode_resized_links_remove(pathnode_t *node_from, pathnode_t *node_to);
void destroy_pathnode_parent(void *node_parent);
void setup_pathnode_parent(pathnode_t *node, const int entnum, const vec3_t *origin_loc);
void level_init_pathnode_parernt_system(int restart);
void pathnode_resized_links_load(MemoryFile *memFile);
void pathnode_parent_load(MemoryFile *memFile);
void pathnode_load(MemoryFile *memFile);
;
void G_DropPathNodeToFloor(unsigned int nodeIndex);
void G_DropPathnodesToFloor();
void G_SpawnPathnodeDynamic(SpawnVar *spawnVar, pathnode_t *spawnedNode);
void Scr_DrawNode();
void Scr_LinkNodes();
void Scr_UnLinkNodes();
void Scr_NodesAreLinked();
// void Scr_DropNodeToFloor(int a1@<ebp>);
void Path_AutoDisconnectPaths();
int Path_CanClaimNode(const pathnode_t *node, sentient_t *claimer);
void Path_ForceClaimNode(pathnode_t *node, sentient_t *claimer);
void G_ProcessPathnodeCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void Scr_SpawnPathNode();
void GetNodesInRadius(int sorted);
void Scr_GetNodesInRadius();
void Scr_GetNodesInRadiusSorted();
pathnode_t *Path_NearestNodeNotCrossPlanes(;
void Path_UpdateLimitedDepthArcBadPlaceCount(badplace_arc_t *arc, int teamflags, int delta, int depth);
void Scr_GetNodeArraySorted();
void Scr_GetCoverNodeArray();
void Scr_GetAnyNodeArray();
void Path_DrawDebugNearestNode(const vec3_t *vOrigin);
pathnode_t *Path_NearestNodeNoHeightCheck(;
pathnode_t *Path_NearestNode(;
void Scr_GetNearestNode();
bool Path_InitializeSpawns(pathnode_t **spawns);
void Path_FlagUnconnectedNode(pathnode_t *node);
void Path_DrawDebugUnconnected(pathnode_t *node);
void Path_DrawDebug();
void Path_Update();

//t6/code/src_noserver/game/pathnode.h
int Path_NodeAnglesValid(const pathnode_t *node);
int Path_IsCoverNode(const pathnode_t *node);
BOOL Path_IsPathStanceNode(const pathnode_t *node);

//t6/code/src_noserver/game/pathnode_load_db.h
void Load_pathnode_constant_t(bool atStreamStart);
void Load_pathnode_tArray(bool atStreamStart, int count);
void Load_pathnode_tree_nodes_t(bool atStreamStart);
void Mark_pathnode_tArray(int count);
void Load_pathnode_tree_ptrArray(bool atStreamStart, int count);
void Load_pathnode_tree_t(bool atStreamStart);
void Load_pathnode_tree_tArray(bool atStreamStart, int count);

//t6/code/src_noserver/game/pathnode_load_obj.cpp
void Path_CreateNodes();
void Path_InitStatic(int restart);
void Path_ShutdownStatic();
void G_ParsePathnodeField(const char *key, const char *value, pathnode_t *node);
// void G_ParsePathnodeFields(SpawnVar *a1@<edx>, SpawnVar *spawnVar, pathnode_t *node, nodeType type);
void SP_spawn_node(SpawnVar *spawnVar, nodeType type);
pathnode_t *SP_spawn_node_dynamic(SpawnVar *spawnVar, nodeType type);
int G_GetNodeTypeFromClassname(const char *classname);
void G_SpawnPathnodeStatic(SpawnVar *spawnVar, const char *classname);
pathnode_t *G_SpawnPathnodeStaticRunTime(SpawnVar *spawnVar, const char *classname);
void Scr_FreePathnodeFields(pathnode_t *node);
void Path_ErasePaths(const char *pathsError);
bool Path_AreBackToBackCornerNodes(pathnode_t *node, pathnode_t *otherNode);
BOOL Path_FindOverlappingNodes();
pathnode_tree_t *Path_BuildNodeBsp_r(unsigned __int16 *nodes, int numNodes);
void Path_DisconnectChokeLinks(;
bool Path_DisconnectNodeForChokePoint(;
pathlink_s *Path_DisconnectNodesOnOppositeSideOfChokeNode(;
bool Path_LinkIsDynamic(unsigned __int16 from, unsigned __int16 to);
bool Path_TwoWayLink(unsigned __int16 from, unsigned __int16 to);
char Path_FindLinkToNode_r(;
;
void Path_DisconnectLink(pathnode_t *nodeA, pathnode_t *nodeB, bool removeRedundantLinks);
pathlink_s *Path_OptimizeGraph(;
bool Path_IsSafeToMoveBetweenNodes(const pathnode_t *nodeFrom, const pathnode_t *nodeTo);
bool Path_CornerSafeLinkCheck(pathnode_t *nodeFrom, pathnode_t *nodeTo);
void Path_MarkSafeShuffleLinks();
// bool isDeflectionOK@<al>(float *a1@<edx>, float *a2@<ecx>, float a3@<xmm0>, const vec2_t *movedir);
;
;
void GetNodeAttackPoint(const pathnode_t *node, vec3_t *attackPos);
int Path_GetExpandedNodeNums_r(int iNodeStart, float fDistLeft, int *iNodeNums, int iNodeCount);
int Path_CheckExpandedNodeVis(int (*iNodeNums)[8192], int *iNodeCount, unsigned __int8 *visbuf);
void Path_BuildNodeVis(unsigned __int8 *visbuf, int iVisCacheSize);
bool Path_SmoothPathIsFloating(const vec3_t *vStart, const vec3_t *vEnd);
void Path_BuildSmoothCache(unsigned __int8 *smoothBuf, int smoothSize);
void Path_SavePaths();
bool Path_CornerNodeCheck(pathnode_t *node);
void Path_MarkValidCoverNodePeekOuts();
pathlink_s *G_GetNextAvailableTempLinks();
void Path_MakePathDataPermanent(;
int Path_LoadPathsInternal();
void Path_LoadPaths();
;
int Path_CanLinkNodes(pathnode_t *pNodeFrom, int *pbNegotiationLink);
bool Path_AttemptLink1(pathnode_t *pNodeFrom, pathnode_t *pNodeTo, pathlink_s *pLinks, int iMaxLinks);
bool Path_AttemptLink(pathnode_t *pNodeFrom, pathnode_t *pNodeTo, pathlink_s *pLinks, int iMaxLinks);
void Path_ConnectPaths();
void Path_ConnectPathsForSingleNode(pathnode_t *node);

//t6/code/src_noserver/game/scr_const.cpp
void initBoneMap();
void GScr_LoadConsts();

//t6/code/src_noserver/game/sentient.cpp
sentient_t *Sentient_Alloc(gentity_t *ent);
void Sentient_DissociateSentient(sentient_t *self, sentient_t *other);
void Sentient_GetOrigin(const sentient_t *self, vec3_t *vOriginOut);
void Sentient_GetVelocity(const sentient_t *self, vec3_t *vVelOut);
void Sentient_GetCentroid(const sentient_t *self, vec3_t *vCentroidOut);
void Sentient_GetEyePosition(const sentient_t *self, vec3_t *vEyePosOut);
void Sentient_GetThirdPersonEyePosition(const sentient_t *self, vec3_t *vEyePosOut);
void Sentient_GetDebugEyePosition(const sentient_t *self, vec3_t *vEyePosOut);
pathnode_t *Sentient_NearestNode(sentient_t *self);
pathnode_t *Sentient_NearestNodeSuppressed(sentient_t *self, PathBlockPlanes *blockPlanes);
void Sentient_InvalidateNearestNode(sentient_t *self);
void Sentient_SetEnemy(sentient_t *self, gentity_t *enemy, int bNotify, int resetThreatUpdate);
sentient_t *Sentient_FirstSentient(const int iTeamFlags);
sentient_t *Sentient_NextSentient(sentient_t *pPrevSentient, const int iTeamFlags);
const char *Sentient_NameForTeam(team_t eTeam);
void Sentient_SetTeam(sentient_t *self, team_t eTeam);
void Sentient_ClaimNode(sentient_t *self, pathnode_t *node);
void Sentient_NodeClaimRevoked(sentient_t *self, pathnode_t *node);
void Sentient_StealClaimNode(sentient_t *self, sentient_t *other);
void Sentient_BanNearNodes(sentient_t *self);
void G_InitSentients();
bool Sentient_NearestNodeDirty(sentient_t *self, bool originChanged);
int Sentient_IsEnemyIndoor(sentient_t *self);
void Sentient_Dissociate(sentient_t *pSentient);
void Sentient_Free(sentient_t *sentient);

//t6/code/src_noserver/game/sentient.h
int Sentient_EnemyTeamFlags(team_t eTeam);
// BOOL __thiscall SentientHandle::isDefined(SentientHandle *this);
// sentient_t *__thiscall SentientHandle::sentient(SentientHandle *this);
BOOL Sentient_IsEnemyTeam(sentient_t *self, sentient_t *other);

//t6/code/src_noserver/game/sentient_fields.cpp
void SentientScr_ReadOnly(sentient_t *pSelf, const sentient_fields_s *pField);
void SentientScr_GetTeam(sentient_t *pSelf);
void GScr_AddFieldsForSentient();
void Scr_SetSentientField(sentient_t *sentient, int offset);
void Scr_GetSentientField(sentient_t *sentient, int offset);
void SentientScr_SetTeam(sentient_t *pSelf);

//t6/code/src_noserver/game/turret.cpp
void Turret_RegisterDvars();
void G_InitTurrets();
void Turret_SetMinimapVisible(gentity_t *self, int isVisible);
void Fire_Lead(gentity_t *ent, gentity_t *activator, int bUseAccuracy);
void turret_shoot_internal(gentity_t *self, gentity_t *other);
void turret_UpdateSound(gentity_t *self);
void turret_CalculateConvergenceAngularVelocity(;
void Turret_ScanStart(gentity_t *self, const WeaponDef *weapDef, float deltaYaw);
void Turret_ScanStop(gentity_t *self);
void Turret_ScanForEnemies(gentity_t *self);
int turret_UpdateTargetAngles(gentity_t *self, const vec2_t *desiredAngles, int bManned);
BOOL turret_IsFiring(gentity_t *self);
void turret_SetState(gentity_t *self, int state);
void turret_ClearTargetEnt(gentity_t *self);
void turret_SetDefaultDropPitch(gentity_t *self, float pitch);
void turret_SetScanningPitch(gentity_t *self, float pitch);
// void turret_shoot(gentity_t *a1@<edx>, gentity_t *self);
int turret_CanTargetPoint(const gentity_t *self, const vec3_t *vPoint, vec3_t *vSource, vec2_t *localAngles);
void Turret_PredictPosition(const gentity_t *ent, const playerState_s *ps, vec3_t *vPos);
// int turret_CanTargetSentient@<eax>(;
void turret_aimat_vector_internal(;
int turret_aimat_vector(gentity_t *self, vec3_t *origin, int bShoot, vec2_t *desiredAngles);
void turret_SetTargetEnt(gentity_t *self, gentity_t *ent);
int turret_aimat_Sentient_Internal(;
int turret_aimat_Sentient(gentity_t *self, sentient_t *enemy, int bShoot, int missTime);
int turret_aimat_Ent(gentity_t *self, gentity_t *ent, int bShoot);
int turret_SightTrace(const vec3_t *start, const vec3_t *end, int passEnt1, int passEnt2, gentity_t *turret);
int turret_isTargetVisible(gentity_t *self, const gentity_t *target, float *distSqr);
gentity_t *turret_findBestKillstreakTarget(gentity_t *self);
gentity_t *turret_findBestGroundKillstreakTarget(gentity_t *self);
sentient_t *turret_findBestTarget(gentity_t *self);
void turret_target_sentry(gentity_t *self, TurretInfo *turretInfo);
void turret_target_killstreak(gentity_t *self, TurretInfo *turretInfo);
void turret_think_auto_nonai(gentity_t *self);
;
void turret_UpdateOverheating(gentity_t *self, gentity_t *owner);
void turret_think(gentity_t *self);
void turret_controller(const gentity_t *self, int *partBits);
int turret_behind(gentity_t *self, gentity_t *other);
// BOOL G_IsTurretUsable@<eax>(gentity_t *a1@<edx>, gentity_t *a2@<ecx>, gentity_t *self, gentity_t *owner);
void G_DeactivateTurret(gentity_t *self);
;
void SP_turret(gentity_t *self, SpawnVar *spawnVar);
void Turret_SetTurretCarried(gentity_t *self, int carried);
void Turret_SetTurretOwner(gentity_t *self, gentity_t *owner);
;
void turret_clientaim(gentity_t *self, gentity_t *other);
void turret_track(gentity_t *self, gentity_t *other);
void G_ClientStopUsingTurret(gentity_t *self);
void turret_think_client(gentity_t *self);
void turret_think_init(gentity_t *self);
void G_FreeTurret(gentity_t *self);
void turret_use(gentity_t *self, gentity_t *owner);
void Turret_ScrRemoteUse(gentity_t *self, gentity_t *owner);
void Turret_ScrStopRemoteUse(gentity_t *self, gentity_t *owner);

//t6/code/src_noserver/game/vehicle_fields.cpp
void GScr_AddFieldsForVehicle();
void Scr_SetVehicleField(gentity_t *pSelf, int offset);
void Scr_GetVehicleField(gentity_t *pSelf, int offset);
void VehicleScr_ReadOnly(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetVehicleDefField(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_SetVehicleType(gentity_t *pSelf);
void VehicleScr_GetVehicleClass(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetVehicleTreadFxArray(gentity_t *pSelf, const vehicle_fields_s *pField);
void VechicleScr_GetVehicleLightFXArray(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetTeam(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_GetPathDistanceTraveled(gentity_t *pSelf);
void VehicleScr_Clamp_0_1(gentity_t *pSelf, const vehicle_fields_s *pField);
void VehicleScr_SetTeam(gentity_t *pSelf);

//t6/code/src_noserver/game/vehicle_threat.cpp
BOOL Vehicle_CheckIgnore(sentient_t *self, sentient_t *enemy);
void DebugResetThreatStrings(const vehicle_t *self);
void DebugThreatStringAll(const vehicle_t *self, sentient_t *enemy, int threat);
void DebugThreatStringSimple(;
void DebugThreatNodes(;
// int Vehicle_ThreatFromScariness@<eax>(float a1@<xmm0>);
int Vehicle_ThreatFromDistance(const float fDistance);
int Vehicle_IsFullyAware(vehicle_t *self, sentient_t *enemy, int isCurrentEnemy);
int Vehicle_ThreatFromVisibilityAndAwareness(int isVisible, int isFullyAware, int friendlyTimingOut);
int Vehicle_ThreatBonusForCurrentEnemy(;
void Vehicle_IncrementThreatTime(vehicle_t *self);
void Vehicle_InitPotentialTarget(;
sentient_info_t *SentientInfo(vehicle_t *self, const sentient_t *enemy);
gentity_t *Vehicle_GetScriptTargetEntity(vehicle_t *self);
gentity_t *Vehicle_GetTargetEntity(vehicle_t *self);
sentient_t *Vehicle_GetTargetSentient(vehicle_t *self);
void Vehicle_PotentialThreat_Debug(vehicle_t *self);
void Vehicle_GetPerfectInfo(vehicle_t *self, sentient_t *other);
void Vehicle_UpdateNearbyEnemyInfo(vehicle_t *self, sentient_sort_t *enemyList, int enemyCount);
void GetVehicleLookAtPosition(const gentity_t *ent, const vec3_t *viewPos, vec3_t *lookAtPos);
int PointInFovAndRange(;
bool Vehicle_SightTrace(vehicle_t *self, const vec3_t *start, const vec3_t *end, int passEntNum);
bool Vehicle_CanSeePointExInternal(;
bool Vehicle_CanSeePointEx(;
void Vehicle_UpdateVisCache(vehicle_t *self, const gentity_t *ent, sentient_info_t *pInfo, bool bVisible);
char Vehicle_CanSeeEntityEx(vehicle_t *self, const gentity_t *ent, float fovDot, float fMaxDistSqrd);
char Vehicle_CanSeeEntity(vehicle_t *self, const gentity_t *ent);
char Vehicle_CanSeeSentient(vehicle_t *self, sentient_t *sentient, int iMaxLatency);
char Vehicle_RecentlySeeSentient(vehicle_t *self, sentient_t *sentient, int latency);
void Vehicle_UpdateSight(vehicle_t *self);
void Vehicle_DissociateSentient(vehicle_t *self, sentient_t *other);
void DebugLastKnownEnemyPositions(vehicle_t *self);
int Vehicle_UpdateSingleThreat(vehicle_t *self, sentient_t *enemy, float enemyDist);
void Vehicle_UpdateThreat(vehicle_t *self);
sentient_info_t *SentientInfo(actor_t *self, const sentient_t *enemy);

//t6/code/src_noserver/game_mp/bot.cpp
void Bot_PredictPosition(const gentity_t *ent, vec3_t *vPos, int numFrames);
bot_goal_t *Bot_GetCurrentGoal(bot_t *bot);
char Bot_AddGoal(;
void Bot_GoalArrive(const bot_t *bot, bot_goal_t *goal);
void Bot_GoalFailed(bot_t *bot, bot_goal_t *goal);
char G_BotGoalAdd(;
void G_BotGoalCancel(const client_t *cl, unsigned __int16 notify);
char G_BotAtGoal(const client_t *cl, unsigned __int16 notify);
char G_BotHasGoal(const client_t *cl, unsigned __int16 notify);
bool G_BotGetGoal(const client_t *cl, unsigned __int16 notify, vec3_t *vOrigin);
int G_BotGetThreats(const client_t *cl, float fov, bot_threat_t *threatList, int maxCount);
bool G_BotSightTrace(const client_t *cl, const gentity_t *ent, const vec3_t *vEnd);
bool Bot_HasLookAt(const bot_t *bot);
void G_BotDisconnect(client_t *cl);
void Bot_InvalidatePaths();
void Bot_Load(MemoryFile *memFile);
void SV_BotRegisterDvars();
void Bot_DrawString(;
// void Bot_DrawDebug(const vec4_t *a1@<ebx>, LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace);
unsigned int DrawClaimedNodes();
// float *LerpColor@<eax>(float *result@<eax>, float *a2@<ecx>, float a3@<xmm4>, const vec4_t *a);
void DrawGoalString(const client_t *cl, const vec3_t *origin, const char *txt, const vec4_t *color);
// void Bot_DrawPath(float a1@<esi>, const client_t *cl);
void Bot_DrawDangerousNode(const pathnode_t *node, const vec4_t *teamColor, team_t team);
// void Bot_DrawDangerousAreas(float a1@<esi>);
void Bot_DrawPaths();
// void Bot_DrawThreats(float a1@<esi>);
// void G_DebugBots(float a1@<esi>);
client_t *Bot_NameUsed(const char *name);
const char *SV_BotNameRandom();
const char *SV_ZombieNameRandom();
void SV_BotNameUpdate(const char *name);
void Bot_SetStance(ClientNum_t clientNum, unsigned __int16 stance);
void G_InitBots();
char Bot_UpdateFailsafe(const bot_t *bot, const playerState_s *ps, usercmd_s *cmd);
void Bot_Think(bot_t *bot, usercmd_s *cmd, const usercmd_s *lastUsercmd, float fov);
void G_BotThink(client_t *cl, usercmd_s *cmd);
bool SV_ZombieNameRandomFriend(const ControllerIndex_t controllerIndex, char *buf, const int bufLen);
void LerpColor(const vec4_t *a, const vec4_t *b, vec4_t *c, float t);

//t6/code/src_noserver/game_mp/bot.h
void Bot_Clear(bot_t *bot);
void Bot_NodeClaim(pathnode_t *pNode, const team_t team);
void Bot_NodeFree(pathnode_t *pNode, const team_t team);
void Bot_SwitchWeapon(const ClientNum_t clientNum, Weapon weapon);
void Bot_PressUseButton(const client_t *cl, int msec);
double Bot_GetLookaheadDist(const client_t *cl);
bool Bot_GetLookaheadDir(const client_t *cl, vec3_t *dir);
void Bot_PressAttackButton(const client_t *cl);
void Bot_PressFragButton(const client_t *cl);
void Bot_PressOffhandButton(const client_t *cl);
void Bot_PressJumpButton(const client_t *cl);
void Bot_LookAt(const client_t *cl, const vec3_t *vOrigin);
void Bot_ClearLookAt(const client_t *cl);
void Bot_AllowAds(const client_t *cl, int allow);
void Bot_AllowAttack(const client_t *cl, int allow);
void Bot_PressMelee(const client_t *cl);
void Bot_SetFailsafeNode(const client_t *cl, pathnode_t *node);

//t6/code/src_noserver/game_mp/bot_combat.cpp
void Bot_KickAngles(bot_t *bot);
bool Bot_IsFacingEnemy(const bot_t *bot, const gentity_t *enemy, float *dot, float *distSq, float fov);
bool Bot_ClientValidThreat(const bot_t *bot, const client_t *cl, int team);
int Bot_CompareThreats(const bot_threat_t *t1, const bot_threat_t *t2);
void Bot_UpdateWeapon(const bot_t *bot, usercmd_s *cmd);
void Bot_FireRecoil(int clientNum, vec3_t *kickAVel);
;
bool Bot_ProjectilePredict(;
bool Bot_ProjectileTrajectory(;
bool Bot_ProjectileTry(bot_t *bot, const vec3_t *target, Weapon weapon, vec3_t *outDir);
bool Bot_TryThrowGrenade(const client_t *cl, vec3_t *target, Weapon weapon);
;
bool Bot_TossGrenade(bot_t *bot, usercmd_s *cmd);
// int Bot_GetThreats@<eax>(int a1@<ebx>, const bot_t *bot, float fov, bot_threat_t *threatList, int maxCount);

//t6/code/src_noserver/game_mp/bot_navigation.cpp
void Bot_FreePathNode(const bot_t *bot, pathnode_t *node);
void Bot_ClaimPath(bot_t *bot);
void Bot_FreePath(bot_t *bot);
int Bot_GetMaxSpeed(const bot_t *bot);
bool Bot_AtNegotiationEnd(const bot_t *bot);
bool Bot_ShouldAvoid(const bot_t *bot);
void Bot_PathClear(bot_t *bot);
bool Bot_GetPathToGoal(bot_t *bot, const vec3_t *goal, pathnode_t *nodeTo, bool continueFromNegotiation);
float Bot_LerpDvars(const dvar_t *from, const dvar_t *to, float frac);
void Bot_CalcAdjustedAxis(float pitchAxis, float yawAxis, float *outPitchAxis, float *outYawAxis);
// float *Bot_ApplyTurnRates@<eax>(;
void Bot_UpdateSteeringInput(;
void Bot_UpdateSteering(bot_t *bot, usercmd_s *cmd);
void Bot_UpdateAngleWrap(bot_steering_t *steer);
const pathnode_t *Bot_FarthestSeenNode(const bot_t *bot, bool useNegotiation);
void Bot_UpdateLookahead(bot_t *bot);
;
void Bot_InvalidatePath(bot_t *bot);
bool Bot_AtNegotiationBegin(const bot_t *bot);
;
bool Bot_UpdateAvoidance(const bot_t *bot, vec3_t *vOutDir);
void Bot_UpdateMovement(bot_t *bot, usercmd_s *cmd);
void Bot_Seek(bot_t *bot, bot_goal_t *goal, usercmd_s *cmd, const usercmd_s *lastUsercmd);

//t6/code/src_noserver/game_mp/bot_navigation.h
long double Bot_AbsDeltaYaw(const bot_t *bot);

//t6/code/src_noserver/game_mp/g_active_mp.cpp
void G_PlayerStateToEntityStateExtrapolate(playerState_s *ps, entityState_s *s, int time, int snap);
void G_AddPlayerMantleBlockage(vec3_t *endPos, int duration, pmove_t *pm);
void G_DrawServerAiming(const gclient_t *client);
void G_BuildWeaponState(gclient_t *client, const viewState_t *vs, weaponState_t *ws, usercmd_s *ucmd);
void G_SaveWeaponState(const weaponState_t *ws, gclient_t *client);
void G_UpdateClientControlledMissile(const playerState_s *ps, const usercmd_s *cmd, int msec);
void G_UpdateVehicleControlledEntity(gentity_t *player);
bool ClientThink_ShouldUpdateAngleFromViewangle(gentity_t *ent);
void IntermissionClientEndFrame(gentity_t *ent);
BOOL G_ClientCanSpectateTeamOrLocalPlayer(gclient_t *client, clientState_s *cs);
BOOL G_ClientCanOnlySpectateLocalPlayer(gclient_t *client);
int G_UpdateClientInfo(gentity_t *ent);
void G_AddClientKnife(clientInfo_t *ci, playerState_s *ps);
void UpdateViewAngleLerp(gentity_t *ent);
void ClientVehicleInteraction(gentity_t *ent);
void G_PlayerVehiclePositionAndBlend(gentity_t *ent, gentity_t *pTurretEnt);
void ClientEndFrame(gentity_t *ent);
void ClientThink_real(gentity_t *ent, usercmd_s *ucmd);
void G_RunClient(gentity_t *ent);

//t6/code/src_noserver/game_mp/g_client_mp.cpp
void G_GetPlayerViewOrigin_Internal(const playerState_s *ps, vec3_t *origin, bool useBodyPosition);
void G_GetPlayerViewOrigin(const playerState_s *ps, vec3_t *origin);
void G_GetPlayerBodyViewOrigin(const playerState_s *ps, vec3_t *origin);
void G_GetPlayerViewDirection(const gentity_t *ent, vec3_t *forward, vec3_t *right, vec3_t *up);
void G_GetPlayerGunDirection(const gentity_t *ent, vec3_t *forward, vec3_t *right, vec3_t *up);
int G_GetClientServerTimeDelta(gclient_t *client);
void ClientMigrate(ClientNum_t clientNum);

//t6/code/src_noserver/game_mp/g_client_script_cmd_mp.cpp
int G_GetNeededStartAmmo(gentity_t *pSelf, Weapon weapon);
void G_InitializeAmmo(gentity_t *pSelf, Weapon weapon, unsigned __int8 weaponModel, int hadWeapon);
void PlayerCmd_setBlockWeaponPickup(scr_entref_t entref);
void PlayerCmd_giveNextBaseWeaponDEVONLY(scr_entref_t entref);
void PlayerCmd_getNormalizedMovementDEVONLY(scr_entref_t entref);
void PlayerCmd_getNormalizedCameraMovementDEVONLY(scr_entref_t entref);
void WeaponComponentListAddAllPoints(WeaponComponentList *componentList);
void WeaponComponentListToName(const WeaponComponentList *componentList, char *name, int size);
void PlayerCmd_calcWeaponOptions(scr_entref_t entref);
void PlayerCmd_calcPlayerOptions(scr_entref_t entref);
void PlayerCmd_setPlayerRenderOptions(scr_entref_t entref);
void SetBBLoadoutData(bbLoadoutData *bbData, const CACRoot *cacRoot, loadoutClass_t customClass);
void PlayerCmd_BlackboxClassChoice(scr_entref_t entref);
void PlayerCmd_NextPlayerRenderOption(scr_entref_t entref);
void PlayerCmd_SetHighlighted(scr_entref_t entref);
void PlayerCmd_IsFiring(scr_entref_t entref);
void PlayerCmd_IsMeleeing(scr_entref_t entref);
void PlayerCmd_IsSwitchingWeapons(scr_entref_t entref);
void PlayerCmd_IsReloading(scr_entref_t entref);
void PlayerCmd_IsThrowingGrenade(scr_entref_t entref);
void PlayerCmd_takeWeapon(scr_entref_t entref);
void PlayerCmd_takeAllWeapons(scr_entref_t entref);
void PlayerCmd_IsInMoveMode(scr_entref_t entref);
int ClientPlaying(gentity_t *pSelf);
void PlayerCmd_getCurrentWeapon(scr_entref_t entref);
void PlayerCmd_getCurrentWeaponAltWeapon(scr_entref_t entref);
void PlayerCmd_forceOffhandEnd(scr_entref_t entref);
void PlayerCmd_isUsingOffhand(scr_entref_t entref);
void PlayerCmd_getCurrentWeaponSpinLerp(scr_entref_t entref);
void PlayerCmd_setCurrentWeaponSpinLerp(scr_entref_t entref);
void PlayerCmd_isWeaponOverheating(scr_entref_t entref);
void PlayerCmd_setWeaponOverheating(scr_entref_t entref);
void PlayerCmd_getCurrentOffhand(scr_entref_t entref);
void PlayerCmd_setOffhandSecondaryClass(scr_entref_t entref);
void PlayerCmd_setOffhandPrimaryClass(scr_entref_t entref);
void PlayerCmd_getOffhandSecondaryClass(scr_entref_t entref);
void PlayerCmd_hasWeapon(scr_entref_t entref);
void Player_SwitchToWeapon(gentity_t *player, bool immediate);
void PlayerCmd_switchToWeapon(scr_entref_t entref);
void PlayerCmd_switchToWeaponImmediate(scr_entref_t entref);
void PlayerCmd_switchToOffhand(scr_entref_t entref);
void PlayerCmd_WeaponPlayEjectBrass(scr_entref_t entref);
void PlayerCmd_getLockOnRadius(scr_entref_t entref);
void PlayerCmd_getLockOnSpeed(scr_entref_t entref);
void PlayerCmd_giveStartAmmo(scr_entref_t entref);
void PlayerCmd_giveMaxAmmo(scr_entref_t entref);
void PlayerCmd_getFractionStartAmmo(scr_entref_t entref);
void PlayerCmd_getFractionMaxAmmo(scr_entref_t entref);
void PlayerCmd_SetWeaponHeatPercent(scr_entref_t entref);
void PlayerCmd_setOrigin(scr_entref_t entref);
void PlayerCmd_SetVelocity(scr_entref_t entref);
void PlayerCmd_setAngles(scr_entref_t entref);
void PlayerCmd_getAngles(scr_entref_t entref);
void PlayerCmd_getGunAngles(scr_entref_t entref);
void PlayerCmd_CameraActivate(scr_entref_t entref);
void PlayerCmd_CameraSetPosition(scr_entref_t entref);
void PlayerCmd_CameraSetLookAt(scr_entref_t entref);
void PlayerCmd_gamepadUsedLast(scr_entref_t entref);
void PlayerCmd_sprintUpRequired(scr_entref_t entref);
void PlayerCmd_buttonPressedDEVONLY(scr_entref_t entref);
void PlayerCmd_playerADS(scr_entref_t entref);
void PlayerCmd_pingPlayer(scr_entref_t entref);
void PlayerCmd_SetViewmodel(scr_entref_t entref);
void PlayerCmd_GetViewmodel(scr_entref_t entref);
void PlayerCmd_setSpawnWeapon(scr_entref_t entref);
void PlayerCmd_initialWeaponRaise(scr_entref_t entref);
void PlayerCmd_setEverHadWeaponAll(scr_entref_t entref);
void PlayerCmd_dropItem(scr_entref_t entref);
void PlayerCmd_dropScavengerItem(scr_entref_t entref);
void PlayerCmd_hasAGrenadePulledBack(scr_entref_t entref);
void PlayerCmd_BotAddGoal(scr_entref_t entref);
void PlayerCmd_BotCancelGoal(scr_entref_t entref);
void PlayerCmd_BotAtGoal(scr_entref_t entref);
void PlayerCmd_BotHasGoal(scr_entref_t entref);
void PlayerCmd_BotGetGoal(scr_entref_t entref);
void PlayerCmd_BotPressUseButton(scr_entref_t entref);
void PlayerCmd_BotGetLookaheadDist(scr_entref_t entref);
void PlayerCmd_BotGetLookaheadDir(scr_entref_t entref);
void PlayerCmd_BotFindThreats(scr_entref_t entref);
void PlayerCmd_BotSightTracePassed(scr_entref_t entref);
void PlayerCmd_BotSetFailsafeNode(scr_entref_t entref);
void PlayerCmd_BotPredictPosition(scr_entref_t entref);
void PlayerCmd_BotPressAttackButton(scr_entref_t entref);
void PlayerCmd_BotPressDTPButton(scr_entref_t entref);
void PlayerCmd_BotAllowAttack(scr_entref_t entref);
void PlayerCmd_BotPressMelee(scr_entref_t entref);
void PlayerCmd_BotAllowAds(scr_entref_t entref);
void PlayerCmd_BotThrowGrenade(scr_entref_t entref);
void PlayerCmd_BotLookAt(scr_entref_t entref);
void PlayerCmd_BotClearLookAt(scr_entref_t entref);
void PlayerCmd_BotSetDefaultClass(scr_entref_t entref);
void PlayerCmd_BotClassAddItem(scr_entref_t entref);
void PlayerCmd_BotClassAddAttachment(scr_entref_t entref);
void PlayerCmd_BotClassSetWeaponOption(scr_entref_t entref);
void PlayerCmd_BotLeaveGame(scr_entref_t entref);
void ForceGrenadeThrow(playerState_s *ps);
void ApplyKnockBack(gentity_t *pSelf, int damage, vec3_t *localdir, int dflags, bool allow_in_air);
void PlayerCmd_ForceGrenadeThrow(scr_entref_t entref);
void PlayerCmd_FakeDamageFrom(scr_entref_t entref);
void PlayerCmd_finishMeleeHit(scr_entref_t entref);
void PlayerCmd_UndoLastStand(scr_entref_t entref);
void PlayerCmd_Suicide(scr_entref_t entref);
BOOL LastStandPossible(gentity_t *self);
void PlayerCmd_TurnedHuman(scr_entref_t entref);
void PlayerCmd_IsSplitscreen(scr_entref_t entref);
bool IsTheSameAddr(netadr_t addr1, netadr_t addr2);
void PlayerCmd_IsPlayerOnSameMachine(scr_entref_t entref);
void PlayerCmd_PlayerKnockback(scr_entref_t entref);
void PlayerCmd_getCameraPos(scr_entref_t entref);
void PlayerCmd_getViewHeight(scr_entref_t entref);
void PlayerCmd_IsInVehicle(scr_entref_t entref);
void PlayerCmd_IsRemoteControlling(scr_entref_t entref);
void PlayerCmd_IsWeaponViewOnlyLinked(scr_entref_t entref);
void PlayerCmd_AllowStand(scr_entref_t entref);
void PlayerCmd_AllowCrouch(scr_entref_t entref);
void PlayerCmd_AllowProne(scr_entref_t entref);
void PlayerCmd_AllowLean(scr_entref_t entref);
void PlayerCmd_GetVehicleOccupied(scr_entref_t entref);
void PlayerCmd_GetFriendlies(scr_entref_t entref);
void PlayerCmd_GetEnemies(scr_entref_t entref);
void PlayerCmd_OpenMenu(scr_entref_t entref);
void PlayerCmd_OpenMenuNoMouse(scr_entref_t entref);
void PlayerCmd_CloseMenu(scr_entref_t entref);
void PlayerCmd_CloseInGameMenu(scr_entref_t entref);
void SetWeaponAmmoClipDualWield(playerState_s *ps);
void PlayerCmd_SetWeaponAmmoClip(scr_entref_t entref);
void PlayerCmd_SetWeaponAmmoStock(scr_entref_t entref);
void PlayerCmd_SetWeaponAmmoFuel(scr_entref_t entref);
void PlayerCmd_SetCurrentSpectatorClient(scr_entref_t entref);
void PlayerCmd_GetWeaponAmmoClip(scr_entref_t entref);
void PlayerCmd_GetWeaponAmmoStock(scr_entref_t entref);
void PlayerCmd_GetWeaponAmmoFuel(scr_entref_t entref);
void PlayerCmd_AnyAmmoForWeaponModes(scr_entref_t entref);
void iclientprintln(scr_entref_t entref);
void iclientprintlnbold(scr_entref_t entref);
void PlayerCmd_spawn(scr_entref_t entref);
void PlayerCmd_RemoteControlTurret(scr_entref_t entref);
void PlayerCmd_RemoteControlTurretOff(scr_entref_t entref);
// void PlayerCmd_RecordKillstreak(unsigned __int8 *a1@<edi>, scr_entref_t entref);
void PlayerCmd_RecordKillstreakEnd(scr_entref_t entref);
void PlayerCmd_RecordGameEvent(scr_entref_t entref);
void PlayerCmd_RecordKillModifier(scr_entref_t entref);
void PlayerCmd_RecordMedal(scr_entref_t entref);
void PlayerCmd_RecordLoadoutPerksAndKillStreaks(scr_entref_t entref);
void PlayerCmd_RecordMultiKill(scr_entref_t entref);
void PlayerCmd_incrementPlayerStat(scr_entref_t entref);
void PlayerCmd_RecordZombieZone(scr_entref_t entref);
void PlayerCmd_RecordPlayerDeathZombies(scr_entref_t entref);
// void PlayerCmd_RecordPlayerDownZombies(unsigned __int8 *a1@<edi>, scr_entref_t entref);
void PlayerCmd_RecordPlayerReviveZombies(scr_entref_t entref);
void PlayerCmd_setEnterTime(scr_entref_t entref);
void BodyEnd(gentity_t *ent);
void PlayerCmd_ClonePlayer(scr_entref_t entref);
void CleanStringForNetwork(const char *inString, char *outString, int outStringSize);
void SetClientDvar(scr_entref_t entref, dvar_cmd_t dvarCmd);
void PlayerCmd_SetClientAimLockonPitchStrength(scr_entref_t entref);
void PlayerCmd_SetClientAmmoCounterHide(scr_entref_t entref);
void PlayerCmd_SetClientCGObjectiveText(scr_entref_t entref);
void PlayerCmd_SetClientCompass(scr_entref_t entref);
void PlayerCmd_SetClientDrawTalk(scr_entref_t entref);
void PlayerCmd_SetClientFOV(scr_entref_t entref);
void PlayerCmd_SetClientHUDHardcore(scr_entref_t entref);
void PlayerCmd_SetClientPlayerSprintTime(scr_entref_t entref);
void PlayerCmd_SetClientMiniScoreboardHide(scr_entref_t entref);
void PlayerCmd_SetClientNumLives(scr_entref_t entref);
void PlayerCmd_SetClientPlayerPushAmount(scr_entref_t entref);
void PlayerCmd_SetClientScriptMainMenu(scr_entref_t entref);
void PlayerCmd_SetClientThirdPersonAngle(scr_entref_t entref);
void PlayerCmd_SetClientThirdPerson(scr_entref_t entref);
void PlayerCmd_SetClientProfileVar(scr_entref_t entref);
void PlayerCmd_SetClientUIVisibilityFlag(scr_entref_t entref);
void PlayerCmd_PlayClientAirstrike(scr_entref_t entref);
void PlayerCmd_PlayClientNapalm(scr_entref_t entref);
void PlayerCmd_IsTalking(scr_entref_t entref);
void PlayerCmd_FreezeControls(scr_entref_t entref);
void PlayerCmd_FreezeControlsAllowLook(scr_entref_t entref);
void PlayerCmd_AreControlsFrozen(scr_entref_t entref);
void PlayerCmd_DisableUsability(scr_entref_t entref);
void PlayerCmd_EnableUsability(scr_entref_t entref);
void PlayerCmd_DisableWeapons(scr_entref_t entref);
void PlayerCmd_EnableWeapons(scr_entref_t entref);
void PlayerCmd_DisableDeathStreak(scr_entref_t entref);
void PlayerCmd_EnableDeathStreak(scr_entref_t entref);
void PlayerCmd_DeathStreakActive(scr_entref_t entref);
void PlayerCmd_DisableOffhandWeapons(scr_entref_t entref);
void PlayerCmd_EnableOffhandWeapons(scr_entref_t entref);
void PlayerCmd_DisableWeaponCycling(scr_entref_t entref);
void PlayerCmd_EnableWeaponCycling(scr_entref_t entref);
void ScrCmd_IsLookingAt(scr_entref_t entref);
void ScrCmd_PlayLocalSound(scr_entref_t entref);
void ScrCmd_StopLocalSound(scr_entref_t entref);
void PlayerCmd_SayAll(scr_entref_t entref);
void PlayerCmd_SayTeam(scr_entref_t entref);
void PlayerCmd_AllowADS(scr_entref_t entref);
void PlayerCmd_AllowJump(scr_entref_t entref);
void PlayerCmd_AllowSprint(scr_entref_t entref);
void PlayerCmd_AllowMelee(scr_entref_t entref);
void PlayerCmd_ForceSlick(scr_entref_t entref);
void PlayerCmd_SetSprintDuration(scr_entref_t entref);
void PlayerCmd_SetSprintCooldown(scr_entref_t entref);
void PlayerCmd_SetSpreadOverride(scr_entref_t entref);
void PlayerCmd_ResetSpreadOverride(scr_entref_t entref);
void PlayerCmd_AllowSpectateTeam(scr_entref_t entref);
void PlayerCmd_GetGuid(scr_entref_t entref);
void PlayerCmd_GetXuid(scr_entref_t entref);
void PlayerCmd_IsHost(scr_entref_t entref);
void PlayerCmd_IsHostForBots(scr_entref_t entref);
void PlayerCmd_MurderLine(scr_entref_t entref);
void PlayerCmd_SetOffhandVisible(scr_entref_t entref);
void PlayerCmd_IsLocalToHost(scr_entref_t entref);
void PlayerCmd_BeginLocationTypeSelection(scr_entref_t entref, locSel_t selectionType);
void PlayerCmd_BeginLocationSelection(scr_entref_t entref);
void PlayerCmd_BeginLocationAirstrikeSelection(scr_entref_t entref);
void PlayerCmd_BeginLocationMortarSelection(scr_entref_t entref);
void PlayerCmd_BeginLocationArtillerySelection(scr_entref_t entref);
void PlayerCmd_BeginLocationComlinkSelection(scr_entref_t entref);
void PlayerCmd_BeginLocationNapalmSelection(scr_entref_t entref);
void PlayerCmd_EndLocationSelection(scr_entref_t entref);
void PlayerCmd_SetActionSlot(scr_entref_t entref);
void PlayerCmd_GetInventoryWeapon(scr_entref_t entref);
void PlayerCmd_SetInventoryWeapon(scr_entref_t entref);
void PlayerCmd_GetWeaponsList(scr_entref_t entref);
void PlayerCmd_GetWeaponsListPrimaries(scr_entref_t entref);
void PlayerCmd_StartRevive(scr_entref_t entref);
void PlayerCmd_StopRevive(scr_entref_t entref);
void PlayerCmd_ApplyKnockBack(scr_entref_t entref);
void PlayerCmd_SetPerk(scr_entref_t entref);
void PlayerCmd_HasPerk(scr_entref_t entref);
void PlayerCmd_GetPerks(scr_entref_t entref);
void PlayerCmd_UnsetPerk(scr_entref_t entref);
void PlayerCmd_ClearPerks(scr_entref_t entref);
void PlayerCmd_EnableInvulnerability(scr_entref_t entref);
void PlayerCmd_DisableInvulnerability(scr_entref_t entref);
void PlayerCmd_EnableAfterlife(scr_entref_t entref);
void PlayerCmd_DisableAfterlife(scr_entref_t entref);
void PlayerCmd_HasDLCAvailable(scr_entref_t entref);
void PlayerCmd_SetRank(scr_entref_t entref);
void PlayerCmd_SetLastStandPrevWeap(scr_entref_t entref);
void PlayerCmd_ClientSysSetState(scr_entref_t entref);
void PlayerCmd_WeaponLockStart(scr_entref_t entref);
void PlayerCmd_WeaponLockFinalize(scr_entref_t entref);
void PlayerCmd_WeaponLockFree(scr_entref_t entref);
void PlayerCmd_WeaponLockTargetTooClose(scr_entref_t entref);
void PlayerCmd_WeaponLockNoClearance(scr_entref_t entref);
void PlayerCmd_ReLinkToTurret(scr_entref_t entref);
void PlayerCmd_CarryTurret(scr_entref_t entref);
void PlayerCmd_StopCarryTurret(scr_entref_t entref);
void PlayerCmd_LinkGuidedMissileCamera(scr_entref_t entref);
void PlayerCmd_UnlinkGuidedMissileCamera(scr_entref_t entref);
void PlayerCmd_GPSJammerActive(scr_entref_t entref);
void PlayerCmd_GPSJammerInactive(scr_entref_t entref);
void PlayerCmd_DualGrenadesActive(scr_entref_t entref);
void PlayerCmd_DualGrenadesInactive(scr_entref_t entref);
void PlayerCmd_SpawnProtectionActive(scr_entref_t entref);
void PlayerCmd_SpawnProtectionInactive(scr_entref_t entref);
void PlayerCmd_LinkToMissile(scr_entref_t entref);
void PlayerCmd_UnlinkFromMissile(scr_entref_t entref);
void PlayerCmd_isCarryingTurret(scr_entref_t entref);
void PlayerCmd_CanPlayerPlaceTurret(scr_entref_t entref);
void PlayerCmd_CanPlayerPlaceVehicle(scr_entref_t entref);
void PlayerCmd_SetHeldWeaponModel(scr_entref_t entref);
void PlayerCmd_CanPlaceRiotshield(scr_entref_t entref);
void PlayerCmd_SetRiotshieldFailHint(scr_entref_t entref);
void PlayerCmd_SetPlacementHint(scr_entref_t entref);
void PlayerCmd_GetSnapshotAckIndex(scr_entref_t entref);
void PlayerCmd_GetLeagueTeamID(scr_entref_t entref);
void (*Player_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
void PlayerCmd_giveWeapon(scr_entref_t entref);
void PlayerCmd_updateWeaponOptions(scr_entref_t entref);
void PlayerCmd_giveWeaponNextAttachmentDEVONLY(scr_entref_t entref);
void PlayerCmd_useButtonPressed(scr_entref_t entref);
void PlayerCmd_ChangeSeatButtonPressed(scr_entref_t entref);
void PlayerCmd_attackButtonPressed(scr_entref_t entref);
void PlayerCmd_actionSlotOneButtonPressed(scr_entref_t entref);
void PlayerCmd_actionSlotTwoButtonPressed(scr_entref_t entref);
void PlayerCmd_actionSlotThreeButtonPressed(scr_entref_t entref);
void PlayerCmd_actionSlotFourButtonPressed(scr_entref_t entref);
void PlayerCmd_adsButtonPressed(scr_entref_t entref);
void PlayerCmd_throwButtonPressed(scr_entref_t entref);
void PlayerCmd_meleeButtonPressed(scr_entref_t entref);
void PlayerCmd_sprintButtonPressed(scr_entref_t entref);
void PlayerCmd_jumpButtonPressed(scr_entref_t entref);
void PlayerCmd_stanceButtonPressed(scr_entref_t entref);
void PlayerCmd_fragButtonPressed(scr_entref_t entref);
void PlayerCmd_secondaryOffhandButtonPressed(scr_entref_t entref);
void PlayerCmd_inventoryButtonPressed(scr_entref_t entref);
void PlayerCmd_finishPlayerDamage(scr_entref_t entref);
void PlayerCmd_RevivePlayer(scr_entref_t entref);
void PlayerCmd_Revive(scr_entref_t entref);

//t6/code/src_noserver/game_mp/g_combat_mp.cpp
void TRACK_g_combat();
void G_ParseHitLocDmgTable();
void LookAtKiller(gentity_t *self, gentity_t *inflictor, gentity_t *attacker);
meansOfDeath_t G_MeansOfDeathFromScriptParam(int scrParam);
void DeathGrenadeDrop(gentity_t *self, int meansOfDeath);
void player_die(;
double G_GetWeaponHitLocationMultiplier(hitLocation_t hitLoc, Weapon weapon);
Weapon G_GetWeaponForEntity(const gentity_t *ent);
void G_DetectLaggedDamage(gentity_t *targ, gentity_t *inflictor);
void G_DamageClient(;
void G_DamageActor(;
void G_DamageVehicle(;
void G_DamageNotify(;
void G_Damage(;
void G_ShieldNotifyAndDamage(;
double CanDamage(;
float EntDistToPoint(const vec3_t *origin, gentity_t *ent);
void AddScrTeamName(team_t team);
void GetFlashbangViewPos(gentity_t *ent, vec3_t *origin);
void GetFlashbangViewDirection(gentity_t *ent, vec3_t *dir);
void FlashbangBlastEnt(;
void G_FlashbangBlast(;
float G_GetRadiusDamageDistanceSquared(const vec3_t *damageOrigin, gentity_t *ent);
// double G_WithinDamageRadius@<st0>(;
gentity_t *G_RadiusDamage(;
unsigned __int16 G_GetHitLocationString(hitLocation_t hitLoc);
hitLocation_t G_GetHitLocationIndexFromString(unsigned __int16 sString);
void G_SensorGrenadeDetonate(gentity_t *grenadeEnt, const WeaponDef *weapDef, gentity_t *grenadeOwnerEnt);
;

//t6/code/src_noserver/game_mp/g_main_mp.cpp
int G_GetTime();
bool G_OnlyConnectingPaths();
void G_RegisterRegisterToolDvars();
void BG_RegisterServerDvars();
void *Hunk_AllocAnimStateDefServer(int size);
int G_GetClientKills(ClientNum_t clientNum);
int G_GetClientAssists(ClientNum_t clientNum);
void G_SetClientRank(ClientNum_t clientNum, int rank);
int G_GetClientRank(ClientNum_t clientNum);
int G_GetClientPrestige(ClientNum_t clientNum);
team_t G_GetClientTeam(ClientNum_t clientNum);
MatchState *G_GetMatchState();
void G_FreeEntities(bool clearTargets);
char G_LoadAnimTreeInstances();
void G_FreeAnimTreeInstances();
void G_PrintFastFileErrors(const char *fastfile);
void G_ClearLowHunk(bool hunkClear);
void G_InitGame(int levelTime, int randomSeed, int restart, int registerDvars, int savegame);
void CheckVote();
void G_UpdateObjectivesForClient(int clientNum, playerState_s *ps);
void G_UpdateObjectiveToClients();
void G_UpdateHudElemsToClients();
void G_RunThink(gentity_t *ent);
void ScriptPump();
void G_XAnimUpdateEnt(gentity_t *ent);
void G_ClientDoPerFrameNotifies(gentity_t *ent);
void G_UpdateIKCulling(gentity_t *ent);
void G_RunFrameForEntity(gentity_t *ent);
void G_UpdateIKDisableTerrainMappingTimeout(gentity_t *ent);
void G_UpdateTimedDamage(gentity_t *ent);
void G_DebugTimedDamage();
void G_UpdateWeapons(gentity_t *ent);
unsigned __int8 G_PopulateMatchState();
bool ResolveParentClientMask(const gentity_t *entChild, gentity_t *entParent);
void G_ShutdownGame(int freeScripts);
;
void G_UpdateClientLinkInfo(gentity_t *ent);
void G_RunFrame(int levelTime);

//t6/code/src_noserver/game_mp/g_misc_mp.cpp
long double G_GetEntInfoScale();
void SP_info_notnull(gentity_t *self);
void SP_light(gentity_t *self, SpawnVar *spawnVar);
void SP_info_volume(gentity_t *self);
void TeleportPlayer(gentity_t *player, vec3_t *origin, vec3_t *angles);
void EntinfoPosAndScale(gentity_t *self, vec3_t *source, vec3_t *pos, float *textScale, float *dist);
void misc_EntInfo(gentity_t *self, vec3_t *source);
void EntInfo_Trigger(gentity_t *self, vec3_t *source);
void EntInfo_Vehicle(gentity_t *self, vec3_t *source);
void EntInfo_Item(gentity_t *self, vec3_t *source);

//t6/code/src_noserver/game_mp/g_public_mp.h
// BOOL __thiscall EntHandle::isDefined(EntHandle *this);
// gentity_t *__thiscall EntHandle::ent(EntHandle *this);
// int __thiscall EntHandle::entnum(EntHandle *this);

//t6/code/src_noserver/game_mp/g_save_mp.cpp
void ConsumeSentinelBlock(MemoryFile *memFile, const int content);
void ReadField(const saveField_t *field, unsigned __int8 *base, MemoryFile *memFile);
void G_SaveError(errorParm_t code, SaveErrorType errorType, const char *fmt, ...);
void SV_LoadConfigstrings(const int first, const int count, MemoryFile *memFile);
int LoadWeapons(MemoryFile *memFile);
void G_LoadLevelBGS(MemoryFile *memFile);
int LoadClientFields(MemoryFile *memFile);
int ReadVehicleIndex(MemoryFile *memFile);
void Scr_FreeFields(const saveField_t *fields, unsigned __int8 *base);
void LoadPlayerCorpses(MemoryFile *memFile);
void ReadLerpFrame(MemoryFile *memFile, lerpFrame_t *lerpFrame);
void ReadClientInfo(MemoryFile *memFile, const ClientNum_t clientNum);
void G_LoadModelPrecacheList(MemoryFile *memFile);
void G_LoadInitState(MemoryFile *memFile);
void Scr_FreeActorFields(actor_t *pActor);
void Scr_FreeSentientFields(sentient_t *sentient);
void ReadActorPotentialCoverNodes(actor_t *pActor, MemoryFile *memFile);
void VerifySaveGame(SaveGame *saveGame, SaveHeader *header);
void G_PreLoadGame(SaveGame **saveGame, int *levelTime);
void G_ReadStruct(const saveField_t *fields, unsigned __int8 *dest, int tempsize, MemoryFile *memFile);
void ReadEntity(gentity_t *ent, SaveGame *save);
void ReadTurretInfo(TurretInfo *turret, SaveGame *save);
void ReadPathNodes(MemoryFile *memFile);
void ReadSentient(sentient_t *sentient, MemoryFile *memFile);
void ReadVehicle(vehicle_t *pVehicle, MemoryFile *memFile);
void ReadActor(actor_t *pActor, MemoryFile *memFile);
void G_LoadLevelState(SaveGame *save);
void G_LoadMainState(SaveGame *save, int scriptRunning, int demoSave);
void G_LoadGame(int checksum, SaveGame *save, int scriptRunning, int demoSave);

//t6/code/src_noserver/game_mp/g_scr_helicopter.cpp
void CMD_Heli_FreeHelicopter(scr_entref_t entref);
void CMD_Heli_SetHeliHeightLock(scr_entref_t entref);
void CMD_Heli_IsInsideHeliHeightLock(scr_entref_t entref);
void CMD_Heli_GetHeliHeightLockHeight();
void (*Helicopter_GetMethod(const char **pName, int *min_args, int *max_args))(scr_entref_t);
void Heli_InitFirstThink(gentity_t *pSelf);
void Helicopter_Pain(;
void Helicopter_Die(;
void Helicopter_Controller(const gentity_t *pSelf, int *partBits);
void Helicopter_Think(gentity_t *ent);
void CMD_Heli_SetDamageStage(scr_entref_t entref);
void G_SpawnHelicopter(gentity_t *ent, gentity_t *owner, const char *vehicleDefName, const char *modelName);

//t6/code/src_noserver/game_mp/g_scr_main_mp.cpp
unsigned int GScr_AllocString(const char *s);
void TRACK_g_scr_main();
void Scr_LoadLevel();
int GScr_LoadScriptAndLabel(;
void GScr_LoadGameTypeScript();
void GScr_LoadGameTypeScriptZombies();
void GScr_LoadSingleAnimScript(scriptInstance_t inst, scr_animscript_t *pAnim, const char *name);
void GScr_LoadDogAnimScripts(scriptInstance_t inst);
void GScr_LoadZombieAnimScripts(scriptInstance_t inst);
void GScr_LoadZombieDogAnimScripts(scriptInstance_t inst);
void *GScr_AnimscriptAlloc(int size);
void GScr_SetScriptsForPathNode(scriptInstance_t inst, pathnode_t *loadNode);
void *G_ZBarrier_Alloc(int size);
void GScr_RebuildLevelZBarrierArray();
void GScr_LoadScriptsForEntities(scriptInstance_t inst, bool bSaveGame);
char GScr_LoadLevelScript();
void GScr_LoadAnimScripts();
;
void GScr_LoadScripts(scriptInstance_t inst, bool bSaveGame);
void GScr_FreeScripts(scriptInstance_t inst);
void Scr_ValidateLocalizedStringRef(int parmIndex, const char *token, int tokenLen);
void Scr_ConstructMessageString(;
void Scr_VerifyWeaponIndex(Weapon weapon, const char *weaponName);
void Scr_GetPlayers();
void Scr_CountPlayers();
void GScr_GetDemoFileID();
void Scr_GetEntByNum();
void Scr_GetWeaponStowedModel();
void Scr_GetWeaponModel();
void GScr_GetAmmoCount(scr_entref_t entref);
void GScr_GetAnimLength();
void GScr_AnimHasNotetrack();
void GScr_GetNotetrackTimes();
void GScr_GetBrushModelCenter();
void GScr_Spawn();
void GScr_SpawnCollision();
void GScr_SpawnVehicle();
void GScr_SpawnTimedFX();
gentity_t *SpawnTurretInternal(unsigned int classname, vec3_t *origin, const char *weaponinfoname);
void GScr_SpawnTurret();
void GScr_SpawnHelicopter();
void GScr_SetTurretCarried(scr_entref_t entref);
void GScr_SetTurretMinimapVisible(scr_entref_t entref);
void GScr_SetMissleCoasting(scr_entref_t entref);
void Scr_SetWeapon(scr_entref_t entref);
void GScr_GetAnimTreesLoaded();
void GScr_FindAnimByName();
Weapon GScr_PrecacheTurret();
void GScr_GameReportThresholdExceeded();
void GScr_GibEnt(scr_entref_t entref);
char GScr_ZeroGravityVolumeOn();
char GScr_ZeroGravityVolumeOff();
void ScrCmd_SetGravity();
void ScrCmd_SetPhysParams(scr_entref_t entref);
void Scr_SetPlayerCollision(scr_entref_t entref);
void ScrCmd_ReportUser(scr_entref_t entref);
void ScrCmd_SetMoveSpeedScale(scr_entref_t entref);
void ScrCmd_GetMoveSpeedScale(scr_entref_t entref);
void ScrCmd_SetStowedWeapon(scr_entref_t entref);
void ScrCmd_ClearStowedWeapon(scr_entref_t entref);
void ScrCmd_GetStowedWeapon(scr_entref_t entref);
void ScrCmd_GetCentroid(scr_entref_t entref);
void ScrCmd_SetVisibleToPlayer(scr_entref_t entref);
void ScrCmd_SetInvisibleToPlayer(scr_entref_t entref);
void ScrCmd_SetVisibleToAll(scr_entref_t entref);
void ScrCmd_SetForceNoCull(scr_entref_t entref);
void ScrCmd_RemoveForceNoCull(scr_entref_t entref);
void ScrCmd_SetInvisibleToAll(scr_entref_t entref);
void ScrCmd_SetVisibleToTeam(scr_entref_t entref);
void ScrCmd_SetVisibleToAllExceptTeam(scr_entref_t entref);
void ScrCmd_IsLinkedTo(scr_entref_t entref);
void ScrCmd_AllowTacticalInsertion(scr_entref_t entref);
void ScrCmd_AllowBotTargetting(scr_entref_t entref);
void ScrCmd_GetLinkedEnt(scr_entref_t entref);
void ScrCmd_GetOrigin(scr_entref_t entref);
void ScrCmd_GetAngles(scr_entref_t entref);
void ScrCmd_GetMins(scr_entref_t entref);
void ScrCmd_GetMaxs(scr_entref_t entref);
void ScrCmd_GetAbsMins(scr_entref_t entref);
void ScrCmd_GetAbsMaxs(scr_entref_t entref);
void ScrCmd_GetPointInBounds(scr_entref_t entref);
void ScrCmd_GetEye(scr_entref_t entref);
void ScrCmd_GetEyeApprox(scr_entref_t entref);
void ScrCmd_UseBy(scr_entref_t entref);
void ScrCmd_IsTouching(scr_entref_t entref);
void ScrCmd_IsTouchingSwept(scr_entref_t entref);
void ScrCmd_IsTouchingVolume(scr_entref_t entref);
char ScrCmd_GetTouchingVolume();
void ScrCmd_SoundExists();
void ScrCmd_SoundGetPlaybackTime();
void ScrCmd_PlaySound(scr_entref_t entref);
void ScrCmd_PlaySoundWithNotify(scr_entref_t entref);
void ScrCmd_PlaySoundOnTag(scr_entref_t entref);
void ScrCmd_PlaySoundToTeam(scr_entref_t entref);
void ScrCmd_PlayBattleChatterToTeam(scr_entref_t entref);
void ScrCmd_PlayLoopSound(scr_entref_t entref);
void ScrCmd_StopLoopSound(scr_entref_t entref);
void ScrCmd_StopSounds(scr_entref_t entref);
void ScrCmd_PlayRumbleInternal(scr_entref_t entref, int event);
void ScrCmd_PlayRumbleOnEntity(scr_entref_t entref);
void ScrCmd_PlayRumbleLoopOnEntity(scr_entref_t entref);
void ScrCmd_StopRumble(scr_entref_t entref);
void ScrCmd_Delete(scr_entref_t entref);
void SetModelInternal(gentity_t *ent, const char *modelName);
void ScrCmd_SetModel(scr_entref_t entref);
void ScrCmd_SetEnemyModel(scr_entref_t entref);
void ScrCmd_GetNormalHealth(scr_entref_t entref);
void ScrCmd_SetNormalHealth(scr_entref_t entref);
void ScrCmd_SetMaxHealth(scr_entref_t entref);
void ScrCmd_DoDamage(scr_entref_t entref);
void ScrCmd_GetVelocity(scr_entref_t entref);
void GScr_FakeFire(scr_entref_t entref);
void GScr_SetCameraSpikeActive(scr_entref_t entref);
void ScrCmd_MakeUnusable(scr_entref_t entref);
void ScrCmd_Show(scr_entref_t entref);
void ScrCmd_Hide(scr_entref_t entref);
void ScrCmd_Ghost(scr_entref_t entref);
void ScrCmd_GhostInDemo(scr_entref_t entref);
void ScrCmd_ShowInDemo(scr_entref_t entref);
void ScrCmd_LaserOn(scr_entref_t entref);
void ScrCmd_LaserOff(scr_entref_t entref);
void ScrCmd_ShowToPlayer(scr_entref_t entref);
void ScrCmd_SetContents(scr_entref_t entref);
void GScr_StartFiring(scr_entref_t entref);
void GScr_StopFiring(scr_entref_t entref);
void GScr_ShootTurret(scr_entref_t entref);
void GScr_StopShootTurret(scr_entref_t entref);
void GScr_SetMode(scr_entref_t entref);
void GScr_GetTurretOwner(scr_entref_t entref);
void GScr_SetTargetEntity(scr_entref_t entref);
void GScr_GetTurretArcLimits(scr_entref_t entref);
void GScr_SetAiSpread(scr_entref_t entref);
void GScr_SetPlayerSpread(scr_entref_t entref);
void GScr_SetConvergenceTime(scr_entref_t entref);
void GScr_SetSuppressionTime(scr_entref_t entref);
void GScr_ClearTargetEntity(scr_entref_t entref);
void GScr_SetTurretIgnoreGoals(scr_entref_t entref);
void GScr_MakeTurretUsable(scr_entref_t entref);
void GScr_MakeTurretUnusable(scr_entref_t entref);
void GScr_SetTurretAccuracy();
void GScr_GetTurretTarget(scr_entref_t entref);
void GScr_DisconnectPaths(scr_entref_t entref);
void GScr_ConnectPaths(scr_entref_t entref);
void ScrCmd_SetStance(scr_entref_t entref);
void ScrCmd_GetStance(scr_entref_t entref);
void Scr_SetStableMissile(scr_entref_t entref);
void GScr_SetCursorHint(scr_entref_t entref);
int G_GetHintStringIndex(int *piIndex, const char *pszString);
void GScr_SetHintString(scr_entref_t entref);
void GScr_SetHintStringForPerk(scr_entref_t entref);
void GScr_SetHintLowPriority(scr_entref_t entref);
void GScr_UseTriggerRequireLookAt(scr_entref_t entref);
void GScr_TriggerIgnoreTeam(scr_entref_t entref);
void GScr_IsMartyrdomGrenade(scr_entref_t entref);
void GScr_GetEntityNumber(scr_entref_t entref);
void GScr_GetEntityType(scr_entref_t entref);
void GScr_EnableGrenadeTouchDamage(scr_entref_t entref);
void GScr_DisableGrenadeTouchDamage(scr_entref_t entref);
void GScr_MissileSetTarget(scr_entref_t entref);
void GScr_MissileDroneSetVisible(scr_entref_t entref);
void GScr_EnableAimAssist(scr_entref_t entref);
void GScr_DisableAimAssist(scr_entref_t entref);
int ObjectiveStateIndexFromString(objectiveState_t *piStateIndex, unsigned int stateString);
void SetObjectiveIcon(objective_t *obj, int paramNum);
void Scr_Objective_Add();
objective_t *Scr_Objective_Delete();
objectiveState_t Scr_Objective_State();
void Scr_Objective_Icon();
int Scr_Objective_Position();
__int16 Scr_Objective_OnEntity();
int Scr_Objective_ClearEntity();
void Scr_Objective_SetVisibleToPlayer();
int Scr_Objective_SetInvisibleToPlayer();
void Scr_Objective_SetVisibleToAll();
int Scr_Objective_SetInvisibleToAll();
void Scr_Objective_SetPlayerUsing();
int *Scr_Objective_ClearPlayerUsing();
int Scr_Objective_ClearAllUsing();
void Scr_Objective_SetProgress();
void Scr_Objective_GetGamemodeFlags();
void Scr_Objective_SetSize();
void GetNormalised2DMapPosition(vec3_t *inPos, vec2_t *outPos);
void SetArtilleryIconLocation();
void GScr_LogPrint();
void GScr_WorldEntNumber();
int GScr_Obituary();
void GScr_ReviveObituary();
void GScr_AddDemoBookmark();
void Scr_UpdateSpawnPoints();
void Scr_BoundsWouldTelefrag(vec3_t *mins, vec3_t *maxs);
void GScr_positionWouldTelefrag();
void GScr_BoundsWouldTelefrag();
void GScr_RecordUsedSpawnPoint();
void GScr_getStartTime();
void GScr_PrecacheMenu();
int GScr_GetScriptMenuIndex(const char *pszMenu);
void GScr_PrecacheStatusIcon();
int GScr_GetStatusIconIndex(const char *pszIcon);
void GScr_PrecacheHeadIcon();
int GScr_GetHeadIconIndex(const char *pszIcon);
void GScr_WeaponClipSize();
void GScr_WeaponFuelLife();
void GScr_WeaponIsSemiAuto();
void GScr_WeaponIsBoltAction();
void GScr_WeaponIsGasWeapon();
void GScr_WeaponType();
void GScr_WeaponClass();
void GScr_WeaponDisplayName();
void GScr_WeaponIsMountable();
void GScr_WeaponInventoryType();
void GScr_WeaponStartAmmo();
void GScr_WeaponMaxAmmo();
void GScr_GetWeaponSupportedAttachments();
void GScr_WeaponHasAttachment();
void GScr_GetWeaponOptic(scr_entref_t entref);
void GScr_WeaponAttachmentCount();
void GScr_GetWeaponAttachments();
void GScr_WeaponAltWeaponName();
void GScr_WeaponDualWieldWeaponName();
void GScr_WeaponIsDualWield();
void GScr_GetWatcherWeapons();
void GScr_GetRetrievableWeapons();
void GScr_GetWeaponIndexFromName();
void GScr_GetWeaponFireSound();
void GScr_GetWeaponFireSoundPlayer();
void GScr_GetWeaponPickupSound();
void GScr_GetWeaponPickupSoundPlayer();
void GScr_IsTurretFiring();
void GScr_SetDefaultDropPitch(scr_entref_t entref);
void GScr_SetScanningPitch(scr_entref_t entref);
void GScr_WeaponFireTime();
void GScr_WeaponReloadTime();
void GScr_WeaponBlocksProne();
void GScr_IsItemRestricted();
void GScr_IsWeaponClipOnly();
void GScr_IsWeaponDetonationTimed();
void GScr_PrecacheLocationSelector();
int GScr_GetLocSelIndex(const char *mtlName);
;
void Scr_BulletTracePassed();
;
void Scr_SightTracePassed();
;
;
;
void GScr_NeedsRevive(scr_entref_t entref);
void GScr_IsInSecondChance(scr_entref_t entref);
void GScr_SetBurn(scr_entref_t entref);
void GScr_SetWorldFogActiveBank(scr_entref_t entref);
void GScr_SetElectrified(scr_entref_t entref);
void GScr_UseWeaponHideTags(scr_entref_t entref);
void GScr_StartTanning(scr_entref_t entref);
void GScr_SetWaterDrops(scr_entref_t entref);
void GScr_StopBurning(scr_entref_t entref);
void GScr_SpawnNapalmGroundFlame(scr_entref_t entref);
void GScr_RestoreDefaultDropPitch(scr_entref_t entref);
void GScr_IsFiringTurret(scr_entref_t entref);
void GScr_IsTurretLockedOn(scr_entref_t entref);
void GScr_ShootUp(scr_entref_t entref);
void GScr_GetWaterHeight();
void GScr_DepthInWater(scr_entref_t entref);
void GScr_DepthOfPlayerInWater(scr_entref_t entref);
int Scr_PrecacheModel();
void Scr_PrecacheShellShock();
void Scr_PrecacheItem();
int Scr_PrecacheShader();
const char *Scr_PrecacheString();
int Scr_PrecacheRumble();
;
void GScr_RadiusDamageInternal(gentity_t *inflictor);
void __thiscall GScr_RadiusDamage(gentity_t *this);
void GScr_EntityRadiusDamage(scr_entref_t entref);
void GScr_GlassRadiusDamage();
// void GScr_Detonate(float a1@<edi>, scr_entref_t entref);
int GScr_SetPlayerIgnoreRadiusDamage();
void GScr_DamageConeTraceInternal(scr_entref_t entref, int contentMask);
void GScr_DamageConeTrace(scr_entref_t entref);
void GScr_SightConeTrace(scr_entref_t entref);
void GScr_PlayerSightTrace(scr_entref_t entref);
void GScr_HeliTurretSightTrace(scr_entref_t entref);
void GScr_HeliTurretDogTrace(scr_entref_t entref);
void GScr_VisionSetLerpRatio(scr_entref_t entref);
void GScr_DirectionalHitIndicator(scr_entref_t entref);
void GScr_SendKillstreakDamageEvent(scr_entref_t entref);
void GScr_DoCowardsWayAnims(scr_entref_t entref);
void GScr_StartPoisoning(scr_entref_t entref);
void GScr_StopPoisoning(scr_entref_t entref);
void GScr_StartBinocs(scr_entref_t entref);
void GScr_StopBinocs(scr_entref_t entref);
void GScr_IsFlared(scr_entref_t entref);
void GScr_IsPoisoned(scr_entref_t entref);
void GScr_GetMoveDelta();
void GScr_GetAngleDelta();
void GScr_GetNorthYaw();
void Scr_SetFxAngles(int givenAxisCount, vec3_t *axis, vec3_t *angles);
void Scr_LoadFX();
void Scr_FxParamError(int paramIndex, const char *errorString, int fxId);
void Scr_PlayFX();
void Scr_PlayFXOnTag();
void Scr_PlayLoopedFX();
void Scr_SpawnFX();
int Scr_TriggerFX();
void Scr_FXBlockSight();
void ScrCmd_SpawnActor(scr_entref_t entref);
void Scr_PredictSpawnPoint(scr_entref_t entref);
void GScr_CreateDynEntAndLaunch();
void Scr_PhysicsExplosionSphere();
void Scr_AreTexturesLoaded();
void Scr_CreateStreamerHint();
void Scr_PhysicsRadiusJolt();
void Scr_PhysicsExplosionCylinder();
void Scr_PhysicsJetThrust();
void Scr_SetFog(;
void Scr_SetExponentialFog();
void Scr_SetVolumetricFog();
void Scr_SetCullDist();
void Scr_VisionSetNaked();
void Scr_VisionSetNight();
void Scr_VisionSetLastStand();
void GScr_IsPlayerNumber();
void GScr_SetWinningPlayer();
void GScr_SetWinningTeam();
void GScr_Announcement();
void GScr_ClientAnnouncement();
void GScr_GetTeamScore();
void GScr_SetTeamScore();
int GScr_SetTeamHasMeat();
void GScr_SetClientNameMode();
void GScr_UpdateClientNames();
void GScr_GetTeamPlayersAlive();
void GScr_GetDroppedWeapons();
void GScr_GetNumParts();
void GScr_GetPartName();
gentity_t *GScr_Earthquake();
void GScr_ShellShock(scr_entref_t entref);
void GScr_StopShellShock(scr_entref_t entref);
int GScr_UpdateTagInternal(;
void GScr_GetWeaponForwardDir(scr_entref_t entref);
void GScr_GetWeaponMuzzlePoint(scr_entref_t entref);
void GScr_GetTagOrigin(scr_entref_t entref);
void GScr_GetTagAngles(scr_entref_t entref);
void GScr_GetEntnum(scr_entref_t entref);
void GScr_SetDepthOfField(scr_entref_t entref);
void GScr_SetViewModelDepthOfField(scr_entref_t entref);
void GScr_ViewKick(scr_entref_t entref);
void GScr_LocalToWorldCoords(scr_entref_t entref);
void GScr_SetRightArc(scr_entref_t entref);
void GScr_SetLeftArc(scr_entref_t entref);
void GScr_SetTopArc(scr_entref_t entref);
void GScr_SetBottomArc(scr_entref_t entref);
;
void ScrCmd_SendFaceEvent(scr_entref_t entref);
;
void GScr_MapRestart();
void GScr_MissionFailed();
void GScr_LoadMap();
void GScr_ExitLevel();
void GScr_KillServer();
void GScr_AddTestClient();
void GScr_SetPlayerCurrentStreak(scr_entref_t entref);
void GScr_SetBombTimer();
int GScr_SetRoundsPlayed();
void GScr_SetInitialPlayersConnected();
void GScr_SetMatchTalkFlag();
void GScr_SetMatchFlag();
void GScr_AllClientsPrint();
void GScr_MapExists();
void GScr_SetVoteString();
void GScr_SetVoteTime();
void GScr_SetVoteYesCount();
void GScr_SetVoteNoCount();
void GScr_KickPlayer();
void GScr_BanPlayer();
void GScr_ClientPrint();
gentity_t *Scr_PlayRumbleOnPosition();
gentity_t *Scr_PlayRumbleLoopOnPosition();
gentity_t *Scr_StopAllRumbles();
void Scr_IsSplitscreen();
void Scr_IsLocalGame();
void Scr_IsGlobalStatsServer();
void GScr_RecordLeagueWinner();
char GScr_SkillUpdate();
char GScr_SetPlayerStatsForMatchRecording();
void GScr_SetPlayerFinalForMatchRecording();
;
void GScr_GetAssignedTeam();
void GScr_GetCustomTeamName();
void GScr_UploadLeaderboards(scr_entref_t entref);
void GScr_IsItemPurchased(scr_entref_t entref);
void GScr_IsItemLocked(scr_entref_t entref);
void GScr_GetRefFromItemIndex();
void GScr_GetItemGroupFromItemIndex();
void GScr_GetBaseWeaponItemIndex();
void GScr_GetGameTypeEnumFromName();
const CACRoot *Scr_GetCACRoot(const CACRoot *result, const gentity_t *ent, loadoutClass_t loadoutClass);
bool ItemRestricted(int clientNum, int itemIndex);
bool IsBonusCardInUse(ClientNum_t clientNum, int itemIndex, loadoutClass_t classNum, bonusCards_t bonusCard);
int GScr_GetLoadoutItemIndex(scr_entref_t entref);
void GScr_IsBonusCardActive(scr_entref_t entref);
void GScr_GetLoadoutItem(scr_entref_t entref);
void GScr_GetLoadoutItemRef(scr_entref_t entref);
void GScr_GetLoadoutWeapon(scr_entref_t entref);
void GScr_GetLoadoutPerks(scr_entref_t entref);
void GScr_GetLoadoutAllocation(scr_entref_t entref);
void GScr_GetFogSettings();
void GScr_EnableOccluder();
void GScr_GetItemAttachment();
void GScr_GetItemAttachmentAllocationCost();
void GScr_GetDefaultClassSlot();
void GScr_GetDate();
void GScr_SetPerkForTrigger(scr_entref_t entref);
void GScr_SetIgnoreEntForTrigger(scr_entref_t entref);
void GScr_ClientClaimTrigger(scr_entref_t entref);
void GScr_ClientReleaseTrigger(scr_entref_t entref);
void GScr_ReleaseClaimedTrigger(scr_entref_t entref);
void GScr_SetMapCenter();
void GScr_SetDemoIntermissionPoint();
void GScr_isTestClient(scr_entref_t entref);
void GScr_SetGameEndTime();
int ScrCmd_SetSlowMotion();
void GScr_NumRemoteClients();
void GScr_SetMiniMap();
int GScr_SetTeamSpyplane();
void GScr_GetTeamSpyplane();
int GScr_SetTeamSatellite();
void GScr_GetTeamSatellite();
void GScr_recordNumZombieRounds();
void GScr_recordGameResult();
void GScr_recordMatchSummaryZombieEndGameData();
void GScr_recordMatchSummaryZombieRoundStart();
void GScr_recordMatchSummaryZombieRoundEnd();
void GScr_recordMatchInit();
void GScr_matchRecorderIncrementHeaderStat();
void GScr_EndLobby();
void GScr_MagicBullet();
void GScr_MagicGrenade(scr_entref_t entref);
void GScr_LaunchBomb(scr_entref_t entref);
void GScr_MakeGrenadeDud(scr_entref_t entref);
void GScr_IsOnLadder(scr_entref_t entref);
void GScr_IsOnSlide(scr_entref_t entref);
void GScr_IsMantling(scr_entref_t entref);
void GScr_StopDoorBreach(scr_entref_t entref);
void GScr_StartRagdoll(scr_entref_t entref);
void GScr_IsRagdoll(scr_entref_t entref);
void GScr_RagdollLaunch(scr_entref_t entref);
void GScr_VehicleLaunch(scr_entref_t entref);
void GScr_SetBlur(scr_entref_t entref);
void GScr_ResetMissileDetonationTime(scr_entref_t entref);
void GScr_GiveAchievement(scr_entref_t entref);
void GScr_SetEntityWeapon(scr_entref_t entref);
void GScr_SetTurretType(scr_entref_t entref);
void GScr_GetTeam(scr_entref_t entref);
void GScr_GetCorpseAnim(scr_entref_t entref);
void ScrCmd_ItemWeaponSetAmmo(scr_entref_t entref);
void Scr_AddStruct();
void Scr_ResetTimeout();
void GScr_ClientSysRegister();
void GScr_ClientSysSetState();
void Scr_GetSnapshotIndexArray();
void Scr_SnapshotAcknowledged();
void GScr_IsAI();
void GScr_GetAITriggerFlags();
void GScr_IsVehicle();
void GScr_GetMaxVehicles();
void ScrCmd_GetShootAtPosition(scr_entref_t entref);
void GScr_DisableDestructiblePieces();
void GScr_EnableAllDestructiblePieces();
;
void GScr_SetSpawnPointRandomVariation();
void GScr_ClearSpawnPointsBaseWeight();
void GScr_SetSpawnPointsBaseWeight();
void GScr_AddSpawnPoints();
void GScr_GetSortedSpawnPoints();
void GScr_GetPlayerSpawnId();
void GScr_IsSpawnPointVisible();
void InfluencerTypeValidation(int type, gentity_t *ent, const char *function_name);
void GScr_SetSpawnClientFlag(scr_entref_t entref);
void GScr_PredictGrenade(scr_entref_t entref);
void GScr_AddSphereInfluencer();
void GScr_AddCylinderInfluencer();
void GScr_RemoveInfluencer();
void GScr_EnableInfluencer();
void GScr_SetInfluencerTeamMask();
void GScr_CollisionTestPointsInSphere();
void GScr_CollisionTestPointsInCylinder();
void GScr_CollisionTestPointsInPill();
void GScr_CollisionTestPointsInCone();
;
void GScr_QSortScoredSpawnPointArrayAscending();
void GScr_Matrix4x4TransformPoints();
void GScr_GetWeaponMinDamageRange();
void GScr_GetWeaponMaxDamageRange();
void GScr_GetWeaponMinDamage();
void GScr_GetWeaponMaxDamage();
void GScr_GetWeaponExplosionRadius();
void GScr_IsWeaponDisallowedAtMatchStart();
void GScr_IsWeaponSpecificUse();
void GScr_IsWeaponEquipment();
void GScr_IsWeaponPrimary();
void GScr_IsWeaponScopeOverlay();
void GScr_GetPregameClass();
void GScr_RecordLeaguePreLoser(scr_entref_t entref);
void GScr_LUINotifyEventToSpectators(scr_entref_t entref);
void GScr_PixBeginEvent();
char CScr_PixEndEvent();
void GScr_PixMarker();
void GScr_ChangeAdvertisedStatus();
void GScr_IncrementCounter();
void GScr_GetCounterTotal();
void GScr_SetScoreboardColumns();
void GScr_SetNemesisXuid(scr_entref_t entref);
void GScr_ReloadOnWiiUmote();
int GScr_SetHostMigrationStatus();
void GScr_StartHostMigration();
void GScr_PrecacheAnimStateDef();
void GScr_RegisterClientField();
void GScr_GetFieldSetForEntityType(gentity_t *pEnt, int *pFieldSet, void **pData);
void GScr_CodeSetClientField();
void GScr_CodeSetPlayerStateClientField();
void GScr_CodeSetWorldClientField();
void GScr_CodeGetClientField();
void GScr_CodeGetPlayerStateClientField();
void GScr_CodeGetWorldClientField();
void GScr_GetClientFieldVersion();
void GScr_GetUTCTime();
void Scr_ScriptMoversUseAnimTree();
void GScr_DisableZombies();
void GScr_EnableZombies();
void (*Scr_GetFunction(const char **pName, int *type, int *min_args, int *max_args))();
void GScr_SetClientFlag(scr_entref_t entref);
void GScr_GetClientFlag(scr_entref_t entref);
void GScr_ClearClientFlag(scr_entref_t entref);
void GScr_SetZombieName(scr_entref_t entref);
void Scr_SetPlayerGravity(scr_entref_t entref);
void Scr_ClearPlayerGravity(scr_entref_t entref);
void Scr_SetEntGravityTrajectory(scr_entref_t entref);
void GScr_IsInsideHeightLock(scr_entref_t entref);
void GScr_IsOnGround(scr_entref_t entref);
void GScr_GetGroundEnt(scr_entref_t entref);
void GScr_GetMoverEnt(scr_entref_t entref);
void GScr_IsSprinting(scr_entref_t entref);
void GScr_HandleAnimError(int error);
XAnimTree_s *GScr_GetEntAnimTree(gentity_t *ent);
void GScr_SetAnimInternal(scr_entref_t entref, unsigned int flags);
void GScr_SetAnim(scr_entref_t entref);
void G_SetAnimTree(gentity_t *ent, scr_animtree_t *animtree);
void GScr_UseAnimTree(scr_entref_t entref);
void ScrCmd_animscriptedInternal(scr_entref_t entref, int bDelayForActor);
void Scr_AnimRelative(scr_entref_t entref);
void ScrCmd_animscripted(scr_entref_t entref);
void ScrCmd_animscriptedskiprestart(scr_entref_t entref);
void ScrCmd_animrelative(scr_entref_t entref);
void GScr_SetEntityAnimRate(scr_entref_t entref);
void GScr_GetEntityAnimRate(scr_entref_t entref);
void GScr_IsZBarrier(scr_entref_t entref);
void GScr_GetNumZBarrierPieces(scr_entref_t entref);
void GScr_GetZBarrierPieceState(scr_entref_t entref);
void GScr_SetZBarrierPieceState(scr_entref_t entref);
void GScr_IsZBarrierOpen(scr_entref_t entref);
void GScr_IsZBarrierClosed(scr_entref_t entref);
void GScr_SetZBarrierColModel(scr_entref_t entref);
void GScr_HideZBarrierPiece(scr_entref_t entref);
void GScr_ShowZBarrierPiece(scr_entref_t entref);
void GScr_ZBarrierPieceUseDefaultModel(scr_entref_t entref);
void GScr_ZBarrierPieceUseAlternateModel(scr_entref_t entref);
void GScr_ZBarrierPieceUseBoxRiseLogic(scr_entref_t entref);
void GScr_ZBarrierPieceUseUpgradedModel(scr_entref_t entref);
void GScr_GetUpgradedPieceNumLives(scr_entref_t entref);
void GScr_GetZBarrierPieceIndicesInState(scr_entref_t entref);
void GScr_GetZBarrierPieceAnimLengthForState(scr_entref_t entref);
void GScr_GetZBarrierPieceAnimState(scr_entref_t entref);
void GScr_GetZBarrierPieceAnimSubState(scr_entref_t entref);
void GScr_ZBarrierSupportsZombieTaunts(scr_entref_t entref);
void GScr_ZBarrierSupportsZombieReachThroughAttacks(scr_entref_t entref);
void GScr_GetZBarrierTauntAnimState(scr_entref_t entref);
void GScr_GetZBarrierReachThroughAttackAnimState(scr_entref_t entref);
void GScr_GetZBarrierNumAttackSlots(scr_entref_t entref);
void GScr_GetZBarrierAttackSlotHorzOffset(scr_entref_t entref);
void DumpAnimCommand(;
void (*BuiltIn_GetMethod(const char **pName, int *type, int *min_args, int *max_args))(scr_entref_t);
void (*Scr_GetMethod(const char **pName, int *type, int *min_args, int *max_args))(scr_entref_t);
void Scr_SetOrigin(gentity_t *ent);
void Scr_SetAngles(gentity_t *ent);
void Scr_SetExposureIndex(gentity_t *ent);
void Scr_SetExposureLerpToLighter(gentity_t *ent);
void Scr_SetExposureLerpToDarker(gentity_t *ent);
void Scr_SetHealth(gentity_t *ent);
void GScr_AddEntity(gentity_t *pEnt);
void Scr_ParseGameTypeList_LoadObj();
void Scr_ParseGameTypeList_FastFile();
void Scr_ParseGameTypeList();
char *Scr_GetGameTypeNameForScript(const char *pszGameTypeScript);
BOOL Scr_IsValidGameType(const char *pszGameType);
void Scr_LoadGameType();
void Scr_StartupGameType();
void Scr_FinalizeInitialization();
void Scr_PlayerConnect(gentity_t *self);
void Scr_PlayerDisconnect(gentity_t *self);
void Scr_PlayerDamage(;
void Scr_PlayerKilled(;
void Scr_PlayerMelee(;
void Scr_ActorDamage(;
void Scr_ActorKilled(;
void Scr_VehicleRadiusDamage(;
void Scr_VehicleDamage(;
void Scr_PlayerLastStand(;
void Scr_PlayerMigrated(gentity_t *self);
void Scr_HostMigration();
void GScr_Shutdown();
void Scr_GlassSmash(const vec3_t *pos, const vec3_t *dir);
void GScr_SpawnPlane();
void ScrCmd_SetZombieShrink(scr_entref_t entref);
void ScrCmd_MakeUsable(scr_entref_t entref);
void GScr_SetTurretTeam(scr_entref_t entref);
void GScr_SetFOVForKillcam(scr_entref_t entref);
void GScr_SetReviveHintString(scr_entref_t entref);
void G_InitObjectives();
int Scr_Objective_SetGamemodeFlags();
int GScr_Objective_Team();
int GScr_Objective_VisibleTeams();
;
void GScr_UseWeaponModel(scr_entref_t entref);
void GScr_IsValidGameType();
void GScr_SetTeamForTrigger(scr_entref_t entref);
void GScr_SetExcludeTeamForTrigger(scr_entref_t entref);
void GScr_BloodImpact(scr_entref_t entref);
void GScr_SetOwner(scr_entref_t entref);
void GScr_SetMissileOwner(scr_entref_t entref);
void GScr_SetTurretOwner(scr_entref_t entref);
void GScr_SetTeam(scr_entref_t entref);
void GScr_ClearAnim(scr_entref_t entref);
void G_StopAnimScripted(gentity_t *ent, bool getScriptedBlend);
void ScrCmd_stopanimscripted(scr_entref_t entref);
void Scr_AddStruct(scriptInstance_t inst);
void Scr_ResetTimeout(scriptInstance_t inst);

//t6/code/src_noserver/game_mp/g_spawnsystem_mp.cpp
void SpawnSystem_ArchiveClientPosData(ClientNum_t clientNum, SpawnClientData *sc);
int SpawnSystem_GetPlayerSpawnId(gentity_t *ent);
void SpawnSystem_ArchiveInfluencer(SpawnInfluencer *influencer, int sortedIndex);
void SpawnSystem_ArchiveInfluencersPrepData(gentity_t *ent, bool bManualSpawn);
void SpawnSystem_RegisterDvars();
void SpawnSystem_Init(bool restart);
void SpawnSystem_Demo_ClearClientBuffer(int clientNum);
void SpawnSystem_Demo_SendClientBuffer(int clientNum);
void SpawnSystem_ClearPoints();
gentity_t *SpawnSystem_GetEntity(const unsigned __int16 *targetname);
char SpawnSystem_AddPoint(int team, gentity_t *ent);
void SpawnSystem_ClearPointsBaseWeight(int teammask);
void SpawnSystem_SetPointsBaseWeight(;
void SpawnSystem_InsertSortedInfluencer(SpawnInfluencer *influencer);
void SpawnSystem_RemoveSortedInfluencer(SpawnInfluencer *influencer);
void SpawnSystem_CalculateCylinderAxis(SpawnInfluencer *influencer);
void SpawnSystem_CalculateCylinderAxisMidpoint(SpawnInfluencer *influencer);
SpawnInfluencerPreset *SpawnSystem_FindPreset(;
SpawnInfluencerPreset *SpawnSystem_SetPresetData(;
void SpawnSystem_InitInfluencer(;
int SpawnSystem_AddSphereInfluencer(;
char SpawnSystem_RemoveInfluencer(int influencer_index);
char SpawnSystem_EnableInfluencer(int influencer_index, bool enabled);
char SpawnSystem_SetInfluencerTeamMask(int influencer_index, int team_mask);
void SpawnSystem_ClearEntityInfluencers(gentity_t *ent);
void __thiscall SpawnSystem_ClearTimedOutInfluencers(SpawnInfluencer *this);
double SpawnSystem_InfluenceWeight(;
double SpawnSystem_ComputeSphereInfluence(SpawnInfluencer *influencer, SpawnPoint *point);
double SpawnSystem_ComputeCylinderInfluence(SpawnInfluencer *influencer, SpawnPoint *point);
bool SpawnSystem_ComputePointWeight(;
int SpawnSystem_ComputePointWeights(;
void SpawnSystem_DisableLowestScorePoints(int team, int shouldDisable);
bool SpawnSystem_SpotWouldTelefrag(vec3_t *vPos, vec3_t *otherPos);
void SpawnSystem_ArchiveManualSpawn(;
int SpawnSystem_GetSortedPointCount(int team);
int SpawnSystem_GetSortedPointEntNum(int team, int index);
;
char SpawnSystem_IsSpawnPointVisible(;
char SpawnSystem_IsSpawnPointVisible(;
void SpawnSystem_SetSpawnClientFlag(int clientNum, int flags);
void SpawnSystem_DemoBadSpawn(;
void SpawnSystem_RegisterPlayerDamage(gentity_t *ent, gentity_t *enemy, Weapon weapon);
void SpawnSystem_ArchiveInfluencers(gentity_t *ent, int point_team, int influencer_team);
;
void SpawnSystem_UpdateCylinderInfluencer(SpawnInfluencer *influencer);
int SpawnSystem_AddCylinderInfluencer(;
void SpawnSystem_UpdateInfluencerBounds();
void SpawnSystem_UpdateInfluencerOriginAngles();
int SpawnSystem_CheckDangerousPoints(;
void SpawnSystem_Cmd_User_BadSpawn(gentity_t *ent);
void SpawnSystem_SortPoints();
void __thiscall SpawnSystem_Update(SpawnInfluencer *this);
void SpawnSystem_SortPointsByScore(int team);
// int SpawnSystem_UpdateSpawnPointsForPlayer@<eax>(;
void SpawnSystem_Load(MemoryFile *memFile);

//t6/code/src_noserver/game_mp/g_spawn_mp.cpp
int G_SpawnFloat(const SpawnVar *spawnVar, const char *key, const char *defaultString, float *out);
int G_SpawnInt(const SpawnVar *spawnVar, const char *key, const char *defaultString, int *out);
void Scr_ReadOnlyField();
void G_FreeEntityWrapper(gentity_t *ent);
unsigned int G_SetEntityScriptVariableInternal(const char *key, const char *value);
unsigned int G_SpawnStruct(SpawnVar *spawnVar);
void G_DuplicateScriptFields(gentity_t *dest, const gentity_t *source);
Weapon G_GetItemForClassname(const char *classname);
char IsClientOnlyEntity(const SpawnVar *spawnVar);
int G_CallSpawnEntity(gentity_t *ent);
void GScr_AddFieldsForEntity();
void GScr_AddFieldsForRadiant();
void Scr_FreeEntityConstStrings(gentity_t *pEnt);
void Scr_FreeEntity(gentity_t *ent);
void Scr_AddEntity(scriptInstance_t inst, gentity_t *ent);
gentity_t *Scr_GetEntityAllowNull(unsigned int index, scriptInstance_t inst);
gentity_t *Scr_GetEntity(unsigned int index);
void Scr_FreeHudElem(game_hudelem_s *hud);
void Scr_AddHudElem(game_hudelem_s *hud);
unsigned __int16 Scr_ExecEntThread(gentity_t *ent, int handle, unsigned int paramcount);
void Scr_Notify(gentity_t *ent, unsigned __int16 stringValue, unsigned int paramcount);
void Scr_GetEnt();
void Scr_GetGenericSpawnerArray(int offset, unsigned int name);
void Scr_GetEntArray();
void Scr_GetDamageableEntArray();
void SP_worldspawn(SpawnVar *spawnVar);
void G_LoadStructs();
void G_ParseEntityFields(const SpawnVar *spawnVar, gentity_t *ent, int radiant_update);
void G_DuplicateEntityFields(gentity_t *dest, const gentity_t *source);
void G_SetupDestructible(gentity_t *ent, const char *destructibleName);
void G_SetupDestructible(gentity_t *ent, SpawnVar *spawnVar);
gentity_t *G_CallSpawn(SpawnVar *spawnVar);
void GScr_SetGenericField(;
void GScr_GetGenericField(unsigned __int8 *b, fieldtype_t type, int ofs, unsigned int whichbits);
void G_SpawnEntitiesFromString();
int Scr_SetEntityField(int entnum, int offset);
// int Scr_SetObjectField@<eax>(int a1@<edx>, unsigned int classnum, int entnum, int offset);
void Scr_GetEntityField(int entnum, int offset);
void Scr_GetObjectField(unsigned int classnum, int entnum, int offset);

//t6/code/src_noserver/game_mp/g_trigger_mp.cpp
void G_Trigger(gentity_t *self, gentity_t *other);
bool InitTrigger(gentity_t *self);
void InitSentientTrigger(gentity_t *self);
void Touch_Multi(gentity_t *self, gentity_t *other);
void SP_trigger_multiple(gentity_t *ent, SpawnVar *spawnVar);
void init_trigger_radius(gentity_t *ent, float radius, float height);
void SP_trigger_radius(gentity_t *ent, SpawnVar *spawnVar);
// void SP_trigger_radius_use(float a1@<esi>, gentity_t *ent, SpawnVar *spawnVar);
void init_trigger_box(gentity_t *ent, const vec3_t *radius);
void SP_trigger_box(gentity_t *ent, SpawnVar *spawnVar);
void SP_trigger_box_use(gentity_t *ent, SpawnVar *spawnVar);
void SP_trigger_disk(gentity_t *ent, SpawnVar *spawnVar);
void hurt_touch(gentity_t *self, gentity_t *other);
void hurt_use(gentity_t *self);
void SP_trigger_hurt(gentity_t *self, SpawnVar *spawnVar);
void SP_trigger_once(gentity_t *ent);
BOOL Respond_trigger_damage(gentity_t *pEnt, int iMOD);
void Activate_trigger_damage(gentity_t *pEnt, gentity_t *pOther, int iDamage, int iMOD);
void Use_trigger_damage(gentity_t *pEnt);
void Pain_trigger_damage(;
void Flame_trigger_damage(;
void Die_trigger_damage(gentity_t *pSelf, gentity_t *pInflictor, gentity_t *pAttacker, int iDamage, int iMod);
void SP_trigger_damage(gentity_t *pSelf, SpawnVar *spawnVar);
void G_CheckHitTriggerDamage(;
void G_GrenadeTouchTriggerDamage(gentity_t *pActivator, vec3_t *vStart, vec3_t *vEnd, int iDamage, int iMOD);
void SP_trigger_lookat(gentity_t *self);
void trigger_ik_playerclip_terrain_touch(gentity_t *ent, gentity_t *other);
void SP_trigger_ik_playerclip_terrain(gentity_t *self);
void trigger_ik_disable_terrain_mapping_touch(gentity_t *ent, gentity_t *other);

//t6/code/src_noserver/game_mp/g_utils_mp.cpp
void G_ClearCachedModels();
int G_FindConfigstringIndex(const char *name, int start, int max, int create, const char *errormsg);
int G_LocalizedStringIndex(const char *string);
void ClearRegisteredLeaderboards();
void SaveRegisteredLeaderboards();
int G_MaterialIndex(const char *name);
unsigned int G_ModelIndex(const char *name);
XModel *G_GetModel(int index);
bool G_GetModelBounds(int index, vec3_t *outMins, vec3_t *outMaxs);
unsigned int G_ModelName(int index);
void G_EntityCentroid(const gentity_t *ent, vec3_t *centroid);
void G_GetEntityBoundsPoint(;
void G_EntityNearestBoxPoint(const gentity_t *ent, const vec3_t *vOrigin, vec3_t *vClosest);
int G_TagIndex(const char *name);
int G_EffectIndex(const char *name);
int G_ShellShockIndex(const char *name);
int G_RumbleIndex(const char *name);
XAnimTree_s *G_GetEntAnimTree(gentity_t *ent);
void G_SetModel(gentity_t *ent, const char *modelName);
void G_SetModelIfLoaded(gentity_t *ent, const char *modelName);
void G_OverrideModel(int modelIndex, const char *defaultModelName);
void G_DObjUpdateServerTime(gentity_t *ent, int bNotify, void (*CallbackFunc)());
void G_DObjCalcPose(gentity_t *ent, int *partBits);
void G_DObjCalcBone(const gentity_t *ent, int boneIndex);
DObjAnimMat *G_DObjGetLocalTagMatrix(const gentity_t *ent, unsigned int tagName);
int G_DObjGetWorldTagMatrix(const gentity_t *ent, unsigned int tagName, vec3_t *tagMat);
int G_DObjGetWorldTagPos(const gentity_t *ent, unsigned int tagName, vec3_t *pos);
DObjAnimMat *G_DObjGetLocalBoneIndexMatrix(const gentity_t *ent, int boneIndex);
void G_DObjGetWorldBoneIndexPos(const gentity_t *ent, int boneIndex, vec3_t *pos);
void G_DObjGetWorldBoneIndexMatrix(const gentity_t *ent, int boneIndex, vec3_t *tagMat);
gentity_t *G_Find(gentity_t *from, int fieldofs, unsigned __int16 match);
void G_InitGentity(gentity_t *e);
void G_PrintEntities();
gentity_t *G_SpawnStaticEntity(int start, int range, const char *entity_type);
gentity_t *G_SpawnTurret(int a1, int a2);
gentity_t *G_SpawnActor(int a1, int a2);
gentity_t *G_Spawn();
void G_ClearGroundEntity(gentity_t *ent);
void G_ClearGroundEntityRefs(gentity_t *ed);
void G_FreeEntityDelay(gentity_t *ed);
void G_BroadcastEntity(gentity_t *ent);
void G_FreeEntityAfterEvent(gentity_t *ent);
void G_AddEvent(gentity_t *ent, int event, unsigned int eventParm);
void G_RegisterSoundWait(gentity_t *ent, unsigned int index, unsigned int notifyString);
void G_SetOrigin(gentity_t *ent, const vec3_t *origin);
void G_SetAngle(gentity_t *ent, const vec3_t *angle);
void G_SetConstString(unsigned __int16 *to, const char *from);
const char *G_GetEntityTypeName(const gentity_t *ent);
BOOL G_IsSpeciesDog(int species);
BOOL G_IsBigDog(gentity_t *gent);
BOOL CG_IsSpeciesBigDog(int species);
BOOL G_SpeciesUsesNonGenericAnimtree(int species);
BOOL G_SpeciesCanUseNegotiations(int species);
void G_srand(unsigned int seed);
unsigned int *G_GetRandomSeed();
unsigned int G_rand();
double G_flrand(float min, float max);
int G_irand(int min, int max);
double G_random();
double G_crandom();
void G_UpdateVehicleAttachedModels(gentity_t *ent);
void G_UpdateScriptMoverAttachedModels(gentity_t *ent);
void G_ClientDObjUpdate(gentity_t *ent);
void G_DObjUpdate(gentity_t *ent);
void G_PlayerCorpseDObjUpdate(gentity_t *ent);
void G_DObjLoad(gentity_t *ent);
int G_EntDetach(gentity_t *ent, const char *modelName, unsigned int tagName);
void G_EntDetachAll(gentity_t *ent);
void G_TraceBulletPathForVehTurret(gentity_t *ent, DObjTrace_s *trace, int gunnerIndex);
gentity_t *G_SpawnVehicle(int a1, int a2);
void G_FreeEntityRefs(gentity_t *ed);
void G_FreeEntity(gentity_t *ed);
gentity_t *G_TempEntity(const vec3_t *origin, int event);
gentity_t *G_PlaySoundAliasAtPoint(const vec3_t *origin, unsigned int alias);
gentity_t *G_PlaySoundAlias(gentity_t *ent, unsigned int alias, unsigned int notifyString, unsigned int bone);
// gentity_t *G_PlaySoundAliasWithNotify@<eax>(;
void G_AnimScriptSound(ClientNum_t client, SndAliasList *aliasList);
int G_EntAttach(gentity_t *ent, const char *modelName, unsigned int tagName, int ignoreCollision);
gentity_t *G_SpawnPlayerClone();
gentity_t *G_SpawnActorClone();
void G_SpawnVehicle(gentity_t *ent, const char *typeName, int load);
void G_SpawnTurret(gentity_t *self, const char *weaponinfoname, SpawnVar *spawnVar);

//t6/code/src_noserver/game_mp/player_use_mp.cpp
void Player_UseEntity(gentity_t *playerEnt, gentity_t *useEnt);
bool Player_ActivateCmd(gentity_t *ent, bool allowWeaponPickup);
char Player_IsPlayerUsingTurretNearby(gentity_t *ent);
char Player_EntityBlocksTacticalInsertion(const gentity_t *player);
bool Player_ActivateHoldCmdAllowed(gentity_t *ent);
void Player_ActivateDoubleTapCmd(gentity_t *ent);
bool trigger_skip_team(gentity_t *trigger, int team);
bool uselist_skip_team(gentity_t *trigger, int team);
int Player_GetItemCursorHint(const gclient_t *client, const gentity_t *traceEnt);
void Player_SetTurretDropHint(gentity_t *ent);
gentity_t *Player_UpdateLookAtEntityTrace(;
void Player_ActivateHoldCmd(gentity_t *ent);
void Player_UpdateActivate(gentity_t *ent);
// void Player_UpdateLookAtEntity(vec3_t *a2@<edi>, gentity_t *ent);
char *Player_GetUseList(gentity_t *ent, useList_t *useList, int prevHintEntIndex);
void Player_UpdateCursorHints(gentity_t *ent);

//t6/code/src_noserver/game_mp/savememory_mp.cpp
SaveGame *SaveMemory_GetSaveHandle(SaveHandleType type);
SaveGame *SaveMemory_GetHeader(SaveGame *save);
MemoryFile *SaveMemory_GetMemoryFile(SaveGame *save);
unsigned int SaveMemory_CalculateChecksum(SaveGame *save);
void SaveMemory_MoveToSegment(SaveGame *save, int index);

//t6/code/src_noserver/gfx_d3d/rb_backend.cpp
void TRACK_rb_backend();
void RB_SetIdentity();
void R_SetVertex2d(GfxVertex *vert, float x, float y, float s, float t, unsigned int color);
void RB_DrawFullSceneTri(const Material *material, unsigned __int8 scene);
void RB_TessAddQuadIndices(unsigned int vertCount);
void RB_DrawSW4Quads(const Material *material, int ParticleCount);
void RB_DrawStretchPic(;
void RB_DrawStretchPicW(;
void RB_DrawStretchPicZ(;
void RB_DrawStretchPicFlipST(;
void RB_DrawStretchPicRotate(;
void RB_DrawFullScreenColoredQuad(;
void RB_FullScreenColoredFilter(const Material *material, unsigned int color);
void RB_FullScreenFilterWithFlag(const Material *material, int filterFlags);
void RB_FullScreenFilter(const Material *material);
void RB_SplitScreenTexCoords(float x, float y, float w, float h, float *s0, float *t0, float *s1, float *t1);
void RB_SplitScreenFilter(const Material *material, const GfxViewInfo *viewInfo, unsigned int color);
void R_Resolve(GfxCmdBufContext context, GfxImage *image);
void R_ResolveFloatZ(GfxCmdBufContext context);
void RB_StretchPicCmd(GfxRenderCommandExecState *execState);
// void RB_StretchPicCmdFlipST(unsigned int a1@<edx>, GfxRenderCommandExecState *execState);
void RB_StretchPicRotateXYCmd(GfxRenderCommandExecState *execState);
void RB_StretchPicRotateSTCmd(GfxRenderCommandExecState *execState);
void RB_DrawQuadPicCmd(GfxRenderCommandExecState *execState);
void RB_DrawQuadList2DCmd(GfxRenderCommandExecState *execState);
void RB_SetUIStencilState(;
void RB_DrawUIQuadsInternal(;
void RB_DrawEmblemLayer(GfxRenderCommandExecState *execState);
void RB_StretchCompositeCmd(GfxRenderCommandExecState *execState);
void RB_DrawFullScreenColoredQuadCmd(GfxRenderCommandExecState *execState);
void TessQuad(unsigned __int16 v0, unsigned __int16 v1, unsigned __int16 v2, unsigned __int16 v3);
void RB_DrawFramedCmd(GfxRenderCommandExecState *execState);
void RB_ConstantSetCmd(GfxRenderCommandExecState *execState);
unsigned int R_RenderDrawSurfStaticModelListMaterial(;
unsigned int R_RenderDrawSurfBspListMaterial(;
unsigned int R_RenderDrawSurfListMaterial(const GfxDrawSurfListArgs *listArgs);
void R_SetCustomCodeConstants(GfxCmdBufContext context);
void R_DrawSurfs(GfxCmdBufContext context, const GfxDrawSurfListInfo *info);
void R_DrawSurfsBsp(GfxCmdBufContext context, const GfxDrawSurfListInfo *info);
void R_DrawSurfsStaticModel(GfxCmdBufContext context, const GfxDrawSurfListInfo *info);
void RB_ClearScreenCmd(GfxRenderCommandExecState *execState);
// void RB_SetGammaRamp(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
void RB_BlendSavedScreenFlashedCmd(GfxRenderCommandExecState *execState);
void RB_DrawPoints2D(const GfxCmdDrawPoints *cmd);
void RB_DrawPoints3D(const GfxCmdDrawPoints *cmd);
void RB_DrawPointsCmd(GfxRenderCommandExecState *execState);
void RB_DrawLines2D(int count, int width, const GfxPointVertex *verts);
void RB_DrawLines3D(int count, int width, const GfxPointVertex *verts, bool depthTest);
void RB_DrawLinesCmd(GfxRenderCommandExecState *execState);
void RB_DrawTriangles_Internal(;
void RB_DrawUIQuadsCmd(GfxRenderCommandExecState *execState);
void RB_DrawUIQuadsReplaceImageCmd(GfxRenderCommandExecState *execState);
void RB_DrawUITrianglesCmd(GfxRenderCommandExecState *execState);
void RB_DrawTrianglesCmd(GfxRenderCommandExecState *execState);
void RB_SetCustomConstantCmd(GfxRenderCommandExecState *execState);
void RB_SetMaterialColorCmd(GfxRenderCommandExecState *execState);
void RB_BeginViewCmd(GfxRenderCommandExecState *execState);
void RB_SetViewportCmd(GfxRenderCommandExecState *execState);
void RB_SetScissorCmd(GfxRenderCommandExecState *execState);
void RB_ResolveCompositeCmd(GfxRenderCommandExecState *execState);
void RB_PCCopyImageGenMIPCmd(GfxRenderCommandExecState *execState);
void RB_LookupColor(unsigned __int8 c, unsigned __int8 *color);
float RB_DrawHudIcon(;
float RB_DrawButton(;
int RB_DrawChar(;
void RB_DrawCursor(;
void GlowColor(GfxColor *result, GfxColor baseColor, GfxColor forcedGlowColor, int renderFlags);
bool SetupFadeinFXVars(;
bool SetupCOD7DecodeFXVars(;
char SetupTypewriterFXVars(;
char SetupPopInFXVars(;
bool SetupPulseFXVars(;
void GetShiftColor(;
bool SetupRedactTextFXVars(;
void SetupRedactFXVars(;
void GetDecayingStringAlphaInfo(;
void GetDecayingLetterInfo(;
void DrawTextFxExtraCharacter(;
;
void DrawTeleType(;
void RB_DrawText(;
void RB_DrawCharInSpace(;
void RB_DrawTextInSpace(;
void RB_DrawText2DCmd(GfxRenderCommandExecState *execState);
void RB_DrawText3DCmd(GfxRenderCommandExecState *execState);
void RB_ProjectionSetCmd(GfxRenderCommandExecState *execState);
_NvAPI_Status RB_SwapBuffers();
void RB_EndFrame(unsigned int drawType);
void RB_ExecuteRenderCommandsLoop(const void *cmds, int *ui3dTextureWindow);
void RB_Draw3D();
void RB_CallExecuteRenderCommands();
void RB_SetBspImages();
void RB_SaveScreen_BlendBlurred(const GfxBlendSaveScreenBlurredParam *p);
void RB_SaveScreen_BlendFlashed(const GfxBlendSaveScreenFlashedParam *p);
// void RB_SaveScreen(int a1@<esi>, const GfxSaveScreenParam *p);
void R_DrawSurfsDepthOnly(GfxCmdBufContext context, const GfxDrawSurfListInfo *info);
void RB_Filter(const Material *material, const GfxViewInfo *viewInfo);
void RB_BeginFrame(const void *data);

//t6/code/src_noserver/gfx_d3d/rb_backend.h
void RB_CheckTessOverflow(int vertexCount, int indexCount);

//t6/code/src_noserver/gfx_d3d/rb_corona.cpp
void RB_TessCoronaBillboard(Corona *corona, GfxColor color, float radius, int query);
void RB_DrawCoronaQuerySprite(Corona *corona);
GfxLightCorona *RB_FindBestCoronaToSpawn(CoronaState *state);
void RB_SpawnCorona(Corona *corona, GfxLightCorona *info);
void RB_PromoteCorona(CoronaState *state, Corona *corona);
void RB_DrawCorona(Corona *corona, int frameTime, const Material *coronaMat);
void RB_DrawCoronas(LocalClientNum_t localClientNum);
void RB_ResetCoronas();
void RB_DrawWaypoint(;

//t6/code/src_noserver/gfx_d3d/rb_debug.cpp
void TRACK_rb_debug();
int RB_AddDebugLine(;
int RB_EndDebugLines(int vertCount, const GfxPointVertex *verts);
void RB_SetPolyVert(const vec3_t *xyz, GfxColor color, int tessVertIndex);
void RB_DrawPolyInteriors(PolySet *polySet);
void RB_DrawPolyOutlines(PolySet *polySet);
const GfxBackEndData *RB_DrawDebugPolys();
void RB_DrawDebugSphere(trDebugSphere_t *sphere);
void RB_DrawDebugSpheres(trDebugSphere_t *spheres, int sphereCount);
void RB_DrawDebugLines(trDebugLine_t *lines, int lineCount, GfxPointVertex *verts);
void RB_DrawDebugStrings(trDebugString_t *strings, int stringCount);
// void RB_AddPlumeStrings(float a1@<edi>, const GfxViewParms *viewParms);
void RB_SetDebugBrushesAndPatchesCallback(void (*callback)());
void RB_DrawDebug(const GfxViewParms *viewParms);
void RB_ApplySunLight(const vec3_t *verts, const vec4_t *color, vec4_t *out_color);
void RB_BeginCollisionPolygons(bool faceDepthTest, bool faceBlend);
void RB_DrawCollisionPolygon(;
materialCommands_t *RB_GetCmd();
;

//t6/code/src_noserver/gfx_d3d/rb_depthprepass.cpp
void R_DepthPrepassCallback(const void *userData, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DepthPrepass(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
// void RB_DrawDepthPrepassCommandBuffer(int a1@<esi>, const GfxBackEndData *data, const GfxViewInfo *viewInfo);
void R_DrawDepthCmd(DrawDepthWorkerCmd *cmd);

//t6/code/src_noserver/gfx_d3d/rb_draw3d.cpp
void RB_DrawWaypoints(const LocalClientNum_t localClientNum, const GfxViewInfo *viewInfo);
void R_CalcGameTimeVec(float gameTime, vec4_t *out);
void R_ShowTris(GfxCmdBufContext context, const GfxDrawSurfListInfo *info);
void RB_CompositeSceneGroup();
void RB_EndSceneRendering(;
void R_RunCommandBuffer(const GfxBackEndData *data, GfxCmdBuf *cmdBuf);
void R_SetAndClearSceneTarget(const GfxViewport *viewport, const GfxViewInfo *viewInfo);
void R_DrawFullbrightLitCallback(const void *__formal, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawFullbrightDecalCallback(const void *__formal, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawFullbrightEmissiveCallback(;
void R_DrawFullbrightOrDebugShader(;
void R_DrawFullbright(const GfxViewInfo *viewInfo, GfxCmdBufInput *input, GfxCmdBuf *cmdBuf);
void RB_FullbrightDrawCommands(const GfxViewInfo *viewInfo);
int RB_FullbrightDrawCommandsCommon();
void R_DrawDebugShaderLitCallback(const void *__formal, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawDebugShaderDecalCallback(;
void R_DrawDebugShaderEmissiveCallback(;
void RB_DebugShaderDrawCommands(const GfxViewInfo *viewInfo);
const GfxBackEndData *RB_DebugShaderDrawCommandsCommon();
void RB_SetFrameBufferAlpha();
void R_DrawEmissiveOpaqueCallback(const void *__formal, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawEmissiveOpaque(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
void R_DrawEmissiveFXCallback(const void *userData, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawEmissiveFX(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
void R_DrawEmissiveFX(const GfxViewInfo *a1, GfxCmdBuf *a2);
void R_DrawViewmodelFX(const GfxViewInfo *a1, GfxCmdBuf *a2);
void R_DrawPostBlur(const GfxViewInfo *viewInfo, unsigned __int8 renderTarget);
void R_DrawSuperflare(;
void R_ResolveDistortion(const GfxViewInfo *viewInfo);
void RB_StandardRenderCommands(const GfxViewInfo *viewInfo);
void RB_SonarRenderToTexture(const GfxBackEndData *data, const GfxViewInfo *viewInfo);
unsigned int RB_DrawLitCommandBuffer(;
void RB_DrawMiscCommandBuffer(;
void RB_DrawWaypoints(const GfxViewInfo *viewInfo, unsigned __int8 renderTarget);
void RB_StandardDrawCommands_ClearScreen(const GfxViewInfo *viewInfo, const GfxBackEndData *data);
void RB_UI3D_DebugDisplay();
void RB_ExtraCam_DebugDisplay(const GfxBackEndData *data);
void RB_QRCodeImages_DebugDisplay();
void RB_DrawSonarDebugText(const GfxViewInfo *firstViewInfo, unsigned int numViewInfos);
void RB_DrawLODScaleDebugText();
int RB_StandardDrawCommandsCommon();
void RB_Draw3DCommon();
void RB_StandardDrawCommands(const GfxViewInfo *viewInfo);
void RB_Draw3DInternal();
void R_DrawPostBlur(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf, unsigned __int8 renderTarget);

//t6/code/src_noserver/gfx_d3d/rb_fog.cpp
// void R_SetFrameFog(float a1@<esi>, GfxCmdBufInput *input, const vec4_t *viewOrigin);

//t6/code/src_noserver/gfx_d3d/rb_imagefilter.cpp
void RB_VirtualToSceneRadius(float radius, float *radiusX, float *radiusY);
int RB_GaussianFilterPoints1D(;
// int *RB_GenerateGaussianFilter1D@<eax>(int a1@<esi>, float pixels@<xmm0>, int *res, int axis);
void RB_GenerateGaussianFilter2D(;
int RB_GenerateGaussianFilterChain(;
void RB_SetupFilterPass(const GfxImageFilterPass *filterPass);
void RB_FilterPingPong(const GfxImageFilter *filter, int passIndex);
// void RB_FilterImage(int a1@<edx>, GfxImageFilter *filter);
void RB_GaussianFilterImage(float radius, unsigned __int8 srcRenderTargetId, unsigned __int8 dstRenderTargetId);
void RB_GaussianFilter(;

//t6/code/src_noserver/gfx_d3d/rb_imagetouch.cpp
int RB_CompareTouchImages(const void *e0, const void *e1);
void RB_TouchAllImages();

//t6/code/src_noserver/gfx_d3d/rb_light.cpp
void R_CalculateLightGridColorFromCoeffs(const __m128 *coeffs, const vec3_t *dir, vec4_t *energy);
void R_DecodeLightGridCoeffsWeighted(;
// unsigned __int8 *R_DecodeLightGridColorsWeighted@<eax>(int a1@<eax>, int a2@<ecx>, float a3@<xmm0>);
void R_ComputeLightGridAverageAndVisibility(;
void R_ShowGridBox(const unsigned int *pos);
void R_ShowGridCorner(;
void R_ShowLightGrid(;
void R_SetLightGridColorsFromIndex(;
void R_BlendAndSetLightGridColors(;
void R_SetBlackLightGridColors(unsigned __int16 dest, float *destVis, GfxLightingSH *destSH);
void R_SetDebugLightGridColors(unsigned __int16 dest, float *destVis, GfxLightingSH *destSH);
bool R_LookupSkyGridVolumesAtPoint(;
unsigned __int8 R_ExtrapolateLightingAtPoint(;
unsigned __int8 R_ExtrapolateAverageLightingAtPoint(;
void R_GetLightGridSampleEntryQuad(;
bool R_IsValidLightGridSample(;
unsigned __int8 R_LightGridLookup(;
unsigned int R_GetLightingAtPoint(;
void R_GetAverageLightingAtPoint(;

//t6/code/src_noserver/gfx_d3d/rb_postfx.cpp
bool RB_UsingElectrifiedFX(const GfxViewInfo *viewInfo);
bool RB_UsingTransportedFX(const GfxViewInfo *viewInfo);
bool RB_UsingWaterSheetingFX(const GfxViewInfo *viewInfo);
bool RB_UsingDepthOfFieldFX(const GfxViewInfo *viewInfo);
bool RB_UsingGenericFilter(const GfxViewInfo *viewInfo);
int RB_FindActivePostFX(const GfxViewInfo *viewInfo);
;
void RB_CreateVisionLut(const GfxViewInfo *viewInfo);
void RB_SetBloomRemapConstants(GfxBloom bloom);
void RB_SSAO(const GfxViewInfo *viewInfo);
;
BOOL R_UsingDoubleVision(const GfxViewInfo *viewInfo);
void RB_PoisonFX(const GfxViewInfo *viewInfo);
;
void RB_FlameFX(const GfxViewInfo *viewInfo);
void RB_ElectrifiedFX(const GfxViewInfo *viewInfo);
void RB_TransportedFX(const GfxViewInfo *viewInfo);
void RB_WaterSheetingFX(const GfxViewInfo *viewInfo);
void RB_GetSceneDepthOfFieldEquation(;
float RB_GetDepthOfFieldBlurFraction(const GfxViewInfo *viewInfo, float pixelRadiusAtSceneRes);
void RB_DepthOfFieldFX(const GfxViewInfo *viewInfo);
void RB_DepthOfFieldHDR(GfxViewInfo *viewInfo, int mode);
// void RB_ReviveFX(__m128 a2@<xmm6>, const GfxViewInfo *viewInfo);
void RB_BlurSceneFX(const GfxViewInfo *viewInfo);
// void RB_AdditionalPostFX(__m128 a1@<xmm6>, const GfxViewInfo *viewInfo);
void RB_BloomLDR(const GfxViewInfo *viewInfo);

//t6/code/src_noserver/gfx_d3d/rb_query.cpp
unsigned int RB_CalcOcclusionQuerySamples();
void RB_TessRectBillboard(;
float RB_GetSampleRectRelativeArea(const vec3_t *position, int widthInPixels, int heightInPixels);
void RB_UpdateVisibilityWithoutQuery(OcclusionQuery *occlusionQuery);
void RB_DrawOcclusionQueries(LocalClientNum_t localClientNum);
void R_GetOcclusionQueryUsage(int *queryTotalCount, int *queryInUseCount);
void RB_FreeOcclusionQuery(unsigned __int16 handle);
void RB_SetOcclusionQueryPosition(unsigned __int16 handle, const vec3_t *position);
double RB_GetOcclusionQueryVisibility(unsigned __int16 handle);
// unsigned __int16 RB_AllocOcclusionQuery@<ax>(;

//t6/code/src_noserver/gfx_d3d/rb_query_d3d.h
void RB_HW_BeginOcclusionQuery(ID3D11Query *query);
unsigned int RB_HW_ReadOcclusionQuery(ID3D11Query *query);

//t6/code/src_noserver/gfx_d3d/rb_shade.cpp
void RB_ClearPixelShader();
void RB_ClearVertexShader();
void RB_ClearVertexDecl();
void R_BeginPixMaterial(GfxCmdBufState *state);
void R_EndPixMaterial(GfxCmdBufState *state);
void R_SetPixPrimarySortKey(GfxCmdBufState *state, unsigned int primarySortKey);
void R_BeginPixMaterials(GfxCmdBufState *state);
void R_EndPixMaterials(GfxCmdBufState *state);
void R_DrawTessTechnique(GfxCmdBufContext context, const GfxDrawPrimArgs *args);
void RB_BeginSurface(const Material *material, unsigned __int8 techType, TessPrimType primType);
void RB_EndSurfaceEpilogue();
void RB_DrawTessSurface();
void RB_EndTessSurface();
void RB_TessOverflow();
void RB_SetTessTechnique(const Material *material, unsigned __int8 techType);

//t6/code/src_noserver/gfx_d3d/rb_showcollision.cpp
void TRACK_rb_showcollision();
void BuildFrustumPlanes(const GfxViewParms *viewParms, cplane_s *frustumPlanes);
void RB_DrawCollisionPoly(int numPoints, vec3_t *points, const vec4_t *colorFloat);
void RB_ShowCollision(const GfxViewParms *viewParms);

//t6/code/src_noserver/gfx_d3d/rb_sky.cpp
GfxVertex *RB_SetTessQuad(GfxColor color);
void TRACK_rb_sky();
float R_UpdateOverTime(float fCurrent, float fGoal, int iFadeInTime, int iFadeOutTime, int frametime);
void RB_DrawSunFlareCore(vec4_t *colorTint, float alpha, float sizeIn640x480);
void RB_DrawSunFlare(vec4_t *colorTint, SunFlareDynamic *sunFlare, int frameTime);
void RB_CalcSunBlind(SunFlareDynamic *sunFlare, int frameTime, float *blind, float *glare);
void RB_AddSunEffects(SunFlareDynamic *sunFlare);
void RB_DrawBlindAndGlare(SunFlareDynamic *sunFlare, int frameTime);
void RB_DrawSun(LocalClientNum_t localClientNum);
void RB_DrawSunPostEffects(;

//t6/code/src_noserver/gfx_d3d/rb_spotshadow.cpp
void R_DrawSpotShadowMapCallback(const void *userData, GfxCmdBufContext context);
void R_DrawSpotShadowMap(;
void RB_SpotShadowMaps(const GfxBackEndData *data, const GfxViewInfo *viewInfo);
void RB_DrawSpotShadowOverlay();

//t6/code/src_noserver/gfx_d3d/rb_state.cpp
void TRACK_rb_state();
void RB_InitSceneViewport();

//t6/code/src_noserver/gfx_d3d/rb_stats.cpp
const char *RB_Stats_GetStageName(GfxPrimStatsStage s);
const char *RB_Stats_GetTargetName(GfxPrimStatsTarget t);
int RB_GetCounterSum(;
void RB_TrackStageBegin(GfxFrameStats *stats, GfxPrimStatsStage stage);
void RB_TrackStageEnd(GfxFrameStats *stats);
void RB_TrackPrimsBegin(GfxFrameStats *stats, GfxPrimStatsTarget target);
void RB_TrackPrimsEnd(GfxFrameStats *stats);
void RB_TrackDrawPrimCall(GfxFrameStats *stats, int triCount);
void RB_TrackDrawSurfMat(GfxFrameStats *stats, int surfCount, int matCount);
void RB_TrackDrawDynamic(GfxFrameStats *stats, int dynamicIndexCount, int dynamicVertexCount);
void RB_TrackDrawStatic(GfxFrameStats *stats, int staticIndexCount, int staticVertexCount);
void RB_TrackGeoIndex(GfxFrameStats *stats, int geoIndexCount);
void RB_TrackFxIndex(GfxFrameStats *stats, int fxIndexCount);
void RB_Stats_Accumulate(GfxFrameStats *dest, const GfxFrameStats *src);

//t6/code/src_noserver/gfx_d3d/rb_sunshadow.cpp
void TRACK_rb_sunshadow();
void RB_SunShadowMaps(const GfxBackEndData *data, const GfxViewInfo *viewInfo);
void RB_GetShadowOverlayDepthBounds(float *nearDepth, float *farDepth);
int RB_SetSunShadowOverlayScaleAndBias();
void RB_DrawSunShadowOverlay();

//t6/code/src_noserver/gfx_d3d/rb_tess.cpp
void RB_ShowTess(GfxCmdBufContext context, const vec3_t *center, const char *tessName, const vec4_t *color);
void R_SetVertexDeclTypeNormal(GfxCmdBufState *state, MaterialVertexDeclType vertDeclType);
void R_SetVertexDeclTypeWorldSurface(GfxCmdBufState *state);
void R_SetVertexDeclTypeModelLit(const XSurface *surf, GfxCmdBufState *state);
void R_SetVertexDeclTypeModel(const XSurface *surf, GfxCmdBufState *state);
void R_TessCodeMeshList_AddCodeMeshArgs(;
// void R_SetObjectIdentityPlacement(const GfxScaledPlacement *a1@<edx>, GfxCmdBufSourceState *source);
unsigned int R_TessCodeMeshList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessRopeMeshList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessGlassMeshList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessMarkMeshList(const GfxDrawSurfListArgs *listArgs);
void RB_Vec3DirWorldToView(const GfxCmdBufSourceState *source, const vec3_t *worldDir, vec3_t *viewDir);
void RB_CreateParticleCloud2dAxis(const GfxParticleCloud *cloud, const vec3_t *viewUp, vec2_t *viewAxis);
void R_SetParticleCloudConstants(;
unsigned int R_TessParticleCloudList(const GfxDrawSurfListArgs *listArgs);
void R_DrawXModelSkinnedCached(GfxCmdBufContext context, const GfxModelSkinnedSurface *modelSurf);
void R_DrawXModelSkinnedUncached(;
void R_DrawXModelSkinnedModelSurf(GfxCmdBufContext context, const GfxModelSkinnedSurface *modelSurf);
;
unsigned int R_TessXModelRigidDrawSurfList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessXModelRigidSkinnedDrawSurfList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessStaticModelRigidList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessStaticModelSkinnedDrawSurfList(const GfxDrawSurfListArgs *listArgs);
unsigned int R_TessTrianglesList(const GfxDrawSurfListArgs *listArgs);
void R_SetBModelPlacement(;
unsigned int R_TessBModel(const GfxDrawSurfListArgs *listArgs);

//t6/code/src_noserver/gfx_d3d/r_add_bsp.cpp
unsigned int R_GetVisLightsMask(;
void R_InitBspDrawSurfRegions(;
void R_AddAllBspDrawSurfacesRangeCamera(;
void R_AddAllBspDrawSurfacesCameraNonlit(;
void R_AddAllBspDrawSurfacesCamera(;
void R_SortAllBspSurfacesCamera(int addAllList);
void R_AddAllBspDrawSurfacesRangeSunShadow(;
void R_SortAllBspSurfacesSunShadow();
void R_InitBspDrawSurfSunShadow(;
void R_AddAllBspDrawSurfacesSunShadow(;
void R_AddAllBspDrawSurfacesSpotShadow(;

//t6/code/src_noserver/gfx_d3d/r_add_bsp.h
void R_InitBspDrawSurf(GfxBspDrawSurfData *surfData, const GfxViewParms *viewParms);
void R_AddBspDrawSurfs(;

//t6/code/src_noserver/gfx_d3d/r_add_cmdbuf.h
void R_EndDelayedCmdBuf(GfxDelayedCmdBuf *delayedCmdBuf);
int R_AllocDrawSurf(;
void R_WritePrimDrawSurfInt(GfxDelayedCmdBuf *delayedCmdBuf, unsigned int value);
void R_WritePrimDrawSurfData(GfxDelayedCmdBuf *delayedCmdBuf, const void *data, unsigned int count);

//t6/code/src_noserver/gfx_d3d/r_add_staticmodel.cpp
void R_SkinStaticModelsShadowForLod(;
void R_SkinStaticModelsShadow(;
void R_ShowCountsStaticModel(int smodelIndex, int lod);
GfxStaticModelId R_GetStaticModelId(int smodelIndex, int lod);
void R_StaticModelWriteInfoHeader(int fileHandle);
void R_StaticModelWriteInfo(int fileHandle, const GfxStaticModelDrawInst *smodelDrawInst, const float dist);
void R_DumpStaticModelLodInfo(const GfxStaticModelDrawInst *smodelDrawInst, const float dist);
unsigned int R_GetSModelDLightMask(;
void R_SetupSModelDrawSurfLightingDataForCamera(;
void R_StaticModelDebugAids(;
void R_SortAllStaticModelSurfacesCamera();
void R_AddAllStaticModelSurfacesRangeSunShadow(;
void R_SortAllStaticModelSurfacesSunShadow();
// void R_AddAllStaticModelSurfacesSunShadow(unsigned int a1@<edx>, int viewIndex);
void R_AddAllStaticModelSurfacesSpotShadow(;
void R_FixupSmodelCullOutDists();
void R_FixupSmodelCullOutDists(const XModel *model, const vec3_t *origin, float newCullDist);
void R_StaticModelCameraDistSort(unsigned __int16 *list, float *dists, unsigned int count);
void R_SkinStaticModelsCameraForLod(;
void R_SkinStaticModelsCamera(;
void R_AddStaticModelSurfacesCamera(;
void R_AddAllStaticModelSurfacesCamera(;

//t6/code/src_noserver/gfx_d3d/r_add_staticmodel.h
void R_InitStaticModelDrawSurf(GfxSModelDrawSurfData *surfData, const GfxViewParms *shadowViewParms);
void R_AddDelayedStaticModelDrawSurf(;

//t6/code/src_noserver/gfx_d3d/r_adszscale.cpp
void R_SetADSZScaleConstants(GfxCmdBufInput *input, float adsZScale);

//t6/code/src_noserver/gfx_d3d/r_bsp.cpp
MaterialUsage *R_GetMaterialUsageData(const Material *material);
void R_CreateMaterialList();
void R_ShutdownMaterialUsage();
void R_CopyParseParamsFromDvars(SunLightParseParams *sunParse);
void R_InterpretSunLightParseParams(SunLightParseParams *sunParse);
void R_UpdateLightsFromDvars();
void R_CopyParseParamsToDvars(const SunLightParseParams *sunParse, int savegame);
void R_SetWorldPtr_LoadObj(const char *name);
void R_SetWorldPtr_FastFile(const char *name);
void R_LoadWorld(const char *name, int *checksum, int savegame);
signed int R_GetDebugReflectionProbeLocs(vec3_t *locArray, unsigned int maxCount);

//t6/code/src_noserver/gfx_d3d/r_bsp_load_db.h
void Load_SSkinModel(bool atStreamStart);
void Load_SSkinAnim(bool atStreamStart);
void Load_SSkinShaders(bool atStreamStart);
void Load_SSkinInstanceArray(bool atStreamStart, int count);
void Load_GfxAabbTreeArray(bool atStreamStart, int count);
void Load_GfxPortalArray(bool atStreamStart, int count);
void Load_GfxWorldVertexData0(bool atStreamStart);
void Load_GfxWorldVertexData1(bool atStreamStart);
void Load_GfxLightGrid(bool atStreamStart);
void Load_GfxWorldStreamInfo(bool atStreamStart);
void Load_GfxShadowGeometryArray(bool atStreamStart, int count);
void Load_GfxWaterBufferArray(bool atStreamStart, int count);
void Load_GfxLightRegionHullArray(bool atStreamStart, int count);
void Load_GfxLightRegionArray(bool atStreamStart, int count);
void Load_GfxWorldDpvsDynamic(bool atStreamStart);
void Load_GfxWorldDpvsPlanes(bool atStreamStart);
void Mark_MaterialMemoryArray(int count);
void Mark_GfxWorld();
void Mark_GfxWorldPtr();
void Load_GfxCell(bool atStreamStart);
void Load_GfxCellArray(bool atStreamStart, int count);
void Load_MaterialMemoryArray(bool atStreamStart, int count);
void Load_GfxWorldDpvsStatic(bool atStreamStart);
void Load_GfxWorldDraw(bool atStreamStart);
void Load_GfxWorld(bool atStreamStart);
void Load_GfxWorldPtr(bool atStreamStart);

//t6/code/src_noserver/gfx_d3d/r_bsp_load_obj.cpp
bool ParseKVPFileFloatKVP(char *kvpFile, char *kvp, vec3_t *vec);
bool ParseKVPFileVec3KVP(char *kvpFile, char *kvp, vec3_t *vec);
void TRACK_r_bsp_load_obj();
Material *R_GetBspMaterial(unsigned int materialIndex, GfxSurface *surface);
void R_CreateWorldVertexBuffer(ID3D11Buffer **vb, const void *srcData, unsigned int sizeInBytes);
const DiskTriangleSoup *R_UpdateDiskSurfaces_Version14(const DiskTriangleSoup *oldSurfs, int surfCount);
const DiskTriangleSoup *R_UpdateDiskSurfaces_Version12(;
const DiskTriangleSoup *R_UpdateDiskSurfaces_Version8(;
void R_LoadTriangleSurfaces(;
int R_DetermineLightmapCoupling(GfxBspLoad *load, long double (*coupling)[30], LumpType lumpType);
int R_BuildLightmapMergability(;
void R_LoadLightmaps(GfxBspLoad *load);
void R_AssertLightGridValid(const GfxLightGrid *lightGrid);
void R_LoadLightGridHeader();
void R_LoadLightGridColors(unsigned int bspVersion);
GfxLightGridEntry *R_LoadLightGridEntries();
void R_LoadReflectionProbes();
int R_HeroLightSorter(const void *a, const void *b);
void R_BuildHeroLightTree(;
void R_LoadHeroOnlyLights(unsigned int bspVersion);
GfxLightCorona *R_LoadCoronas();
unsigned __int8 *R_LoadOccluders();
unsigned __int8 *R_LoadShadowMapVolumes();
unsigned __int8 *R_LoadExposureVolumes();
void R_LoadWorldFogVolumes();
void R_LoadWorldFogModifierVolumes();
void R_LoadLutVolumes();
void R_CalculateSurfaceBounds(GfxSurface *surface, const DiskGfxVertex *vertsDisk, int vertCount);
void R_MergeSurfaceLightMapCoords(;
void R_CalculateOutdoorBounds(GfxBspLoad *load, const DiskTriangleSoup *diskSurfaces);
bool R_CompareSurfaces(const GfxSurface *surf0, const GfxSurface *surf1);
BOOL R_SortSurfacesOnAxis_PosX(const GfxSurface *surf0, const GfxSurface *surf1);
BOOL R_SortSurfacesOnAxis_NegX(const GfxSurface *surf0, const GfxSurface *surf1);
BOOL R_SortSurfacesOnAxis_PosY(const GfxSurface *surf0, const GfxSurface *surf1);
BOOL R_SortSurfacesOnAxis_NegY(const GfxSurface *surf0, const GfxSurface *surf1);
void R_PackPosition(const vec3_t dataDisk, vec3_t *dataMem);
void R_PackWorldVertex0(const GfxSurface *surface, unsigned __int8 *out, const GfxWorldVertex *worldVert);
void R_PackWorldVertex1(;
void R_ValidateSurfaceLightmapUsage(const GfxSurface *surface);
void R_CalculateTriangleGroupTexCoordExtents(;
void R_LoadSubmodels();
float R_FloatForKey(const char *key, float defaultValue, char *(*spawnVars)[2], int spawnVarCount);
int R_IntForKey(const char *key, int defaultValue, char *(*spawnVars)[2], int spawnVarCount);
bool R_VectorForKey(;
void R_LoadStaticModelData(int bspVersion);
void R_LoadSkyGridVolumes(int bspVersion);
void R_PrefixStaticModelName(;
bool R_CheckValidStaticModel(char *(*spawnVars)[2], int spawnVarCount, XModel **model, vec3_t *origin);
void R_SetStaticModelsLightmapData();
// void R_LoadMiscModel(int a1@<edx>, char *(*spawnVars)[2], int spawnVarCount);
char *R_ParseSunLight(SunLightParseParams *params, const char *text);
void R_LoadPrimaryLights(unsigned int bspVersion);
void R_LoadLightRegions();
unsigned int R_GetStaticModelSortIndex(const XModel *model);
bool R_StaticModelCompare(;
int R_AabbTreeChildrenCount_r(GfxAabbTree *tree);
void R_AabbTreeFixAABBSizes_r(GfxAabbTree *tree);
GfxAabbTree *R_AabbTreeMove_r(GfxAabbTree *tree, GfxAabbTree *newTree, GfxAabbTree *newChildren);
void R_FixupGfxAabbTrees(GfxCell *cell);
BOOL R_SortStaticModelsOnAxis_NegX(;
BOOL R_SortStaticModelsOnAxis_PosY(;
BOOL R_SortStaticModelsOnAxis_NegY(;
bool R_CompareStaticModelSortModels(;
void R_LoadEntities();
int R_FinishLoadingAabbTrees_r(GfxAabbTree *tree, int totalTreesUsed);
unsigned int R_LoadAabbTrees();
void R_LoadCells(unsigned int bspVersion);
GfxPortal *R_LoadPortals();
void R_SetParentAndCell_r(mnode_load_t *node);
unsigned int R_CountNodes_r(mnode_load_t *node);
mnode_t *R_SortNodes_r(mnode_load_t *node, mnode_t *out);
void R_LoadNodesAndLeafs(unsigned int bspVersion);
unsigned __int8 *R_AllocPrimaryLightBuffers();
unsigned __int8 *R_LoadWorldRuntime();
void R_SetStaticModelReflectionProbes();
void R_IncrementShadowGeometryCount(GfxWorld *world, unsigned int primaryLightIndex);
void R_SetUpSunLight(const vec3_t *sunColor, const vec3_t *sunDirection, GfxLight *light);
void R_InterpretSunLightParseParamsIntoLights(SunLightParseParams *sunParse, GfxLight *sunLight);
void R_InitPrimaryLights(GfxLight *primaryLights);
void R_ForEachPrimaryLightAffectingSurface(;
MaterialTechniqueSet *R_GetSurfaceVertexLayerDataStride(const GfxSurface *surface);
void R_GetSurfaceVertexPosition(const GfxSurface *surface, int vertIndex, vec3_t *result);
void R_GetSurfaceVertexLmapCoord(const GfxSurface *surface, int vertIndex, vec2_t *result);
void R_GetSurfaceVertexNormal(const GfxSurface *surface, int vertIndex, vec3_t *result);
void R_RecenterSurfaceTexCoords(;
// void R_LoadSurfaces(const DiskTriangleSoup **a1@<edx>, unsigned int a2@<ecx>, GfxBspLoad *load);
void R_LoadSunSettings();
void R_ForEachShadowCastingSurfaceOnEachLight(void (*Callback)(GfxWorld *, unsigned int, unsigned int));
void R_AddShadowSurfaceToPrimaryLight(;
void R_InitShadowGeometryArrays();
void R_SpatialSortSurfaceSubArray_r(GfxSurface *beginSurf, GfxSurface *endSurf, unsigned int predIndex);
void R_SpatialSortAllSurfaces(int surfaceCount);
void R_SortSurfaces();
void R_SpatialSortStaticModelSubArray_r(;
void R_SpatialSortAllStaticModels(GfxStaticModelCombinedInst *smodelCombinedInsts);
void R_InitSortStaticModelsByModel();
void R_PostLoadEntities();
GfxWorld *R_LoadWorldInternal(const char *name);

//t6/code/src_noserver/gfx_d3d/r_buffers.cpp
void TRACK_r_buffers();
char *R_LockVertexBuffer(;
void R_UnlockVertexBuffer(ID3D11DeviceContext *device, ID3D11Buffer *handle);
char *R_LockIndexBuffer(;
void R_UnlockIndexBuffer(ID3D11DeviceContext *device, ID3D11Buffer *handle);
void *R_AllocDynamicVertexBuffer(ID3D11Buffer **vb, int sizeInBytes);
void *R_AllocStaticVertexBuffer(ID3D11Buffer **vb, int sizeInBytes, const void *data);
void *R_AllocDynamicIndexBuffer(ID3D11Buffer **ib, int sizeInBytes);
void *R_AllocStaticIndexBuffer(ID3D11Buffer **ib, int sizeInBytes, const void *data);
void Load_IndexBuffer(ID3D11Buffer **ib, void *bufferData, int indexCount);
void Load_VertexBuffer(ID3D11Buffer **vb, void *bufferData, int sizeInBytes);
void R_InitDynamicVertexBufferState(GfxVertexBufferState *vb, int bytes);
void R_InitSkinnedVertexBuffers(const SkinnedVertsDef *sv);
void R_FreeStaticVertexBuffer(ID3D11Buffer *vb);
void R_FreeStaticIndexBuffer(ID3D11Buffer *ib);
void R_ShutdownSkinnedVertexBuffers();

//t6/code/src_noserver/gfx_d3d/r_cinematic.cpp
void duck_Initialize();
void duck_Update();
void R_Cinematic_MemoryInit(CinematicInfo *cinematicInfo);
void R_Cinematic_CancelQueuedMovie(CinematicInfo *info);
bool R_Cinematic_GetPathFromFilename(;
void R_Cinematic_StartSound(CinematicInfo *info, bool startPaused);
void *R_Cinematic_OpenMovie_Now(;
void StreamThread_OpenMovie(int msAllotted, void *user);
void R_Cinematic_QueueStreamOpen(bool isNextBink, bool isNeededImmediately);
void R_Cinematic_PopFromQueue();
void R_Cinematic_RemoveInactiveFromQueue(int a1);
void StreamThread_GetMoviePath(int msAllotted, void *user, int id);
void R_Cinematic_StartPlayback_Internal(;
int R_Cinematic_GetPlayingId();
int R_Cinematic_StartPlayback(;
char R_Cinematic_StopPlayback(int id, bool cancelAll);
void R_Cinematic_HandleFinishedCallbacks(CIN_CALLBACK_TYPE type);
char R_Cinematic_UpdateSoundTime();
void R_Cinematic_UpdateFrame(bool force_wait);
char R_Cinematic_GetFilenameAndTimeInMsec(int id, char *outName, int outNameSize, unsigned int *outTimeInMsec);
char R_Cinematic_IsAnyPlaying();
char R_Cinematic_IsInProgress(int id);
char R_Cinematic_IsPreloading(int id);
void R_Cinematic_GetDebugInfo(const char **name, int *bytesUsed);
void R_Cinematic_ForceRelinquishIO();

//t6/code/src_noserver/gfx_d3d/r_cinematic_bink.cpp
const char *R_Cinematic_CheckBinkError();
void CinematicHunk_Open(CinematicHunk *hunk, void *memory, int size);
void CinematicHunk_Close(CinematicHunk *hunk);
void CinematicHunk_Reset(CinematicHunk *hunk);
int CinematicHunk_GetFreeSpace(CinematicHunk *hunk);
void *CinematicHunk_Alloc(CinematicHunk *hunk, int size);
// double BinkMoviePlayer::GetTimeRemaining(void *handle);
// void BinkMoviePlayer::SetPaused(void *handle, bool paused, bool forUnderrun);
// void **BinkMoviePlayer::GetMaxTextureBytesNeeded();
// unsigned int BinkMoviePlayer::GetMainBytesNeeded(unsigned int playbackFlags);
// GfxImage *BinkMoviePlayer::R_Cinematic_BlackRendererImages();
// void BinkMoviePlayer::InitMemory(;
// void __thiscall BinkMoviePlayer::Destroy(CinematicHunk *this);
// void BinkMoviePlayer::R_Cinematic_ReleaseImages(CinematicTextureSet *textureSet);
// int BinkMoviePlayer::MakeBinkTexturePC(;
// HRESULT BinkMoviePlayer::R_Cinematic_MakeBinkDrawTextures@<eax>(;
// HRESULT BinkMoviePlayer::R_Cinematic_InitBinkTextures@<eax>(unsigned int *a1@<edi>);
// void BinkMoviePlayer::R_Cinematic_Unlock_textures();
// void BinkMoviePlayer::R_Cinematic_SetRendererImagesToFrame(int frameToSetTo);
// double BinkMoviePlayer::GetTimeElapsed();
// void BinkMoviePlayer::SetMovieClock(void *handle, float time);
// void BinkMoviePlayer::SetVolume(void *handle, float volume);
// int BinkMoviePlayer::GetBufferFillPercentage(void *handle);
// bool __thiscall BinkMoviePlayer::IsUnderrun(void *this);
// int BinkMoviePlayer::R_Cinematic_BinkWaitAsyncDecode(BINK *bink, int waitMs);
// bool __thiscall BinkMoviePlayer::IsReadyToStart(void *this);
// void BinkMoviePlayer::StreamThread_DoBackgroundIO_Bink(int msAllotted, void *user, int id);
// void BinkMoviePlayer::StartPlayback(void *handle, unsigned int playbackFlags);
// const char *BinkMoviePlayer::AdvanceFrame();
// void BinkMoviePlayer::R_Cinematic_Lock_textures(;
// const char *BinkMoviePlayer::R_Cinematic_BinkLaunchAsyncDecode@<eax>(;
// void BinkMoviePlayer::DoFrameSync(D3D11_MAPPED_SUBRESOURCE *a1@<ebx>, int a2@<edi>, int a3@<esi>);
// void BinkMoviePlayer::UpdateMoviesAndImages(;
// char BinkMoviePlayer::ForceRelinquishIO();
// void *BinkMoviePlayer::Bink_Alloc_Alt(unsigned int bytes);
// void BinkMoviePlayer::Bink_Free(void *ptr);
// void BinkMoviePlayer::Bink_Free_Alt(void *ptr);
// void BinkMoviePlayer::PreOpen_Common(bool isNextBink);
// void BinkMoviePlayer::PostOpen_Common(BINK *pbink, unsigned int playbackFlags, bool isNextBink);
// ;
// BINK *BinkMoviePlayer::OpenFromFastfile(const char *assetname, unsigned int playbackFlags);
// BINK *BinkMoviePlayer::OpenPath(const char *filepath, unsigned int playbackFlags);
// void BinkMoviePlayer::StopPlayback(void *handle);
MoviePlayerFunctions *R_Cinematic_GetBinkFunctions();
// int launch_async_bink_drawCallback@<eax>(D3D11_MAPPED_SUBRESOURCE *a1@<ebx>, jqBatch *batch);

//t6/code/src_noserver/gfx_d3d/r_cmdbuf.cpp
void R_ShutdownCmdBuf(GfxCmdBuf *cmdBuf);
void R_InitContext(const GfxBackEndData *data, GfxCmdBuf *cmdBuf);

//t6/code/src_noserver/gfx_d3d/r_compile_shader.cpp
void Material_EmitShaderString(GfxAssembledShaderText *prog, const char *string);
void Material_AddShaderFile(GfxAssembledShaderText *prog, const char *shaderFileName, unsigned int srcLine);
char Material_FindCachedShaderText(const char *filename, const char **data, unsigned int *byteCount);
void Material_FileIncludeFileAndLineNumber(;
bool Material_PreLoadSingleShaderText(const char *filename, const char *subdir, GfxCachedShaderText *cached);
bool Material_CachedShaderTextLess(const GfxCachedShaderText *cached0, const GfxCachedShaderText *cached1);
bool Material_IncludeShader(GfxAssembledShaderText *prog, const char *includeName, bool isInLibDir);
bool Material_GenerateShaderString_r(GfxAssembledShaderText *prog, const char *shaderName, const char *file);
unsigned int Material_GenerateShaderString(;
ID3D10Blob *Material_CompileShader(;

//t6/code/src_noserver/gfx_d3d/r_debug.cpp
void TRACK_r_debug();
void R_AddDebugPolygonInternal(;
void R_AddDebugPolygon(;
void R_AddPersistentDebugPolygon(;
void R_ClearPersistentDebugPolygons();
void R_AddDebugLine(;
void R_AddDebugBox(;
;
void R_AddDebugString(;
void R_AddScaledDebugString(;
void R_InitDebugEntry(DebugGlobals *debugGlobalsEntry);
void R_ShutdownDebugEntry(DebugGlobals *debugGlobalsEntry);
void R_UpdatePersistentDebugPolys(DebugGlobals *debugGlobalsEntry);
void R_TransferDebugGlobals(DebugGlobals *debugGlobalsEntry);
void R_ShutdownDebug();
void R_CopyDebugStrings(;
void R_CopyDebugLines(;
void R_CopyDebugSpheres(;
void R_AddDebugAxis(;
void R_AddDebugPolygonOutline(;

//t6/code/src_noserver/gfx_d3d/r_debug_alloc.cpp
void R_DebugAlloc(void **memPtr, int size, const char *name);
void R_DebugFree(void **dataPtr);

//t6/code/src_noserver/gfx_d3d/r_dobj_skin.cpp
int R_PreSkinXSurface(const GfxModelSurfaceInfo *surfaceInfo, unsigned __int8 *surfPos);
unsigned int R_GetSkinSurfaceBufferSize(GfxSceneEntity *sceneEnt, const DObj *obj);
void R_GetPartBitsForSurfaceAndBoneIndex(XSurface *xsurf, unsigned int boneIndex, int *partBits);
unsigned int R_SkinSceneDObjModels(GfxSceneEntity *sceneEnt, const DObj *obj);
void R_FlagXModelAsSkinned(GfxSceneEntity *sceneEnt, unsigned int surfaceCount);
void R_SkinSceneDObj(;
void R_SkinGfxEntityCmd(void *data);

//t6/code/src_noserver/gfx_d3d/r_dpvs.cpp
// int DpvsCachedCell::Compare(const void *lhs, const void *rhs);
void TRACK_r_dpvs();
void R_GetSidePlaneNormals(const vec3_t *winding, unsigned int vertexCount, vec3_t *normals);
float R_FurthestPointOnWinding(const vec3_t *points, int pointCount, const DpvsPlane *plane);
float R_NearestPointOnWinding(const vec3_t *points, int pointCount, const DpvsPlane *plane);
void R_FrustumClipPlanes(;
char *R_PortalAssertMsg();
void R_ProjectPortal(;
void R_UnprojectPoint(GfxViewParms *viewParms, const vec2_t *projected, vec4_t *unprojected);
unsigned int R_AddBevelPlanes(;
unsigned int R_PortalClipPlanes(;
unsigned int R_PortalClipPlanesNoFrustum(DpvsPlane *planes, unsigned int vertexCount, const vec3_t *winding);
bool R_PortalBehindAnyPlane(const GfxPortal *portal, const DpvsPlane *planes, int planeCount);
const vec3_t *R_ChopPortalWinding(;
unsigned int R_GetLightingMask_Box(;
unsigned int R_GetLightingMask_Sphere(;
void R_AddSceneEntSurfs_SceneDObjs(AddSceneEntSurfsCmd *cmd);
void R_AddSceneEntSurfs_SceneModels(AddSceneEntSurfsCmd *cmd);
void R_AddSceneEntSurfs_SceneDynEnts(AddSceneEntSurfsCmd *cmd);
void R_AddSceneEntSurfs_SceneBrush(AddSceneEntSurfsCmd *cmd);
void R_AddSceneEntSurfs_SceneGlassBrush(AddSceneEntSurfsCmd *cmd);
void R_AddSceneEntSurfs_SceneDynBrush(AddSceneEntSurfsCmd *cmd);
void R_InitSceneEntDrawSurfs(;
void R_FinishSceneEntDrawSurfs(GfxDrawSurf **drawSurfs);
void R_AddAllSceneEntSurfacesCamera(;
void R_AddAllSceneEntSurfacesRangeSunShadow(unsigned int partitionIndex);
void R_AddAllSceneEntSurfacesSunShadow();
void R_AddAllSceneEntSurfacesSpotShadow(;
int R_DrawBModel(;
void R_CullDynBrushInCell(unsigned int cellIndex, const DpvsPlane *planes, int planeCount);
void R_DrawAllSceneEnt(const GfxViewInfo *viewInfo);
void R_DrawAllDynEnt(const GfxViewInfo *viewInfo);
void R_FilterEntIntoCells_r(;
void R_FilterDynEntIntoCells_r(;
void R_UnfilterEntFromCells(LocalClientNum_t localClientNum, unsigned int entnum);
void R_UnfilterDynEntFromCells(unsigned int dynEntId, DynEntityDrawType drawType);
void R_FilterDObjIntoCells(;
void R_FilterBModelIntoCells(;
void R_FilterDynEntIntoCells(;
int R_DpvsBoxIsVisible(;
void R_FilterXModelIntoScene(;
void R_InitialEntityCulling();
void R_GetStaticModelsAabb(;
void R_GetStaticModels(const vec3_t *mins, const vec3_t *maxs, int *models, int *models_count, int max_models);
void R_AddCellDynBrushSurfacesInFrustumCmd(void *data);
void R_FinishDpvsDynamicBatch(DpvsDynamicCellCmd *dpvsDynamicBatch, bool bRunCmd);
void R_AddDpvsDynamicBatch(;
void R_AddCellSurfacesInFrustumDelayed(;
void R_CacheCell(int cellIndex, int planeIndex, int planeCount, int frustumPlaneCount);
void R_AddCellSurfaces(;
void R_AssertValidQueue();
// void R_EnqueuePortal(const vec3_t *a1@<ecx>, const DpvsPlane *a2@<edi>, float a3@<xmm0>, GfxPortal *portal);
GfxPortal *R_NextQueuedPortal();
void R_AddVertToPortalHullPoints(GfxPortal *portal, const vec3_t *v);
int R_ChopPortal(;
bool R_ChopPortalAndAddHullPoints(;
bool R_ChopPortalAndAddHullPointsNoFrustum(;
int R_GetFurtherCellList_r(;
void R_SetCellVisible(unsigned int cellIndex);
void R_VisitAllFurtherCells(;
void R_SetAncestorListStatus(GfxPortal *portal, bool isAncestor);
int R_VisitPortalsForCell(;
void R_VisitPortals(;
void R_VisitPortalsForCellNoFrustum(;
void R_VisitPortalsNoFrustum(const GfxCell *cell);
void R_GenerateShadowMapCasterCells();
void R_AddSunShadowSurfacesFrustumOnly(unsigned int viewIndex, bool cache);
void R_ShowCull(const vec3_t *viewOrigin);
void R_InitSceneData(LocalClientNum_t localClientNum);
void DynEntCl_InitFilter();
void R_InitSceneBuffers();
void R_ClearDpvsScene(LocalClientNum_t previousLocalClientNum, bool bIsExtraCam);
void R_CullDynamicPointLightsInCameraView();
void R_EnableOccluder(const char *name, bool enable);
void R_SetViewFrustumPlanes(GfxViewInfo *viewInfo);
void R_AddWorldSurfacesPortalWalk(int cameraCellIndex, DpvsDynamicCellCmd *pDynamicBatch);
void R_DpvsClearCellVisibility();
void R_StartCachedDpvsBatches(unsigned int view, unsigned int batchMask);
void R_SetupShadowSurfacesDpvs(;
double R_GetFarPlaneDist();
void R_SetCullDist(float dist);
int R_CullBoxCurDpvs_SceneSelect(;
int R_CullBoxCurDpvs(const vec3_t *mins, const vec3_t *maxs, unsigned int viewIndex);
int R_CullPoint(LocalClientNum_t localClient, const vec3_t *p0, float cutoff);
int R_CullPoint(int max_local_clients, const vec3_t *point, float cutoff);
int R_CullLine(int localClient, const vec3_t *p0, const vec3_t *p1, float cutoff);
unsigned int R_ExtraCam_SaveDpvsData(;
void R_ExtraCam_RestoreDpvsData(LocalClientNum_t localClientNum, unsigned __int8 *buffer);
void R_PerMap_DpvsGlobInit();
int r_sceneents_dobjCallback(jqBatch *batch);
int r_sceneents_modelCallback(jqBatch *batch);
int r_sceneents_dynentCallback(jqBatch *batch);
int r_sceneents_brushCallback(jqBatch *batch);
int r_sceneents_glassbrushCallback(jqBatch *batch);
int r_sceneents_dynbrushCallback(jqBatch *batch);
void R_DpvsStartCachedShadowBatches(unsigned int viewIndex);
void R_SetupWorldSurfacesDpvs(const GfxViewParms *viewParms, unsigned int renderCullFlags);
void R_AddWorldSurfacesDpvs();
void R_DpvsGetVisibleCells(int cameraCellIndex);

//t6/code/src_noserver/gfx_d3d/r_dpvs.h
int R_CullBoxDpvs(const vec3_t *min, const vec3_t *max, const DpvsPlane *planes, int planeCount);

//t6/code/src_noserver/gfx_d3d/r_dpvs_dynmodel.cpp
void R_CullDynModelInCell(;
void R_AddCellDynModelSurfacesInFrustumCmd(void *data);

//t6/code/src_noserver/gfx_d3d/r_dpvs_entity.cpp
void R_AddEntitySurfacesInFrustum(;
void R_ForceAddEntitySurfacesInFrustum(GfxSceneEntity *sceneEnt, unsigned __int8 *entVisData);

//t6/code/src_noserver/gfx_d3d/r_dpvs_sceneent.cpp
void R_AddCellSceneEntSurfacesInFrustum(;
void R_AddCellSceneEntSurfacesInFrustumCmd(void *data);

//t6/code/src_noserver/gfx_d3d/r_dpvs_static.cpp
int R_CullBoxLeaf(const vec3_t *mins, const vec3_t *maxs, DpvsClipPlanes *planes);
char TestOccluders(const vec3_t *bounds, int numOccluders, vec4_t *plane);
vec4_t *TestOccludersPartial(const vec3_t *bounds, int *numOccludersPtr, vec4_t *plane);
;
int R_AddCellStaticSurfacesInFrustum(const DpvsPlanes *planes);
void R_AddCellStaticSurfacesInFrustumCmd(void *data);

//t6/code/src_noserver/gfx_d3d/r_drawsurf.cpp
GfxWorld *R_SetPrimaryLightShadowSurfaces();
int R_GetWorldDrawSurf(GfxSurface *worldSurf);
void R_SortWorldSurfaces();
GfxDrawSurf *R_AllocFxDrawSurf(unsigned int region);
unsigned int R_GetDrawSurfRegionForSortKey(const Material *material, unsigned int baseRegion);
void R_AddCodeMeshDrawSurf(;
void R_AddCodeMeshDrawSurf_UseIndices(;
void R_AddRopeCodeMeshDrawSurf(;
// FxCodeMeshData *R_AddGlassDrawSurf@<eax>(;
void R_AddMarkMeshDrawSurf(;
// char R_AddParticleCloudDrawSurf@<al>(float a1@<xmm0>, unsigned int cloudIndex, Material *material);
void R_BeginCodeMeshVerts();
void R_EndCodeMeshVerts();
void R_BeginMarkMeshVerts();
void R_EndMarkMeshVerts();
// char R_ReserveCodeMeshIndices@<al>(float a1@<xmm0>, int indexCount, r_double_index_t **indicesOut);
// char R_ReserveCodeMeshVerts@<al>(float a1@<xmm0>, int vertCount, unsigned __int16 *baseVertex);
// char R_ReserveCodeMeshArgs@<al>(float a1@<xmm0>, int argCount, unsigned int *argOffsetOut);
// char R_ReserveMarkMeshIndices@<al>(float a1@<xmm0>, int indexCount, r_double_index_t **indicesOut);
// char R_ReserveMarkMeshVerts@<al>(float a1@<xmm0>, int vertCount, unsigned __int16 *baseVertex);
vec4_t *R_GetCodeMeshArgs(unsigned int argOffset);
GfxPackedVertex *R_GetCodeMeshVerts(unsigned __int16 baseVertex);
GfxWorldVertex *R_GetMarkMeshVerts(unsigned __int16 baseVertex);
// void R_SortDrawSurfs(int a1@<edx>, GfxDrawSurf *drawSurfList);

//t6/code/src_noserver/gfx_d3d/r_draw_bsp.cpp
void R_SetStreamsForBspSurface(GfxCmdBufPrimState *state, const srfTriangles_t *tris);
void R_DrawTrianglesLit(GfxTrianglesDrawStream *drawStream, GfxCmdBufState *state);
void R_DrawTriangles(GfxTrianglesDrawStream *drawStream, GfxCmdBufState *state);
void R_DrawBspDrawSurfsLit(const unsigned int *primDrawSurfPos, GfxCmdBufContext context);
void R_DrawBspDrawSurfs(const unsigned int *primDrawSurfPos, GfxCmdBufContext context);

//t6/code/src_noserver/gfx_d3d/r_draw_lit.cpp
void R_DrawSonarCallback(const void *__formal, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawSonar(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
void R_DrawLitQuasiOpaqueCallback(const void *__formal, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawLitQuasiOpaque(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
void R_DrawTransCallback(const void *userData, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawTransInternal(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
void R_DrawTrans(const GfxViewInfo *a1, GfxCmdBuf *a2);
void R_DrawTransPostFX(const GfxViewInfo *a1, GfxCmdBuf *a2);
void RB_SetSonarCodeImages(GfxCmdBufSourceState *source);
void R_AdjustDrawsurfListToCmdBufPartition(;
void R_DrawLit(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf, LitPhaseID phase);
void R_DrawLitBsp(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf, LitPhaseID phase);
void R_DrawLitStaticModel(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf, LitPhaseID phase);
void R_DrawViewModelTransCallback(const void *userData, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
void R_DrawViewModelTrans(const GfxViewInfo *viewInfo, GfxCmdBuf *cmdBuf);
void R_PostBlurCallback(const void *userData, GfxCmdBufContext context, const GfxViewInfo *viewInfo);
;
;
;

//t6/code/src_noserver/gfx_d3d/r_draw_material.cpp
unsigned __int8 RemoveShadowTech(unsigned __int8 srcTech);
int R_SetPrepassMaterial(GfxCmdBufContext context, GfxDrawSurf drawSurf, unsigned __int8 techType);
int R_SetMaterial(GfxCmdBufContext context, GfxDrawSurf drawSurf, const Material **techType);
int R_SetMaterialNoShaderConstantSet(GfxCmdBufContext context, GfxDrawSurf drawSurf, unsigned __int8 techType);
unsigned __int8 R_GetTechType(;
const char *RB_LogTechniqueType(unsigned __int8 techType);
// int R_SetTechnique@<eax>(;
// int R_SetLitTechniqueNoShaderConstantSet@<eax>(;
void R_SetGameTime(GfxCmdBufSourceState *source, float gameTime);
int R_UpdateMaterialTime(GfxCmdBufSourceState *source, float materialTime, float burn);

//t6/code/src_noserver/gfx_d3d/r_draw_method.cpp
void R_SetDefaultLitTechTypes();
void R_InitDrawMethod();
void R_UpdateDrawMethod(GfxBackEndData *data);

//t6/code/src_noserver/gfx_d3d/r_draw_model_util.cpp
void R_SetStreamsForXModelSurface(const XSurface *localSurf, GfxCmdBufState *state);

//t6/code/src_noserver/gfx_d3d/r_draw_shadowablelight.cpp
void R_SetLightProperties(;
void R_SetShadowableLight(GfxCmdBufSourceState *source, unsigned int shadowableLightIndex);

//t6/code/src_noserver/gfx_d3d/r_draw_staticmodel.cpp
void R_SetStaticModelVertexBuffer(GfxCmdBufPrimState *primState, XSurface *xsurf);
void R_SetStaticModelIndexBuffer(GfxCmdBufPrimState *primState, XSurface *xsurf);
void R_DrawStaticModelUnlitNoPrepass(GfxStaticModelDrawStream *drawStream);
;
;
void R_DrawStaticModelsLit(GfxStaticModelDrawStream *drawStream, GfxCmdBufContext context);
void R_DrawStaticModels(GfxStaticModelDrawStream *drawStream, GfxCmdBufContext context);
void R_DrawStaticModelSurfLit(;
void R_DrawStaticModelDrawSurfPlacement(;
void R_DrawStaticModelDrawSurfNonOptimized(GfxStaticModelDrawStream *drawStream, GfxCmdBufContext context);
void R_DrawStaticModelsSkinnedDrawSurfLighting(GfxStaticModelDrawStream *drawStream, GfxCmdBufContext context);
void R_DrawStaticModelsSkinnedDrawSurf(GfxStaticModelDrawStream *drawStream, GfxCmdBufContext context);
void R_DrawStaticModelSkinnedSurfLit(;
void R_DrawStaticModelSkinnedSurf(;
void R_DrawStaticModelSurf(;

//t6/code/src_noserver/gfx_d3d/r_draw_sunshadow.cpp
void R_DrawSunShadowMapCallback(const void *userData, GfxCmdBufContext context);
void R_DrawSunShadowMap(;

//t6/code/src_noserver/gfx_d3d/r_draw_xmodel.cpp
void R_GetWorldMatrixForModelSurf(;
const GfxModelRigidSurface *R_GetLocalModelSurfaceOnly(const GfxBackEndData *data, GfxDrawSurf drawSurf);
// unsigned int R_DrawXModelSurfLitInternal@<eax>(;
// GfxCmdBufSourceState *R_DrawXModelSurfCameraInternal@<eax>(;
// XSurface *R_DrawXModelSurfInternal@<eax>(;
// unsigned int R_DrawXModelSurfLit@<eax>(;
// GfxCmdBufSourceState *R_DrawXModelSurfCamera@<eax>(;
// XSurface *R_DrawXModelSurf@<eax>(;

//t6/code/src_noserver/gfx_d3d/r_draw_xmodel.h
unsigned int R_DrawXModelSurfCheckBreak(;

//t6/code/src_noserver/gfx_d3d/r_dvars.cpp
void R_RegisterDvars();
bool R_CheckDvarModified(const dvar_t *dvar);
double R_GetDefaultNearClip();
double R_GetDefaultNearClip_DepthHack();
void DvarBlock_SetFog();
void DvarBlock_SetWSI();
void DvarBlock_SetVcBloom();
void DvarBlock_SetVcColor();

//t6/code/src_noserver/gfx_d3d/r_extracam.cpp
void CreateExtraCamRenderTargets(eExtraCamResolution resConfig, int location);
void R_ExtraCam_Init(int location);
void R_ExtraCam_Shutdown();
unsigned int R_ExtraCam_RenderTargetWidth(bool usingMultiExtraCam);
unsigned int R_ExtraCam_RenderTargetHeight(bool usingMultiExtraCam);
BOOL R_ExtraCam_GfxResourcesReady();
void RB_ExtraCam_SetSampler(GfxCmdBufSourceState *cmdBufSrcState);

//t6/code/src_noserver/gfx_d3d/r_fog.cpp
void R_SetFogFromServer(;
void R_GetFogSettings(float *fogSettings);
void R_SwitchFog(LocalClientNum_t localClientNum, int fogvar, int startTime, int transitionTime);

//t6/code/src_noserver/gfx_d3d/r_font.cpp
Glyph *R_GetCharacterGlyph(Font_s *font, unsigned int letter);
int R_GetKerningAmount(Font_s *font, int previousLetter, int letter);
unsigned int R_FontGetRandomLetter(Font_s *font, int seed);
unsigned int R_FontGetRandomNumberCharacter(Font_s *font, int seed);
void TRACK_r_font();
Font_s *R_RegisterFont_LoadObj(const char *fontName, int imageTrack);
Font_s *R_RegisterFont_FastFile(const char *fontName);
Font_s *R_RegisterFont();
double R_NormalizedTextScale(Font_s *font, float scale);
void GetButtonProperties(;
int R_TextWidth(LocalClientNum_t localClientNum, const char *text, int maxChars, Font_s *font);
int R_TextHeight(Font_s *font);
const char *R_TextLineWrapPosition(;
int R_ConsoleTextWidth(const char *textPool, int poolSize, int firstChar, int charCount, Font_s *font);

//t6/code/src_noserver/gfx_d3d/r_fonticon.cpp
FontIconEntry *R_GetFontIconEntryByHash(int fontIconNameHash, int size);
FontIconAlias *R_GetFontAliasEntry(char *fontIconAlias);
void R_GetFontIconEntryInfo(;

//t6/code/src_noserver/gfx_d3d/r_fonticon_load_db.h
void Mark_FontIconEntryArray(int count);
void Mark_FontIconHandle();
void Load_FontIconEntryArray(bool atStreamStart, int count);
void Load_FontIcon(bool atStreamStart);
void Load_FontIconHandle(bool atStreamStart);

//t6/code/src_noserver/gfx_d3d/r_font_load_db.h
void Mark_Font();
void Mark_FontHandle();
void Load_Font(bool atStreamStart);
void Load_FontHandle(bool atStreamStart);

//t6/code/src_noserver/gfx_d3d/r_font_load_obj.cpp
Font_s *R_LoadFont(const char *fontName, int imageTrack);

//t6/code/src_noserver/gfx_d3d/r_gpu_timer.cpp
void R_GPU_CalcDerivedTimers(GPUTimerFrame *timerFrame);
void R_GPU_CalcTimers(GPUTimerFrame *timerFrame);
void R_GPU_FreeInterveningTimeStamps(int lastReadIndex, int readIndex);
void R_GPU_EndFrameCallback();
void R_GPU_BeginFrame();
void R_GPU_EndFrame();
// void R_GPU_BeginTimer(int a1@<edi>, int a2@<esi>, GPUTimerId timerId);
;
void R_GPU_DrawTimers();

//t6/code/src_noserver/gfx_d3d/r_image.cpp
void TRACK_r_image();
void Image_TrackTotalMemory(GfxImage *image, int platform, int memory);
void R_AddImageToList(XAssetHeader header, void *data);
void R_GetImageList(ImageList *imageList);
void Image_Release(GfxImage *image);
int Image_GetAvailableHashLocation(const char *name);
void Image_Construct(;
GfxImage *Image_AllocProg(int imageProgType, unsigned __int8 category, unsigned __int8 semantic);
GfxImage *Image_GetProg(int imageProgType);
GfxImage *Image_Alloc(const char *name, const char *category, int semantic, int imageTrack);
void Image_Create2DTexture_PC(;
void Image_Create3DTexture_PC(;
void Image_CreateCubeTexture_PC(;
void Image_SetupRenderTarget(;
void Image_PicmipForSemantic(unsigned __int8 semantic, Picmip *picmip);
bool Image_AssignDefaultTexture(GfxImage *image);
void R_DelayLoadImage(XAssetHeader header);
void Load_Texture(GfxImageLoadDef **remoteLoadDef, GfxImage *image);
GfxImage *Image_FindExisting_LoadObj(const char *name);
GfxImage *Image_FindExisting_FastFile(const char *name);
GfxImage *Image_Register_LoadObj(const char *imageName, unsigned __int8 semantic, int imageTrack);
GfxImage *Image_Register_FastFile(const char *imageName);
GfxImage *Image_Register();
void R_EnumImages(void (*func)(XAssetHeader, void *), void *data);

//t6/code/src_noserver/gfx_d3d/r_image_load_common.cpp
unsigned int Image_GetCardMemoryAmountForMipLevel(;
unsigned int Image_GetCardMemoryAmount(;
int Image_SourceBytesPerSlice_PC(DXGI_FORMAT format, int width, int height);
void Image_Upload2D_CopyDataBlock_PC(;
void Image_Upload2D_CopyData_PC(;
void Image_Upload3D_CopyData_PC(;
void Image_UploadData(;
unsigned int Image_CountMipmaps(;
void Image_GetPicmip(const GfxImage *image, Picmip *picmip);
unsigned int Image_CubemapFace(unsigned int faceIndex);
void Image_TrackTexture(GfxImage *image, int imageFlags, DXGI_FORMAT format, int width, int height, int depth);
void Image_Setup(;
void Image_SetupAndLoad(;

//t6/code/src_noserver/gfx_d3d/r_image_load_db.h
void Load_GfxImageLoadDef(bool atStreamStart);
void Mark_GfxImagePtr();
void Load_GfxTextureLoad(bool atStreamStart);
void Load_GfxImage(bool atStreamStart);
void Load_GfxImagePtr(bool atStreamStart);

//t6/code/src_noserver/gfx_d3d/r_image_load_obj.cpp
unsigned __int8 Image_GetPcStreamedMips(GfxImageFileHeader *fileHeader);
int Image_GetPicmipUsed(const GfxImage *image);
void Image_SetupFromFile(;
unsigned __int8 *Image_AllocTempMemory(int bytes);
void Image_FreeTempMemory(unsigned __int8 *mem, int bytes);
void Image_LoadBitmap(;
void Image_LoadDxtc(;
void Image_LoadFromData(;
char Image_LoadFromFileInternal(const GfxImageFileHeader *a1, unsigned int a2, GfxImage *image);
char Image_LoadFromFile(GfxImage *image);
void Image_Generate2D(GfxImage *image, unsigned __int8 *pixels, int width, int height, DXGI_FORMAT imageFormat);
void Image_GenerateCube(;
void Image_LoadWhite(GfxImage *image);
void Image_LoadBlack(GfxImage *image);
void Image_LoadGray(GfxImage *image);
void Image_LoadLinearGray(GfxImage *image);
void Image_LoadIdentityNormalMap(GfxImage *image);
void Image_LoadWhiteTransparent(GfxImage *image);
void Image_LoadBlackTransparent(GfxImage *image);
GfxImage *Image_LoadBuiltin(const char *name, unsigned __int8 semantic, int imageTrack);
GfxImage *Image_Load(const char *name, int semantic, int imageTrack);

//t6/code/src_noserver/gfx_d3d/r_image_wavelet.cpp
void TRACK_r_image_wavelet();

//t6/code/src_noserver/gfx_d3d/r_init.cpp
void TRACK_r_init();
const char *R_ErrorDescription(int hr);
;
char *R_GetFontPathFromName(const char *fontName);
void R_SetBrightness(float brightness);
void R_SetColorMappings();
void R_GammaCorrect(unsigned __int8 *buffer, int bufSize);
void SetGfxConfig(const GfxConfiguration *config);
void __thiscall R_MakeDedicated(const GfxConfiguration *this);
void R_SetVidRestart();
void R_AllocateMinimalResources();
void R_SetIsMultiplayer(bool isMp);
void R_SetIsZombie(bool isZM);
void R_ShutdownStreams();
void R_Shutdown(int destroyWindow);
void R_UnloadWorld();
void R_BeginRegistration(vidConfig_t *vidConfigOut);
void R_EndRegistration();
void R_TrackStatistics(trStatistics_t *stats);
void __thiscall R_ConfigureRenderer(const GfxConfiguration *this);
bool R_StereoActivated();

//t6/code/src_noserver/gfx_d3d/r_light.cpp
GfxLightDef *R_RegisterLightDef_LoadObj(const char *name);
GfxLightDef *R_RegisterLightDef_FastFile(const char *name);
GfxLightDef *R_RegisterLightDef();
void R_InitFlashlight();
bool R_LightImportanceGreaterEqual(const GfxLight *light0, const GfxLight *light1);
// void R_MostImportantLights(const GfxLight *a1@<edx>, const GfxLight **lights, int lightCount, int keepCount);
// int R_GetPointLightPartitions@<eax>(GfxLight *visibleLights);
void R_ComputeSpotLightCrossDirs(const GfxLight *light, vec3_t *crossDirs);
void R_CalcSpotLightPlanes(;
void R_GetSceneEntLightSurfs(const GfxLight *visibleLights, int visibleCount);
void R_SortSceneEntLightSurfs(const GfxLight *visibleLights, int visibleCount);
BOOL R_AllowBspSpotLightShadows(int surfIndex);
BOOL R_SortBspLightSurfaces(GfxSurface *surface0, GfxSurface *surface1);
BOOL R_AllowStaticModelSpotLight(int smodelIndex);
void R_GetStaticModelLightSurfs(int viewIndex, const GfxLight *visibleLights, int visibleCount);
void R_SortStaticModelLightSurfs(const GfxLight *visibleLights, int visibleCount);
void R_GetBspLightSurfs(const GfxLight *visibleLights, int visibleCount);

//t6/code/src_noserver/gfx_d3d/r_light_load_db.h
void Mark_GfxLightDefPtr();
void Mark_GfxLight();
void Load_GfxLightDef(bool atStreamStart);
void Load_GfxLightDefPtr(bool atStreamStart);
void Load_GfxLight(bool atStreamStart);

//t6/code/src_noserver/gfx_d3d/r_light_load_obj.cpp
const unsigned __int8 *R_LoadLightImage(const unsigned __int8 *readPos, GfxLightImage *lightImage);
GfxLightDef *R_LoadLightDef(const char *name);

//t6/code/src_noserver/gfx_d3d/r_marks.cpp
int R_ChopPolyBehindPlane(;
int R_ChopWorldPolyBehindPlane(;
bool R_Mark_MaterialAllowsMarks(;
BOOL R_AllowMarks();
void R_AABBTreeBoxSurfaces_r(;
void R_AABBTreeBoxSurfacesTwoLists_r(;
void R_AddStaticModelToList(int smodelIndex, unsigned __int16 *smodelList, int *smodelCount);
void R_AABBTreeBoxStaticModels_r(;
void R_AABBTreeFrustumSurfaces_r(;
void R_AABBTreeFrustumStaticModels_r(;
void R_CellBoxSurfaces(;
void R_CellBoxSurfacesTwoLists(;
void R_BoxSurfaces_r(;
void R_BoxStaticModels_r(;
void R_FrustumSurfaces_r(;
void R_FrustumStaticModels_r(;
void R_BoxSurfaces(;
// int R_BoxStaticModels@<eax>(;
// int R_FrustumSurfaces@<eax>(;
// int R_FrustumStaticModels@<eax>(;
void R_GetMarkFragmentClipPlanes(;
bool R_MarkFragments_BrushSurface(;
bool R_MarkFragments_WorldBrushes(MarkInfo *markInfo);
void R_Mark_TransformClipPlanes(;
char R_MarkFragments_EntBrushes(MarkInfo *markInfo);
bool R_MarkFragments_Glass(MarkInfo *markInfo);
void R_MarkUtil_GetDObjAnimMatAndHideParts(;
void R_MarkFragments_Begin(;
bool R_MarkFragments_AddDObj(MarkInfo *markInfo, DObj *dObj, cpose_t *pose, unsigned __int16 entityIndex);
char R_MarkFragments_AddViewModelDObj(MarkInfo *markInfo, DObj *dObj, cpose_t *pose);
bool R_MarkFragments_AddBModel(;
// char R_MarkFragments_XModelSurface_Basic@<al>(;
bool R_MarkFragments_EntirelyRigidXModel(;
;
bool R_MarkFragments_AnimatedXModel(;
bool R_MarkFragments_SceneDObjs(MarkInfo *markInfo);
bool R_MarkFragments_ViewmodelDObjs(MarkInfo *markInfo);
bool R_MarkFragments_StaticModels(MarkInfo *markInfo);
bool R_MarkFragments_Models(MarkInfo *markInfo);
void R_MarkFragments_Go(;

//t6/code/src_noserver/gfx_d3d/r_material.cpp
void TRACK_r_material();
unsigned __int8 *Material_Alloc(int size);
void Load_CreateStateBits(const unsigned int (*pLoadBits)[2], GfxStateBits *stateBits);
void Load_CreateMaterialPixelShader(int a1, GfxPixelShaderLoadDef *loadDef, MaterialPixelShader *mtlShader);
void Load_CreateMaterialVertexShader(GfxVertexShaderLoadDef *loadDef, MaterialVertexShader *mtlShader);
void AssertValidVertexDeclOffsets(const stream_source_info_t *streamTable);
void Load_BuildVertexDecl(MaterialVertexDeclaration **mtlVertDecl, MaterialPass *pass);
bool MaterialTechniqueSet_FindHashLocation(const char *name, int *foundHashIndex);
// MaterialTechniqueSet *Material_FindTechniqueSet_LoadObj@<eax>(;
MaterialTechniqueSet *Material_FindTechniqueSet_FastFile(;
void Material_SetTechniqueSet(const char *name, MaterialTechniqueSet *techniqueSet);
void Material_SetAlwaysUseDefaultMaterial(const bool alwaysUseDefaultMaterial);
MaterialTechniqueSet *Material_RegisterTechniqueSet(;
void Material_ReleaseMaterialResources(Material *mtl);
void Material_WarmTechniqueSetShaders(XAssetHeader header);
void Material_WarmAllShaders();
void Material_DirtySort();
void Material_Add(Material *material, unsigned __int16 hashIndex);
bool Material_IsDefault(const Material *material);
void Material_GetHashIndex(const char *name, unsigned __int16 *hashIndex, bool *exists);
Material *Material_Register_FastFile(const char *name, int imageTrack, bool errorIfMissing, int waitTime);
void R_MaterialParameterTweakUpdate();
void R_EnumTechniqueSets(void (*func)(XAssetHeader, void *), void *data);
void R_EnumMaterials(void (*func)(XAssetHeader, void *), void *data);
const char *Material_GetName(Material *handle);
int Material_LoadFile(const char *filename, int *file);
BOOL IsValidMaterialHandle(Material *const handle);
int GetCodeConst_GenericParam0();
int GetCodeConst_GenericParam1();
int GetCodeConst_GenericParam2();
int GetCodeConst_GenericParam3();
int GetCodeConst_GenericParamA();
int GetCodeConst_GenericParamB();
int GetCodeConst_GameTimeParam();
void Material_ReleaseTechniqueSetResources(MaterialTechniqueSet *techniqueSet);
Material *Material_Duplicate(Material *mtlCopy, const char *name);
Material *Material_MakeDefault(const char *name);
Material *Material_Register_LoadObj(const char *name, int imageTrack);
Material *Material_Register();
Material *Material_RegisterHandle(const char *name, int imageTrack, bool errorIfMissing, int waitTime);
void Material_LoadPerMap(const PerMapMaterialTable *mtlTable, int mtlTableCount);
void R_InitAssets_PostMapFastfileLoad(int a1, int a2);

//t6/code/src_noserver/gfx_d3d/r_material.h
Material *Material_FromHandle(Material *handle);
MaterialTechniqueSet *Material_GetTechniqueSet(const Material *material);
MaterialTechnique *Material_GetTechnique(const Material *material, unsigned __int8 techType);

//t6/code/src_noserver/gfx_d3d/r_material_consts.cpp
void R_RegisterShaderConst(;
void R_GetPixelLiteralConsts(;
int R_ComparePixelConsts(const Material **material, const MaterialPass **pass);

//t6/code/src_noserver/gfx_d3d/r_material_load_db.h
void Load_GfxVertexShaderLoadDef(bool atStreamStart);
void Load_GfxPixelShaderLoadDef(bool atStreamStart);
void Load_MaterialVertexShader(bool atStreamStart);
// void Load_MaterialPixelShader(int a1@<edi>, bool atStreamStart);
void Load_MaterialShaderArgumentArray(bool atStreamStart, int count);
void Load_MaterialPassArray(bool atStreamStart, int count);
void Load_MaterialTechnique(bool atStreamStart);
void Load_MaterialTechniquePtrArray(bool atStreamStart, int count);
void Load_MaterialTechniqueSet(bool atStreamStart);
void Load_MaterialTechniqueSetPtr(bool atStreamStart);
void Load_GfxStateBitsTableArray(bool atStreamStart, int count);
void Mark_MaterialTextureDefArray(int count);
void Mark_MaterialTechniqueSetPtr();
void Mark_Material();
void Mark_MaterialHandle();
void Mark_MaterialHandleArray(int count);
void Load_MaterialTextureDefArray(bool atStreamStart, int count);
void Load_Material(bool atStreamStart);
void Load_MaterialHandle(bool atStreamStart);
void Load_MaterialHandleArray(bool atStreamStart, int count);

//t6/code/src_noserver/gfx_d3d/r_material_load_obj.cpp
int Material_GetTypeByPrefix(const char *name);
int Material_GetTypeByTechsetPrefix(const char *name);
const char *Material_GetPrefix(unsigned int materialType);
int R_DrawSurfStandardPrepassSortKey(const Material *material);
unsigned int Material_HashVertexDecl(const MaterialStreamRouting *routingData, int streamCount);
MaterialVertexDeclaration *Material_AllocVertexDecl(;
const float *Material_RegisterLiteral(const vec4_t *literal);
const char *Material_StringFromHash(unsigned int hash);
const char *Material_RegisterString(const char *string);
char Material_HashStateMap(const char *name, unsigned int *foundHashIndex);
bool MaterialTechnique_FindHashLocation(const char *name, unsigned int *foundHashIndex);
void Material_SetTechnique(const char *name, MaterialTechnique *technique);
const MtlStateMapBitName *Material_ParseValueForState(const char **text, const MtlStateMapBitName *bitNames);
MtlParseSuccess Material_ParseRuleSetConditionTest(;
MtlParseSuccess Material_ParseRuleSetCondition(;
bool Material_ParseRuleSetValue(;
MaterialStateMapRuleSet *Material_AssembleRuleSet(int ruleCount, const MaterialStateMapRule *rules);
bool Material_ParseRuleSet(;
bool Material_ParseStateMap(const char **text, MaterialStateMap *stateMap);
MaterialStateMap *Material_LoadStateMap(const char *name);
MaterialStateMap *Material_RegisterStateMap(const char *name);
bool Material_LoadPassStateMap(const char **text, MaterialStateMap **stateMap);
bool Material_ParseIndex(const char **text, int indexCount, int *index);
const char *Material_NameForStreamDest(unsigned __int8 dest);
bool Material_StreamDestForName(const char **text, const char *destName, unsigned __int8 *dest);
bool Material_StreamSourceForName(const char **text, const char *sourceName, unsigned __int8 *source);
bool Material_ResourceDestForStreamDest(;
bool Material_LoadPassVertexDecl(;
bool Material_ParseIndexRange(const char **text, unsigned int arrayCount, ShaderIndexRange *indexRange);
bool Material_ParseArrayOffset(const char **text, int arrayCount, int arrayStride, int *offset);
bool Material_CodeSamplerSource_r(;
bool Material_ParseSamplerSource(const char **text, ShaderArgumentSource *argSource);
bool Material_DefaultSamplerSourceFromTable(;
bool Material_ParseVector(const char **text, int elemCount, vec4_t *vector);
bool Material_ParseLiteral(const char **text, const char *token, vec4_t *literal);
bool Material_ParseCodeConstantSource_r(;
bool Material_ParseConstantSource(;
char Material_DefaultConstantSourceFromTable(;
bool Material_UnknownShaderworksConstantSource(;
unsigned int Material_ElemCountForParamName(;
bool Material_ParseArgumentSource(;
bool Material_DefaultArgumentSource(;
unsigned int R_SetParameterDefArray(;
unsigned int Material_PrepareToParseShaderArguments(;
int Material_CompareShaderArgumentsForCombining(const void *e0, const void *e1);
unsigned int Material_CombineShaderArguments(unsigned int usedCount, MaterialShaderArgument *localArgs);
bool Material_SetShaderArguments(;
ShaderUniformDef *Material_GetShaderArgumentDest(;
MaterialUpdateFrequency Material_GetArgUpdateFrequency(const MaterialShaderArgument *arg);
bool MaterialAddShaderArgument(;
bool Material_AddShaderArgumentFromLiteral(;
bool Material_AddShaderArgumentFromCodeConst(;
bool Material_AddShaderArgumentFromMaterial(;
// bool Material_AddShaderArgument@<al>(;
bool Material_ParseShaderArguments(;
MaterialVertexShader *Material_LoadVertexShader(const char *shaderName, ShaderStats *stats);
MaterialPixelShader *Material_LoadPixelShader(const char *shaderName, int shaderVersion, ShaderStats *stats);
bool Material_GetVertexShaderHashIndex(const char *shaderName, unsigned int *foundHashIndex);
// MaterialVertexShader *Material_RegisterVertexShader@<eax>(;
bool Material_GetPixelShaderHashIndex(const char *shaderName, unsigned int *foundHashIndex);
// MaterialPixelShader *Material_RegisterPixelShader@<eax>(;
unsigned __int8 Material_GetStreamDestForSemantic(const _D3D11_SIGNATURE_PARAMETER_DESC *semantic);
bool Material_SetPassShaderArguments_DX(;
bool Material_LoadPassVertexShader(;
bool Material_LoadDeclTypes(const char **text, MaterialPass *pass);
bool Material_LoadPassPixelShader(;
bool Material_ValidateShaderLinkage(;
int Material_CompareShaderArgumentsForRuntime(const void *e0, const void *e1);
unsigned __int8 Material_CountArgsWithUpdateFrequency(;
bool Material_LoadPass(;
MaterialTechnique *Material_LoadTechnique(const char *name, int materialType);
MaterialTechnique *Material_RegisterTechnique(const char *name, int materialType);
bool Material_IgnoreTechnique(const char *name);
unsigned __int8 Material_TechniqueTypeForName(const char *name, bool *inUse);
bool Material_HasAlphaTest(const Material *mtl);
void Material_GetTechniqueSetDrawRegion;
void Material_SetMaterialDrawRegion(Material *material);
MaterialTechniqueSet *Material_LoadTechniqueSet(const char *fullName);
void Material_RemapStateBits(;
unsigned __int8 Material_AddStateBitsArrayToTable(;
unsigned int Material_GetCullFlags(Material *material);
unsigned int Material_GetCullShadowFlags(Material *material);
unsigned int Material_GetDecalFlags(const Material *mtl);
unsigned int Material_GetWritesDepthFlags(const Material *mtl);
unsigned int Material_GetUsesDepthBufferFlags(const Material *mtl);
unsigned int Material_GetUsesStencilBufferFlags(const Material *mtl);
void Material_UpdateTechniqueFlags(Material *material);
void Material_SetStateBits(;
void Material_BuildStateBitsTable(;
char Material_ValidatePassArguments(;
char Material_Validate(const Material *material);
int CompareRawMaterialTextures(const void *e0, const void *e1);
int CompareHashedMaterialTextures(const void *e0, const void *e1);
bool Material_FinishLoadingInstance(;
void Material_GetLayeredStateBits(;
unsigned int Material_CreateLayeredStateBitsTable(;
;
bool Material_HasNormalMap(const Material *mtl);
unsigned int Material_AppendTechniqueSetName(;
const LayeredTechniqueSetName *Material_GetLayeredTechniqueSetName(const char *techSetName);
void Material_SetGameFlags;
Material *Material_LoadRaw(;
void Material_GetInfo(Material *handle, MaterialInfo *matInfo);
void Material_GetVertexShaderName(char *dest, const MaterialPass *pass, int destsize);
int Material_ComparePixelConsts(const Material *mtl0, const Material *mtl1, unsigned __int8 techType);
int Material_CompareBySortKeyAndTechnique(;
bool Material_Compare(const Material *mtl0, const Material *mtl1);
void R_BuildScritableConstantArray(ScriptableConstant *array, int arraySize);
// char R_FindScriptableConstantSource_ByHash@<al>(;
char R_FindScriptableConstantSource_ByName(const char *name, unsigned __int8 *dest);
// const char *R_FindScriptableConstantName_BySource@<eax>(;
MaterialTechniqueSet *Material_RegisterLayeredTechniqueSet(const Material **mtl, unsigned int layerCount);
Material *Material_LoadLayered(const char *assetName);
// Material *Material_Load@<eax>(LocalClientNum_t a1@<ebx>, const char *fullAssetName, int imageTrack);
void Material_SortInternal(Material **sortedMaterials, unsigned int materialCount);
void Material_Sort();

//t6/code/src_noserver/gfx_d3d/r_material_pass_load_obj.cpp
int R_IsMaterialPassMatch(MaterialPass *pass, VertexConstantMappingEntry *entry);
int R_IsMaterialPassConflict(;
// void R_MaterialPrecompilePass(VertexConstantMappingEntry *a1@<edx>, MaterialPass *pass);

//t6/code/src_noserver/gfx_d3d/r_mem_track.cpp
void R_Track_Init();

//t6/code/src_noserver/gfx_d3d/r_meshdata.cpp
void R_BeginMeshVerts(GfxMeshData *mesh);
char R_ReserveMeshIndices(GfxMeshData *mesh, int indexCount, r_double_index_t **indicesOut);
char R_ReserveMeshVerts(GfxMeshData *mesh, int vertCount, unsigned __int16 *baseVertex);
unsigned __int8 *R_GetMeshVerts(GfxMeshData *mesh, unsigned __int16 baseVertex);
void R_ResetMesh(GfxMeshData *mesh);
void R_SetQuadMeshData(;
void R_SetQuadMesh(;

//t6/code/src_noserver/gfx_d3d/r_model.cpp
void TRACK_r_model();
unsigned __int8 *Hunk_AllocXModelPrecache(int size);
unsigned __int8 *Hunk_AllocXModelPrecacheColl(int size);
XModel *R_RegisterModel();
void R_XModelDebugBoxes(const DObj *obj, int *partBits);
void R_XModelDebugAxes(const DObj *obj, int *partBits);
void R_XModelDebug(const DObj *obj, int *partBits);
int R_SkinXModel(;
int R_SkinAndBoundSceneEnt(GfxSceneEntity *sceneEnt);
void XSurfaceReleaseResources(XSurface *surf);
void XSurfaceRenderString(const vec3_t *pos, const char *string);

//t6/code/src_noserver/gfx_d3d/r_model_lighting.cpp
unsigned int R_ModelLightingIndexFromHandle(unsigned __int16 handle);
void R_SetModelLightingConsts(;
void R_SetStaticModelLightingConsts(;
// unsigned int R_AllocModelLightingPixel@<eax>(;
void R_ToggleModelLightingFrame();
void R_SetStaticModelLightingForSource(;
void R_BeginAllStaticModelLighting();
void R_SetupDynamicModelLighting(GfxCmdBufInput *input);
void R_InitModelLightingGlobals();
void R_ResetModelLighting();
void R_InitStaticModelLighting();
void R_SetModelLightingForSource(unsigned __int16 handle, GfxCmdBufSourceState *source);
char R_AllocStaticModelLighting(const GfxStaticModelDrawInst *smodelDrawInst, unsigned int smodelIndex);
void R_CalcModelLighting(;
void R_SetStaticModelLighting(unsigned int smodelIndex);
void R_SetAllStaticModelLighting();
// unsigned int R_AllocModelLighting@<eax>(;

//t6/code/src_noserver/gfx_d3d/r_model_lighting.h
void R_EncodeLightingSH(const GfxLightingSH *lightingSH, GfxLightingSHQuantized *encodedLightingSH);
void R_DecodeLightingSH(const GfxLightingSHQuantized *encodedLightingSH, GfxLightingSH *lightingSH);

//t6/code/src_noserver/gfx_d3d/r_model_lod.cpp
double R_GetBaseLodDist(const vec3_t *origin);
double R_GetAdjustedLodDistExtracam(;
double R_GetAdjustedLodDist(float dist, XModelLodRampType lodRampType);

//t6/code/src_noserver/gfx_d3d/r_model_pose.cpp
DObjAnimMat *R_DObjCalcPose(const GfxSceneEntity *sceneEnt, const DObj *obj, int *partBits);
void R_SetNoDraw(GfxSceneEntity *sceneEnt, GfxSceneEntity *localSceneEnt);
;
void R_UpdateGfxEntityBoundsCmd(void *data);
// int R_SkinSceneModel@<eax>(;
void R_ModelSkelCmd(void *data);

//t6/code/src_noserver/gfx_d3d/r_model_skin.cpp
void R_Tension(;
DWORD EndBench();
void BenchSurf(const XSurface *surf, const DObjSkelMat *mat);
void R_SkinXSurfaceRigid(const XSurface *surf);
void R_SkinXSurfaceWeight(const GfxPackedVertex *inVerts, const XSurfaceVertexInfo *vertexInfo);
void R_SkinXModelCmd(void *data);

//t6/code/src_noserver/gfx_d3d/r_outdoor.cpp
void Outdoor_ApplyBoundingBox(const vec3_t *outdoorMin, const vec3_t *outdoorMax);
unsigned int Outdoor_UpdateTransforms();
// void R_RegisterOutdoorImage(const vec3_t *a1@<edx>, GfxWorld *world, const vec3_t *outdoorMin);
;
void R_GenerateOutdoorImage(GfxImage *outdoorImage);

//t6/code/src_noserver/gfx_d3d/r_perf_timer.cpp
void R_Perf_GetTimerAverageAndMaxMs(;
void R_Perf_GetFrameAverageAndMaxMs(;
void R_Perf_ResetDraw();
void R_Perf_DrawTimers(PerfTimerFrameHistory *timerFrameHistory, PerfTimerStyle *timerStyle);

//t6/code/src_noserver/gfx_d3d/r_pix_profile.h
void PIXBeginNamedEvent(int Color, const char *Name, ...);
void PIXSetMarker(int Color, const char *Name, ...);

//t6/code/src_noserver/gfx_d3d/r_pointlights.cpp
void GenerateLightGridBasisDirs();
void GatherIncidentEnergyInSpaceForLightFromDir(;
void AddLightGridLightingForDir(vec3_t *lightingForDir, GfxDecodedLightGridColors *colors);
bool EvaluateHeroLightForGrid(;
void R_AdjustLightColorSamples(GfxDecodedLightGridColors *colors);
void R_AddHeroOnlyLightsToGridColors(GfxDecodedLightGridColors *packed, const vec3_t *heroPos);

//t6/code/src_noserver/gfx_d3d/r_pretess.cpp
void R_InitDrawSurfListInfo(GfxDrawSurfListInfo *info);
void R_EmitDrawSurfList(;
unsigned int R_GetKeyCount(;
void R_MergeAndEmitDrawSurfLists(;

//t6/code/src_noserver/gfx_d3d/r_primarylights.cpp
unsigned int R_AddPotentiallyShadowedLight(;
void R_AddShadowedLightToShadowHistory(;
void R_FadeOutShadowHistoryEntries(GfxShadowedLightHistory *shadowHistory, float fadeDelta);
void R_ClearShadowedPrimaryLightHistory(LocalClientNum_t localClientNum);
unsigned int R_AddDynamicShadowableLight(GfxViewInfo *viewInfo, const GfxLight *visibleLight);
BOOL R_IsDynamicShadowedLight(unsigned int shadowableLightIndex);
BOOL R_IsPrimaryLight(unsigned int shadowableLightIndex);
void R_ChooseShadowedLights(unsigned __int8 *shadowableLightIsUsed, GfxViewInfo *viewInfo);
unsigned int R_GetPrimaryLightEntityShadowBit(;
unsigned int R_GetPrimaryLightDynEntShadowBit(unsigned int entnum, unsigned int primaryLightIndex);
void R_LinkSphereEntityToPrimaryLights(;
void R_LinkBoxEntityToPrimaryLights(;
void R_LinkDynEntToPrimaryLights(;
void R_UnlinkEntityFromPrimaryLights(;
void R_UnlinkDynEntFromPrimaryLights(;
// BOOL R_IsEntityVisibleToPrimaryLight@<eax>(unsigned int a1@<edx>, LocalClientNum_t localClientNum);
// BOOL R_IsDynEntVisibleToPrimaryLight@<eax>(;
int R_IsEntityVisibleToAnyShadowedLight(const GfxViewInfo *viewInfo, unsigned int entityNum);
BOOL R_IsDynEntVisibleToAnyShadowedLight(;
void R_ShowPrimaryLightDebugLine(;
void R_ShowPrimaryLightBsp(const GfxSurface *surface, unsigned int primaryLightIndex);

//t6/code/src_noserver/gfx_d3d/r_primarylights_cull.h
char R_CullBoxFromLightRegionHull(;
char R_CullBoxFromLightRegion(;

//t6/code/src_noserver/gfx_d3d/r_qrcode.cpp
void RB_QRCode_SetShaderConstants(GfxCmdBufSourceState *source, const GfxQRCodeBackend *rbQRCode);
void R_QRCode_SetupBackendData(GfxQRCodeBackend *qrcodeBackend);

//t6/code/src_noserver/gfx_d3d/r_reflection_probe.cpp
void R_GetReflectionProbePosition(unsigned int index, vec3_t *pos);
void R_SetBlackProbe(unsigned __int8 *to, unsigned int size);
GfxImage *R_GenerateReflectionImageFromRawData(;
void R_GenerateDummyReflectionImages(;
void R_GenerateReflectionImages(;

//t6/code/src_noserver/gfx_d3d/r_reflection_probe_load_db.h
void Mark_GfxReflectionProbeArray(int count);
void Load_GfxReflectionProbeArray(bool atStreamStart, int count);

//t6/code/src_noserver/gfx_d3d/r_rendercmds.cpp
void TRACK_r_rendercmds();
void R_InitGlassRenderBuffers(int numIndices, int numVerts, int vertexSize);
void R_InitTempSkinBuf(unsigned int maxVerts);
void R_ShutdownTempSkinBuf();
unsigned int R_UpdateSkinCacheUsage();
GfxCmdHeader *R_GetCommandBuffer(GfxRenderCommand renderCmd, int bytes);
void R_BeginClientCmdList2D();
void R_ClearClientCmdList2D();
void R_BeginSharedCmdList();
void R_BeginCompositingCmdList();
void R_AddCmdEndOfList();
int R_ToggleSmpFrame();
unsigned int R_GetFrameCount();
GfxViewParms *R_AllocViewParms();
void R_AddCmdDrawStretchPicWInternal(;
void R_AddCmdDrawStretchPicInternal(;
void R_AddCmdDrawStretchPicRotateXYInternal(;
void R_AddCmdDrawStretchPicRotateSTInternal(;
GfxCmdDrawText2D *AddBaseDrawTextCmd(;
void R_AddCmdDrawTextWithCursorInternal(;
void R_AddCmdDrawTextInternal(;
void R_AddCmdDrawTextWInternal(;
void R_AddCmdDrawTextSubtitleInternal(;
void R_AddCmdDrawTextWithEffectsInternal(;
void R_AddCmdDrawTextWithCOD7DecodeEffectsInternal(;
void R_AddCmdDrawTextWithCOD7TypeWriterEffectsInternal(;
void R_AddCmdDrawTextWithRedactEffectsInternal(;
void R_AddCmdDrawTextWithPopInEffectsInternal(;
void CopyPoolTextToCmd(;
GfxCmdDrawText2D *AddBaseDrawConsoleTextCmd(;
void R_AddCmdDrawConsoleTextInternal(;
void R_AddCmdDrawConsoleTextTypewriterFXInternal(;
void R_AddCmdDrawConsoleTextSubtitleInternal(;
void R_AddCmdDrawConsoleTextPulseFXInternal(;
void R_AddCmdDrawQuadPicWInternal(const vec2_t *verts, float w, const vec4_t *color, Material *material);
void R_AddCmdDrawQuadPicInternal(const vec2_t *verts, const vec4_t *color, Material *material);
void R_AddCmdSetCustomConstantInternal(unsigned int type, const vec4_t *vec);
void R_AddCmdSetViewportValuesInternal(int x, int y, int width, int height);
void R_AddCmdSetScissorValuesInternal(bool enabled, int x, int y, int width, int height);
void R_AddCmdPCCopyImageGenMIPInternal(void (*callback)(void *), GfxImage *image, void *job);
bool R_LightTweaksModified();
void R_SetTestLods();
int R_SetOutdoorFeatherConst();
void R_EndFrame();
void R_AddCmdClearScreenInternal(int whichToClear, const vec4_t *color, float depth, unsigned __int8 stencil);
GfxCmdHeader *R_AddCmdDrawQuadList2DInternal(Material *materialHandle, int quadCount);
void R_AddCmdProjectionSet2DInternal();
void R_AddCmdDrawFramedInternal(;
void R_AddCmdSetShaderConstantSetInternal(const ShaderConstantSet *scs_src);
void R_EnableRemoteScreenUpdateInGame(bool en);
void R_BeginRemoteScreenUpdate();
void R_EndRemoteScreenUpdate();
void R_PushRemoteScreenUpdate(int remoteScreenUpdateNesting);
int R_PopRemoteScreenUpdate();
BOOL R_IsInRemoteScreenUpdate();
void R_InitRenderCommands();
void R_FreeGlassRenderBuffers();
void R_SyncRenderThread();
void R_ToggleSmpFrameCmd();
void R_IssueRenderCommands(unsigned int type);
bool R_UpdateFrontEndDvarOptions();
void R_BeginFrame();

//t6/code/src_noserver/gfx_d3d/r_rendertarget.cpp
void AssertUninitializedRenderTarget(const GfxRenderTarget *renderTarget);
void R_AssignImageToRenderTargetDepthStencil(;
void R_AssignImageToRenderTargetColor(GfxRenderTarget *renderTarget, GfxImage *image, DXGI_FORMAT format);
void R_InitRenderTargetImage(;
void R_InitSizedRenderTargetImage(;
void R_InitShadowmapRenderTarget(;
const char *R_RenderTargetName(unsigned __int8 renderTargetId);
void R_InitExtraCamRenderTargets(;
void R_ShutdownExtraCamRenderTargets();
void R_InitUI3DRenderTarget(int width, int height, int location, bool allocatePingPongBuffer);
void R_ShutdownUI3DRenderTarget(bool freePingPongBuffer);
void R_ResizeSunShadowmapRenderTarget_PC();
void R_ResizeSpotShadowmapRenderTarget_PC();

//t6/code/src_noserver/gfx_d3d/r_rope_render.cpp
void SetupVertex(;
;
void R_Rope_GenerateVerts_Camera(RopeGenerateVertsCmd *cmd);
void R_Rope_ClearAll();
void R_Rope_Add(const VisualRope *vropeIn);
unsigned __int8 R_Rope_CalcVisibility(const vec3_t *mins, const vec3_t *maxs, LocalClientNum_t localClientNum);
const Material *R_Rope_GetMaterialFromGfxWorld();
RopeRenderInfo *R_Rope_GetInfo();

//t6/code/src_noserver/gfx_d3d/r_scene.cpp
GfxScene *R_GetScene();
unsigned int R_AllocSceneDObj();
unsigned int R_AllocSceneModel();
char R_AllocTextureOverride(;
char R_AllocTextureOverride(;
char R_AllocTextureOverride(;
char R_AllocTextureOverride(;
char R_AllocTextureOverride(;
unsigned int R_AllocSceneBrush();
void R_TryToValidateBrushModel(unsigned int modelIndex);
GfxBrushModel *R_GetBrushModel(unsigned int modelIndex);
void R_AddBrushModelToSceneFromAngles(;
void R_AddGlassBrushToScene(;
void R_AddDObjToScene(;
int R_AllocParticleCloud();
GfxParticleCloud *R_GetGfxParticleCloud(unsigned int index);
void R_PrepareXModelRigidCullInfo(XModelRigidCullInfoContext *cullInfoContext);
void R_CloneAndSetupXModelDrawSurf(;
void R_AddOmniLightToScene(;
void R_AddSpotLightToScene(;
void R_AddFlashLightToScene(;
void R_UpdateFrameFog(refdef_t *refdef);
void R_SetupViewProjectionMatrices(GfxViewParms *viewParms);
void R_SetAllowShadowMaps(const bool allowShadowMaps);
void R_AddBModelSurfacesCamera(;
GfxDrawSurf *R_AddBModelSurfaces(;
const XSurface *R_GetXSurface(const void *modelSurf, surfaceType_t surfType);
void R_SetEnablePlayerShadowFlag(bool flag);
Material *R_MaterialOverride(unsigned int modelIndex, int textureOverrideIdx, Material *drawMaterial);
void R_AddXModelSurfacesCamera(;
GfxDrawSurf *R_AddXModelSurfaces(;
GfxDrawSurf *R_AddDObjSurfaces(;
void R_SetSceneComposition(;
void R_CheckShadowMapVolumes(const vec3_t *position);
char R_CheckShadowMapVolume(const vec3_t *position, unsigned int volumeIdx);
int R_CheckWorldFogModifierVolumes(vec3_t *position, unsigned int bankMask);
void R_UpdateWorldFrameFog(refdef_t *refdef);
int R_CheckExposureVolumes(vec3_t *position, float *feather);
void R_UpdateExposureValue;
void R_SetExposure;
// void R_InitModifierVolumes(float *a1@<edx>, vec3_t *a2@<ecx>, refdef_t *refdef);
void R_SetDepthOfField(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetDoubleVision(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetWaterSheetingFx(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetFlameFx(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetElectrifiedFx(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetTransportedFx(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetReviveFx(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetRimIntensity(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetGenericSceneVectors(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetPoisonFx(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
__int16 R_TestLutVolumes(vec3_t *position, unsigned __int16 bankMask);
void R_SetFilmInfo(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms, refdef_t *refdef);
void R_SetBloomInfo(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetCharacterPrimaryLightScaleInfo(GfxViewInfo *viewInfo, const GfxSceneParms *sceneParms);
void R_SetFullSceneViewMesh(int viewInfoIndex, GfxViewInfo *viewInfo);
void R_AddDrawLitCall(;
void R_AddDrawLitBspCall(;
void R_AddDrawLitStaticModelCall(;
void R_AddEmissiveSpotLight(GfxViewInfo *viewInfo, GfxLight *visibleLights, int visibleLightCount);
void R_SetSunShadowConstants(GfxCmdBufInput *input, const GfxSunShadowProjection *sunProj);
void R_SetSkyConstants(GfxCmdBufInput *input, const GfxViewInfo *viewInfo);
void R_SetSunConstants(GfxCmdBufInput *input, float sunVisibility);
void R_SetHeroLighting(GfxCmdBufInput *input, GfxViewInfo *viewInfo);
void R_SetSkyColorMatrix(GfxCmdBufInput *input);
void R_SetHDRControlConstants(;
;
void R_SplitDrawSurfacesPrimarySortKeyScanRev(;
void DrawLightDebug(;
void DrawSunDirectionDebug(const vec3_t *viewOrg, const vec3_t *viewForward);
void R_DrawFogParams(const refdef_t *refdef);
// void R_SetSkyDynamicIntensity(float a1@<edi>, const vec3_t *viewForward, GfxCmdBufInput *input);
int R_WaitForFXUpdateWorkerCmds();
int R_WaitForFXNonSpriteWorkerCmds();
void R_SetupDrawSurfListInfos(;
void R_SplitAndMergeDrawLists(;
void R_MergeAndEmitDrawSurfListsIntoList(;
void R_FinishDecalAndEmissiveDrawSurfs(;
void R_DrawRecordFrame();
void R_AddDrawRecord(GfxViewInfo *viewInfo, GfxBackEndData *data, unsigned int viewInfoIndex);
unsigned int R_GetDrawRecordFrame();
void R_InvalidateShadowableLightCache();
int R_UpdateCachedLightUsage();
void R_InitCachedVisibleLights();
void R_GetCachedVisibleLights(GfxViewInfo *viewInfo);
void R_SetupVisibility(GfxViewInfo *viewInfo, const GfxViewParms *viewParmsDpvs, bool recalculateShadows);
void R_SetupNeedResolve(GfxViewInfo *viewInfo);
GfxViewInfo *R_AllocViewInfo();
void R_SetupSunShadowGlobals();
void R_GenerateSortedDrawSurfs(;
void R_AddDrawCalls();
void R_ClearScene(LocalClientNum_t localClientNum, bool forStereoRightEyeView, bool forExtraCam);
LocalClientNum_t R_GetLocalClientNum();
void R_SetViewParmsForScene(const refdef_t *refdef, GfxViewParms *viewParms);
void R_SetSceneParms(const refdef_t *refdef, GfxSceneParms *sceneParms);
void R_ExtraCam_SetSceneParms(const refdef_t *refdef, GfxSceneParms *sceneParms);
void R_LerpDir(;
int R_UpdateFrameSun();
double R_LodScaleForSkinCacheOverflow(unsigned int viewIndex, float currentScale);
void R_UpdateLodParms(const refdef_t *refdef, GfxLodParms *lodParms);
void R_SetLodOrigin(const refdef_t *refdef);
GfxViewParms *R_SetupRenderSceneViewParms(const refdef_t *refdef);
void R_RenderScene(;
void R_LinkDObjEntity(LocalClientNum_t localClientNum, unsigned int entnum, vec3_t *origin, float radius);
void R_LinkBModelEntity(LocalClientNum_t localClientNum, unsigned int entnum, GfxBrushModel *bmodel);
void R_UnlinkEntity(LocalClientNum_t localClientNum, unsigned int entnum);
void R_LinkDynEnt(unsigned int dynEntId, DynEntityDrawType drawType, vec3_t *mins, vec3_t *maxs);
void R_UnlinkDynEnt(unsigned int dynEntId, DynEntityDrawType drawType);
void R_PvsLock_GetViewOrigin(vec3_t *out);
void R_PvsLock_GetViewAxis(vec3_t *out);
GfxViewParms *R_PvsLock_GetViewParms();
void ShowLodInfo(;
void R_PerMap_Init();
void R_AddDObjSurfacesCamera(;
void R_SetupVisibilityEarly(;
int r_add_draw_callsCallback(jqBatch *batch);
void R_RenderExtraCam(;

//t6/code/src_noserver/gfx_d3d/r_screenshot.cpp
void TRACK_r_screenshot();
void R_CubemapShotFlipVerticalBuffer(unsigned __int8 *buffer);
void R_CubemapShotWriteTargaHeader(const int res, unsigned __int8 *fileBuffer);
void R_CubemapShotCopyBufferToTarga(const unsigned __int8 *srcBuffer, unsigned __int8 *targa);
void R_CubemapShotApplyFresnelToTarga(;
void R_CubemapShotWriteTargaFile(;
void R_BeginCubemapShot(const int pixelWidthHeight, const int pixelBorder);
void R_SaveCubemapShot(const char *filename, const CubemapShot shotIndex, const float n0, const float n1);
void R_CubemapLightingForDir(;
void R_CubemapLighting(;
void R_CubemapShotExtractLinearLight(unsigned __int8 **pixels, int width, int height, vec3_t **linearColors);
void R_LightingFromCubemapShots(const vec3_t *baseColor);
// char R_GetBackBufferData@<al>(;
void R_CubemapShotCopySurfaceToBuffer(unsigned __int8 *buffer, const int bufferSizeInBytes);
void R_CopyCubemapShot(CubemapShot shotIndex);
void __thiscall R_EndCubemapShot(void *this);

//t6/code/src_noserver/gfx_d3d/r_setstate_d3d.h
void R_HW_SetVertexShaderConstant(;
void R_HW_SetPixelShaderConstant(;
void R_HW_ForceSamplerState(ID3D11DeviceContext *device, unsigned int samplerIndex, unsigned int samplerState);
void R_FlushDirtyConstantBuffers(GfxCmdBufPrimState *state);

//t6/code/src_noserver/gfx_d3d/r_shade.cpp
void R_SetVertexShaderConstantFromLiteral(;
void R_SetPixelShaderConstantFromLiteral(;
const float *R_GetCodeConstant(const GfxCmdBufContext *context, unsigned int constant);
void R_SetVertexShaderConstantFromCode(;
int R_IsPixelShaderConstantUpToDate(;
void R_SetPixelShaderConstantFromCode(;
void R_SetPassShaderPrimArguments(;
void R_SetPassShaderObjectArguments(;
void R_SetupPassPerPrimArgs(GfxCmdBufContext context);
void R_SetupPassPerObjectArgs(GfxCmdBufContext context);
void R_SetPassPixelShaderStableArguments(;
void R_SetPassVertexShaderStableArguments(;
void R_SetupPassCriticalPixelShaderArgs(GfxCmdBufContext context);
void R_SetupPassVertexShaderArgs(GfxCmdBufContext context);
const MaterialTextureDef *R_SetPixelSamplerFromMaterial(;
void R_SetPassShaderStableArguments(;
int R_SetIndexDataIndexCount(GfxCmdBufState *state, const unsigned __int16 *indices, int indexCount);
void R_SetPixelShader(GfxCmdBufState *state, const MaterialPixelShader *pixelShader);
void R_SetVertexShader(GfxCmdBufState *state, const MaterialVertexShader *vertexShader);
void R_UpdateVertexDecl(GfxCmdBufState *state);
void R_SetupPass(GfxCmdBufContext context, unsigned int passIndex);
int R_SetVertexData(GfxCmdBufState *state, const void *data, int vertexCount, int stride);

//t6/code/src_noserver/gfx_d3d/r_shade.h
char R_CheckVertexDataOverflow(GfxVertexBufferState *buffer, int dataSize);

//t6/code/src_noserver/gfx_d3d/r_shader_constant_set.cpp
void R_InitShaderConstantSet(ShaderConstantSet *scs);
BOOL R_ShaderConstantSetIsUsed(const ShaderConstantSet *scs);
void R_CopyShaderConstantSet(const ShaderConstantSet *scs_src, ShaderConstantSet *scs_dst);
int R_GetConstantIndex(const ShaderConstantSet *scs, const char *constantName);
char R_SetShaderConstantSetValue(ShaderConstantSet *scs, int index, const vec4_t *v);
char R_SetShaderConstantSetValue(ShaderConstantSet *scs, int index, float x, float y, float z, float w);
char R_SetShaderConstantSetValueX(ShaderConstantSet *scs, int index, float x);
char R_SetShaderConstantSetValueY(ShaderConstantSet *scs, int index, float y);
char R_SetShaderConstantSetValueZ(ShaderConstantSet *scs, int index, float z);
char R_SetShaderConstantSetValueW(ShaderConstantSet *scs, int index, float w);
int RB_ApplyShaderConstantSet(GfxCmdBufSourceState *gfxSourceState, const ShaderConstantSet *scs);
void XModelDrawSurf_EncodeIndex(GfxDrawSurf *drawSurf, unsigned int scsIndex);
ShaderConstantSet *RB_ShaderConstantSetFromDrawSurf(;
void RB_ApplyShaderConstantSet(GfxCmdBufSourceState *gfxSourceState, const GfxDrawSurf *drawSurf);
BOOL RB_DrawSurf_Uses_ShaderConstantSet(const GfxDrawSurf *drawSurf);
unsigned int CopyShaderConstantSetToBackendData(const ShaderConstantSet *scs);
void R_XModelDrawSurfEncodeShaderConstantSet(;
unsigned int R_ShaderConstantSet_CopyToFrontEndDataOut(const ShaderConstantSet *scs);
ShaderConstantSet *R_ShaderConstantSet_FromFrontEndDataOut(unsigned int constSetindex);
void RB_SaveCurrentShaderConstantSetValues(;
// void __thiscall ScopedShaderConstantSetUndo::ScopedShaderConstantSetUndo(;
// void __thiscall ScopedShaderConstantSetUndo::~ScopedShaderConstantSetUndo(ScopedShaderConstantSetUndo *this);
void R_ShaderConstantShowDebug(;
bool R_MapShaderConstantSet(ShaderConstantSet *scs, int index, const char *constantName);
int R_AllocShaderConstantSet(ShaderConstantSet *scs, const char *name);

//t6/code/src_noserver/gfx_d3d/r_skinnedverts_load_db.h
void Load_SkinnedVertsDef(bool atStreamStart);
void Load_SkinnedVertsDefPtr(bool atStreamStart);
void Mark_SkinnedVertsDefPtr();

//t6/code/src_noserver/gfx_d3d/r_sky.cpp
void R_RegisterSunDvars(const char *a1, dvarType_t a2);
void R_SetSunFromDvars(sunflare_t *sun);
void R_LoadSunThroughDvars(const char *sunName, sunflare_t *sun);
void R_FlushSun();

//t6/code/src_noserver/gfx_d3d/r_skybox.cpp
void R_RegisterSkyboxModel();
void R_ClearSkyboxModel();
void R_AddSkyboxModel(const vec3_t *eyePos);
XModel *R_MapGetSkyboxModel();

//t6/code/src_noserver/gfx_d3d/r_sky_load_obj.cpp
void R_LoadSun(const char *name, sunflare_t *sun);

//t6/code/src_noserver/gfx_d3d/r_spotshadow.cpp
;
void R_GetSpotShadowLookupMatrix(;
void R_AddSpotShadowModelEntities(;
void R_EmitSpotShadowMapSurfs(GfxViewInfo *viewInfo);
void R_GenerateAllSortedSpotShadowDrawSurfs(GfxViewInfo *viewInfo, int viewIndex);
char R_AddSpotShadowsForLight(;

//t6/code/src_noserver/gfx_d3d/r_sprite.cpp
void R_BuildQuadStampCodeMeshVerts(;
void R_GenerateQuadStampCodeMeshVerts(;
// _DWORD *really_fast_sincos@<eax>(_DWORD *result@<eax>, _DWORD *a2@<ecx>, __m128d a3@<xmm0>);
;

//t6/code/src_noserver/gfx_d3d/r_state.cpp
void R_ChangeDepthHackNearClip(GfxCmdBufSourceState *source, unsigned int depthHackFlags);
void R_ChangeObjectPlacement_Core(GfxCmdBufSourceState *source, const GfxScaledPlacement *placement);
void R_ChangeObjectPlacementRemote(GfxCmdBufSourceState *a1, const GfxScaledPlacement *a2);
void R_DeriveViewMatrix(GfxCmdBufSourceState *source);
;
void R_DeriveProjectionMatrix(GfxCmdBufSourceState *source);
void R_DeriveViewProjectionMatrix(GfxCmdBufSourceState *source);
;
void R_DeriveShadowLookupMatrix(GfxCmdBufSourceState *source);
;
void R_DeriveCodeMatrix(;
const vec4_t *R_GetCodeMatrix(GfxCmdBufSourceState *source, unsigned int sourceIndex, unsigned int firstRow);
const GfxImage *R_GetTextureFromCode(;
void R_TextureFromCodeError(const GfxCmdBufContext *context, unsigned int codeTexture);
GfxImage *R_OverrideLightmapImage(int dvar_integer);
void R_SetReflectionProbe(GfxCmdBufContext context, unsigned int reflectionProbeIndex);
void R_ChangeDepthRange(GfxCmdBufState *state, GfxDepthRangeType depthRangeType);
void R_ChangeIndices(GfxCmdBufPrimState *state, ID3D11Buffer *ib);
void R_FlushStreamSources(GfxCmdBufPrimState *state, int firstStream, int lastStream);
void R_ChangeStreamSource(;
void R_DrawIndexedPrimitive(;
ID3D11BlendState *R_HW_CreateBlendState(unsigned int stateBits0);
ID3D11DepthStencilState *R_HW_CreateDepthStencilState(unsigned int stateBits1, unsigned __int8 stencilMask);
ID3D11RasterizerState *R_HW_CreateRasterizerState(unsigned int stateBits0, unsigned int stateBits1);
void R_DX11_ReleaseSamplerStates();
void R_SetSampler(;
void R_TextureOverride(;
void R_GetViewport(GfxCmdBufSourceState *source, GfxViewport *outViewport);
void R_SetViewport(GfxCmdBufState *state, const GfxViewport *viewport);
void R_SetViewportStruct(GfxCmdBufSourceState *source, const GfxViewport *viewport);
void R_SetViewportStructNoOffset(GfxCmdBufSourceState *source, const GfxViewport *viewport);
void R_SetScissorStruct(GfxCmdBufSourceState *source, const GfxViewport *scissor);
void R_ClearScissorStruct(GfxCmdBufSourceState *source);
char R_GetScissor(GfxCmdBufSourceState *source, GfxViewport *outScissor);
void R_SetScissor(GfxCmdBufState *state, const GfxViewport *_scissor);
void R_ClearScissor(GfxCmdBufState *state);
void R_SetViewportValues(GfxCmdBufSourceState *source, int x, int y, int width, int height);
void R_SetFullViewport(GfxCmdBufSourceState *source);
void R_UpdateViewport(GfxCmdBufSourceState *source, GfxViewport *viewport);
void R_DisableSampler(GfxCmdBufState *state, unsigned int samplerIndex);
void R_UnbindImage(GfxCmdBufState *state, const GfxImage *image);
void R_SetRenderTargetSize(GfxCmdBufSourceState *source, unsigned __int8 newTargetId);
void R_SetRenderTarget(GfxCmdBufContext context, unsigned __int8 newTargetId);
void R_ClearRenderTargetForMultiGpu(GfxCmdBufContext context, unsigned __int8 targetId);
void R_ClearScreenInternal(;
void R_ClearScreen(;
void R_DrawCall(;
void R_SetLightmap(GfxCmdBufContext context, unsigned int lmapIndex);
void R_ClearAllStreamSources(GfxCmdBufPrimState *state);
void R_SetMeshStream(GfxCmdBufState *state, GfxMeshData *mesh);
void R_HW_SetBlendState(GfxCmdBufState *state, unsigned int stateBits0);
ID3D11DepthStencilState *R_HW_FindDepthStencilState(unsigned int stateBits1, unsigned __int8 stencilMask);
void R_HW_SetDepthStencilState(;

//t6/code/src_noserver/gfx_d3d/r_state.h
void R_SetInputCodeConstantFromVec4(GfxCmdBufInput *input, unsigned int constant, const vec4_t *value);
void R_SetCodeConstant(GfxCmdBufSourceState *source, unsigned int constant, float x, float y, float z, float w);
int R_UpdateCodeConstant(;
void R_SetCodeConstantFromVec4(GfxCmdBufSourceState *source, unsigned int constant, const vec4_t *value);
int R_UpdateCodeConstantFromVec4(GfxCmdBufSourceState *source, unsigned int constant, const vec4_t *value);
void R_SetObjectPlacement(GfxCmdBufSourceState *source, const GfxScaledPlacement *placement);
void R_SetState(GfxCmdBufState *state, const GfxStateBits *stateBits, unsigned __int8 stencilRef);
void R_SetStreamSource(;
void R_HW_SetRenderTarget(GfxCmdBufState *state, unsigned __int8 newTargetId);
void R_SetTripleStreamSource(;
void R_SetDoubleStreamSource(;
void R_UpdateShadowLookupMatrix(;

//t6/code/src_noserver/gfx_d3d/r_state_utils.cpp
void R_InitCmdBufSourceState(GfxCmdBufSourceState *source, const GfxCmdBufInput *input, int cameraView);
void R_SetDebugShaderFeatures(GfxCmdBufSourceState *source);
void R_PixStartNamedRenderTarget(unsigned __int8 renderTargetId);
void R_InitCmdBufState(GfxCmdBufState *state, const GfxBackEndData *backEndData);
void R_ShutdownCmdBufState(GfxCmdBufState *state);
GfxCmdBufSourceState *R_GetActiveWorldMatrix(GfxCmdBufSourceState *source);
;
void R_Set2D(GfxCmdBufSourceState *source);
void R_CmdBufSet3D(GfxCmdBufSourceState *source);
void R_Set3D(GfxCmdBufSourceState *source);
void R_BeginView(GfxCmdBufSourceState *source, const GfxSceneDef *sceneDef, const GfxViewParms *viewParms);
void R_SetShadowLookupMatrix(GfxCmdBufSourceState *source, const GfxMatrix *matrix);
void R_InitGlobalCmdBufState();

//t6/code/src_noserver/gfx_d3d/r_staticmodel.cpp
int FindStaticModelIndex(const vec3_t *pos);
void HideStaticModel(unsigned int smodelIndex);
void UnhideStaticModel(unsigned int smodelIndex);

//t6/code/src_noserver/gfx_d3d/r_staticmodel_load_db.h
void Load_GfxStaticModelLmapVertexInfoArray(bool atStreamStart, int count);
void Mark_GfxStaticModelDrawInstArray(int count);
void Load_GfxStaticModelDrawInstArray(bool atStreamStart, int count);

//t6/code/src_noserver/gfx_d3d/r_staticmodel_load_obj.cpp
int R_CellForPoint(const vec3_t *origin);
unsigned int R_FindNearestReflectionProbeInCell(int cellIndex, const vec3_t *origin);
unsigned int R_FindNearestReflectionProbe(const GfxWorldDraw *worldDraw, const vec3_t *origin);
unsigned int R_FindProbeFromVolume(const GfxWorldDraw *worldDraw, const vec3_t *origin);
// unsigned int R_CalcReflectionProbeIndex@<eax>(;
void R_AllocStaticModels(GfxAabbTree *tree);
int R_SortGfxAabbTreeChildren(;
int CompareStaticModels(const void *smodel0, const void *smodel1);
void R_SortGfxAabbTree(GfxWorld *world, GfxAabbTree *tree);
void R_AddStaticModelToAabbTree_r(GfxWorld *world, GfxAabbTree *tree, int smodelIndex);
void R_AddStaticModelToCell(GfxWorld *world, GfxStaticModelInst *smodelInst, const int cellIndex);
const char *GetNameFromStaticModelInst(const GfxStaticModelInst *smodelInst);
void R_FilterStaticModelIntoCells_r(;
int R_CellForPoint(const GfxWorld *world, const vec3_t *origin);
unsigned int R_CalcReflectionProbeIndex(const GfxWorld *world, const vec3_t *origin);
void R_SetStaticModelReflectionProbe(;
void R_CreateStaticModel(;

//t6/code/src_noserver/gfx_d3d/r_sunshadow.cpp
void R_CalcBoxVsCylinderRayMinBox(;
void R_GetSceneExtentsAlongDir(;
void R_GetSunAxes(vec3_t *sunAxis);
void R_ClipSpaceToWorldSpace(;
void R_SetupSunShadowBoundingPoly(;
void R_SunShadowMapBoundingPoly(;
// unsigned int R_SunShadowMapClipSpaceClipPlanes@<eax>(;
void R_SunShadowMapProjectionMatrix(;
void R_SetupSunShadowMapPartitionFraction(;
void R_SetupNearRegionPlane(const vec4_t *partitionFraction);
void R_SetupSunShadowMapProjection(;
void R_GetSunShadowLookupMatrix(;
void R_SunShadowMaps(bool cache);
void R_FinishSunShadowMaps();
void R_MergeAndEmitSunShadowMapsSurfs(GfxViewInfo *viewInfo);
void R_SetupSunShadowMaps(const GfxViewParms *viewParms, GfxSunShadow *sunShadow);

//t6/code/src_noserver/gfx_d3d/r_surface_load_db.h
void Mark_GfxSurfaceArray(int count);
void Mark_GfxLightmapArrayArray(int count);
void Load_GfxSurfaceArray(bool atStreamStart, int count);
void Load_GfxLightmapArrayArray(bool atStreamStart, int count);

//t6/code/src_noserver/gfx_d3d/r_types_d3d.h
// void R_ReleaseAndSetNULL<ID3D11Texture2D>(ID3D11Texture2D *var, const char *fn, const char *filename, int line);

//t6/code/src_noserver/gfx_d3d/r_ui3d.cpp
GfxUI3DStack *R_GetUI3DStack();
void R_UI3DStack_Push(GfxUI3DStack *stack, int val);
void R_UI3DStack_Pop(GfxUI3DStack *stack);
int R_UI3DStack_Top(GfxUI3DStack *stack);
ScreenPlacement *R_UI3D_ScrPlaceFromTextureWindow(int windowIndex);
void R_UI3D_SetBlurRadius(float blurRadius);
void R_UI3D_Shutdown();
void R_UI3D_SetupBackendData_UVConstants(GfxUI3DBackend *ui3dBackend);
void R_UI3D_SetupBackendData(GfxUI3DBackend *ui3dBackend);
void ScrPlace_SetupUI3D(ScreenPlacement *scrPlace, int viewportWidth, int viewportHeight);
void R_UI3D_IncrementRenderCmdCount(int wndIndex, int renderCmdDrawsSomething);
void R_UI3D_SetupTextureWindow(;
void RB_UI3D_SetShaderConstants(GfxCmdBufSourceState *source, const GfxUI3DBackend *rbUI3D);
void RB_SetUI3DSamplerAndConstants(GfxCmdBufSourceState *cmdBufSrcState, const GfxUI3DBackend *rbUI3D);
int RB_UI3D_GetValidWindows(const GfxUI3DBackend *rbUI3D, int *validWindowsArray);
void RB_UI3D_RenderToTexture(const void *cmds, const GfxUI3DBackend *rbUI3D, const GfxCmdBufInput *input);
void R_UI3D_OnetimeInit(int width, int height, int pmemLocation, bool allocatePingPongBuffer);
void R_UI3D_PerframeInit();

//t6/code/src_noserver/gfx_d3d/r_utils.cpp
int R_HashAssetName(const char *name);
unsigned int R_HashString(const char *string, unsigned int hash);
void *R_AllocGlobalVariable(unsigned int bytes, const char *name);
void R_FreeGlobalVariable(void *var);
char R_CullPointAndRadius(const vec3_t *pt, float radius, const DpvsPlane *clipPlanes, int clipPlaneCount);
;
double FresnelTerm(float n0, float n1, float cosIncidentAngle);
char R_GetClearColor(vec4_t *unpackedRgba);
;

//t6/code/src_noserver/gfx_d3d/r_warn.cpp
void R_UpdateFrameRate();
// void R_WarnOncePerFrame(float a1@<xmm0>, GfxWarningType warnType, ...);
void R_WarnInitDvars(int a1, dvarType_t a2);

//t6/code/src_noserver/gfx_d3d/r_wind.cpp
void R_SetWindDirection(vec3_t *dir, float speed);
void R_SetVariantWindSpringAngle(unsigned int index, float angle);
void R_SetVariantWindRustleAngle(unsigned int windIndex, const vec3_t *angles);
void R_SetWindShaderConstants(GfxCmdBufInput *input);
void R_CopyWindStateToBackEnd();

//t6/code/src_noserver/gfx_d3d/r_workercmds.cpp
int r_add_bspCallback_Implementation(jqBatch *batch, void *data);
int r_add_bsp_sunCallback_Implementation(jqBatch *batch, void *data);
int r_add_staticmodelCallback_Implementation(jqBatch *batch, void *data);
int r_add_staticmodel_sunCallback_Implementation(jqBatch *batch, void *data);
int r_add_bsp_dlightCallback_Implementation(jqBatch *batch, void *data);
int r_add_smodels_dlightCallback_Implementation(jqBatch *batch, void *data);
int r_model_skinCallback_Implementation(jqBatch *batch, void *data);
int r_draw_litCallback_Implementation(jqBatch *batch, void *data);
int r_draw_lit_bspCallback_Implementation(jqBatch *batch, void *data);
int r_draw_lit_static_modelCallback_Implementation(jqBatch *batch, void *data);
int fx_update_remainingCallback_Implementation(jqBatch *batch, void *data);
int fx_post_updateCallback_Implementation(jqBatch *batch, void *data);
int fx_draw_nonspriteCallback_Implementation(jqBatch *batch, void *data);
int fx_marks_drawCallback_Implementation(jqBatch *batch, void *data);
int fx_spawnCallback_Implementation(jqBatch *batch, void *data);
int r_add_bspCallback(jqBatch *batch);
int r_add_bsp_sunCallback(jqBatch *batch);
int r_add_staticmodelCallback(jqBatch *batch);
int r_add_staticmodel_sunCallback(jqBatch *batch);
int r_add_bsp_dlightCallback(jqBatch *batch);
int r_add_smodels_dlightCallback(jqBatch *batch);
int r_model_skinCallback(jqBatch *batch);
int r_draw_litCallback(jqBatch *batch);
int r_draw_lit_bspCallback(jqBatch *batch);
int r_draw_lit_static_modelCallback(jqBatch *batch);
int r_draw_depthCallback(jqBatch *batch);
int r_dpvs_staticCallback(jqBatch *batch);
int r_dpvs_dynmodelCallback(jqBatch *batch);
int r_dpvs_sceneentCallback(jqBatch *batch);
int r_dpvs_dynbrushCallback(jqBatch *batch);
int fx_updateCallback(jqBatch *batch);
int fx_update_remainingCallback(jqBatch *batch);
int fx_update_portalledCallback(jqBatch *batch);
int fx_post_updateCallback(jqBatch *batch);
int fx_drawCallback(jqBatch *batch);
int fx_update_nonspriteCallback(jqBatch *batch);
int fx_draw_nonspriteCallback(jqBatch *batch);
int dobj_skelCallback(jqBatch *batch);
int dobj_skinCallback(jqBatch *batch);
int model_skelCallback(jqBatch *batch);
int fx_marks_drawCallback(jqBatch *batch);
int fx_update_spotCallback(jqBatch *batch);
int fx_spawnCallback(jqBatch *batch);

//t6/code/src_noserver/gfx_d3d/r_workercmds_common.cpp
void R_ProcessCmd_UpdateFxSpotLight(FxCmd *cmd);
void R_ProcessCmd_UpdateFxNonDependent(FxCmd *cmd);
void R_DrawEffects(FxCmd *cmd);
void R_ProcessCmd_FxPostUpdate(FxCmd *cmd);
void R_UpdateSpotLightEffect(FxCmd *cmd);
void R_UpdateNonDependentEffects(FxCmd *cmd);
void R_UpdateRemainingEffects(FxCmd *cmd);
void R_UpdateNonSpriteEffects(FxCmd *cmd);
void R_ProcessCmd_DrawNonSprite(FxCmd *cmd);
void R_UpdatePortalledEffects(FxCmd *cmd);
void R_UpdateXModelBoundsDelayed(GfxSceneEntity *sceneEnt);
void R_SkinGfxEntityDelayed(GfxSceneEntity *sceneEnt);
void R_SkelGfxModelInit();
void R_SkelGfxModelDelayed(GfxSceneModel *sceneModel);
void R_SkelGfxModelFinish();

//t6/code/src_noserver/gfx_d3d/r_xsurface.cpp
int XSurfaceGetNumVerts(const XSurface *surface);
int XSurfaceGetNumTris(const XSurface *surface);
void XSurfaceGetVerts(const XSurface *surf, float *pVert, float *pTexCoord, float *pNormal);

//t6/code/src_noserver/gfx_d3d/r_xsurface_load_db.h
void Load_XSurfaceCollisionTree(bool atStreamStart);
void Load_XRigidVertListArray(bool atStreamStart, int count);
void Load_XSurfaceVertexInfo(bool atStreamStart);
void Load_XSurfaceArray(bool atStreamStart, int count);

//t6/code/src_noserver/glass/glass_allocator.cpp
// void __thiscall SmallAllocator::Init(SmallAllocator *this, void *buffer, unsigned int bs, unsigned int nb);
// void **__thiscall SmallAllocator::Allocate(SmallAllocator *this, unsigned int size);
// char __thiscall Allocator::Memory::MakeFree(Allocator::Memory *this);
// void __thiscall Allocator::FreeAll(Allocator *this);
// int __thiscall Allocator::GetMemorySize(Allocator *this, void *ptr);
// void __thiscall Allocator::Split(Allocator *this, Allocator::Memory *mem, int size);
// void __thiscall Allocator::Merge(Allocator *this, Allocator::Memory *mem1, Allocator::Memory *mem2);
// int __thiscall Allocator::Defrag(Allocator *this, void (*func)(void *), int count);
// int __thiscall Allocator::GetFree(Allocator *this);
// int __thiscall Allocator::GetLargestFree(Allocator *this);
// void __thiscall SmallAllocator::Free(SmallAllocator *this, void *ptr, unsigned int num);
// void __thiscall Allocator::Init(Allocator *this, void *buf, int size);
// Allocator::Memory **__thiscall Allocator::Allocate(Allocator *this, int size, void *userData);
// void __thiscall Allocator::Free(Allocator *this, void *ptr);

//t6/code/src_noserver/glass/glass_allocator.h
// TempPackedOutline *__thiscall FixedSizeAllocator<TempPackedOutline>::Allocate(;
// FixedSizeAllocator<TempPackedOutline>::Block *__thiscall FixedSizeAllocator<TempPackedOutline>::FirstUsed(;
// void __thiscall StaticFixedSizeAllocator<TempPackedOutline,350>::StaticFixedSizeAllocator<TempPackedOutline,350>(;
// void __thiscall FixedSizeAllocator<GlassShard>::FixedSizeAllocator<GlassShard>(;
// GlassShard *__thiscall FixedSizeAllocator<GlassShard>::Allocate(FixedSizeAllocator<GlassShard> *this);
// void __thiscall FixedSizeAllocator<ShardGroup>::FixedSizeAllocator<ShardGroup>(;
// ShardGroup *__thiscall FixedSizeAllocator<ShardGroup>::AllocateAfter(;
// ShardGroup *__thiscall FixedSizeAllocator<ShardGroup>::AllocateBefore(;
// void __thiscall FixedSizeAllocator<GlassShard *>::Free(FixedSizeAllocator<GlassShard *> *this, GlassShard **ptr);
// void __thiscall FixedSizeAllocator<ShardGroup>::FreeAll(FixedSizeAllocator<ShardGroup> *this);
// void __thiscall FixedSizeAllocator<GlassPhysics>::FixedSizeAllocator<GlassPhysics>(;
// GlassPhysics *__thiscall FixedSizeAllocator<GlassPhysics>::Allocate(FixedSizeAllocator<GlassPhysics> *this);
// void __thiscall FixedSizeAllocator<GlassPhysics>::Free(FixedSizeAllocator<GlassPhysics> *this, GlassPhysics *ptr);
// void __thiscall FixedSizeAllocator<GlassShard *>::FixedSizeAllocator<GlassShard *>(;
// GlassShard **__thiscall FixedSizeAllocator<GlassShard *>::Allocate(FixedSizeAllocator<GlassShard *> *this);
// TempPackedOutline *__thiscall FixedSizeAllocator<TempPackedOutline>::AllocateAfter(;
// TempPackedOutline *__thiscall FixedSizeAllocator<TempPackedOutline>::AllocateBefore(;

//t6/code/src_noserver/glass/glass_client.cpp
// void *GlassesClient::Allocate(int size, int align, const char *file, int line);
// void GlassesClient::Free(void *ptr);
// unsigned int GlassesClient::GetFreeMem();
// GlassClient *__thiscall GlassesClient::GetGlass(GlassesClient *this, int idx);
// void __thiscall GlassesClient::WriteDemoSnapshot(GlassesClient *this, msg_t *msg);
int compareOutlineEdges(const void *s1, const void *s2);
// void __thiscall GlassClient::PlayShatterFX(;
bool GlassIsVisible(LocalClientNum_t localClientNum, const Glass *glass);
// void __thiscall GlassClient::SetBrushMaterial(GlassClient *this, GlassState::State state);
void GlassCl_WriteDemoSnapshot(msg_t *msg);
void GlassCl_BeginGenerateVerts(LocalClientNum_t localClientNum, unsigned int viewIndex);
void GlassCl_WaitUpdate();
void GlassCl_GenerateVerts(LocalClientNum_t localClientNum, unsigned int viewIndex);
void GlassCl_ExplosionEvent(;
void GlassCl_MeleeEvent(LocalClientNum_t localClientNum, int attackerEntNum);
void GlassCl_DrawDebug(LocalClientNum_t localClientNum);
// unsigned int __thiscall GlassesClient::AreaGlasses(;
// void __thiscall GlassesClient::ClipMoveTrace(GlassesClient *this, const moveclip_t *clip, trace_t *results);
// void __thiscall GlassesClient::Update(GlassesClient *this, LocalClientNum_t localClientNum);
// void __thiscall GlassClient::Init(GlassClient *this, const Glass *gls);
// void __thiscall GlassClient::SetState(;
// unsigned int __thiscall GlassClient::Outlines::InitShards(;
void GlassCl_Update(LocalClientNum_t localClientNum);
// void __thiscall GlassesClient::TracePoint(GlassesClient *this, const pointtrace_t *clip, trace_t *results);
unsigned int GlassCl_AreaGlasses(;
void GlassCl_ClipMoveTrace(const moveclip_t *clip, trace_t *results);
// void __thiscall GlassesClient::GlassesClient(GlassesClient *this, const Glasses *glss);
// void __thiscall GlassesClient::Reset(GlassesClient *this);
// void __thiscall GlassesClient::ParseSnapshot(;
// void __thiscall GlassClient::Outlines::SaveOutlines(;
void GlassCl_AllocateMemory();
void GlassCl_FreeMemory();
void GlassCl_Reset(LocalClientNum_t localClientNum);
void GlassCl_ReadGameState(LocalClientNum_t localClientNum, msg_t *msg);
void GlassCl_ParseSnapshot(LocalClientNum_t localClientNum, msg_t *msg);
void GlassCl_TracePoint(const pointtrace_t *clip, trace_t *results);
// char __thiscall GlassClient::Shatter(GlassClient *this, GlassShard **newShards, int *numNewShards);
// void __thiscall GlassesClient::PreShatterNext(GlassesClient *this);
// void __thiscall GlassClient::Shatter(GlassClient *this, const vec3_t *pos, const vec3_t *dir);

//t6/code/src_noserver/glass/glass_load_db.h
void Mark_GlassDef();
void Mark_GlassArray(int count);
void Mark_GlassesPtr();
void Load_GlassDef(bool atStreamStart);
void Load_GlassArray(bool atStreamStart, int count);
void Load_Glasses(bool atStreamStart);
void Load_GlassesPtr(bool atStreamStart);

//t6/code/src_noserver/glass/glass_load_obj.cpp
Glasses *GetGlasses_LoadObj();
XModelPieces *GetGlasses_FastFile();
Glasses *GetGlasses();

//t6/code/src_noserver/glass/glass_renderer.cpp
int Remove(const SimplePlaneIntersection **pts, int ptsCount, const SimplePlaneIntersection *removePoint);
// void *GlassRenderer::operator new(unsigned int size);
// void GlassRenderer::operator delete(void *ptr);
// void __thiscall GlassRenderer::InitShardMeshVertexLists(GlassRenderer *this);
// GlassShardMeshVertex *__thiscall GlassRenderer::GetVertexList(GlassRenderer *this, unsigned int numOutlineVerts);
// void __thiscall GlassRenderer::AddGroupChange(GlassRenderer *this, GlassShard *shard);
int GroupChangeSort(const void *a, const void *b);
// int __thiscall GlassRenderer::CalcPackedPos(GlassRenderer *this, const vec3_t *pos);
// Allocator::Memory **__thiscall GlassRenderer::AllocateShardMemory(;
// void __thiscall GlassRenderer::FreeShardMemory(GlassRenderer *this, void *ptr);
// int __thiscall GlassRenderer::ShardMemorySize(GlassRenderer *this, void *ptr);
// void __thiscall GlassRenderer::AddShatterAction(;
// void __thiscall GlassRenderer::AddExplosionAction(;
// void __thiscall GlassRenderer::AddTraceAction(GlassRenderer *this, const vec3_t *p0, const vec3_t *p1);
// void __thiscall GlassRenderer::AddMeleeAction(;
// void __thiscall GlassRenderer::AddUsedShardMaterial(GlassRenderer *this, Material *material);
// void __thiscall sd_xa2_callback::OnLoopEnd(bdLobbyEventHandler *this, unsigned __int64 __formal);
// void __thiscall ShardGroup::UpdateBBox(ShardGroup *this);
// void __thiscall ShardGroup::GenerateVertsInternal(ShardGroup *this, const GlassRenderer *renderer);
// void __thiscall ShardGroup::FreeRenderMemory(ShardGroup *this);
// int __thiscall ShardGroup::TracePoint(ShardGroup *this, const vec3_t *p0, const vec3_t *p1);
// void __thiscall GlassRenderer::~GlassRenderer(GlassRenderer *this);
// void GlassRenderer::CrashGlassCmd();
// void __thiscall GlassRenderer::PrintHwm(GlassRenderer *this);
// void __thiscall ShardGroup::Add(ShardGroup *this, GlassShard *shard);
// void __thiscall ShardGroup::Update(ShardGroup *this, float deltaTime, GlassUpdateCmd *cmd);
// void __thiscall ShardGroup::GenerateVertsFinish(ShardGroup *this);
// void __thiscall GlassRenderer::Reset(GlassRenderer *this);
// GlassShard *__thiscall GlassRenderer::AllocShard(GlassRenderer *this);
// void __thiscall GlassRenderer::FreeShard(GlassRenderer *this, GlassShard *shard);
// GlassPhysics *__thiscall GlassRenderer::AllocPhysics(GlassRenderer *this);
// void __thiscall GlassRenderer::FreePhysics(GlassRenderer *this, GlassPhysics *phys);
// void __thiscall GlassRenderer::AddDelayedPhysicsShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::RemoveDelayedPhysicsShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::DoDelayedPhysics(GlassRenderer *this, float deltaTime);
// void __thiscall GlassRenderer::ExplosionEvent(;
// int __thiscall GlassRenderer::TracePoint(GlassRenderer *this, const vec3_t *p0, const vec3_t *p1);
// void __thiscall GlassRenderer::Melee(;
// ShardGroup *__thiscall GlassRenderer::GetShardGroup(;
// void GlassRenderer::PrintHwmCmd();
// void __thiscall GlassRenderer::Broom(GlassRenderer *this);
// void __thiscall GlassRenderer::DrawDebug(GlassRenderer *this, LocalClientNum_t localClientNum);
// void __thiscall ShardGroup::Remove(ShardGroup *this, GlassShard *shard);
// void __thiscall ShardGroup::GenerateVerts(;
// void __thiscall GlassRenderer::DoGroupChanges(GlassRenderer *this);
// ShardGroup *__thiscall GlassRenderer::GetShardGroup(GlassRenderer *this, const vec3_t *pos, const GlassDef *glassDef);
// void __thiscall GlassRenderer::RemoveColidingShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::GlassRenderer(GlassRenderer *this, const Glasses *glasses);
// void __thiscall GlassRenderer::RemoveGlassShards(GlassRenderer *this, unsigned int glassIndex);
// GlassShard *__thiscall GlassRenderer::GetSmallestColidingShard(GlassRenderer *this);
// void __thiscall GlassRenderer::SortedShardsList::Insert(GlassRenderer::SortedShardsList *this, GlassShard *shard);
// void __thiscall GlassRenderer::SortedShardsList::InsertReverse(;
// BOOL __thiscall GlassRenderer::AddColidingShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::GetSmallestShards(;
// void __thiscall GlassRenderer::GetLargestShards(;
// void __thiscall GlassRenderer::DoMaintenance(GlassRenderer *this);
// void __thiscall GlassRenderer::CrashGlass(GlassRenderer *this);
// void __thiscall GlassRenderer::RemovePhysicsShards(GlassRenderer *this);
// void __thiscall GlassRenderer::ExecuteActions(GlassRenderer *this);
// char __thiscall GlassRenderer::Update(GlassRenderer *this);
// void __thiscall GlassRenderer::GenerateVerts(;
// void *operator new(unsigned int size);

//t6/code/src_noserver/glass/glass_server.cpp
// void __thiscall GlassesServer::Load(GlassesServer *this, MemoryFile *memFile);
// void __thiscall GlassesServer::ResetAll(GlassesServer *this);
void GlassSv_Shutdown();
unsigned int GlassSv_AreaGlasses(;
void GlassSv_ClipMoveTrace(const moveclip_t *clip, trace_t *results);
void GlassSv_PointTrace(const pointtrace_t *clip, trace_t *results);
void GlassSv_Damage(unsigned int glassId, int damage, int mod, const vec3_t *pos, const vec3_t *dir);
void GlassSv_RadiusDamage(;
GlassServer *GlassSv_GetGlassByIndex(unsigned int index);
// void __thiscall GlassesServer::WriteSnapshotToClient(GlassesServer *this, msg_t *msg, int sinceTime);
void GlassSv_WriteSnapshotToClient(msg_t *msg, int sinceTime);
void GlassSv_WriteEmptySnapshotToClient(msg_t *msg);
void GlassSv_WriteGameState(msg_t *msg);
void GlassSv_Load(MemoryFile *memFile);
// void __thiscall GlassesServer::Update(GlassesServer *this);
// void __thiscall GlassesServer::ShatterAll(GlassesServer *this);
// void GlassesServer::ResetAllCmd();
void GlassSv_Update();
void GlassSv_Touch(unsigned int glassId, gentity_t *other);
void GlassSv_PredictTouch(gentity_t *other);
// void GlassesServer::ShatterAllCmd();
// void __thiscall GlassesServer::Init(GlassesServer *this);
void GlassSv_Init();

//t6/code/src_noserver/glass/glass_shard.cpp
// void GlassPhysics::InitStatics();
// void __thiscall GlassPhysics::AddForce(GlassPhysics *this, const vec3_t *worldPos, const vec3_t *impulse);
// void __thiscall GlassPhysics::tensor_transform_principle(;
// bool __thiscall GlassOutline::Add(GlassOutline *this, const vec2_t *pos);
// bool __thiscall GlassOutline::Add(GlassOutline *this, const vec2_t *dir, float len);
// void __thiscall GlassOutline::AddSafe(GlassOutline *this, float x, float y, bool isOriginalEdge);
// double __thiscall GlassOutline::EdgeRatio(GlassOutline *this);
// void __thiscall GlassOutline::GetBBox(GlassOutline *this, vec2_t *mn, vec2_t *mx);
// void __thiscall GlassOutline::Recenter(GlassOutline *this, vec2_t *offset);
// BOOL __thiscall GlassOutline::HasNarrowAngle(GlassOutline *this);
// bool __thiscall GlassOutline::IsNarrow(GlassOutline *this);
// char __thiscall GlassOutline::DoesIntersect(;
// void __thiscall GlassOutline::GetNearestDistances(;
int compareOutlines(const void *o1, const void *o2);
// int __thiscall GlassPackedOutline::Init(GlassPackedOutline *this, void *ptr, unsigned __int8 num);
// int __thiscall GlassPackedOutline::GetStreamSize(GlassPackedOutline *this);
// unsigned __int8 *__thiscall GlassPackedOutline::StreamOut(GlassPackedOutline *this, unsigned __int8 *streamBuff);
// void __thiscall GlassPackedOutline::GetBBox(GlassPackedOutline *this, vec2_t *mn, vec2_t *mx);
// void __thiscall GlassPackedOutline::Recenter(GlassPackedOutline *this, vec2_t *offset);
// double __thiscall GlassPackedOutline::EdgeRatio(GlassPackedOutline *this);
// void __thiscall GlassShard::Mesh::Init(;
// ;
// bool __thiscall GlassShard::Triangles::Triangulate(GlassShard::Triangles *this);
// void __thiscall GlassShard::Init(GlassShard *this);
// void __thiscall GlassShard::ToLocal(;
// void __thiscall GlassShard::GetLocalBBox(GlassShard *this, vec3_t *mins, vec3_t *maxs);
// void __thiscall GlassShard::UpdateBBox(GlassShard *this);
// void __thiscall GlassShard::GenerateVerts(;
// double __thiscall GlassShard::GetMass(GlassShard *this);
// void __thiscall GlassShard::DestroyPhysicsObj(GlassShard *this);
// void __thiscall GlassShard::AddForce(GlassShard *this, const vec3_t *pos, const vec3_t *forceIn);
// void __thiscall GlassShard::SetVelocity(GlassShard *this, const vec3_t *t_vel, const vec3_t *a_vel);
// int GetNumIntersections<GlassOutline>(;
// int GetNumIntersections<GlassPackedOutline>(;
// void GlassPhysics::CreateAxis(;
// void GlassPhysics::IntegrateVelocity(GlassPhysics *this@<ecx>, int a2@<ebp>, float deltaTime);
// void __thiscall GlassPhysics::GetPosition(GlassPhysics *this, vec3_t *position, vec3_t *axis);
// GlassOutline *__thiscall GlassOutline::operator=(GlassOutline *this, const GlassOutline *o);
// bool __thiscall GlassOutline::CloseOutline(GlassOutline *this);
// void __thiscall GlassOutline::Reverse(GlassOutline *this);
// int __thiscall GlassOutline::InitSplitOutlines(;
// const unsigned __int8 *__thiscall GlassOutline::StreamIn(GlassOutline *this, const unsigned __int8 *streamBuff);
// bool __thiscall GlassPackedOutline::LeaveOnEdge(GlassPackedOutline *this, float stickiness);
// void __thiscall GlassShard::Destroy(GlassShard *this);
// char __thiscall GlassShard::AllocateMemory(;
// bool __thiscall GlassShard::Intersect(GlassShard *this, const vec3_t *pos, const vec3_t *dir, vec2_t *hitPoint);
// bool __thiscall GlassOutline::LeaveOnEdge(GlassOutline *this, float stickiness);
// bool __thiscall GlassOutline::IsOnBottomEdge(GlassOutline *this, const GlassShard *shard);
// void GlassPhysics::Step(GlassPhysics *this@<ecx>, int a2@<ebp>, float deltaTime);
// void __thiscall GlassOutline::GlassOutline(;
// void __thiscall GlassOutline::GlassOutline(;
// int __thiscall GlassOutline::Split(;
// int __thiscall GlassOutline::Chip(;
// int __thiscall GlassOutline::HitPoint(;
// void __thiscall GlassPackedOutline::Init(GlassPackedOutline *this, const GlassOutline *other, const GlassShard *shard);
// void __thiscall GlassShard::Remove(GlassShard *this, GlassShard::RemoveReason reason, bool delay);
// char __thiscall GlassShard::Init(;
// void __thiscall GlassShard::DisableCollisions(GlassShard *this);
// unsigned int __thiscall GlassOutline::Shatter(;
// GlassShard *GlassShard::Create(const Glass *glass, GlassOutline *outline);
// GlassShard *GlassShard::Create(const Glass *glass, GlassPackedOutline *outline);
// bool __thiscall GlassShard::InitPhysicsObj(GlassShard *this, bool enableCollisions);
// char __thiscall GlassShard::InitPhysics(;
// void __thiscall GlassShard::DrawOutline(GlassShard *this);
// void GlassShard::InitPhysics(;
// void __thiscall GlassShard::ExplosionEvent(;
// char __thiscall GlassShard::TracePoint(;
// char __thiscall GlassShard::DelayedUpdate(GlassShard *this, float deltaTime);
// void __thiscall GlassShard::UpdateInternal(GlassShard *this, GlassRenderer *localRenderer, float deltaTime);
// void __thiscall GlassShard::Update(GlassShard *this, float deltaTime, GlassUpdateCmd *cmd);

//t6/code/src_noserver/glass/glass_shard.h
// double __thiscall GlassOutline::Area(GlassOutline *this);
// void GlassShard::Defrag(void *ptr);
// void __thiscall GlassOutline::MarkAllEdge(GlassOutline *this, bool e);
// void __thiscall GlassShard::Defrag(GlassShard *this);

//t6/code/src_noserver/groupvoice/decode.cpp
void Decode_Shutdown();
int Decode_Sample(char *buffer, int maxLength, __int16 *out, int frame_size);
char Decode_Init(int bandwidthEnum);

//t6/code/src_noserver/groupvoice/encode.cpp
void Encode_SetOptions(int frequency, int quality);
bool Encode_Init(int bandwidthEnum);
char Encode_Shutdown();
int Encode_Sample(__int16 *buffer_in, char *buffer_out, int maxLength);
int Encode_GetFrameSize();

//t6/code/src_noserver/groupvoice/play.cpp
;
;
;
;
;
;
int Sound_Init(const void *handle);
;

//t6/code/src_noserver/groupvoice/play_dsound.cpp
HRESULT CreateBasicBuffer(;
void DSound_AdjustSamplePlayback(dsound_sample_t *sample, int bytesLeft);
void DSound_HandleBufferUnderrun(dsound_sample_t *sample);
void DSound_SetVolume(dsound_sample_t *sample, int level);
// dsound_sample_t *DSound_NewSample@<eax>(int a1@<edi>);
char DSound_StopSample(dsound_sample_t *sample);
int DSound_Init(bool callDsoundInit, const void *handle);
void DSound_Shutdown();
unsigned int DSound_UpdateSample(dsound_sample_t *sample, char *data, unsigned int data_len);
void DSound_SampleFrame(dsound_sample_t *sample);

//t6/code/src_noserver/groupvoice/record.cpp
int Record_QueueAudioDataForEncoding(audioSample_t *sample);
int Record_AudioCallback(audioSample_t *sample);
int Record_Stop(dsound_sample_t *sample);
int Record_DestroySample(dsound_sample_t *sample);
void Record_Shutdown();
int Record_Init(bool callInit, const void *handle);

//t6/code/src_noserver/groupvoice/record_dsound.cpp
dsound_sample_t *DSOUNDRecord_NewSample();
int DSOUNDRecord_DestroySample(dsound_sample_t *pRecSample);
// int DSOUNDRecord_Stop@<eax>(int a1@<edi>, int a2@<esi>, dsound_sample_t *pRecSample);
const char *GetDSoundErrorDesc(HRESULT hr);
int DSOUNDRecord_Init(bool bCallDsoundInit);
void DSOUNDRecord_Shutdown();

//t6/code/src_noserver/ik/ik.cpp
void IK_AllocateLocalClientMemory(void *ikStatesBuf, int localClientIndex);
void IK_InitSystem();
BOOL IK_IsCalcBone(IKState *ikState, int ikBoneIndex);
void IK_UpdateTimeAll(int time, int localClientIndex, bool inViewer);
void IK_ResetTime();
void IK_UpdateDvarValues(IKState *ikState);
void IK_UpdateLayerLerps(IKState *ikState);
void IK_UpdateStatusFunctions(IKState *ikState);
IKBoneNames *IK_GetBoneParents(IKState *ikState);
IKJointBones *IK_GetJoints(IKState *ikState);
bool *IK_GetEssentialBones(IKState *ikState);
void IK_InitializeIKState(IKState *ikState);
IKState *IK_CreateIKForEntity(int entityNum, unsigned __int8 *model);
void IK_GetJointVars(IKState *ikState);
IKState *IK_GetIKStateForEntity(int entityNum, unsigned __int8 *model, bool bScanAll);
void IK_UpdateEntity(int entityNum, unsigned __int8 *model, bool isLocalBones, int *calcBoneBits);

//t6/code/src_noserver/ik/ik_import.cpp
void IKImport_InitVars(IKSystem *ikSystem);
bool IKImport_GetVar_IK_Enable();
bool IKImport_GetVar_IK_Foot_Test();
int IKImport_GetVar_IK_Debug();
bool IKImport_GetVar_IK_Hand_Get_Data();
bool IKImport_GetVar_IK_Enable(IKState *ikState);
int IKImport_GetVar_IK_Debug(IKState *ikState);
int IKImport_GetVar_IK_Hand_Tuning(IKState *ikState);
void IKImport_GetVar_IK_Hand_Offset_Vec(IKState *ikState, vec3_t *offset);
void IKImport_GetVar_IK_Hand_Rotation_Vec(IKState *ikState, vec3_t *rotation);
void IKImport_GetBoneStrings();
char IKImport_CalcAnimatedIKBonesBits(IKState *ikState, unsigned __int8 *model);
void IKImport_RecurseSetIKPartBits(const DObj *obj, int boneIndex, int *partBits);
IKBoneNames *IKImport_GetMinBoneExtents(IKState *ikState, int *boneCount);
void IKImport_SetIKPartBits(const DObj *obj, int *partBits);
char IKImport_CheckIKPartBits(IKState *ikState);
;
void IKImport_ApplyIKToSkeleton(IKState *ikState);
IKState *IKImport_FetchDObjIKState(const unsigned __int8 *model);
void IKImport_SetDObjIKState(const unsigned __int8 *model, const IKState *ikState);
int IKImport_EntityNumToIndex(int entityNum);
char IKImport_ApplyLeftHandIK(IKState *ikState);
bool IKImport_ApplyRightHandIK(IKState *ikState);
void IKImport_DrawAxisOrigin(vec4_t *mat44, float colorScale);
// void IKImport_DrawLine(clientDebugLineInfo_t *a1@<edi>, vec3_t *start, vec3_t *end, int colorType);
void IKImport_DrawDebugSkeleton(IKState *ikState);
int IKImport_GetFrameNum();
;
LocalClientNum_t IKImport_GetLocalClientIndexForModel(unsigned __int8 *model);
BOOL IKImport_IsServerModel(unsigned __int8 *model);
BOOL IKImport_IsClient(IKState *ikState);
LerpEntityState *IKImport_GetLerpEntityState(IKState *ikState, const int inEntityNum);
gentity_t *IKImport_GetEntityState(IKState *ikState, const int inEntityNum);
bool IKImport_IsVehicleRemoteControl(IKState *ikState);
double IKImport_GetGunnerCrouch(IKState *ikState);
BOOL IKImport_IsMountedTurret(IKState *ikState);
int IKImport_IsFiring(IKState *ikState);
unsigned int IKImport_IsCrouching(IKState *ikState);
unsigned int IKImport_IsProne(IKState *ikState);
bool IKImport_GetBoneControllers(IKState *ikState, float *outAngles);
void IKImport_GetVelocity(IKState *ikState, vec3_t *velocity);
bool IKImport_IsSpectating(IKState *ikState);
char IKImport_IsMoving(IKState *ikState);
// LerpEntityStateActor::<unnamed_type_index> IKImport_GetActorNum(unsigned __int8 *model);
bool IKImport_IsValidEntityType(const unsigned __int8 *model);
BOOL IKImport_IsValidEntityNum(int entityNum);
void IKImport_Profiler(IKState *ikState);
bool IKImport_IsOnGround(IKState *ikState);
bool IKImport_ActorIKEnabled(const DObj *obj);
bool IKImport_IsServerRunning();
char IKImport_GetBoneLookups(IKState *ikState, IKBoneNames ikBoneName);
void IKImport_AccumulateParentObjBones(;
void IKImport_GetBoneMatrixArrayLocalBones(IKState *ikState);
void IKImport_GetBoneMatrixArray(IKState *ikState);
char IKImport_IsIKEntity(const unsigned __int8 *model);
char IKImport_BypassTerrainMapping(IKState *ikState);
bool IKImport_ApplyTerrainMapping(IKState *ikState);
;
void IKImport_UpdateCollisionCache(IKState *ikState);
;
clientInfo_t *IKImport_GetClientInfo(IKState *ikState);
Weapon IKImport_GetWeapon(IKState *ikState);
const WeaponVariantDef *IKImport_GetWeaponVariantDef(IKState *ikState);
const WeaponDef *IKImport_GetWeaponDef(IKState *ikState);
double IKImport_GetLayerLerp(;
double IKImport_GetLayerLerp(IKState *ikState, IKLayerNames layerName);
void IKImport_SetWeaponOffsetType(IKState *ikState);
void IKImport_UpdateWeaponClass(IKState *ikState);
void IKImport_GetPitchWeaponOffset(IKState *ikState, bool bIsPitchDirectionUp, vec3_t *weapOfsOut);
double IKImport_GetMaxLayerLerp(IKState *ikState);
void IKImport_InitCollisionCache(IKState *ikState);

//t6/code/src_noserver/ik/ik_import.h
double IKImport_SmoothLerpAdjust(float in);

//t6/code/src_noserver/ik/ik_layers.cpp
void IK_Layer_ApplyFootIK(;
void IK_Layer_ApplyHandIK(;
;
;
void IK_Layer_PlayerControllers(IKState *ikState);
;
;
;
;

//t6/code/src_noserver/ik/ik_math.cpp
void ikMatrixIdentity44(vec4_t *out);
void MatrixSet44(vec4_t *out, const vec3_t *origin, const vec3_t *axis, float scale);
void ikQuatTransToMatrix44(const float *quat, const float *trans, vec4_t *out);
void ikAxisToQuat(const vec3_t *mat, vec4_t *out);
void IK_FlipHack(vec4_t *mat);
void ikNormalizedMatrixAssert_func(vec4_t *mat);
void ikQuatToAxis(const vec4_t *quat, vec3_t *axis);
void ikMatrix44ToQuatTrans(vec4_t *mat, vec4_t *quat, vec3_t *trans);
;
;
;
;
;
;
void ikMatrixLerp44(vec4_t *from, vec4_t *to, float lerp, vec4_t *res);

//t6/code/src_noserver/ik/ik_process.cpp
;
void IK_Process(IKState *ikState);

//t6/code/src_noserver/ipak/ipak_game.cpp
IPakLoadedPackfile *IPak_FindPackfile(const char *name);
void IPak_MarkAdjacencyInfoAsStale();
int IPak_RemovePackfile(const char *name);
void IPak_IndexReadCallback(int id, stream_status result, unsigned int numBytesRead, void *user);
void IPak_ReadIndexData(IPakWorkData *work, int buffer);
void IPak_WaitReadIndexData(IPakWorkData *work, int buffer);
void IPak_BeginIndexRead(IPakWorkData *work, IPakLoadedPackfile *pak);
// char IPak_CurrentIndexEntry@<al>(int a1@<edx>, IPakWorkData *work, IPakIndexEntry *entry);
// char IPak_NextIndexEntry@<al>(int a1@<edx>, IPakWorkData *work, IPakIndexEntry *entry);
void IPak_EndIndexRead(IPakWorkData *work);
int IPak_CompareImagePartHashes(const void *A, const void *B);
int IPak_CompareImageOffsets(const void *A, const void *B);
void IPak_BuildAdjacencyInfo(unsigned __int8 *workBuffer, int workBufferSize);
void IPak_InvalidateImages();
void IPak_RemovePackfilesForZone(const char *zoneName);

//t6/code/src_noserver/json/json.cpp
int jsmn_parse_primitive(jsmn_parser *parser, const char *js, jsmntok_t *tokens, unsigned int num_tokens);
int jsmn_parse_string(jsmn_parser *parser, const char *js, jsmntok_t *tokens, unsigned int num_tokens);
int jsmn_parse(jsmn_parser *parser, const char *js, jsmntok_t *tokens, unsigned int num_tokens, int *errorPos);
void jsmn_init(jsmn_parser *parser);
jsmntok_t *JSMN_GetToken();
void JSMN_UnGetToken();
jsmntok_t *JSMN_GetKey(const char *key);
const GfxViewParms *JSMN_GetLocalizedString(const char *loc);
int jsmn_parse(jsmn_parser *parser, const char *js, jsmntok_t *tokens, unsigned int num_tokens);
char JSMN_BeginParseSession(const char *json, jsmntok_t *tokens, int maxTokens);

//t6/code/src_noserver/leaderboard/leaderboard_load_db.h
void Load_LbColumnDefArray(bool atStreamStart, int count);
void Load_LeaderboardDef(bool atStreamStart);
void Load_LeaderboardDefPtr(bool atStreamStart);
void Mark_LeaderboardDefPtr();

//t6/code/src_noserver/leaderboard/leaderboard_load_obj.cpp
void LB_LoadId(const char *parse, LeaderboardDef *lbDef);
bool LB_LoadColDef(const char *parse, LeaderboardDef *lbDef);
LeaderboardDef *LB_LoadDef_LoadObj(const char *filename);
LeaderboardDef *LB_LoadDef_FastFile(const char *name);
LeaderboardDef *LB_LoadDef();

//t6/code/src_noserver/live/live.cpp
const char *Live_GetDWEnviroment();
void Live_Base_LobbyPump(const ControllerIndex_t localControllerIndex);
void Live_Base_ContentStreamingInit(ControllerIndex_t localControllerIndex);
void Live_Base_PooledStorageInit(ControllerIndex_t localControllerIndex);
ControllerIndex_t Live_GetControllerFromXuid(unsigned __int64 xuid);
bool Live_IsUserSignedInToDemonware(const ControllerIndex_t controllerIndex);
;
void Live_LeaveAllPartiesCmd();
;
void Live_CloseAllBusyPopups_f();
void Live_DelayedComError(const char *comErrorString);
void Live_SetComErrorIfJoinInProgressFails(bool shouldComError);
void Live_ResetLobbyModeDvars(;
unsigned int Live_IsUserInGame(const ControllerIndex_t controllerIndex);
int Live_IsAnyUserInGame();
bool Live_IsGeoLocationDataRetrieved();
bdDMLHierarchicalInfo *Live_GetGeoLocation();
bool Live_GetUserGeoLocationDataSuccess(TaskRecord *task);
char Live_GetUserGeoLocationDataFailure(TaskRecord *task);
bool Live_NATTypeAllowed(XONLINE_NAT_TYPE NATtype);
bool Live_CanHostServer(const ControllerIndex_t localControllerIndex, const int playerCount);
void Live_AwardAchievement_f();
int Live_SessionMode_EncodePlaylistNumber(int playlistNum);
int Live_SessionMode_DecodePlaylistNumber(int playlistNum);
unsigned __int64 Live_GetLocalXUID(const ControllerIndex_t controllerIndex, unsigned __int64 myXUID);
void Live_Init();
bool Live_GetConnectivityInformation(ControllerIndex_t controllerIndex, int *infoBitmask, bool outputDebugInfo);
void Live_GetGeoLocationData(const ControllerIndex_t controllerIndex);
bool Live_CanHostServer(;

//t6/code/src_noserver/live/live_anticheat.cpp
void LiveAntiCheat_BanDoConnected();
void LiveAntiCheat_DWPlayerBanned(unsigned __int64 userID, unsigned int reputationLevel);
void LiveAntiCheat_GenerateCRC32Checksum(const unsigned __int8 *data, int length, unsigned int *key);
unsigned int LiveAntiCheat_GenerateCRC32ChecksumSplit(;
HashInfo *LiveAntiCheat_StartHash(;
bool LiveAntiCheat_ContinueHash(void *handle);
char LiveAntiCheat_CompleteHash(void *handle, unsigned __int64 *result);
void LiveAntiCheat_AnswerChallengesRetry(const ControllerIndex_t controllerIndex);
char LiveAntiCheat_AnswerChallengesFailure(TaskRecord *task);
void LiveAntiCheat_ResetChallengeResponse(const ControllerIndex_t controllerIndex);
void LiveAntiCheat_ClearGameReport();
void LiveAntiCheat_SetThresholdExceeded(int threshold);
void LiveAntiCheat_ReportLaggedDamage();
void LiveAntiCheat_SetGameReportTags(int *numTags, bdTag *tags);
TaskRecord *LiveAntiCheat_AnswerChallenges(const ControllerIndex_t controllerIndex);
char LiveAntiCheat_AnswerChallengesSuccess(TaskRecord *task);
// void LiveAntiCheat_OnChallengesReceived(unsigned __int64 userID, bdReference<bdAntiCheatChallenges> challenges);
bool LiveAntiCheat_AnswerChecksumRequest(;
bool LiveAntiCheat_AnswerDvarRequest(;
bool LiveAntiCheat_AnswerDvarFloatRequest(;
bool LiveAntiCheat_AnswerExpressionRequest(;
bool LiveAntiCheat_GetChallengeResponse(;
void LiveAntiCheat_ProcessChallenges(const ControllerIndex_t controllerIndex);

//t6/code/src_noserver/live/live_counter.cpp
char LiveCounter_UploadAllCountersComplete();
char LiveCounter_UploadAllCountersFailure(TaskRecord *task);
char LiveCounter_DownloadAllCountersComplete();
char LiveCounter_DownloadAllCountersFailure();
void LiveCounter_AddToQueueByID(int counterID, __int64 increment);
void LiveCounter_ForceFlushQueue_f();
void LiveCounter_Dump_f();
int LiveCounter_GetCounterTotalValue(int counterID);
int LiveCounter_CounterStringToID(const char *counterType);
void LiveCounter_SetupCounters();
void LiveCounter_AddToQueueByName(const char *counterType, __int64 increment);
void LiveCounter_AddToQueueByName_f();
void LiveCounter_Init();

//t6/code/src_noserver/live/live_dedicated.cpp
char *dwSelectLSGAddress();
char *dwSelectAuthAddress();
void Live_SetTitleIDFromCommandLine();
void Live_SetAuthAddrFromCommandLine();
void Live_SetLsgAddrFromCommandLine();
int Live_GetTitleID();
void SV_SwitchPlaylists(const int newplaylist);
void SV_PlaylistDvarChanged(const dvar_t *playlistdvar);
void Live_OnDWConnect(const ControllerIndex_t localControllerIndex);
void Live_OnDWDisconnect(const ControllerIndex_t localControllerIndex);
const char *Live_DedicatedReadDWKey();
bool Live_Base_AuthorizeLicenseWithDW(const ControllerIndex_t controllerIndex, dediUserData_t *userData);
bool Live_Base_HandleAuthServiceReady(;
void Live_Base_StateAuthorizing(const ControllerIndex_t controllerIndex, dediUserData_t *userData);
void Live_Base_StateConnecting(const ControllerIndex_t controllerIndex, dediUserData_t *userData);
void Live_Base_StateError(const ControllerIndex_t controllerIndex, dediUserData_t *userData);
void Live_Base_Init();
char Live_Base_UserGetName(const ControllerIndex_t controllerIndex, char *buff, int buffSize);
char Live_Base_UserGetXuid(const ControllerIndex_t controllerIndex, unsigned __int64 *xuid);
ControllerIndex_t Live_Base_GetControllerFromXUID(const unsigned __int64 xuid);
bool Live_IsSignedInToLive(ControllerIndex_t controllerIndex);
unsigned __int64 Live_GetXuid(ControllerIndex_t controllerIndex);
void Live_SetAddressForDedicatedServer(MatchMakingInfo *sessionInfo);
const char *SV_GetLSPID();
int SV_GetLSPPort();
void Live_FakeDLC_ClientDisconnect();
void Live_FakeDLC_ClientJoin(unsigned int contentFlags);
unsigned int Live_FakeDLC_GetFlags();
void MatchmakingHopper_UpdateState(matchmakingHopperState_t newState);
void MatchmakingHopper_Init();
char MatchmakingHopper_ClientJoin(int memberPlaylist);
void MatchmakingHopper_Frame();
BOOL MatchmakingHopper_isParked();
void Live_SetPingTestKey();
void Live_Base_StateConnected(const ControllerIndex_t controllerIndex, dediUserData_t *userData);
void Live_Base_PumpForController(;
void Live_Base_Pump(ControllerIndex_t a1, dediUserData_t *a2);
void Live_HandleDemonwareLSP(;
void Live_DedicatedFrame();

//t6/code/src_noserver/live/live_doublexp.cpp
int Live_DoubleXPGetGroupMaskFromString(const char *groupString);
void Live_DoubleXPSetServerGroupMasks();
unsigned int Live_DoubleXPGetServerGroupMask();
unsigned int Live_DoubleXPGetServerGunGroupMask();
unsigned int Live_DoubleXPGetGroupMask(doubleXPGroups_e group);
unsigned int Live_DoubleXPGetGroupMaskForController(const ControllerIndex_t controllerIndex);
void Live_DoubleXPRecordIW6Promo(const ControllerIndex_t controllerIndex, bool accessed);
void Live_DoubleXPUpdatGroupMaskForController(;
void Live_DoubleXPUpdateMapPackInfo(bool ignoreMountedControllers);
void Live_DoubleXPUpdateMapPackInfoCmd();
void Live_DoubleXPRecordSeasonPass(const ControllerIndex_t controllerIndex);
void Live_DoubleXPSetGroupMaskForController(const ControllerIndex_t controllerIndex, bool includeKeyArchive);
int Live_DoubleXPGetContentMask(const char *contentPakNames);
void Live_DoubleXPInit();
void Live_DoubleXPUnsetGroupManuallyForController(const ControllerIndex_t controllerIndex, int groupIndex);

//t6/code/src_noserver/live/live_elite.cpp
void ClearRetrievedEliteAccountInfo();
TaskRecord *LiveElite_ClanLeave(const ControllerIndex_t localControllerIndex, unsigned __int64 teamid);
char LiveElite_ClanLeaveSuccess(TaskRecord *task);
char LiveElite_ClanLeaveFailure(TaskRecord *task);
char LiveElite_ClanInviteSuccess(TaskRecord *task);
char LiveElite_ClanInviteFailure(TaskRecord *task);
TaskRecord *LiveElite_CreateClan(const ControllerIndex_t localControllerIndex, const char *teamName);
char LiveElite_CreateClanSuccess(TaskRecord *task);
char LiveElite_CreateClanFailure(TaskRecord *task);
TaskRecord *LiveElite_TeamSetPublicProfile(;
char LiveElite_TeamSetPublicProfileSuccess(TaskRecord *task);
char LiveElite_TeamSetPublicProfileFailure(TaskRecord *task);
TaskRecord *LiveElite_TeamSetPrivateProfile(;
char LiveElite_TeamSetPrivateProfileSuccess(TaskRecord *task);
char LiveElite_TeamSetPrivateProfileFailure(TaskRecord *task);
unsigned __int64 LiveElite_GetTeamID(const ControllerIndex_t localControllerIndex);
bool LiveElite_IsClanAbbrevValidated(const ControllerIndex_t localControllerIndex);
char LiveElite_GetMembersFailure(TaskRecord *task);
char LiveElite_GetClanXPAndLevelSuccess(TaskRecord *task);
char LiveElite_GetClanXPAndLevelFailure(TaskRecord *task);
char LiveElite_GetMembershipFailure(TaskRecord *task);
char LiveElite_GetTeamPublicProfileFailure(TaskRecord *task);
char LiveElite_GetTeamPrivateProfileSuccess(TaskRecord *task);
char LiveElite_GetTeamPrivateProfileFailure(TaskRecord *task);
char LiveElite_ArchiveMarketingOptInSuccess(TaskRecord *task);
char LiveElite_ArchiveMarketingOptInFailure(TaskRecord *task);
char LiveElite_GetSubscriberInfoFromDWSuccess(TaskRecord *task);
char LiveElite_GetSubscriberInfoFromDWFailure(TaskRecord *task);
char LiveElite_RefreshDWSubscriberInfoSuccess(TaskRecord *task);
char LiveElite_RefreshDWSubscriberInfoFailure(TaskRecord *task);
void LiveElite_CreateClanCmd();
void LiveElite_ClanLeaveCmd();
void LiveElite_TeamSetPublicProfileCmd();
void LiveElite_TeamSetPrivateProfileCmd();
void LiveElite_LaunchAppExecutable_f();
void LiveElite_ShowForceEliteCmds_f();
BOOL LiveElite_CheckProgress(const ControllerIndex_t localControllerIndex, eliteStatus_e status);
void LiveElite_GetGoldClanTag(char *out, const char *clanTag, const char *playerName);
char *LiveElite_GetClanTag_VA(bool useGold, const char *clanTag, const char *playerName);
// bool __thiscall jsonWriter::checkJSON(jsonWriter *this, char *strJSON);
// void __thiscall eventAccumulator::reset(eventAccumulator *this);
// void __thiscall eventAccumulator::setMatchID(eventAccumulator *this, unsigned __int64 inputFileID);
// int __thiscall eventAccumulator::getSegmentJSON(;
// BOOL __thiscall eventAccumulator::canFlush(eventAccumulator *this);
char LiveElite_GetMembersSuccess(TaskRecord *task);
char LiveElite_GetMembershipSuccess(TaskRecord *task);
char LiveElite_GetTeamPublicProfileSuccess(TaskRecord *task);
// void __thiscall jsonWriter::beginObject(jsonWriter *this);
// void __thiscall jsonWriter::writeValue(jsonWriter *this, char *strValue, bool isNameValuePair, segment *segmentType);
// void __thiscall jsonWriter::terminate(jsonWriter *this, int minObjectCounter);
// void __thiscall eventAccumulator::writeCategoryValue(;
// void __thiscall eventAccumulator::endMatch(eventAccumulator *this);
// void __thiscall eventAccumulator::endCategory(eventAccumulator *this);
// bool __thiscall eventAccumulator::flush(eventAccumulator *this);
// void __thiscall eventAccumulator::flushCheck(eventAccumulator *this);
void LiveElite_Clear(const ControllerIndex_t localControllerIndex);
void __thiscall LiveElite_Init(void *this);
// void __thiscall eventAccumulator::startMatch(eventAccumulator *this);
// void __thiscall eventAccumulator::beginCategory(eventAccumulator *this, char *categoryName);
void __noreturn terminate();

//t6/code/src_noserver/live/live_fileshare.cpp
BOOL LiveFileShare_IsReady(ControllerIndex_t controllerIndex, bool allowRead);
int LiveFileShare_GetIndexFromGameType(const char *gameType, const char *zmMapStartLoc);
void LiveFileshare_AddTag(;
bool LiveFileshare_TagSanityCheck(bdTag *tags, int numTags);
int LiveFileshare_SortByTime(const void *a, const void *b);
int LiveFileshare_SortByType(const void *a, const void *b);
void LiveFileshare_Sort();
char LiveFileshare_GetVoteStatsFailure(TaskRecord *task);
char LiveFileshare_GetViewStatsFailure(TaskRecord *task);
void LiveFileshare_GetStats(;
void LiveFileshare_GetViewStats(const ControllerIndex_t controllerIndex, int offset);
void LiveFileshare_GetVoteStats(const ControllerIndex_t controllerIndex, int offset);
void LiveFileshare_GetSlotDataSuccess(const ControllerIndex_t controllerIndex);
void LiveFileshare_GetSlotDataFailure(const ControllerIndex_t controllerIndex);
void LiveFileshare_GetSlotData(const ControllerIndex_t controllerIndex, int offset);
void LiveFileshare_SetCopyFileName(char *name);
void LiveFileshare_SetCopyFileDescription(char *description);
void LiveFileshare_DeleteFileSuccess(const ControllerIndex_t controllerIndex, int slot);
void LiveFileshare_DeleteFile(const ControllerIndex_t controllerIndex, unsigned __int64 fileID);
void LiveFileshare_GetSummary(;
void LiveFileshare_DownloadSummarySuccess(const ControllerIndex_t controllerIndex);
void LiveFileshare_DownloadSummaryFailure();
void LiveFileshare_DownloadSummary(const ControllerIndex_t controllerIndex);
void LiveFileShare_AbortOperationCmd();
void LiveFileshare_GetSummaryCmd();
void LiveFileshare_AbortSummaryCmd();
void LiveFileshare_CopyFileParams();
void LiveFileshare_DeleteFileCmd();
void LiveFileshare_Invalidate();
void LiveFileshare_Mem_Startup();
char LiveFileshare_GetVoteStatsSuccess(TaskRecord *task);
char LiveFileshare_GetViewStatsSuccess(TaskRecord *task);
void LiveFileshare_UpdateSlots(const ControllerIndex_t controllerIndex, bool finishEarly);
void LiveFileshare_GetSlots(const ControllerIndex_t controllerIndex, const char *groupName);
void LiveFileshare_Copy_TransferSuccess();
char LiveFileshare_Copy_UpdateDescriptorUser(const ControllerIndex_t controllerIndex);
char LiveFileshare_Copy_UpdateDescriptorPooled(const ControllerIndex_t controllerIndex);
void LiveFileshare_Copy_DownloadDescriptorSuccess(const ControllerIndex_t controllerIndex);
void LiveFileshare_CopyFile(;
void __thiscall LiveFileshare_Update(void *this);
void LiveFileshare_GetSlotsCmd();
void LiveFileshare_CopyFileCmd();
void LiveFileshare_Init();
void LiveFileshare_Mem_Shutdown();

//t6/code/src_noserver/live/live_fileshare_cache.cpp
bool Live_FileShare_CacheInit();
void Live_FileShare_CacheShutdown();
char Live_FileShare_IsCached(unsigned __int64 fileID, fileShareLocation location, int *index);
void Live_FileShareCache_AddDescriptor(;
char Live_FileShareCache_GetDescriptor(;

//t6/code/src_noserver/live/live_fileshare_search.cpp
char Live_FileshareSearch_ShouldSearch(searchContext_t *context);
void Live_FileshareSearch_PushResultsToLUA();
bool Live_FileshareSearch_GetCounts(;
bool Live_FileshareSearch_ReadVotesSuccess(TaskRecord *task);
bool Live_FileshareSearch_ReadVotesFailure();
char Live_FileshareSearch_ReadViewsSuccess();
char Live_FileshareSearch_ReadViewsFailure();
void Live_FileshareSearch_ClearContext();
void Live_FileshareSearch_SetContext(searchContext_t *context);
void Live_FileshareSearch_TestCmd();
void Live_FileshareSearch_Init();

//t6/code/src_noserver/live/live_fileshare_tables.h
int LiveFileshare_GroupTable_GetMaxSlots();
int LiveFileshare_GroupTable_GetRow(const char *group);
int LiveFileshare_CategoryTable_GetRow(int categoryID);

//t6/code/src_noserver/live/live_friends.cpp
int SortABCFriendsUnifiedFunc(const void *a, const void *b);
int SortStatusFriendsUnifiedFunc(const void *a, const void *b);
void FriendsUnified_SortList(const ControllerIndex_t localControllerIndex);
void FriendsUnified_Init();
void FriendsUnified_UpdateList(const ControllerIndex_t localControllerIndex);

//t6/code/src_noserver/live/live_friends_pc.cpp
void Friends_Init();
FriendInfo *Friends_GetFriendInfoByIndex(const ControllerIndex_t controllerIndex, int index);
void Friends_UpdateInvites(ControllerIndex_t controllerIndex);
char Friends_IsFriendByID(ControllerIndex_t controllerIndex, unsigned __int64 id);
bool Friends_IsInCurrentSession(unsigned __int64 id);
int XFriendStatus(const FriendInfo *xfriend);
void XFriendToFriendInfo(const FriendInfo *xfriend, FriendInfo *info);
void Friends_SetInviteInfo(;
int Friends_GetCount(ControllerIndex_t controllerIndex, int filter, int inverseFilter);
char Friends_GetByID(ControllerIndex_t controllerIndex, unsigned __int64 id, FriendInfo *info);
char Friends_GetByIndex(;
char Friends_Update(ControllerIndex_t controllerIndex);

//t6/code/src_noserver/live/live_groups_dw.cpp
char LiveGroups_SetGroupsComplete(TaskRecord *task);
char LiveGroups_GetGroupID(const char *path, int *offset, GroupSet **gs);
void LiveGroups_JoinGroup(ControllerIndex_t localControllerIndex, const char *path);
bool LiveGroups_IsInGroup(ControllerIndex_t localControllerIndex, const char *path);
void LiveGroups_LeaveGroup(ControllerIndex_t localControllerIndex, const char *path);
unsigned int LiveGroups_GetCount(const char *path);
void LiveGroups_JoinGroup_f();
void LiveGroups_LeaveGroup_f();
void LiveGroups_Dump_f();
void LiveGroups_Init();
void LiveGroups_UpdateGroupMemberships(const ControllerIndex_t localControllerIndex);
void LiveGroups_SetGroups(ControllerIndex_t localControllerIndex);
bool LiveGroups_GetGroupCountsComplete(TaskRecord *task);
void LiveGroups_GetCounts(ControllerIndex_t localControllerIndex);
void LiveGroups_Update(ControllerIndex_t localControllerIndex);

//t6/code/src_noserver/live/live_leaderboards_dedicated.cpp
char *getLbNameString(typeEnumLB type);
lbdef_t *Live_DedicatedLB_GetLBDef(typeEnumLB type);
int getLbColumnIndexForContentPack(int pack);
void ownershipSet(client_t *client, typeEnumLB type);
void Live_DedicatedLB_Ownerhip_Approved(client_t *client);
void Live_DedicatedLB_Ownerhip_Denied(client_t *client);
void Live_DedicatedLB_Ownerhip_Played(client_t *client);
void Live_DedicatedLB_ClientConnected(client_t *client);
void Live_DedicatedLB_ClientDisconnected(client_t *client);
// LeaderboardRow<10> *getFreeLBRow();
char Live_DedicatedLB_WriteSuccess();
void Live_DedicatedLB_Frame();
bool Live_DedicatedLB_ParseLBDef(const char *lbBuf, int lbBufLen);
int Live_DedicatedLB_FetchDefsFailure(const ControllerIndex_t controllerIndex, void *data);
void Live_DedicatedLB_FetchDefsSuccess(const char *a1, int a2);
char Live_DedicatedLB_FetchLBDefs();
void Live_DedicatedLB_Init();

//t6/code/src_noserver/live/live_leaderboard_dw.cpp
TaskRecord *LiveLeaderboard_SetupNestedTask(;
void LiveLeaderboard_RowDebugPrint(;
char LiveLeaderboard_ReadStatsDataFailure(TaskRecord *task);
char LiveLeaderboard_ReadGhostLBFailure(TaskRecord *task);
BOOL LiveLeaderboard_IsGhostLBFetchingFinished();
int LiveLeaderboard_GetGhostLBReadBeginTime();
int LiveLeaderboard_CalculatePlayerLbRowValue(;
char LiveLeaderboard_UploadPlayerDataExecuteTask(;
char LiveLeaderboard_WriteStatsDataSuccess();
char LiveLeaderboard_CanUserAccessLeaderboard(const ControllerIndex_t localControllerIndex);
bool LiveLeaderboard_IsUploadedZombie(const ControllerIndex_t localControllerIndex);
void LiveLeaderboard_SetUploadedStatusZombie(const ControllerIndex_t localControllerIndex, bool isUploaded);
void LiveLeaderboard_SetWriteLeaderboards(const LocalClientNum_t localClientNum, const char *lbConfigStr);
int LiveLeaderboard_CompareXUserStatsRowRanks(const void *r1, const void *r2);
void LiveLeaderboard_SortXUserStatsByRank(Leaderboard *lb);
void LiveLeaderboard_ReadStatsSuccess(ControllerIndex_t localControllerIndex, Leaderboard *lb);
char LiveLeaderboard_GetStatsByXuidsFailure(TaskRecord *task);
char LiveLeaderboard_GetByRank(;
char LiveLeaderboard_GetByRankFailure(TaskRecord *task);
char LiveLeaderboard_GetByPlayerFailure(TaskRecord *task);
bool LiveLeaderboards_GetResetLeaderboards(;
ControllerIndex_t LiveLeaderboard_SortMultiSearchResults(ControllerIndex_t localControllerIndex);
int LiveLeaderboard_lbGetCache(const ControllerIndex_t controllerIndex, const int colIndex);
char LiveLeaderboard_ReadStatsDataSuccess(TaskRecord *task);
char LiveLeaderboard_ReadGhostLBSuccess(TaskRecord *task);
// int LiveLeaderboard_ColumnIDToValue(const LeaderboardDef *lbDef, LeaderboardRow<10> *row, int colId);
int LiveLeaderboard_MakeRow(;
bool LiveLeaderboard_RankUpdate(;
bool LiveLeaderboard_CombineUpdate(;
char LiveLeaderboard_UploadPlayerDataExecuteBlockingTask(;
char LiveLeaderboard_WriteStatsDataFailure(TaskRecord *task);
char LiveLeaderboard_UploadPlayerStatsExecute(const ControllerIndex_t localControllerIndex);
char LiveLeaderboard_UploadPlayerStats(const ControllerIndex_t localControllerIndex);
char LiveLeaderboard_GetStatsSuccess(TaskRecord *task);
char LiveLeaderboard_GetStatsByXuidsSuccess(TaskRecord *task);
char LiveLeaderboard_GetByPlayerSuccess(TaskRecord *task);
char LiveLeaderboards_ResetLeaderboardsClearRows(;
// void LiveLeaderboards_ResetLeaderboards(const char **a1@<edx>, const ControllerIndex_t controllerIndex);
void LiveLeaderboards_ResetLeaderboards_f();
void LiveLeaderboard_Init();
char LiveLeaderboard_GetMiniLbsSuccess(TaskRecord *task);

//t6/code/src_noserver/live/live_leagues.cpp
void ParseError(jsmntok_t *token, const char *msg);
void DataError(jsmntok_t *token, const char *msg);
jsmntok_t *GetNextToken(jsmntok_t **token, jsmntok_t *end);
jsmntok_t *GetEndToken(jsmntok_t *token);
char GetNextKeyValue(jsmntok_t **token, jsmntok_t *end, jsmntok_t **key, jsmntok_t **value);
bool IsTokenEqual(jsmntok_t *token, const char *str);
char *GetTokenString(jsmntok_t *token);
const GfxViewParms *CopyTokenString(jsmntok_t *token);
const GfxViewParms *CopyTokenLocalizedString(jsmntok_t *token);
int GetTokenInt(jsmntok_t *token);
float GetTokenFloat(jsmntok_t *token);
bool GetTokenBool(jsmntok_t *token);
int GetTokenTime(jsmntok_t *token);
char ParseSeasons(League *league, jsmntok_t *token);
char ParseIcons(LeagueDivision *division, jsmntok_t *token);
char ParseAwards(League *league, jsmntok_t *token);
char ParseNouns(jsmntok_t *token);
char ParseNumbers(jsmntok_t *token);
char ParseLeagues(jsmntok_t *token);
char ParseDivisions(jsmntok_t *token);
void ResetLeagueInfo();
bool ValidateLeagueInfo();
bool CheckTokenizerError(jsmnerr_t result);
bool ParseLeagueInfo(const char *buffer);
int League_GetCurrentID();
char League_ParseInfo(const char *buffer);
int League_GetTeamSize(int id);
LeagueSeason *League_GetSeasonByID(int leagueID, int seasonID);
LeagueSeason *League_GetActiveSeason(int id);
LeagueSeason *League_GetNextActiveSeason(int id);
LeagueDivision *League_FindDivision(int id, int divisionID);
char League_GetTeamIDFailure(TaskRecord *task);
void League_Backoff(ControllerIndex_t controllerIndex);
void League_SetupDefaultStats(StatsLookup *lookup);
void League_PushStats(LeagueStats *stats, bdLeagueStatsInfo *dwStats);
void League_MSGWriteStats(msg_t *msg, const LeagueStats *stats);
void League_MSGReadStats(msg_t *msg, LeagueStats *stats);
char League_GetStatsFailure(TaskRecord *task);
char League_FetchTeamsListFailure();
char LeagueFetchSoloTeamIDFailure();
char League_FetchTeamSubdivisionsSuccess(TaskRecord *task);
char League_FetchTeamSubdivisionsFailure(TaskRecord *task);
char League_FetchTeamInfoFailure();
char League_FetchLbTeamMemberInfoFailure();
char League_FetchTeamMemberInfoSuccess(TaskRecord *task);
char League_FetchTeamMemberInfoFailure();
int SortSubdivisionInfosBySeasonDate(const void *a, const void *b);
char League_FetchHistorySubdivisionInfosFailure();
char League_FetchLeagueHistoryFailure();
bool ParseMetaData(;
char League_FetchSubdivisionFailure(TaskRecord *task);
// char League_RefetchSubdivisionSuccess@<al>(bool *a1@<edi>, TaskRecord *task);
char League_RefetchSubdivisionFailure(TaskRecord *task);
void League_ClearTeamTasks(const ControllerIndex_t controllerIndex);
char League_GetCurrentTeamID(;
bool League_SetOutcomes(const ControllerIndex_t controllerIndex, const LeagueOutcomes *outcomes);
void League_SetMatchDelta(StatsLookup *lookup, LeagueStats *outcomeStats, LeagueStats *baseStats);
char League_AreWeFetchingStats(const ControllerIndex_t controllerIndex);
char League_FetchLbDataFailure(TaskRecord *task);
char League_FindTeamAndLeagueInFetchedData(;
char League_FetchAllInfoForTeamInLeagueFailure();
void League_RecordEvent(;
const GfxViewParms *League_GetCurrentTeamName(const ControllerIndex_t controllerIndex);
void League_Status(const ControllerIndex_t controllerIndex);
bool League_GetSkillAndVariance(const ControllerIndex_t controllerIndex, float *skill, float *variance);
char League_GetCurrentStats(const ControllerIndex_t controllerIndex, LeagueStats *stats);
void League_Status_f();
void League_Refresh_f();
char League_HandleInstantMessage(ControllerIndex_t controllerIndex, const char *msg);
void League_CalculateScore(League *league, int count, LeagueTeam *teams);
void League_CalculateMatchResult(int count, LeagueTeam *teams);
char League_GetTeamID(;
void League_UpdateBonusAllocation(ControllerIndex_t controllerIndex);
char League_GetStatsSuccess(TaskRecord *task);
bool League_FetchTeamsListInternal(;
char LeagueFetchSoloTeamIDSuccess(TaskRecord *task);
bool League_FetchSoloTeamID(const ControllerIndex_t controllerIndex);
bool League_FetchTeamsList(;
char League_FetchTeamInfo(const ControllerIndex_t controllerIndex);
char League_FetchTeamMemberInfo(const ControllerIndex_t controllerIndex);
char League_FetchHistorySubdivisionInfosSuccess(TaskRecord *task);
void League_FetchLeagueHistorySubdivisionInfos(const ControllerIndex_t controllerIndex);
char League_FetchLeagueHistoryInternal(;
char League_FetchLeagueHistorySuccess(TaskRecord *task);
// char League_FetchSubdivisionSuccess@<al>(bool *a1@<edi>, TaskRecord *task);
char League_UploadStatsSuccess(TaskRecord *task);
char League_UploadStatsFailure(TaskRecord *task);
void League_SetCurrentTeamID(;
// char League_ApplyOutcome@<al>(;
char League_FetchLbDataSuccess(TaskRecord *task);
char League_FetchLbDataByPivot(;
char League_FetchLbDataByRank(;
bool League_SetCurrentTeamEmblem(;
void League_Force_f();
void League_Fake_f();
char League_FetchTeamsListSuccess(TaskRecord *task);
char League_FetchLbData(;
char League_FetchAllInfoForTeamInLeagueSuccess(TaskRecord *task);
void League_FetchLbData_f();
void League_Init();
void ParseError(const char *msg);

//t6/code/src_noserver/live/live_league_friends.cpp
void League_Friends_TeamMemberInfoDownloaded(;

//t6/code/src_noserver/live/live_metplayer.cpp
void LiveMetPlayer_ClearUploadFlags(const ControllerIndex_t controllerIndex);
bool LiveMetPlayer_UploadMetPlayerListNeeded(ControllerIndex_t controllerIndex);
void LiveMetPlayer_ResetData(ControllerIndex_t controllerIndex);
void LiveMetPlayer_RemoveFriendsFromRecentPlayerList(ControllerIndex_t controllerIndex);
void LiveMetPlayer_UploadMetPlayerList(ControllerIndex_t localControllerIndex);
void LiveMetPlayer_RemoveFriendsFromRecentPlayerListCmd();
void LiveMetPlayer_Init();
char LiveMetPlayer_GetIndexByXUID(ControllerIndex_t controllerIndex, unsigned __int64 xuid, int *index);
char LiveMetPlayer_GetRecentPlayerInfoByID(;

//t6/code/src_noserver/live/live_presence_win.cpp
unsigned int __thiscall offsetOfBufInHunkUserDefault(bdChannelInfo *this);
void Live_Disconnected();
void Live_NotPlaying();
void Live_SetLobbyPresence();
void Live_SetPartyPresence();
void Live_SetGeographicalRegion();
void Live_SetPlaylistVersion(ControllerIndex_t controllerIndex);
void Live_SetPlaylistNum(ControllerIndex_t localControllerIndex, int playlistNum);
void Live_SetGametype(ControllerIndex_t localControllerIndex, const char *gametype);
void Live_SetZmLocationContext(ControllerIndex_t localControllerIndex, const char *zmLocation);
int Live_GetMapIndex(const char *mapname);
void Live_SetCurrentMapname(const char *mapname);
void Live_SetTeamSizeRange(const int teamMaxSize);
int Live_GetMapSource(const int mapIndex);
void Live_SetMapPacks(const int mapPacks);
void Live_SetCurrentGametype();
void Live_SetTheaterPlayingPresence();

//t6/code/src_noserver/live/live_sessions.cpp
int Session_BuildQoSPayload(SessionData *session);
unsigned __int8 *Session_GetQosPayloadBuffer();
void Session_UpdateQoSPayload(SessionData *session);
char GetQoSPayload(unsigned __int8 *data, int dataSize, qosPayload_t *qosPayload);
ClientNum_t Session_HostNum(SessionData *session);
bool Session_IsLocalMember(SessionData *session, const ClientNum_t clientNum);
void Session_CloseJoinSessionPopup(ControllerIndex_t controllerIndex);
netadr_t *Live_GetPlayerAddr(netadr_t *result, SessionData *session, const ClientNum_t clientNum);
BOOL Live_PlayerHasLoopbackAddr(SessionData *session, const ClientNum_t clientNum);
ClientNum_t Session_FindRegisteredUser(const SessionData *session, const unsigned __int64 xuid);
bool Session_IsUserRegistered(const SessionData *session, const ClientNum_t clientNum);
unsigned __int64 Session_GetXuid(const SessionData *session, const ClientNum_t clientNum);
unsigned __int64 Session_GetXuidEvenIfInactive(const SessionData *session, const ClientNum_t clientNum);
netadr_t *Live_GetPlayerNetAddr(netadr_t *result, const SessionData *session, const ClientNum_t clientNum);
bool Live_IsClientRegistered(const SessionData *session, const ClientNum_t clientNum);
ClientNum_t Live_GetOurClientNum(ControllerIndex_t controllerIndex, SessionData *session);
int Session_CurrentFlags(SessionData *session);
int Session_PublicSlots(const SessionData *session);
int Session_PrivateSlots(SessionData *session);
unsigned __int64 Session_GetNonce(SessionData *session);
void Session_SetNonce(SessionData *session, unsigned __int64 nonce);
XSESSION_INFO *Session_GetXNKId(SessionData *session);
bool Session_Started(SessionData *session);
void Live_UpdatePlayerNetAddr(SessionData *session, const ClientNum_t clientNum, const netadr_t *addr);
void Live_UpdatePlayerInAddr(;
void Live_UpdatePlayerAddr(SessionData *session, const ClientNum_t clientNum, const netadr_t addr);
void Session_Init();
void Session_QoSListenStart(SessionData *session);
bool Session_IsControllerValidForCreatingSession(ControllerIndex_t controllerIndex, int requiredSigninState);
int Session_GetSessionCreateController(int requiredSigninState);
char Session_StartClient(;
bool Session_NeedToSyncParams(SessionData *session, const int numPublic, const int numPrivate, const int flags);
bool Session_ModifyInProgress();
bool Session_CreateInProgress();
bool Session_SearchInProgress();
void Session_CheckSessionTaskBySession(TaskRecord *task, void *inData);
char Session_SessionTasksInProgress(SessionData *session);
bool Session_CreateInProgress(SessionData *session);
void Session_CancelIndividualSessionTasks(SessionData *session);
void Session_CancelSessionTasks(SessionData *session);
void Session_WaitOnSessionTasks(SessionData *session);
void Session_WaitForTaskToComplete(TaskRecord *sessionTask, int startTime, int timeOut);
void Session_FinishOngoingSessionJoinTasksForXUID(SessionData *session, unsigned __int64 player);
SessionData *Session_GetCurrentSession();
void Session_UnregisterRemotePlayer(SessionData *session, const ClientNum_t slot);
void Session_EndGameSession(SessionData *session);
int Session_GetFreeSessionGraveYardSlot();
void Session_DeleteSession(SessionData *session, bool deleteNow);
void Session_DeleteSession(SessionData *session);
void Session_StartHost(;
void Session_FinishModify();
void Session_StartGameSession(const ControllerIndex_t localControllerIndex, SessionData *session);
void Session_RemoveAllPlayersFromSession(SessionData *session);
void Session_CleanUpSearches();
void Session_EmptyGraveYard();
void Session_EndOngoingSessionTasksForLeave(SessionData *session);

//t6/code/src_noserver/live/live_sessions_delegate.cpp
void HostDelegate_UpdateState(hostDelegationState_t newState);
BOOL HostDelegate_AreWeSessionOwner();
BOOL HostDelegate_ShouldSendPartyState();
void HostDelegate_RegisterPlayer(unsigned __int64 playerXUID, netadr_t playerAddr);
char HostDelegate_CurrentlyDelegating();
char anyPotentialDelegates();
void cleanupSessionDetails();
void HostDelegate_UnregisterPlayer(unsigned __int64 playerXUID);
char HostDelegate_Choose();
BOOL HostDelegate_IsCurrentHostValid();
bool sendHostDelegateCmd(netadr_t to);
char HostDelegate_ResendDelegateCmd();
void HostDelegate_Frame();
BOOL packetIsFromDelegate(netadr_t from);
void hostDelegateHandleSessionCreate(;
void HostDelegate_Init();
void HostDelegate_HandlePacket(LocalClientNum_t clientNum, netadr_t from, msg_t *msg);

//t6/code/src_noserver/live/live_sessions_dw.cpp
void Session_DeleteDWSession();
char Session_DeleteSessionSuccess();
char Session_DeleteSessionFailure();
void Session_QoSUpdate_Platform();
void Session_QoSListenStart_Platform(SessionData *session);
void Session_QoSListenStop(SessionData *session);
char Session_CreateHostSessionFailure(TaskRecord *task);
char Session_CreateNonMatchmakingSessionFailure(TaskRecord *task);
char Session_CreateNonMatchmakingSessionSuccess(TaskRecord *task);
bool Session_StartClient_Platform(;
void Session_Modify(;
char Session_ModifySessionSuccess(TaskRecord *task);
void Session_JoinSession(;
void Session_LeaveSession(SessionData *session, const ClientNum_t registeredUserSlot);
void Session_RegisterRemotePlayer(;
void Session_EveryoneLeaveSessionAsync(const ControllerIndex_t localControllerIndex, SessionData *session);
TaskRecord *Session_StartHostCreateTask_Platform(ControllerIndex_t controllerIndex, int sessionFlags);
int Session_StartHost_Platform_DW(;
void Session_ChangeAdvertisedStatus(bool onOff, bool force);
void Live_SetSkill(const float skill);
void Session_StartDeleteHandle(SessionData *session);
char Session_CreateHostSessionSuccess(TaskRecord *task);
int Session_CreateNonMatchmakingSession(TaskRecord *task);
char Session_ModifySessionFailure(TaskRecord *task);
char Session_FindSessionsFailure(TaskRecord *task);
char Session_FindSessionsSuccess(TaskRecord *task);

//t6/code/src_noserver/live/live_sessions_win.cpp
int Session_StartHost_Platform(;
void Session_Init_Platform();

//t6/code/src_noserver/live/live_stats.cpp
bool LiveStats_IsUsingLoadoutStats();
unsigned int LiveStats_GetDDLHeaderVersion(unsigned __int8 *statsBuffer);
int LiveStats_CanPerformStatOperation(ControllerIndex_t controllerIndex);
int LiveStats_GetStat(;
int LiveStats_GetUIntStat(;
ddlValue_t LiveStats_GetInt64Stat(;
const GfxViewParms *LiveStats_GetStringStat(;
bool LiveStats_GetStatsDDLSizeByFile(const char *ddlFileName, int version, int *size);
unsigned int LiveStats_ChecksumGamerStats(unsigned __int8 *buffer, const int len);
void LiveStats_SetDInt64StatFromBuffer(;
void LiveStats_SetDInt64Stat(;
bool LiveStats_IsStableStatsBufferInitialized(const ControllerIndex_t controllerIndex);
void LiveStats_SetItemStat(;
unsigned int LiveStats_GetItemStat(;
const char *LiveStats_GameHistory_GetModeName();
unsigned int LiveStats_GameHistory_GetMatchStatUInt(;
bool LiveStats_GameHistory_SetMatchStatUInt(;
bool LiveStats_GameHistory_SetMatchStatFloat(;
void LiveStats_GameHistory_InitializeHitLocationsArray(;
void LiveStats_Probation_GetProbationQuitTypeCost(eGameModes gamemode, float (*quitTypeCost)[5]);
bool StringBeginsWith(const char *prefix, const char *name);
int LiveStats_GetNumRecentlyUnlockedItems(ControllerIndex_t controllerIndex);
int LiveStats_GetRecentlyUnlockedItemIndex(ControllerIndex_t controllerIndex, unsigned int itemNum);
unsigned int LiveStats_CompressStats(;
void LiveStats_DecompressStats(unsigned __int8 *statsDestBuffer, int numCompressedPackets);
BOOL LiveStats_ValidateChecksum(unsigned __int8 *buffer, const int len);
BOOL LiveStats_ValidateBuffer(unsigned __int8 *buffer, int bufferSize);
char LiveStats_ParsePathToState(const char *path, ddlState_t *destState);
unsigned __int8 LiveStats_GetRecentUnlocks(const ControllerIndex_t controllerIndex);
double LiveStats_UpdateSkillAndVariance_Score(int count, PlayerSkill *players);
void LiveStats_SkillTestCmd();
bool LiveStats_CheckValidDelta(statsDelta_t *delta, int currentDelta);
void LiveStats_CheckForModUnlocks(;
void LiveStats_CheckForTokenUnlocks(;
bool LiveStats_HasRecentItemAttachmentsUnlocked(;
bool LiveStats_IsItemAttachmentRecentlyUnlocked(;
void LiveStats_StatReadDDLCommand(int cmdArgcStartPos, statsLocation statsLoc);
void LiveStats_StatReadDDLExtCmd();
void LiveStats_StatReadDDLCmd();
void LiveStats_StatWriteDDLCmdInternal(bool localize);
void LiveStats_StatWriteDDLCmd();
void LiveStats_StatWriteFromLocalizedStrCmd();
void LiveStats_ClearCustomClassWarning(const ControllerIndex_t controllerIndex);
void LiveStats_ClearStatsWarning(const ControllerIndex_t controllerIndex);
bool LiveStats_CheckClassVersion(const ControllerIndex_t controllerIndex);
ddlState_t *LiveStats_GetRootDDLState();
ddlDef_t *LiveStats_GetStatsDDL();
ddlDef_t *LiveStats_GetClassSetsDDL();
const CACRoot *LiveStats_GetCACRoot(;
const CACRoot *LiveStats_GetCACRoot(const CACRoot *result, unsigned __int8 *buffer);
const CACRoot *LiveStats_GetCustomMatchCACRoot(const CACRoot *result, const ControllerIndex_t controllerIndex);
const CACRoot *LiveStats_GetLeagueCACRoot(const CACRoot *result, const ControllerIndex_t controllerIndex);
char LiveStats_WriteXUIDToStats(const ControllerIndex_t controllerIndex);
void LiveStats_ClearXUIDInStableStats(const ControllerIndex_t controllerIndex);
unsigned int LiveStats_ReadXUIDFromStatsBuffer(unsigned __int8 *buff);
void LiveStats_SetBufferInitialised(const ControllerIndex_t controllerIndex, bool isInitialised);
void LiveStats_SetOnlineRankedState(unsigned __int8 *buffer, bool value);
bool LiveStats_GetOnlineRankedState(unsigned __int8 *buffer);
void LiveStats_SetOnlineZombieState(unsigned __int8 *buffer, bool value);
bool LiveStats_GetOnlineZombieState(unsigned __int8 *buffer);
BOOL LiveStats_IsSettingOnlineStatsAllowed();
void LiveStats_GetNemesisXuid(const ControllerIndex_t controllerIndex, unsigned __int64 *nemesisXuid);
int LiveStats_MoveToDemonwareFlags(ddlState_t *searchState, demonwareFlags_e flags);
void LiveStats_SetDemonwareFlag(const ControllerIndex_t controllerIndex, demonwareFlags_e flags, int value);
void LiveStats_CheckPrestigeFiles(const ControllerIndex_t controllerIndex);
void LiveStats_BackupAllStats(unsigned __int8 *inBuffer, unsigned __int8 *outBuffer);
void LiveStats_PrestigeAddCACCmd();
bool LiveStats_ParsePathToDeltaState(const char *path, int currentDelta);
void LiveStats_BuildStatsDeltaTable();
char *LiveStats_GetGameTypeString();
int LiveStats_MoveToPlayerStatPath(ddlState_t *resultState, const char *statName, const char *statType);
int LiveStats_MoveToCurrentGameTypeStatPath(;
int LiveStats_MoveToWeaponStatPathZombie(;
int LiveStats_MoveToWeaponStatPath(;
int LiveStats_MoveToWeaponXPPath(ddlState_t *resultState, int weaponStatIndex);
int LiveStats_MoveToAttachmentStatPathZombie(;
int LiveStats_MoveToAttachmentStatPath(;
int LiveStats_MoveToGroupStatPathZombie(;
int LiveStats_MoveToGroupStatPath(;
int LiveStats_MoveToUnlockPath(ddlState_t *resultState, int tokenIndex);
void ddlTestFixedPoint_f();
void ddlTestFloat_f();
void ddlTestBool_f();
ddlState_t *LiveStats_GetRankXPState();
void LiveStats_SetMOTDViewed(const ControllerIndex_t controllerIndex, int viewTime, int viewVersion);
void LiveStats_SetMOTDViewedCmd();
void LiveStats_SetVotingDemonwareFlags(;
void LiveStats_IncrementVotingMenuViewedCount(const ControllerIndex_t controllerIndex);
void LiveStats_SetDemonwareFlagsWithUTCTime(;
void LiveStats_SetVotingMenuViewedCmd();
void LiveStats_SetVoteCmd();
void LiveStats_SetVoteOptOutCmd();
void LiveStats_SetDSPPromotionOptOutCmd();
void LiveStats_SetDSPPromotionViewedCmd();
void LiveStats_SetGhostUpsellOptOutCmd();
void LiveStats_SetGhostUpsellViewedCmd();
void LiveStats_SetSPReminderViewedCmd();
void LiveStats_SetupStates();
void LiveStats_InitGameTypes();
int LiveStats_GetGameTypeIndex(const char *gameTypeRef, bool isHardcore);
int LiveStats_GetGameTypeIndexFromRef(const char *gameTypeRef);
int LiveStats_GetGameTypeNameHash(int index);
char *LiveStats_GetGameTypeName(int index);
void LiveStats_UpdateContentData(const ControllerIndex_t controllerIndex);
int LiveStats_GetStatsDDLSize();
char LiveStats_ShouldSetStats();
int LiveStats_GetIntPlayerStatInternal(int pathDepth, const char **statPath, unsigned __int8 *buffer);
int LiveStats_GetIntStatFromPath(const char *statPath, unsigned __int8 *buffer);
int LiveStats_GetIntPlayerStatFromBuffer(const char *statName, unsigned __int8 *buffer);
int LiveStats_GetIntPlayerStatFromPath(const ControllerIndex_t controllerIndex, const char *statPath);
int LiveStats_GetIntPlayerStat(const ControllerIndex_t controllerIndex, const char *statName);
int LiveStats_GetIntPlayerStatByMap(;
int LiveStats_GetIntPlayerStatByKey(const ControllerIndex_t controllerIndex, playerStatsKeyIndex_t keyIndex);
bool LiveStats_SetIntPlayerStatInternal(;
int LiveStats_GetIntPlayerStatMatchDelta(const ControllerIndex_t controllerIndex, const char *statName);
int LiveStats_GetIntPlayerStatMatchDeltaFromPath(const ControllerIndex_t controllerIndex, const char *statPath);
bool LiveStats_SetIntPlayerStat(;
bool LiveStats_SetIntPlayerStatByMap(;
int LiveStats_GetPlayerStatByKeyFromBuffer(playerStatsKeyIndex_t key, unsigned __int8 *buffer);
int LiveStats_GetStatsVersion(const ControllerIndex_t localControllerIndex);
void LiveStats_RestoreStatsFromStable(;
void LiveStats_SecurityErrorDetected(const ControllerIndex_t controllerIndex);
void LiveStats_SetStatByKey(;
// void LiveStats_StatSetByNameCmd(unsigned int a1@<edi>);
void LiveStats_StatAddByNameCmd();
void LiveStats_StatGetByNameInDvarCmd();
char LiveStats_CheckXUIDAndReport(const ControllerIndex_t controllerIndex);
unsigned int LiveStats_GetPlayerStat(const char *statsList, const char *statName, unsigned __int8 *buffer);
int LiveStats_GetLastGameWeaponStat(;
void LiveStats_UpdateBestWeaponIndexAAR(unsigned __int8 *liveStatsBuffer, unsigned __int8 *oldStatsBuffer);
void LiveStats_SetPlayerStat(;
bool LiveStats_UpdatetBestMatchAccuracy(unsigned __int8 *liveStatsBuffer, unsigned __int8 *oldStatsBuffer);
bool LiveStats_UpdatetBestMatchKdRatio(unsigned __int8 *liveStatsBuffer, unsigned __int8 *oldStatsBuffer);
void LiveStats_GameHistory_GetCompletionInfo(;
bool LiveStats_GameHistory_IncCompletionStat(;
void LiveStats_GameHistory_AddMatchHistory(;
void LiveStats_GameHistory_AddMatchCompleted(const ControllerIndex_t localControllerIndex, bool hosted);
void LiveStats_GameHistory_AddMatchTimeout(const ControllerIndex_t localControllerIndex, bool hosted);
void LiveStats_GameHistory_InitializeMatchHistory(ClientNum_t clientNum, unsigned int gameTypeIndex);
void LiveStats_GameHistory_InitializeHitLocations(ClientNum_t clientNum);
void LiveStats_GameHistory_StartMatch(ClientNum_t clientNum, unsigned int gameTypeIndex);
bool LiveStats_GameHistory_MoveToCurrentHistory(;
bool LiveStats_GameHistory_MoveToHistory(;
void LiveStats_GameHistory_FinishMatch(;
void LiveStats_GameHistory_FinishMatch(;
char LiveStats_Probation_GiveProbation(;
bool LiveStats_Probation_MoveToMatchHistory(;
void LiveStats_GameHistory_ClearMatchStats(const ControllerIndex_t controllerIndex, const char *gamemode);
void LiveStats_Probation_ValidateProbationVersion(const ControllerIndex_t controllerIndex, eGameModes gamemode);
bool LiveStats_Probation_CheckInProbation(;
bool LiveStats_Probation_ShouldCheckProbation(const ControllerIndex_t controllerIndex, eGameModes gamemode);
float LiveStats_Probation_GetProbationPoints(;
;
void LiveStats_Probation_ForgiveProbation(;
void LiveStats_Probation_ReportProbationStats(const ControllerIndex_t controllerIndex, eGameModes gamemode);
;
void LiveStats_Theater_IncrementStat(;
void LiveStats_GameHistory_DumpMatchStats(const ControllerIndex_t controllerIndex, const char *gamemode);
void LiveStats_GameHistory_ClearProbation(const ControllerIndex_t controllerIndex, const char *gamemode);
void LiveStats_GameHistory_GiveProbation(const ControllerIndex_t controllerIndex, const char *gamemode);
// void LiveStats_GameHistory_FinishMatch(ddlState_t *a1@<edi>, const ControllerIndex_t controllerIndex);
// void LiveStats_GameHistory_TimeoutMatch(ddlState_t *a1@<edi>, const ControllerIndex_t controllerIndex);
int LiveStats_GetTotalMatchesPlayed(const ControllerIndex_t controllerIndex);
void LiveStats_DumpMatchStatsCmd();
void LiveStats_ClearMatchStatsCmd();
void LiveStats_ClearProbationCmd();
void LiveStats_GiveProbationCmd();
void LiveStats_SetLobbyPopup(const ControllerIndex_t controllerIndex, const char *menuName);
char LiveStats_ValidateStatsBackup(const ControllerIndex_t controllerIndex);
bool LiveStats_MoveToSkillAndVariance(ddlState_t *skillState, ddlState_t *varianceState);
bool LiveStats_GetSkillAndVariance(const ControllerIndex_t controllerIndex, float *skill, float *variance);
void LiveStats_StoreOriginalValues(const ControllerIndex_t controllerIndex, unsigned __int8 *statsBuffer);
void LiveStats_CheckVsOriginalValues(const ControllerIndex_t controllerIndex);
statsValidation_t LiveStats_AreStatsDeltasValid(;
void LiveStats_CheckScoreInfoTable();
void LiveStats_ResetAttachmentChallenges(;
void LiveStats_ResetGroupChallenges(;
void LiveStats_ResetGlobalChallenges(;
void LiveStats_ResetWeaponChallenges(;
void LiveStats_PushMatchesPlayedMilestonesToElite(const ControllerIndex_t controllerIndex);
void LiveStats_IncrementPlayerLeanMatchesCount(const ControllerIndex_t controllerIndex);
unsigned int LiveStats_GetClanTagFeature(const ControllerIndex_t controllerIndex);
char LiveStats_SetClanTagText(const ControllerIndex_t controllerIndex, const char *clanName);
int LiveStats_GetPrestige(const ControllerIndex_t controllerIndex);
BOOL LiveStats_GetGametypeBan(const ControllerIndex_t controllerIndex);
int LiveStats_GetCurrency(const ControllerIndex_t controllerIndex);
int LiveStats_GetIntZombieStatByKey(const ControllerIndex_t controllerIndex, zombieStatsKeyIndex_t keyIndex);
int LiveStats_GetZombieWeightedRoundsPlayed(const ControllerIndex_t controllerIndex);
int LiveStats_GetZombieWeightedDowns(const ControllerIndex_t controllerIndex);
int LiveStats_GetZombieTimePlayedTotal(const ControllerIndex_t controllerIndex);
int LiveStats_GetIntPlayerStatByLocationGameType(;
void LiveStats_TrackSpending(const ControllerIndex_t controllerIndex, int currencyAmount);
// char LiveStats_SpendCurrency@<al>(;
bool LiveStats_DoXUIDsMatch(const ControllerIndex_t controllerIndex);
void LiveStats_InitStatsBuffer(;
void LiveStats_ResetStats(;
char LiveStats_GetConsoleDetails(unsigned __int8 *consoleLocalIP, unsigned __int8 *consoleExternalIP);
void LiveStats_CheckUnlockTokens(const ControllerIndex_t controllerIndex);
void LiveStats_DoSecurityChecks(const ControllerIndex_t controllerIndex);
void LiveStats_DoSecurityChecksCmd();
void LiveStats_PrestigeStatsResetAllCmd();
void LiveStats_PrestigeRespecCmd();
char *LiveStats_MoveToGameTypeStatPath(;
// void LiveStats_SetRankXP(unsigned int a1@<esi>, ControllerIndex_t controllerIndex, unsigned int rankXP);
// void LiveStats_SetRankXPCmd(unsigned int a1@<esi>);
void LiveStats_SetZombieRank(ControllerIndex_t controllerIndex, unsigned int rank, unsigned int daysPlayed);
void LiveStats_SetZombieRankCmd();
void LiveStats_SetStatChangedInternal(;
void LiveStats_SetStatChanged(const ControllerIndex_t controllerIndex, const char *hexMsg, int isMoreComing);
void LiveStats_SetStatChangedNoCache(;
// void LiveStats_PreGame(unsigned int a1@<edi>, const ControllerIndex_t controllerIndex);
void LiveStats_MakeStableStatsBuffer(const ControllerIndex_t controllerIndex);
void LiveStats_CopyFromSponsor(const ControllerIndex_t controllerIndex);
void LiveStats_ResetGametypeChallenges(;
int LiveStats_GetRank(const ControllerIndex_t controllerIndex);
int LiveStats_GetZombieLastDaysPlayed(const ControllerIndex_t controllerIndex);
bool LiveStats_SetLeaderboardCombinedRankZombie(const ControllerIndex_t controllerIndex);
void LiveStats_SetCheckSumFromServer(const char *checkSumMsg);
void LiveStats_PublishNews(const ControllerIndex_t controllerIndex);
void LiveStats_ShowStatsError(const ControllerIndex_t localControllerIndex);
void LiveStats_ValidateStats(const ControllerIndex_t controllerIndex);
void LiveStats_PrestigeResetChallenges(const ControllerIndex_t controllerIndex);
int LiveStats_GetCurrentChallengeIndex(;
void LiveStats_GetCurrentchallengeRowCmd();
void LiveStats_CheckAchievements(const ControllerIndex_t controllerIndex);
char LiveStats_CompareStatsVsStableBuffer(const ControllerIndex_t controllerIndex, bool onlyCheckValidStats);
// void LiveStats_PrestigeStatsResetCmd(unsigned int a1@<edi>);
void LiveStats_CompareStatsVsStableBufferCmd();
void LiveStats_Init();

//t6/code/src_noserver/live/live_steam.cpp
bool LiveSteam_isVacAuthorized();
bool LiveSteam_IsInitialized();
unsigned __int64 LiveSteam_GetUserSteamIDAsXUID();
void LiveSteam_ShowStore(unsigned int appID);
void __thiscall LiveSteam_ShowFriendsList(void *this);
int LiveSteam_GetAppID();
void LiveSteam_Shutdown();
void LiveSteam_Frame();
int Utf8SymbolSize(char utf8Byte1);
int LiveSteam_FilterPersonaName(char *utf8Name, bool asciionly);
void Utf8safe_strncpyz(char *dest, const char *src, int destsize);
BOOL LiveSteam_isValidAppId(unsigned int appId);
int LiveSteam_GetAppIdForContentPack(const int contentPack);
int LiveSteam_GetContentPackForSteamAppID(unsigned int steamAppID);
int LiveSteam_SetContentPack(const int contentPack);
void LiveSteam_Client_SteamDisconnect();
;
void LiveSteam_Init();
char *LiveSteam_FriendPersonaNameFromXuid(unsigned __int64 xuid, char *buff, int size, bool asciionly);
unsigned int LiveSteam_Client_ConnectToSteamServer(;

//t6/code/src_noserver/live/live_steam_achievements.cpp
void LiveSteam_Achievements_Frame();
void LiveSteam_GiveAchievement(const char *achievementName);
void LiveSteam_Achievements_Shutdown();

//t6/code/src_noserver/live/live_steam_server.cpp
void SV_SteamAuthClientRequest(netadr_t to, unsigned __int64 serverSteamID);
int FindClient(unsigned __int64 liveUserID);
void RunClientChecks(const int clientNum);
// void __thiscall LiveSteamServer::OnSteamServersConnected(LiveSteamServer *this, SteamServersConnected_t *pLogonSuccess);
// void __thiscall LiveSteamServer::OnSteamServerConnectFailure(;
// void __thiscall LiveSteamServer::OnSteamServersDisconnected(;
// void __thiscall LiveSteamServer::OnPolicyResponse(LiveSteamServer *this, GSPolicyResponse_t *pPolicyResponse);
// void __thiscall LiveSteamServer::KickClientFromSteamGameServer(;
// void __thiscall LiveSteamServer::OnGSClientApprove(LiveSteamServer *this, GSClientApprove_t *pGSClientApprove);
// void __thiscall LiveSteamServer::OnGSClientDeny(LiveSteamServer *this, GSClientDeny_t *pGSClientDeny);
// void __thiscall LiveSteamServer::OnGSClientKick(LiveSteamServer *this, GSClientKick_t *pGSClientKick);
unsigned int LiveSteam_Server_InitErroExceptionFilter(unsigned int code, _EXCEPTION_POINTERS *info);
void LiveSteam_Server_HandleInitError(const char *error);
void LiveSteam_Server_ClientSteamAuthentication(;
unsigned int LiveSteam_Server_SetCurrentDlcAppID(unsigned int steamAppID);
void LiveSteam_Server_ClientSteamDisconnect(unsigned __int64 clientSteamID);
// void __thiscall LiveSteamServer::~LiveSteamServer(LiveSteamServer *this);
// void __thiscall LiveSteamServer::LiveSteamServer(LiveSteamServer *this, unsigned int ip);
void LiveSteam_Server_Shutdown();
void LiveSteam_Server_Init(const char *mapname);
// void __thiscall LiveSteamServer::RunFrame(LiveSteamServer *this);
void LiveSteam_Server_Frame();

//t6/code/src_noserver/live/live_storage.cpp
void LiveStorage_CorrectStatsError(const char *msg);
void LiveStorage_VerifyCorrectStats(persistentStats *stats, statsLocation location);
persistentStats *LiveStorage_GetPersStatsBuffer(;
// persistentStats *LiveStorage_GetStatsBufferForDownload@<eax>(;
int LiveStorage_GetStatsBufferSize();
classSets_t *LiveStorage_GetClassSetsBuffer(const ControllerIndex_t controllerIndex);
// bool LiveStorage_GetStatsChecksumValid@<al>(statsLocation a1@<edx>, const ControllerIndex_t controllerIndex);
void LiveStorage_SetStatsChecksumValid(;
// bool LiveStorage_AreStatsDDLValidated@<al>(statsLocation a1@<edx>, const ControllerIndex_t controllerIndex);
void LiveStorage_SetStatsDDLValidated(;
void LiveStorage_StatsBackupFetchCompleted(const ControllerIndex_t controllerIndex);
// bool LiveStorage_DoWeHaveStats@<al>(statsLocation a1@<edx>, const ControllerIndex_t controllerIndex);
bool LiveStorage_DoWeHaveCurrentStats(const ControllerIndex_t controllerIndex);
bool LiveStorage_DoWeHaveAllStats(const ControllerIndex_t controllerIndex);
void LiveStorage_SetStatsFetched(;
void LiveStorage_DisableStatsUpload(const ControllerIndex_t localControllerIndex);
bool LiveStorage_IsStatsUploadDisabled(const ControllerIndex_t localControllerIndex);
EUserTier getTierForGamertag(const char *gamertag, unsigned __int64 xuid);
void LiveStorage_ParseUserTiers();
bool Live_CanGamertagUseRestrictedClanTag(const char *gamertag, unsigned __int64 xuid);
TaskRecord *LiveStorage_SetupNestedTask(;
void LiveStorage_ResetFileInfo(dwFileOperationInfo *fileInfo);
void LiveStorage_UpdateFileTryData(fileRetryInfo *retryInfo);
char LiveStorage_TryFile(fileRetryInfo *retryInfo);
char LiveStorage_DeleteUserFileFailure(TaskRecord *task);
char LiveStorage_DeleteUserFileSuccess(TaskRecord *task);
char LiveStorage_WriteUserFileFailure(TaskRecord *task);
char LiveStorage_WriteUserFileSuccess(TaskRecord *task);
TaskRecord *LiveStorage_WriteDWUserFile(;
char LiveStorage_GetUserFileFailure(TaskRecord *task);
TaskRecord *LiveStorage_ReadDWFile(const ControllerIndex_t controllerIndex, dwFileOperationInfo *fileInfo);
TaskRecord *LiveStorage_ReadDWFileByUserID(;
void LiveStorage_CopyClassSetsFromSponsor(;
void LiveStorage_SetClassSetsWriteNeeded(const ControllerIndex_t controllerIndex, bool writeNeeded);
bool LiveStorage_WriteClassSetsFailure(TaskRecord *task);
void LiveStorage_TrackUsedClassSets(const ControllerIndex_t controllerIndex);
TaskRecord *LiveStorage_WriteClassSets(const ControllerIndex_t controllerIndex, char *customFileName);
int LiveStorage_PlayerStatsFileNotFound(const ControllerIndex_t controllerIndex, void *data);
char LiveStorage_KeyArchiveWriteComplete(TaskRecord *task);
char LiveStorage_KeyArchiveWriteFailed(TaskRecord *task);
char LiveStorage_KeyArchiveReadComplete(TaskRecord *task);
char LiveStorage_KeyArchiveReadFailed(TaskRecord *task);
TaskRecord *LiveStorage_GetXPGroupsKeyArchive(;
bool LiveStorage_GetServerTimeComplete();
char LiveStorage_GetServerTimeFailed();
int LiveStorage_GetUTC();
int LiveStorage_GetUTCOffset();
bool LiveStorage_IsTimeSynced();
void LiveStorage_WriteMetPlayerListSuccessful(const ControllerIndex_t controllerIndex);
TaskRecord *LiveStorage_WriteMetPlayerList(;
int LiveStorage_OtherPlayerStatsFileNotFound(const ControllerIndex_t controllerIndex, void *data);
TaskRecord *LiveStorage_ReadCommonStats(;
int LiveStorage_CalculateParity(;
void LiveStorage_CheckParityBits(;
void LiveStorage_AppendParityToStats(;
TaskRecord *LiveStorage_WriteBackupStatsInternal(;
void LiveStorage_BackupCorruptedStatsDecompressError(;
void LiveStorage_SetAllStatsNotFetched(const ControllerIndex_t controllerIndex);
fileShareLocation LiveStorage_FileShare_GetCurrentHTTPLocation(ControllerIndex_t controllerIndex);
void LiveStorage_FileShare_GetDownloadProgress(;
void LiveStorage_FileShare_GetUploadProgress(;
BOOL LiveStorage_FileShare_IsReady(const ControllerIndex_t controllerIndex, bool allowRead);
void LiveStorage_FileShare_AbortOperation(const ControllerIndex_t controllerIndex, fileShareLocation location);
TaskRecord *LiveStorage_FileShare_ReadListing(;
char LiveStorage_FileShare_ReadListingFailure(TaskRecord *task);
int LiveStorage_FileShareSortComparator_MostRecent(const void *arg0, const void *arg1);
void LiveStorage_FileShare_LoadBlockSuccessAction(;
void LiveStorage_FileShare_DownloadFile_f();
char LiveStorage_FileShare_SearchFailure(TaskRecord *task);
unsigned int LiveStorage_FileShare_ReadFileData(;
unsigned int LiveStorage_FileShare_GetDownloadingFileTotalSize(const ControllerIndex_t controllerIndex);
ControllerIndex_t LiveStorage_FileShare_GetUploadingFileTotalSize(const ControllerIndex_t controllerIndex);
// unsigned int __thiscall fileShareDownloadInterceptor::handleDownload(;
char LiveStorage_FileShare_ReadFileFailure(TaskRecord *task);
char LiveStorage_FileShare_ReadFileSuccess(TaskRecord *task);
char *LiveStorage_GetDWDownloadBuffer();
int LiveStorage_GetDWDownloadBufferSize();
unsigned int LiveStorage_FileShare_WriteFileData(;
// unsigned int __thiscall fileShareUploadInterceptor::handleUpload(;
BOOL LiveStorage_FileShare_ReadFileIsInProgress(const ControllerIndex_t controllerIndex);
BOOL LiveStorage_FileShare_WriteFileIsInProgress(const ControllerIndex_t controllerIndex);
char LiveStorage_FileShare_WriteFileFailure(TaskRecord *task);
char LiveStorage_FileShare_WriteFileSuccess(TaskRecord *task);
BOOL LiveStorage_FileShare_ParseDownloadedMatchData(;
TaskRecord *LiveStorage_FileShare_WriteSummary(;
char LiveStorage_FileShare_WriteSummaryFailure(TaskRecord *task);
char LiveStorage_FileShare_WriteSummarySuccess(TaskRecord *task);
BOOL LiveStorage_FileShare_ReadSummaryInProgress();
TaskRecord *LiveStorage_FileShare_ReadSummary(;
char LiveStorage_FileShare_ReadSummaryFailure(TaskRecord *task);
char LiveStorage_FileShare_ReadSummarySuccess(TaskRecord *task);
TaskRecord *LiveStorage_FileShare_ReadMetaDataByID(;
char LiveStorage_FileShare_ReadMetaDataByIDFailure(TaskRecord *task);
char LiveStorage_FileShare_ReadMetaDataByIDSuccess(TaskRecord *task);
TaskRecord *LiveStorage_FileShare_RemoveFile(;
char LiveStorage_FileShare_RemoveFileFailure(TaskRecord *task);
char LiveStorage_FileShare_RemoveFileSuccess(TaskRecord *task);
TaskRecord *LiveStorage_FileShare_TransferFile(;
char LiveStorage_FileShare_TransferFileFailure(TaskRecord *task);
char LiveStorage_FileShare_TransferFileSuccess(TaskRecord *task);
char LiveStorage_FileShare_ReadTopRatedFailure(TaskRecord *task);
bool LiveStorage_UserFileListAvailable(const ControllerIndex_t controllerIndex);
void LiveStorage_AssertDWConnectionCmd();
;
void LiveStorage_FakeComErrorCmd();
void LiveStorage_CopyStatsBuffer(;
// char LiveStorage_VerifyStatsPresent@<al>(;
persistentStats *LiveStorage_GetStatsBufferWithCaller(;
// bool LiveStorage_GetStatsWriteNeeded@<al>(;
void LiveStorage_SetStatsWriteNeeded(;
int LiveStorage_ValidateWithDDL(ControllerIndex_t controllerIndex, statsLocation location);
void LiveStorage_FetchRequiredFiles(const ControllerIndex_t controllerIndex);
void LiveStorage_GetUserFileDecompressError(TaskRecord *task);
char LiveStorage_GetUserFileSuccess(TaskRecord *task);
char LiveStorage_IsPublicStatsCorrectState(const ControllerIndex_t controllerIndex, statsLocation location);
void LiveStorage_ResetClassSets(const ControllerIndex_t controllerIndex);
int __thiscall LiveStorage_ClassSetsFileNotFound(void *this);
void LiveStorage_ReadClassSetsSuccessful(const ControllerIndex_t controllerIndex, void *data);
TaskRecord *LiveStorage_ReadClassSets(const ControllerIndex_t controllerIndex);
void LiveStorage_ReadOtherPlayerStatsSuccessful(;
void LiveStorage_CheckEmptyStats(const ControllerIndex_t controllerIndex, int decompressedSize);
TaskRecord *LiveStorage_SyncTime(ControllerIndex_t controllerIndex);
TaskRecord *LiveStorage_ReadOtherPlayerStats(;
TaskRecord *LiveStorage_WriteStats(;
bool LiveStorage_WritePlayerStatsFailure(TaskRecord *task);
TaskRecord *LiveStorage_WritePlayerStats(const ControllerIndex_t controllerIndex);
void LiveStorage_WriteBackupStats(const ControllerIndex_t controllerIndex);
void LiveStorage_BackupStatsToFile(;
char LiveStorage_FileShare_ReadListingSuccess(TaskRecord *task);
char LiveStorage_FileShare_LoadBlockFailure(TaskRecord *task);
char LiveStorage_FileShare_LoadBlockSuccess(TaskRecord *task);
char LiveStorage_FileShare_SearchSuccess(TaskRecord *task);
char LiveStorage_FileShare_ReadTopRatedSuccess(TaskRecord *task);
void LiveStorage_UploadStatsForController(const ControllerIndex_t controllerIndex);
void LiveStorage_UploadStats();
void LiveStorage_WriteBackupStatsCmd();
void LiveStorage_GetFriendStatsCmd();
char LiveStorage_GetUserFileListSuccess(TaskRecord *task);
char LiveStorage_GetUserFileListFailure(TaskRecord *task);
bdFileInfo *LiveStorage_UserFileListGetFileDetails(;
void LiveStorage_RestoreStatsFromBackup(const ControllerIndex_t localControllerIndex);
void LiveStorage_RestoreCorrectPublicStatsState(;
void LiveStorage_StatsBackupReadSuccessful(const ControllerIndex_t controllerIndex, void *data);
int LiveStorage_StatsBackupFileNotFound(const ControllerIndex_t controllerIndex, void *data);
void LiveStorage_ReadPlayerStatsSuccessful(const ControllerIndex_t controllerIndex, void *data);
TaskRecord *LiveStorage_ReadStatsBackup(const ControllerIndex_t controllerIndex);
// TaskRecord *LiveStorage_ReadPlayerStats@<eax>(;
void LiveStorage_ReadStats(const ControllerIndex_t controllerIndex, bool validate);
TaskRecord *LiveStorage_FileShare_LoadPage(;
TaskRecord *LiveStorage_FileShare_ReadFile(;
TaskRecord *LiveStorage_FileShare_WriteFile(;
void LiveStorage_ReadStatsBackupCmd();
void LiveStorage_RestoreStatsFromBackupCmd();
char LiveStorage_Init();
char LiveStorage_WaitOnStats(ControllerIndex_t controllerIndex);

//t6/code/src_noserver/live/live_storage_pub.cpp
bool LiveStorage_DoWeHavePlaylists();
bool LiveStorage_DoWeHaveContracts();
int LiveStorage_GetFFOTDVersion();
bool LiveStorage_DoWeHaveLeagues();
const char *LiveStorage_GetOnlineWADFilename();
TaskRecord *LiveStorage_GetFFOTDTimeStamp(ControllerIndex_t controllerIndex);
TaskRecord *LiveStorage_GetOnlineWADTimestamp(ControllerIndex_t controllerIndex);
void LiveStorage_CheckWADTimestampRequired(ControllerIndex_t controllerIndex);
BOOL LiveStorage_DecompressBuffer(;
void LiveStorage_ParseOnlineData();
char LiveStorage_WaitForContentMounting();
char LiveStorage_WaitForGhostLBFetching();
void LiveStorage_FetchOnlineWADSuccessful(const ControllerIndex_t controllerIndex);
int LiveStorage_PublisherStorageFetchOnlineWADNotFound();
TaskRecord *LiveStorage_FetchOnlineWAD(const ControllerIndex_t controllerIndex);
bool LiveStorage_DoWeHaveOnlineWAD();
void LiveStorage_RefetchOnlineWAD();
bool LiveStorage_CompletedPlaylistPopulation();
unsigned __int8 *LiveStorage_GetPlaylistPopulationBuffer();
int LiveStorage_PublisherStorageFetchFFOTDNotFound(const ControllerIndex_t controllerIndex);
void LiveStorage_FetchFFOTDChunkSuccessful(const ControllerIndex_t controllerIndex);
TaskRecord *LiveStorage_FetchFFOTDChunk(ControllerIndex_t controllerIndex, int part);
TaskRecord *LiveStorage_FetchFFOTD(const ControllerIndex_t controllerIndex);
bool LiveStorage_DoWeHaveFFOTD();
unsigned __int8 *LiveStorage_GetFFOTDBuffer();
unsigned int LiveStorage_GetFFOTDSize();
bool LiveStorage_ValidateFFOTD();
void LiveStorage_ExecFFOTDSettings();
void LiveStorage_HandleFFOTDTasks();
void LiveStorage_SetFFOTDVersion_f();
ecc_key *LiveStats_GetPublicKey();
ecc_key *LiveStats_GetPrivateKey();
BOOL LiveStorage_SignedStats_InitPublicKey(const void *buffer, int size);
BOOL LiveStorage_SignedStats_InitPrivateKey(const void *buffer, int size);
int LiveStorage_SignedStatsKeyFileNotFound(const ControllerIndex_t controllerIndex, void *data);
void LiveStorage_SignedStatsKeyFetchSuccessful(const ControllerIndex_t controllerIndex, void *data);
void LiveStorage_FetchSignedStatsKeys(const ControllerIndex_t controllerIndex);
char LiveStorage_DoWeHaveSignedStatsKeys();
char LiveStorage_GetOnlineWADTimestampSuccess(TaskRecord *task);
char LiveStorage_GetOnlineWADTimestampFailure(TaskRecord *task);
char LiveStorage_GetFFOTDTimeStampSuccess(TaskRecord *task);
char Live_StorageGetFFOTDTimeStampFailure(TaskRecord *task);
void LiveStorage_ProcessOnlineWAD();
void LiveStorage_HandlePublisherStorageTasks();

//t6/code/src_noserver/live/live_storage_streambuff.cpp
bool LiveStorage_StreamBuff_Init(;
int LiveStorage_StreamBuff_Write(streamBuffer_t *streamBuff, unsigned __int8 *data, int dataSize);

//t6/code/src_noserver/live/live_storage_win.cpp
dwFileOperationInfo *SV_GetFreeFileOp();
void SV_DumpFileOps();
void SV_UseFileOp();
void SV_FreeFileOp();
void CL_GetXP_f();
void LiveStorage_Init_Platform();

//t6/code/src_noserver/live/live_tracker.cpp
unsigned int LiveTracker_GetColType(trackerColumn_e col);
int LiveTracker_SetItem(int queuePos, trackerColumn_e col, unsigned __int64 ent, int val);
int LiveTracker_GetColumnByName(const char *name);
int LiveTracker_WriteByID(trackerColumn_e col, unsigned __int64 ent, int val);
const StringTable *LiveTracker_WriteByName(const char *colName, unsigned __int64 ent, int val);
BOOL LiveTracker_WriteForAllLocalUsers(trackerColumn_e col, int val);
BOOL LiveTracker_WriteForUserAndHost(;
void LiveTracker_UpdateCmd();
void LiveTracker_ReportUser();
void LiveTracker_StressTestCmd();
void LiveTracker_Init();

//t6/code/src_noserver/live/live_twitch.cpp
char LiveTwitch_IsRegisteredSuccess(TaskRecord *task);
char LiveTwitch_IsRegisteredFailure(TaskRecord *task);
char LiveTwitch_GetAccountSuccess(TaskRecord *task);
char LiveTwitch_GetAccountFailure(TaskRecord *task);
void LiveTwitch_ClearAccount(const ControllerIndex_t localControllerIndex);
TaskRecord *LiveTwitch_RegisterAccount(;
char LiveTwitch_RegisterAccountSuccess(TaskRecord *task);
void LiveTwitch_PrintError(;
char LiveTwitch_UnregisterAccountSuccess(TaskRecord *task);
char LiveTwitch_UnregisterAccountFailure(TaskRecord *task);
void LiveTwitch_Register_f();
void LiveTwitch_UnRegister_f();
// char LiveTwitch_RegisterAccountFailure@<al>(bdLobbyErrorCode a1@<edi>, TaskRecord *task);
void LiveTwitch_Init();

//t6/code/src_noserver/live/live_twitter.cpp
char LiveTwitter_GetAccountSuccess(TaskRecord *task);
char LiveTwitter_GetAccountFailure(TaskRecord *task);
void LiveTwitter_ClearAccount(const ControllerIndex_t localControllerIndex);
char LiveTwitter_RegisterAccountSuccess(TaskRecord *task);
void LiveTwitter_PrintError(;
char LiveTwitter_UnregisterAccountSuccess(TaskRecord *task);
char LiveTwitter_UnregisterAccountFailure(TaskRecord *task);
char LiveTwitter_PostSuccess(TaskRecord *task);
char LiveTwitter_GetInfoSuccess(TaskRecord *task);
char LiveTwitter_GetInfoFailure(TaskRecord *task);
char LiveTwitter_SearchFailure(TaskRecord *task);
// char LiveTwitter_RegisterAccountFailure@<al>(bdLobbyErrorCode a1@<edi>, TaskRecord *task);
// char LiveTwitter_PostFailure@<al>(bdLobbyErrorCode a1@<edi>, TaskRecord *task);
char LiveTwitter_SearchSuccess(TaskRecord *task);

//t6/code/src_noserver/live/live_voice.cpp
int Voice_FindUser(const SessionData *session, const unsigned __int64 xuid);
char Voice_UnregisterRemotePlayer(SessionData *session, const ClientNum_t slot);
int Live_GetConnectedPlayerList(const SessionData *session, unsigned __int64 *playerList);
int Voice_IncomingVoiceData(SessionData *session, ClientNum_t clientNum, unsigned __int8 *data, int size);
int Voice_IsMemberMuted(ControllerIndex_t localControllerIndex, const unsigned __int64 playerXuid);
void Voice_MuteMemberByXuid(const unsigned __int64 playerXuid);
void Voice_UnmuteMemberByXuid(const unsigned __int64 playerXuid);
int Voice_GetTalkingCount(SessionData *session, const ControllerIndex_t localControllerIndex);
void Voice_ClearRemoteTalkers(SessionData *session);
void Voice_EnableMicIfAllowed(SessionData *session);
char Voice_RegisterRemotePlayer(;

//t6/code/src_noserver/live/live_vote.cpp
dwVoteCategory_e LiveVote_History_FileshareToVoteCategory(int fileshareCategory);
int LiveVote_History_GetEntryLinear(int startIndex, unsigned __int64 entityID, dwVoteCategory_e category);
int LiveVote_History_GetEntry(;
int LiveVote_History_SortComparator(const void *a, const void *b);
void LiveVote_History_Sort();
void LiveVote_History_RecordVote(;
// int LiveVote_History_GetVoteForEntity@<eax>(;
void LiveVote_RecentlyLiked_Build(const ControllerIndex_t localControllerIndex);
void LiveVote_RecentlyLiked_Remove(;
void LiveVote_RecentlyLiked_Add(;
char LiveVote_Task_SubmitVoteSuccess(TaskRecord *task);
char LiveVote_Task_SubmitVoteFailure(TaskRecord *task);
TaskRecord *LiveVote_Task_SubmitVote(;
char LiveVote_Task_DownloadHistoryFailure(TaskRecord *task);
void LiveVote_SubmitCmd(dwVote_e vote);
void LiveVote_SubmitLikeCmd();
void LiveVote_SubmitDislikeCmd();
void LiveVote_GetHistoryCmd();
void LiveVote_GetVoteCmd();
void LiveVote_FillVoteHistoryCmd();
void LiveVote_Init();
char LiveVote_Task_DownloadHistorySuccess(TaskRecord *task);

//t6/code/src_noserver/live/live_win.cpp
char IsServerRunning();
SessionData *Live_GetCurrentSession();
char *Live_ControllerIndex_GetClientName(const ControllerIndex_t controllerIndex);
char *Live_ControllerIndex_GetXuidString(const ControllerIndex_t controllerIndex);
int CL_ControllerIndex_GetSignInState(ControllerIndex_t controllerIndex);
int CL_GetFirstActiveSignedInControllerIndex();
void Live_FakeDWDisconnect_f();
void Live_TestNotification_f();
void Live_UpdateInfoForInGameList_f();
void Live_InitPlatform();
char Live_XUIDIsLocalPlayer(const unsigned __int64 player);
ControllerIndex_t Live_GetControllerFromXUID(const unsigned __int64 player);
void Live_GiveAchievement(ControllerIndex_t localControllerIndex, const char *achievementName);
bool Live_AreWeAcceptingInvite();
void Live_AcceptInvite(ControllerIndex_t controllerIndex, InviteMessage *message, unsigned __int64 fromXuid);
char Live_UserGetName(ControllerIndex_t controllerIndex, char *buf, const int bufsize);
bool Live_UserSignedInToLive(const ControllerIndex_t controllerIndex);
EUserTier Live_GetTier(ControllerIndex_t controllerIndex);
void Live_SetTier(ControllerIndex_t controllerIndex, EUserTier tier);
bool Live_IsSystemUiActive();
bool __thiscall Live_ShowFriendsList(void *this);
int Live_GetUploadSpeed();
char Live_BandwidthTestSuccess(TaskRecord *task);
char Live_BandwidthTestFailure(TaskRecord *task);
int Live_RunBandwidthTest(TaskRecord *task);
bool Live_QoSProbeEarlyComplete(dwQoSMultiProbeListener *listener);
void Live_EstimateQoSPercentage(dwQoSMultiProbeListener *listener);
char Live_QoSProbeSuccess(TaskRecord *task);
char Live_QoSProbeFailure(TaskRecord *task);
void Live_CleanUpQoSProbes();
BOOL Live_QoSInProgress();
void Live_InitSigninState();
char *JoinMessageReplyCriteriaError(JoinSessionMessage *message);
char Live_AreWeJoinable(bool fromInvite, e_JoinRejectionReason *reason);
char Live_ShowPlayerProfile(ControllerIndex_t localControllerIndex, unsigned __int64 xuid);
char Live_IsUserBlocked(ControllerIndex_t controllerIndex, unsigned __int64 xuid);
bdNATType Live_GetLocalNatType();
LocalTaskState Live_RunQoSProbe(TaskRecord *task);
void Live_StartQoSProbe(ControllerIndex_t localControllerIndex, int numXenons, XSESSION_INFO *xenonsInfo);
void Live_SendJoinInfo(;
void Live_JoinMessageAction(;
char Live_ProcessFriendInstantMessage(unsigned __int64 senderID, const ControllerIndex_t destIndex, msg_t *msg);

//t6/code/src_noserver/live/live_youtube.cpp
void LiveYouTube_ClearAccount(const ControllerIndex_t localControllerIndex);
char LiveYouTube_GetAccountSuccess(TaskRecord *task);
char LiveYouTube_GetAccountFailure(TaskRecord *task);
char LiveYouTube_GetUserTokenSuccess(TaskRecord *task);
char LiveYouTube_GetUserTokenFailure(TaskRecord *task);
TaskRecord *LiveYouTube_RegisterAccount(const ControllerIndex_t localControllerIndex);
char LiveYouTube_RegisterAccountSuccess(TaskRecord *task);
char LiveYouTube_RegisterAccountFailure(TaskRecord *task);
char LiveYouTube_UnregisterAccountSuccess(TaskRecord *task);
char LiveYouTube_UnregisterAccountFailure(TaskRecord *task);
TaskRecord *LiveYouTube_UploadVideo(const ControllerIndex_t localControllerIndex, unsigned __int64 fileID);
char LiveYouTube_UploadSuccess(TaskRecord *task);
char LiveYouTube_UploadFailure(TaskRecord *task);
void LiveYouTube_PrintError(ControllerIndex_t controllerIndex, bdLobbyErrorCode error);
void LiveYouTube_AuthReceived(const ControllerIndex_t localControllerIndex, bdLobbyErrorCode result);
bool LiveYouTube_IsAccountRegistered(const ControllerIndex_t localControllerIndex);
BOOL LiveYouTube_SetStat(const ControllerIndex_t controllerIndex, const char *statName, const char *statValue);
void LiveYouTube_SetViewerHighwater(const ControllerIndex_t controllerIndex, int numViewers);
void LiveYouTube_ParseDWKeys(unsigned __int8 *buffer);
void LiveYouTube_GetAccountCmd();
void LiveYouTube_TestSetStatCmd();
void LiveYouTube_TestGetStatCmd();
void LiveYouTube_TestSetViewerHighwaterCmd();
void LiveYouTube_RegisterAccountCmd();
void LiveYouTube_CancelCmd();
void LiveYouTube_UploadCmd();
TaskRecord *LiveYouTube_UnregisterAccount(const ControllerIndex_t localControllerIndex);
void LiveYouTube_UnregisterCmd();
void LiveYouTube_Init();

//t6/code/src_noserver/lui/lui_cod_fileio.cpp
unsigned int LUI_CoD_GetChecksum();

//t6/code/src_noserver/physics/destructible.cpp
void TRACK_destructible();
void Destructible_DumpEventInfo();
void EnableAllDestructiblePieces();
char IsDestructiblePieceDisabled(int label);
void CG_EnableAllDestructiblePieces();
int CG_GetDestructibleIndex(LocalClientNum_t localClientNum, const Destructible *destructible);
Destructible *Destructible_GetDestructibleByIndex(int index);
Destructible *Destructible_GetFreeDestructible();
void Destructible_FreeDestructible(Destructible *destructible);
Destructible *CG_GetFreeDestructible(LocalClientNum_t localClientNum, int entNum);
void CG_InitDestructibles(LocalClientNum_t localClientNum);
void G_InitDestructibles();
destructible_gamestate *Destructible_FindGameState(int entityNum, LocalClientNum_t localClientNum);
char Destructible_RemoveGameState(int entityNum, LocalClientNum_t localClientNum);
int Destructible_GetNumStagesForPiece(DestructibleDef *ddef, int pieceIndex);
int Destructible_GetDestructibleStage(const DestructibleDef *ddef, int pieceIndex, int health);
unsigned int Destructible_GetShowBoneNameForPiece(Destructible *destructible, int pieceIndex);
void Destructible_GetHideParts(Destructible *destructible, unsigned int *partBits);
char Destructible_GetPieceIndexFromBoneName(;
int GetHealthFromState(;
void DestructibleEventSetPieceState(Destructible *destructible, LerpEntityStateDestructibleHit *state);
void CG_DestructibleClientOnlyCreate(centity_t *ent, DestructibleDef *ddef);
int CG_SpawnPhysObjForBone(;
unsigned int CG_GetTagTransform(;
unsigned int G_GetTagTransform(gentity_t *ent, DestructibleDef *ddef, int pieceIndex, vec3_t *tagMat);
void CG_DestructibleSetBurn(;
double CG_DestructibleGetBurnFrac(Destructible *destructible);
BOOL CG_DestructibleIsClientOnly(Destructible *destructible);
void CG_DestructibleUpdateDObj(centity_t *self);
void CG_StoreDestructibleState(centity_t *cent, DestructibleState newState);
void CG_DestructibleRewindToTime(LocalClientNum_t localClientNum, Destructible *destructible, int time);
unsigned __int8 *CM_Hunk_AllocDestructible(int size);
DestructibleDef *DestructibleDefPrecache_LoadObj(const char *name);
DestructibleDef *DestructibleDefPrecache_FastFile(const char *name);
DestructibleDef *DestructibleDefPrecache();
int Destructible_GetPieceCount(Destructible *obj);
unsigned int Destructible_XDollActive(Destructible *obj);
int Destructible_GetXDollHandle(Destructible *obj, int piece_index);
;
void Destructible_LoadDestructibles(MemoryFile *memFile);
void Destructible_WriteGameState(msg_t *msg);
void Destructible_ReadGameState(msg_t *msg, LocalClientNum_t localClientNum);
void Demo_Destructible_WriteGameState(msg_t *msg, LocalClientNum_t localClientNum);
void Demo_Destructible_ReadGameState(msg_t *msg, LocalClientNum_t localClientNum);
DestructiblePose *CG_GetDestructiblePose(__int16 index);
void CG_DestructibleShake(;
void Destructible_SetDebugRender(Destructible *destructible);
void Destructible_DebugRender();
DestructibleDef *Destructible_GetDDef(const centity_t *cent);
void Scr_DestructibleCallback(gentity_t *self, unsigned __int16 event, int piece, float time, int damage);
void DisableDestructiblePiece(int label);
void CG_DisableDestructiblePiece(LocalClientNum_t localClientNum, int label);
unsigned __int16 DestructibleUpdate(gentity_t *ent, DObjModel_s *dobjModels, unsigned __int16 numModels);
void DestructibleExplosiveDamageEvent(gentity_t *self, const vec3_t *point, const float radius, const int mod);
void DestructibleBulletDamageEvent(gentity_t *self, const vec3_t *point, const vec3_t *dir, const int mod);
// char DamagePiece@<al>(;
double DestructibleRadiusDamage(;
int DestructibleDamage(;
unsigned int CG_DestructibleUpdate(;
;
void CG_DestructibleBreakPiece(;
void CG_RestartDestructibles(LocalClientNum_t localClientNum);
// bool CG_DestructibleDamage@<al>(;
void CG_FreeDestructiblePose(LocalClientNum_t localClientNum, unsigned __int8 destructiblePoseID);
void CG_FreeDestructible(LocalClientNum_t localClientNum, Destructible *destructible);
// char CG_DamagePiece@<al>(;
void CG_DestructibleRadiusDamage(;
void CG_DestructibleHitEvent(;
void CG_DestructibleDamage(;
void CG_ProcessDestructibleEvents();

//t6/code/src_noserver/physics/destructible.h
// void __thiscall Destructible_BonePose::Destructible_BonePose(Destructible_BonePose *this);

//t6/code/src_noserver/physics/destructibledef_load_db.h
void Mark_DestructibleStageArray(int count);
void Mark_DestructiblePieceArray(int count);
void Mark_DestructibleDef();
void Load_DestructibleStageArray(bool atStreamStart, int count);
void Load_DestructiblePieceArray(bool atStreamStart, int count);
void Load_DestructibleDef(bool atStreamStart);
void Load_DestructibleDefPtr(bool atStreamStart);

//t6/code/src_noserver/physics/destructibledef_load_obj.cpp
void DestructibleDef_Strcpy(unsigned __int8 *member, const char *keyValue);
int DestructiblePiece_ParseDefSpecificFieldType(;
DestructiblePiece *DestructiblePieceLoadFile(const char *name, DestructiblePiece *destructiblePiece);
int Destructible_ParseDefSpecificFieldType(unsigned __int8 *pStruct, const char *pValue, const int iFieldType);
DestructibleDef *DestructibleDefLoadFile(const char *name, void *(*Alloc)(int));

//t6/code/src_noserver/physics/physconstraints_load_db.h
void Mark_PhysConstraintArray(int count);
void Load_PhysConstraintArray(bool atStreamStart, int count);
void Load_PhysConstraints(bool atStreamStart);
void Load_PhysConstraintsPtr(bool atStreamStart);

//t6/code/src_noserver/physics/physconstraints_load_obj.cpp
void PhysConstraints_Strcpy(unsigned __int8 *member, const char *keyValue);
int CON_ParseSpecificField(unsigned __int8 *pStruct, const char *pValue, const int fieldType);
void PhysConstraintsPostLoadFixup(PhysConstraints *physConstraints);
PhysConstraints *PhysConstraintsLoadFile(const char *name, void *(*Alloc)(int));
PhysConstraints *PhysConstraintsPrecache(const char *name, void *(*Alloc)(int));
void PhysConstraintsUpdateField(;

//t6/code/src_noserver/physics/physpreset_load_db.h
void Load_PhysPreset(bool atStreamStart);
void Load_PhysPresetPtr(bool atStreamStart);

//t6/code/src_noserver/physics/physpreset_load_obj.cpp
void PhysPreset_Strcpy(unsigned __int8 *member, const char *keyValue);
PhysPreset *PhysPresetLoadFile(const char *name, void *(*Alloc)(int));
PhysPreset *PhysPresetPrecache(const char *name, void *(*Alloc)(int));
PhysPreset *PhysPreset_Register_FastFile(const char *name);
PhysPreset *PhysPreset_Register_LoadObj(const char *name);
PhysPreset *PhysPreset_Register();

//t6/code/src_noserver/physics/phys_auto_rigid_body.cpp
// user_rigid_body *auto_rigid_body::ent_has_auto_rigid_body(const centity_t *cent);
void fixup_wheel_constraints_arb(auto_rigid_body *arb);
// void auto_rigid_body::add(;
// void auto_rigid_body::update(int a1@<ebp>);
// void auto_rigid_body::remove_ent(const centity_t *cent);

//t6/code/src_noserver/physics/phys_colgeom.cpp
void setup_gjk_polygon_cylinder(;
;
// gjk_aabb_t *gjk_aabb_t::create(;
// gjk_obb_t *gjk_obb_t::create(;
// gjk_aabb_t *gjk_brush_t::create@<eax>(;
// gjk_partition_t *gjk_partition_t::create(const CollisionAabbTree *tree, gjk_collision_visitor *allocator);
// gjk_double_sphere_t *gjk_double_sphere_t::create(;
// gjk_cylinder_t *gjk_cylinder_t::create(;
// gjk_polygon_cylinder_t *gjk_polygon_cylinder_t::create(;
// gjk_aabb_t *create_aabb_gjk_geom@<eax>(;
;
;
// gjk_cylinder_t *create_cylinder_gjk_geom@<eax>(;
void create_brush_model_gjk_geom_r(;
// void __thiscall query_brush_model_gjk_geom_visitor::visit(;
;
void create_gjk_dobj_geom(;
// void collision_add_persistent_box(gjk_base_t *a1@<ebp>, vec3_t *axis, vec3_t *position, vec3_t *dims);
// void gjk_aabb_t::destroy(gjk_aabb_t *geom);
// void gjk_obb_t::destroy(gjk_obb_t *geom);
// void gjk_brush_t::destroy(gjk_brush_t *geom);
// void gjk_partition_t::destroy(gjk_partition_t *geom);
// void gjk_double_sphere_t::destroy(gjk_double_sphere_t *geom);
// void gjk_cylinder_t::destroy(gjk_cylinder_t *geom);
// void gjk_polygon_cylinder_t::destroy(gjk_polygon_cylinder_t *geom);
;
void create_brush_model_gjk_geom(;
void create_gjk_geom(;
void create_gjk_geom(;
void create_gjk_geom(;
void create_gjk_geom(const DynEntityDef *dynEntDef, gjk_collision_visitor *allocator, unsigned int brush_mask);
void collision_reset_persistent_code_collision();

//t6/code/src_noserver/physics/phys_colgeom.h
bool R_Is3DOn();
// void __thiscall gjk_collision_visitor::get_local_query_aabb(;
// void __thiscall gjk_geom_list_t::add_geom(gjk_geom_list_t *this, gjk_base_t *geom);
// void *__thiscall create_gjk_geom_collision_visitor::allocate(;
// char __thiscall create_gjk_geom_collision_visitor::query_create_prolog(;
// void __thiscall create_gjk_geom_collision_visitor::query_create_epilog_1(;
// char __thiscall create_gjk_geom_collision_visitor::query_create_prolog_1(;
// const phys_vec3 *__thiscall gjk_base_t::get_aabb_mn_loc(gjk_base_t *this, const phys_vec3 *result);
// const phys_vec3 *__thiscall gjk_base_t::get_aabb_mx_loc(gjk_base_t *this, const phys_vec3 *result);
// gjk_base_t *__thiscall gjk_geom_list_t::get_first_geom(gjk_geom_list_t *this);
// void gjk_geom_list_t::comp_aabb_loc(;
// void __thiscall gjk_base_t::comp_aabb_loc(gjk_base_t *this);
// void __thiscall gjk_base_t::set_xform(gjk_base_t *this, const phys_mat44 *xform);
// bool __thiscall gjk_base_t::is_walkable(gjk_base_t *this, const phys_vec3 *hit_point, const phys_vec3 *up);
// void __thiscall gjk_aabb_t::get_simplex(;
// const cbrush_t *__thiscall gjk_aabb_t::get_brush(gjk_aabb_t *this);
// void __thiscall gjk_aabb_t::support(;
// void gjk_aabb_t::get_feature(gjk_aabb_t *this@<ecx>, int a2@<ebp>, phys_contact_manifold *cman);
// void __thiscall gjk_aabb_t::calc_aabb(;
// void __thiscall gjk_obb_t::get_simplex(;
// const phys_vec3 *__thiscall gjk_obb_t::get_center(gjk_obb_t *this, const phys_vec3 *result);
// void gjk_obb_t::calc_aabb(;
// unsigned int __thiscall gjk_obb_t::get_type(gjk_obb_t *this);
// void __thiscall gjk_obb_t::support(;
// void gjk_obb_t::get_feature(gjk_obb_t *this@<ecx>, int a2@<ebp>, phys_contact_manifold *cman);
// const cbrush_t *__thiscall gjk_brush_t::get_brush(gjk_brush_t *this);
// unsigned int __thiscall gjk_brush_t::get_type(gjk_brush_t *this);
// void __thiscall gjk_brush_t::support(;
// void __thiscall gjk_brush_t::get_simplex(;
// void gjk_brush_t::get_feature(gjk_brush_t *this@<ecx>, int a2@<ebp>, phys_contact_manifold *cman);
// void __thiscall gjk_brush_t::calc_aabb(;
// const phys_vec3 *__thiscall gjk_brush_t::get_center(gjk_partition_t *this, const phys_vec3 *result);
// unsigned int __thiscall gjk_partition_t::get_type(gjk_partition_t *this);
// void __thiscall gjk_partition_t::support(;
// void __thiscall gjk_partition_t::get_simplex(;
// void gjk_partition_t::get_feature(gjk_partition_t *this@<ecx>, float a2@<ebp>, phys_contact_manifold *cman);
// void __thiscall gjk_partition_t::calc_aabb(;
// void __thiscall gjk_double_sphere_t::support(;
// void __thiscall gjk_double_sphere_t::get_simplex(;
// void __thiscall gjk_double_sphere_t::set_simplex(;
// const phys_vec3 *__thiscall gjk_double_sphere_t::get_center(gjk_double_sphere_t *this, const phys_vec3 *result);
// void __thiscall gjk_double_sphere_t::calc_aabb(;
// double __thiscall gjk_double_sphere_t::get_geom_radius(gjk_double_sphere_t *this);
// bool __thiscall gjk_double_sphere_t::is_polyhedron(gjk_double_sphere_t *this);
// void gjk_double_sphere_t::get_feature(;
// const phys_vec3 *__thiscall gjk_cylinder_t::get_center(gjk_cylinder_t *this, const phys_vec3 *result);
// double __thiscall gjk_cylinder_t::get_geom_radius(gjk_cylinder_t *this);
// void gjk_cylinder_t::support(;
// void gjk_cylinder_t::get_simplex(;
// void gjk_cylinder_t::get_feature(gjk_cylinder_t *this@<ecx>, int a2@<ebp>, phys_contact_manifold *cman);
// void gjk_cylinder_t::calc_aabb(;
// void gjk_polygon_cylinder_t::poly_verts::support(phys_vec3 const &);
// void __thiscall gjk_polygon_cylinder_t::poly_verts::get_co_si(;
// void gjk_polygon_cylinder_t::support(;
// void gjk_polygon_cylinder_t::get_simplex(;
// const phys_vec3 *__thiscall gjk_aabb_t::get_center(gjk_polygon_cylinder_t *this, const phys_vec3 *result);
// void __thiscall gjk_polygon_cylinder_t::calc_aabb(;
// double __thiscall gjk_polygon_cylinder_t::get_geom_radius(gjk_polygon_cylinder_t *this);
void destroy_gjk_geom(gjk_base_t *geom);
void destroy_gjk_geom(gjk_geom_list_t *gjk_geom_list);
// int __thiscall gjk_geom_list_t::get_geom_count(gjk_geom_list_t *this);
void get_simplex(;
void set_simplex(;

//t6/code/src_noserver/physics/phys_collision.cpp
void process_dynent_hits();
void process_destructible_hits();
// unsigned __int8 __thiscall destructible_ent_aa::has_auto_activated(bdDTLSHeader *this);
// void __thiscall destructible_ent_aa::auto_activate(destructible_ent_aa *this, broad_phase_info *bpi_impactor);
void set_bp_standard_query();
void debug_callback();
void set_debug_callback();
user_rigid_body *GetTraceResultsRigidBody(const trace_t *traceResults);
void set_cpi_params(contact_point_info *cpi, phys_collision_pair *pcp);
// void __thiscall dynamic_ent_aa::auto_activate(dynamic_ent_aa *this, broad_phase_info *bpi_impactor);
// void *__thiscall gjk_physics_collision_visitor::allocate(;
// void __thiscall gjk_physics_collision_visitor::get_local_query_aabb(;
// bool gjk_physics_collision_visitor::query_create_prolog_1@<al>(;
phys_mat44 *create_ent_mat(gjk_physics_collision_visitor *collision_visitor);
phys_auto_activate_callback *create_ent_aac(gjk_physics_collision_visitor *collision_visitor);
// void __thiscall gjk_physics_collision_visitor::query_create_epilog(;
void prop_system_collision_process();
;
void generic_avl_map_destroy_all_recurse(generic_avl_map_node_t *gamn, void (*destroy_func)(void *));
void generic_avl_map_destroy_all(;
// char __thiscall gjk_physics_collision_visitor::query_create_prolog(;
// void create_entity_bpi(LONG a1@<ebp>, gjk_physics_collision_visitor *collision_visitor, const int mask);
// void standard_query::query(;
// int wheel_collision_worker@<eax>(int a1@<ebp>);
generic_avl_map_node_t *generic_avl_map_add(;
void *generic_avl_map_destroy(;

//t6/code/src_noserver/physics/phys_convert.h
void Phys_NitrousMat44ToVec33(const phys_mat44 *inMat, vec3_t *outAxis);
void Phys_Mat4ToNitrousMat(const vec3_t *inMat, phys_mat44 *outMat);
void Phys_PosAxisToNitrousMat(const vec3_t *inPos, const vec3_t *axis, phys_mat44 *outMat);

//t6/code/src_noserver/physics/phys_effects.cpp
void Phys_InitSoundAliases();
void Phys_EffectsInit(int a1, dvarType_t a2);
void Phys_EffectsProcess();

//t6/code/src_noserver/physics/phys_gjk_collision_detection.cpp
void gjk_collision_epilog(const bool is_server_thread);
// void __thiscall gjk_query_output::calc_query_aabb(gjk_query_output *this, const gjk_query_input *input);
// void __thiscall gjk_query_output::query_epilog(gjk_query_output *this);
// void __thiscall gjk_physics_collision_visitor::query_create_epilog_1(;
// void __thiscall gjk_query_output::set_local_query_info(;
bool query_should_pass_gentity(const gjk_query_input *input, const gentity_t *gent);
char query_should_pass_centity(const gjk_query_input *input, const centity_t *cent);
// void __thiscall gjk_query_output::accum_query_reset(gjk_query_output *this, const phys_vec3 *start_origin);
char query_should_pass_entity(const gjk_query_input *input, gjk_entity_info_t *ent_info);
void adjust_gjk_polygon_cylinder_query_aabb(vec3_t &,vec3_t &);
void get_material_from_brush(const cbrush_t *brush, int *sflags);
void fill_results_type_and_id(const gjk_trace_output_t *gto, trace_t *results);
void fill_results_no_hit(trace_t *results);
// bool is_walkable@<al>(const gjk_trace_output_t *gto);
// char *__thiscall gjk_query_output::allocate(;
// void __thiscall gjk_query_output::get_local_query_aabb(;
// bool __thiscall gjk_query_output::query_create_prolog_1(;
// gjk_geom_info_t *__thiscall gjk_query_output::create_geom_info(;
void setup_gjk_capsule(;
void setup_gjk_cylinder(;
// bool gjk_aabb_t::is_walkable@<al>(;
bool is_walkable(const cbrush_t *brush, const phys_vec3 *hit_point_loc, const phys_vec3 *up_loc);
bool is_walkable(const CollisionPartition *partition, const phys_vec3 *hit_point_loc, const phys_vec3 *up_loc);
void fill_results(const gjk_trace_output_t *gto, const bool is_walkable, trace_t *results);
// void __thiscall gjk_query_output::query_prolog(gjk_query_output *this, const gjk_query_input *input);
// void __thiscall gjk_query_output::query_create_epilog(gjk_query_output *this, gjk_base_t *gjk_geom);
;
// void __thiscall gjk_query_output::reset_cache(gjk_query_output *this);
// bool __thiscall gjk_query_output::query_create_prolog(gjk_query_output *this, const void *geom);
// void __thiscall gjk_query_output::add(gjk_query_output *this, const gjk_query_input *input, gentity_t *gent);
// void __thiscall gjk_query_output::add(gjk_query_output *this, const gjk_query_input *input, centity_t *cent);
// void __thiscall gjk_query_output::add(gjk_query_output *this, const gjk_query_input *input, const Glass *glass);
// void __thiscall gjk_query_output::add(gjk_query_output *this, const gjk_query_input *input, const DynEntityDef *dent);
void gjk_query_prims(const gjk_query_input *input, gjk_query_output *output);
void gjk_query_terrain(const gjk_query_input *input, gjk_query_output *output);
void gjk_query_gents(const gjk_query_input *input, gjk_query_output *output);
void gjk_query_cents(const gjk_query_input *input, gjk_query_output *output);
void gjk_query_glass(const gjk_query_input *input, gjk_query_output *output);
void gjk_query_dents(const gjk_query_input *input, gjk_query_output *output);
void gjk_query(const gjk_query_input *input, gjk_query_output *output);
// ;
// void __thiscall gjk_query_output::cached_query_prolog(;
// void __thiscall gjk_query_output::cached_query_epilog(gjk_query_output *this);
void gjk_query_cached(const gjk_query_input *input, gjk_query_output *output);

//t6/code/src_noserver/physics/phys_gjk_collision_detection.h
// const gentity_t *__thiscall gjk_entity_info_t::get_gent(gjk_entity_info_t *this);
// const centity_t *__thiscall gjk_entity_info_t::get_cent(gjk_entity_info_t *this);
// const DynEntityDef *__thiscall gjk_entity_info_t::get_dent(gjk_entity_info_t *this);
// const Glass *__thiscall gjk_entity_info_t::get_glass(gjk_entity_info_t *this);
// void __thiscall cached_query_info_t::add_query(;
// BOOL __thiscall cached_query_info_t::is_subset(;
// void __thiscall gjk_query_output::verify_empty(gjk_query_output *this);
char gjk_trace_aabb(;
// void __thiscall gjk_query_input::visit_skip_list(gjk_query_input *this, const int query_visitor_count);
// void __thiscall gjk_query_output::gjk_query_output(gjk_query_output *this);

//t6/code/src_noserver/physics/phys_main.cpp
void Phys_EnterPhysicsCriticalSection();
void Phys_LeavePhysicsCriticalSection();
void PhysPrint(const char *fmt, ...);
void Phys_ObjGetPosition(int id, phys_mat44 *m2w);
void Phys_ObjGetVelocities(int id, vec3_t *tvel, vec3_t *avel);
void Phys_ObjAddCollFlags(int physObjId, int collFlags);
void Phys_ObjRemoveCollFlags(int physObjId, int collFlags);
void Phys_RenderBulletMeshInfo(;
void Phys_ComputeStringPosition(const vec3_t *start, const vec3_t *end, vec3_t *position);
int sort_scored_spawn_point_vectors_ascending(const void *a, const void *b);
void Phys_FindAndRenderEntityBounds(const vec3_t *pos);
void Phys_DumpCollisionTree();
void Phys_RenderHeliMesh(int a1, cmodel_t **a2);
// void __thiscall colgeom_debug_renderer_t::update(;
char Phys_DebugRenderChanged();
int Phys_GetMaskFromDVar();
int SortModelsFunc(const void *a, const void *b);
char Phys_ShouldCollideCallback(const broad_phase_base *bpi1, const broad_phase_base *bpi2);
int Phys_ObjIsDangerous(int id);
int Phys_ObjIsExpensive(int id);
void Phys_SetHingeParams(int id, float motorSpeed, float damp);
// rigid_body_constraint_ragdoll *Phys_CreateHinge@<eax>(;
void Phys_CalcPreset(PhysPreset *physPreset, vec3_t *dims, int surfaceType);
int Phys_GetCurrentTime();
void Phys_ObjSetPosition(int id, const vec3_t *newPosition);
void Phys_ObjSetOrientation(int id, const vec3_t *newPosition, const vec4_t *newOrientation);
void Phys_ObjSetAngularVelocity(int id, const vec3_t *angularVel);
void Phys_ObjSetVelocity(int id, const vec3_t *velocity);
void Phys_ObjSetAngularVelocityRaw(int id, const vec3_t *angularVel);
void Phys_ObjGetPosition(int id, vec3_t *outPosition, vec3_t *outRotation);
void Phys_ObjGetCenterOfMass(int id, vec3_t *outPosition);
void Phys_ObjSetGravity(int id, const vec3_t *gravity);
// void Phys_AddCacheImpulses(int a1@<ebp>);
void Phys_ObjAddForce(;
void Phys_ObjAddTorque(int id, const vec3_t *torque);
;
void Phys_BodyGrabSnapshotNitrous(PhysObjUserData *userData, float deltaT);
int Phys_ObjGetSnapshot(int id, vec3_t *outPos, vec3_t *outMat);
void free_chull_lists();
void print_static_models_stats();
void draw_static_models_bounds();
int buoyancy_worker();
void Phys_ObjGetInterpolatedState(int id, vec3_t *outPos, vec4_t *outQuat);
void Phys_SetUserBody(int id, vec3_t *position);
// BOOL Phys_ObjIsAsleep@<eax>(clientDebugLineInfo_t *a1@<edi>, int id);
// BOOL Phys_ObjIsAsleepSingle@<eax>(clientDebugLineInfo_t *a1@<edi>, int id);
void Phys_SetAngularMotorParams(int id, const vec3_t *motorSpeeds, const vec3_t *damp);
// rigid_body_constraint_ragdoll *Phys_CreateSwivel@<eax>(;
void Phys_ObjAddCustomForce(;
;
chull_t *create_chull(phys_convex_hull *pch);
chull_t *generate_brush_chull(const cbrush_t *brush);
chull_t *generate_partition_chull(const CollisionAabbTree *tree);
void generate_brushmodel_chull_r(cLeafBrushNode_s *node, chull_t **hull);
chull_t *generate_collmap_chull(PhysGeomList *geomList);
chull_t *get_collmap_chull(PhysGeomList *geomList, unsigned int key);
// chull_t *get_brushmodel_chull@<eax>(cmodel_t **a1@<edx>, int brushmodel, unsigned int key);
chull_t *get_brush_chull(const cbrush_t *brush);
chull_t *get_partition_chull(const CollisionAabbTree *tree);
void Phys_FindAndRenderEntityBrushes(const vec3_t *pos, int contentmask);
// void __thiscall colgeom_debug_renderer_t::visit(colgeom_debug_renderer_t *this, const CollisionAabbTree *tree);
// void __thiscall colgeom_debug_renderer_t::visit(colgeom_debug_renderer_t *this, const cbrush_t *brush);
void Phys_RenderWorldCollMesh(;
// void debug_loop(int a1@<ebp>);
void UpdateRigidBody(float delta_t);
void Phys_CollisionCallback();
void Phys_RunToTime(int timeNow);
void Phys_Init();
void Phys_DestroyUserData(PhysObjUserData *userData);
// PhysObjUserData *Phys_CreateUserBody@<eax>(;
// rigid_body **Phys_CreateBodyFromState@<eax>(;
int Phys_ObjCreateAxis(;
int Phys_ObjCreate(;
void Phys_ObjDestroy(int id);
void PhysicsSystem_Update();

//t6/code/src_noserver/physics/phys_render.cpp
void DebugPatchesAndBrushesProlog();
void DebugPatchesAndBrushesEpilog();
// __int16 __thiscall debug_brush_info_t::find_index_in_brush(;
// unsigned int __thiscall debug_patch_info_t::find_index_in_clipmap(;
void clear_debug_brushes_and_patches();
void SeedColor(const void *ptr, const vec4_t *baseColor, float scale, vec4_t *color);
void render_debug_brushes();
void render_debug_patches_full();
void render_debug_brushes_and_patches();
void calc_color(const void *id, const float alpha, vec4_t *color);
void render_tree(const CollisionAabbTree *tree, vec3_t *_trans);
void render_collision_tree(const CollisionAabbTree *tree, const vec4_t *color);
// void __thiscall debug_patch_info_t::add_patch(debug_patch_info_t *this, const CollisionAabbTree *tree);
void add_debug_patch(const CollisionAabbTree *tree);
;
void render_convex_partition(const CollisionAabbTree *tree);
;
void render_xmodel_chull(;
void render_brushmodel_chull(;
void render_line(;
void render_box(;
void render_box(const vec3_t *_mn, const vec3_t *_mx, const vec4_t *color, int duration);
void render_box(const phys_vec3 *mins, const phys_vec3 *maxs, const vec4_t *color, int duration);
;
;
void Phys_DebugPoint(;
void Phys_DebugBox(const phys_mat44 *mat, const vec4_t *color, float scale);
void Phys_DebugBox(const phys_mat44 *mat, const phys_vec3 *dims, const vec4_t *color);
;
void Phys_JointDebugRender(int id);
void render_prims(col_prim_t *prims, int nprims);
// void GjkTraceGeom::Render(unsigned int a1@<ebp>);
;
// void clip_winding(phys_static_array<phys_vec3,512> *winding, const plane_lt *clip);
;
;
// void debug_brush_info_t::add_brush(;
void add_debug_brush(const cbrush_t *brush, const phys_mat44 *mat);

//t6/code/src_noserver/physics/phys_traverse.cpp
// void __thiscall colgeom_visitor_t::intersect_box_brushnode(colgeom_visitor_t *this, cLeafBrushNode_s *node);
// void __thiscall colgeom_visitor_t::intersect_box_partitions_r(colgeom_visitor_t *this, CollisionAabbTree *aabbTree);
// void __thiscall static_colgeom_visitor_t::visit(static_colgeom_visitor_t *this, const CollisionAabbTree *tree);
// void __thiscall static_colgeom_visitor_t::visit(static_colgeom_visitor_t *this, const cbrush_t *brush);
// void __thiscall colgeom_visitor_t::intersect_box_brushes(colgeom_visitor_t *this, cLeaf_s *leaf);
// void __thiscall colgeom_visitor_t::intersect_box_partitions(colgeom_visitor_t *this, cLeaf_s *leaf);
// void __thiscall colgeom_visitor_t::intersect_box(colgeom_visitor_t *this, const vec3_t *mn, const vec3_t *mx, int mask);
// void __thiscall static_colgeom_visitor_t::update(;

//t6/code/src_noserver/physics/phys_visitor.h
// void __thiscall colgeom_visitor_inlined_t<300>::colgeom_visitor_inlined_t<300>(colgeom_visitor_inlined_t<300> *this);
// void __thiscall colgeom_visitor_inlined_t<300>::visit(;
// void __thiscall colgeom_visitor_inlined_t<300>::visit(colgeom_visitor_inlined_t<300> *this, const cbrush_t *brush);
// void __thiscall colgeom_visitor_inlined_t<300>::update(;
// void __thiscall static_colgeom_visitor_t::prolog(static_colgeom_visitor_t *this);
// void __thiscall colgeom_visitor_inlined_t<300>::update(;
// void __thiscall colgeom_visitor_inlined_t<300>::render(colgeom_visitor_inlined_t<300> *this);
// void __thiscall colgeom_visitor_inlined_t<200>::update(;
// void __thiscall colgeom_visitor_inlined_t<200>::visit(;
// void __thiscall colgeom_visitor_inlined_t<200>::visit(colgeom_visitor_inlined_t<200> *this, const cbrush_t *brush);
// void __thiscall colgeom_visitor_inlined_t<500>::visit(;
// void __thiscall colgeom_visitor_inlined_t<500>::visit(colgeom_visitor_inlined_t<500> *this, const cbrush_t *brush);
// void __thiscall colgeom_visitor_inlined_t<500>::update(;

//t6/code/src_noserver/physics/proftimers.h
// void __thiscall cdl_proftimer::reset(cdl_proftimer *this);

//t6/code/src_noserver/physics/rope.cpp
BOOL Rope_IsValid(int rope_index);
void Rope_Activate(int rope_index);
void Rope_SetFlag(int rope_index, int flags, int onoff);
void Rope_Reset(int rope_index);
void Rope_Reset();
void Rope_SetMaterial(int rope_index, Material *const material);
int Rope_GetNumParticles(int rope_index);
void Rope_AddParticle(int rope_index, const vec3_t *pos);
void Rope_Init(;
void Rope_AddAnchor(;
void Rope_AddDynEntAnchor(int rope_index, int particle_index, const vec3_t *p, int entity_index);
void Rope_AddEntAnchor(;
void Rope_RemoveAnchor(int rope_index, int particle_index);
void Rope_ApplyPhysics(int rope_index, float dt);
void Rope_ApplyContactConstraint(int rope_index, int contact_index);
void Rope_ApplyConstraint(int rope_index, int constraint_index);
// void Rope_ApplyConstraints(int a1@<edx>, int rope_index, bool forward);
void Rope_UpdateVisible(int rope_index);
void Rope_DebugDraw(int rope_index);
void Rope_GetPosition(int rope_index, float frac, vec3_t *pos);
void Rope_BuildCurve(const RopeUpdateCmdData *cmd, int rope_index);
void Rope_Draw(int rope_index, LocalClientNum_t localClientNum);
void Rope_Create(;
void Rope_Render(LocalClientNum_t localClientNum);
void Rope_ExplosionEvent(;
void Rope_Trace(const vec3_t *p0, const vec3_t *p1);
void Rope_CollideEntitiesHelper(int rope_index, const vec3_t *origin);
void Rope_CollideEntities(int rope_index);
;
void Rope_UpdateInternal(const RopeUpdateCmdData *cmd);
void Rope_Update(LocalClientNum_t localClientNum, int curtime);
void Rope_Settle(int rope_index);

//t6/code/src_noserver/physics/rope_gamestate.cpp
void Rope_WriteGameState(msg_t *msg);
void Rope_ReadGameState(msg_t *msg, LocalClientNum_t localClientNum);

//t6/code/src_noserver/physics/xdoll.cpp
int XDoll_GetUnusedBody();
void XDoll_SnapshotBonePositions(XDollBody *body, XDollBoneOrientation *boneSnapshot);
void XDoll_DestroyConstraint(XDoll_ConstraintInfo *cinfo);
rigid_body_constraint_hinge *XDoll_CreateHingeConstraint(rigid_body *rb1, rigid_body *rb2);
rigid_body_constraint_point *XDoll_CreatePointConstraint(rigid_body *rb1, rigid_body *rb2);
rigid_body_constraint_angular_actuator *XDoll_CreateActuatorConstraint(rigid_body *rb1);
bool XDoll_Activate(const PhysConstraints *constraintsDef, int health);
void XDoll_SetCollides(XDollBone *bone, bool collides);
void XDoll_SetCollides(XDollBody *body, bool collides);
void XDoll_UpdateTimers(XDollBody *body, int msec);
void XDoll_UpdateStability(XDollBody *body, int msec);
rigid_body *XDoll_GetRigidBody(XDollBody *body, const char *bone_name);
void XDoll_DestroyXDoll(XDollBody *body);
XDollBody *XDoll_HandleBody(int xdollHandle);
void XDoll_DoControllers(int xdoll_handle, int *partBits, LocalClientNum_t localClientNum);
void XDoll_SetCollides(int xdoll_handle, bool collides);
bool XDoll_CreatePhysObj(;
void XDoll_Update(int msec);
void XDoll_CreateConstraint(const PhysConstraint *constraint);
void XDoll_DestroyXDoll(int xdoll_handle);
int XDoll_CreateXDollForBoneLaunch(;
int XDoll_CreateXDollForConstraints(;
void XDoll_UpdateHealth(int xdoll_handle, int health);
void XDoll_ApplyForce(int xdoll_handle, const vec3_t *hitp, const vec3_t *hitd, const int mod);

//t6/code/src_noserver/qcommon/bitarray.h
// BOOL __thiscall bitarray<64>::testBit(bitarray<64> *this, unsigned int pos);
// char __thiscall bitarray<64>::anyBitsOn(bitarray<64> *this);
// void bitarray<64>::bitarray<64>(bitarray<64> *this, int first, ...);
// void __thiscall bitarray<64>::resetBit(bitarray<64> *this, unsigned int pos);
// void bitarray<58>::bitarray<58>(bitarray<58> *this, int first, ...);
// char __thiscall bitarray<64>::areAllBitsEqual(;

//t6/code/src_noserver/qcommon/cmd.cpp
void TRACK_cmd();
void Cmd_SetZM_f();
void Cmd_Wait_f();
void Cbuf_Init();
void Cmd_ShiftArgs(int count, CmdArgs *args);
void Cbuf_AddText(LocalClientNum_t localClientNum, const char *text);
void Cbuf_InsertText(LocalClientNum_t localClientNum, const char *text);
void Cbuf_AddServerText_f();
void Cmd_AddServerCommandInternal(const char *cmdName, void (*function)(), cmd_function_s *allocedCmd);
bool Cmd_ExecFromDiskAddText(;
void Cmd_ExecAddText_f();
void SV_Cmd_ArgvBuffer(int arg, char *buffer, int bufferLength);
void Cmd_ArgsBuffer(int start, char *buffer, int bufLength);
bool Cmd_IsWhiteSpaceChar(char letter);
void Cmd_EmitChar(char letter, CmdArgs *argsPriv);
void Cmd_EmitString(const char *str, CmdArgs *argsPriv);
void Cmd_EvaluateExpression(const char **text_in, CmdArgs *argsPriv);
int Cmd_TokenizeStringInternal(;
void AssertCmdArgsConsistency(const CmdArgs *args);
void Cmd_TokenizeStringKernel(;
void Cmd_EndTokenizedStringKernel(CmdArgs *args);
void Cmd_TokenizeStringWithLimit(const char *text_in);
void Cmd_TokenizeString(const char *text_in);
void Cmd_TokenizeStringNoEval(const char *text_in);
void Cmd_EndTokenizedString();
// void SV_Cmd_TokenizeString(ControllerIndex_t a1@<edx>, LocalClientNum_t a2@<ecx>, const char *text_in);
void __thiscall SV_Cmd_EndTokenizedString(CmdArgs *this);
cmd_function_s *Cmd_FindCommand(const char *cmdName);
void Cmd_AddCommandInternal(const char *cmdName, void (*function)(), cmd_function_s *allocedCmd);
void Cmd_RemoveCommand(const char *cmdName);
void Cmd_SetAutoComplete(const char *cmdName, const char *dir, const char *ext);
void Cmd_Shutdown();
void Cmd_ForEach(void (*callback)(const char *));
void Cmd_ForEach(LocalClientNum_t localClientNum, void (*callback)(LocalClientNum_t, const char *));
const char **Cmd_GetAutoCompleteFileList(const char *cmdName, int *fileCount, int allocTrackType);
void Cmd_ComErrorCleanup();
void Cmd_List_f();
;
void Cmd_HandleMissingCommand(const char *msg, bool fromRemoteConsole);
// void Cmd_ExecuteServerString(ControllerIndex_t a1@<edx>, LocalClientNum_t a2@<ecx>, const char *text);
void Cbuf_SV_Execute();
void Cmd_ExecuteSingleCommandInternal(;
void Cmd_ExecuteSingleCommand(;
void SV_Cmd_ExecuteString(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex, const char *text);
void ExecuteRestOfCommand();
;
void Cbuf_ExecuteBufferInternal(;
void Cbuf_ExecuteBuffer(;
void Cbuf_ExecuteBufferUI(;
void Cbuf_ExecuteInternal(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex);
void Cbuf_Execute(LocalClientNum_t localClientNum);
bool Cmd_ExecFromDisk(;
void Cmd_Exec_f();
void Cmd_Init();

//t6/code/src_noserver/qcommon/cmd.h
CmdArgs *Cmd_Args();
int Cmd_Argc();
const GfxViewParms *Cmd_Argv(int argIndex);
int SV_Cmd_Argc();
const GfxViewParms *SV_Cmd_Argv(int argIndex);
itemDef_s *Cmd_ItemDef();

//t6/code/src_noserver/qcommon/cm_brush_related_load_db.h
void Load_cbrushside_t(bool atStreamStart);
void Load_cbrushside_tArray(bool atStreamStart, int count);

//t6/code/src_noserver/qcommon/cm_load.cpp
void TRACK_cm_load();
void Load_ClipInfoFixup(ClipInfo **pInfo, ClipInfo *info);
void CM_InitThreadData(int threadContext);
unsigned __int16 *CM_InitAllThreadData();
void CM_LoadMapData_LoadObj(const char *name);
void CM_LoadMapData_FastFile(const char *name);
void CM_LoadMap(const char *name, int *checksum);
void CM_LoadAddonMapEnts_FastFile(const char *name);
void CM_LoadAddonMapEnts(const char *name);
void CM_LoadAddOnMapEnts(const char *name);
void Rope_InitRopes();
void ShutdownRopes();
void CM_Shutdown();
void CM_Unload();
void CM_ModelBounds(unsigned int model, vec3_t *mins, vec3_t *maxs);
int CM_ModelSurfaceFlags(unsigned int model);
void *CM_Hunk_Alloc(int size, const char *name, int type);
;
void *CM_Hunk_AllocateTempMemoryHigh(int size, const char *name);
;

//t6/code/src_noserver/qcommon/cm_load_obj.cpp
unsigned int CMod_LoadMaterials();
void CMod_LoadSubmodels();
float CMod_GetPartitionScore(;
cLeafBrushNode_s *CMod_PartionLeafBrushes_r(;
void CMod_PartionLeafBrushes(unsigned __int16 *leafBrushes, int numLeafBrushes, cLeaf_s *leaf);
unsigned int CMod_LoadSubmodelBrushNodes();
cNode_t *CMod_LoadNodes();
vec3_t *CMod_LoadBrushes();
void CMod_LoadLeafs(bool usePvs);
void CMod_LoadLeafs_Version14(bool usePvs);
int *CMod_LoadLeafBrushNodes();
int *CMod_LoadLeafBrushNodes_Version14();
void CMod_LoadPlanes();
unsigned __int16 *CMod_LoadLeafBrushes();
CollisionPartition *CMod_LoadCollisionPartitions();
CollisionAabbTree *CMod_LoadCollisionAabbTrees();
bool MapEnts_CanPurgeEntity(;
const char *CMod_GetSpawnString(void *userData, const char *key);
MapEnts *MapEnts_GetFromString(const char *name, const char *entityString);
void CMod_LoadVisibility();
unsigned int EmitTechniqueSetName(;
unsigned int AppendTechniqueSetName(char *name, unsigned int nameLen, const char *append, char lyrToken);
LayeredTechniqueSetName *FindLayeredTechniqueSetNameInTable(const char *techSetName);
const LayeredTechniqueSetName *GetLayeredTechniqueSetName(const char *mtlName);
unsigned int AssembleLayeredMaterial(;
int CompareTechSetNames(const void *e0, const void *e1);
unsigned int CM_InitBoxHull();
cplane_s *CM_GetPlanes();
int CM_GetPlaneCount();
char *CM_EntityString();
void CMod_LoadBrushRelated(unsigned int version, bool usePvs);
// void RunPIMP(const std::string *MaterialSubset);
void AssembleBspLayeredMaterials();
void CM_LoadMapFromBsp(const char *name, char usePvs);

//t6/code/src_noserver/qcommon/cm_local_load_db.h
void Load_cNode_tArray(bool atStreamStart, int count);
void Load_ClipMaterialArray(bool atStreamStart, int count);
void Load_MapTriggers(bool atStreamStart);
void Load_MapEnts(bool atStreamStart);
void Load_MapEntsPtr(bool atStreamStart);
void Load_cbrush_t(bool atStreamStart);
void Mark_cStaticModel_tArray(int count);
void Mark_MapEntsPtr();
void Mark_AddonMapEntsPtr();
void Load_cStaticModel_tArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeLeaf_t(bool atStreamStart);
void Load_cLeafBrushNode_tArray(bool atStreamStart, int count);
void Load_cbrush_array_tArray(bool atStreamStart, int count);
void Load_ClipInfo(bool atStreamStart);
void Load_cmodel_t(bool atStreamStart);
void Load_cmodel_tArray(bool atStreamStart, int count);
void Load_cmodel2_tArray(bool atStreamStart, int count);
void Load_AddonMapEnts(bool atStreamStart);
void Load_AddonMapEntsPtr(bool atStreamStart);
void Mark_clipMap_t();
void Mark_clipMap_ptr();
void Load_clipMap_t(bool atStreamStart);
void Load_clipMap_ptr(bool atStreamStart);

//t6/code/src_noserver/qcommon/cm_mesh.cpp
bool CM_IsEdgeWalkable(int triIndex, int edgeIndex);
void CM_TracePointThroughTriangle(const traceWork_t *tw, const unsigned __int16 *indices, trace_t *trace);
SphereEdgeTraceResult CM_TraceSphereThroughEdge(;
void CM_TraceSphereThroughVertex(;
void CM_TraceCapsuleThroughTriangle(;
void CM_ClosestPointOnTri(;
float CM_DistanceSquaredBetweenSegments(const vec3_t *start0, const vec3_t *start1);
bool CM_DoesCapsuleIntersectTriangle(;
void CM_PositionTestCapsuleInTriangle(;
void CM_TraceThroughAabbTree_work(const traceWork_t *tw, const CollisionAabbTree *aabbTree, trace_t *trace);
void CM_TraceThroughAabbTree_r(const traceWork_t *tw, trace_t *trace);
// void CM_TraceThroughPartition(int a1@<edx>, const traceWork_t *tw, int partitionIndex, trace_t *trace);
void CM_PositionTestInAabbTree_r(const traceWork_t *tw, CollisionAabbTree *aabbTree, trace_t *trace);
void CM_TraceThroughAabbTree(const traceWork_t *tw, const CollisionAabbTree *aabbTree, trace_t *trace);
void CM_MeshTestInLeaf(const traceWork_t *tw, cLeaf_s *leaf, trace_t *trace);
void CM_MeshTest(const traceWork_t *tw, const CollisionAabbTree *tree, trace_t *trace);

//t6/code/src_noserver/qcommon/cm_public.h
void Trace_SetHitId(trace_t *trace, TraceHitType hitType, unsigned __int16 hitId);

//t6/code/src_noserver/qcommon/cm_showcollision.cpp
void TRACK_cm_showcollision();
bool CM_BrushInView(const cbrush_t *brush, cplane_s *frustumPlanes, int frustumPlaneCount);
int CM_AddSimpleBrushPoint(;
void CM_GetPlaneVec4Form(;
int CM_ForEachBrushPlaneIntersection(;
int CM_GetXyzList(int sideIndex, const ShowCollisionBrushPt *pts, int ptCount, vec3_t *xyz, int xyzLimit);
void CM_AddColinearExteriorPointToWindingProjected(;
void CM_AddExteriorPointToWindingProjected(winding_t *w, const vec3_t *pt, int i, int j);
float CM_RepresentativeTriangleFromWinding(;
void CM_ReverseWinding(winding_t *w);
bool CM_BuildBrushWindingForSide(;
void CM_ShowSingleBrushCollision(;
void CM_ShowBrushCollision(;

//t6/code/src_noserver/qcommon/cm_staticmodel.cpp
void *CM_Hunk_AllocXModel(int size);
void *CM_Hunk_AllocXModelColl(int size);
XModel *CM_XModelPrecache(const char *name);
void CM_TraceStaticModel(;
;

//t6/code/src_noserver/qcommon/cm_staticmodel_load_obj.cpp
void CM_InitStaticModel(cStaticModel_s *staticModel, vec3_t *origin, vec3_t *angles, float scale);
bool CM_CreateStaticModel(;
void CM_LoadStaticModels();

//t6/code/src_noserver/qcommon/cm_test.cpp
int CM_PointLeafnum_r(const vec3_t *p, int num);
void CM_StoreLeafs(leafList_s *ll, int nodenum);
// void CM_BoxLeafnums_r(int a1@<edx>, leafList_s *a2@<ecx>, leafList_s *ll, int nodenum);
int CM_PointContentsLeafBrushNode_r(const vec3_t *p, cLeafBrushNode_s *node);
int CM_PointContents(const vec3_t *p, unsigned int model);
int CM_TransformedPointContents(;

//t6/code/src_noserver/qcommon/cm_trace.cpp
// void __thiscall col_context_t::col_context_t(col_context_t *this);
// void __thiscall col_context_t::col_context_t(col_context_t *this, int _mask);
// void __thiscall col_context_t::init_locational(col_context_t *this, int ent0);
// void __thiscall col_context_t::init_locational(col_context_t *this, int ent0, int ent1);
int Trace_GetEntityHitId(const trace_t *trace);
unsigned __int16 Trace_GetDynEntHitId(const trace_t *trace, DynEntityDrawType *drawType);
int Trace_GetGlassHitId(const trace_t *trace);
void CM_GetTraceThreadInfo(TraceThreadInfo *threadInfo);
clipMap_t *CM_GetClipMap();
void CM_GetBox(cbrush_t **box_brush, cmodel_t **box_model, PhysGeomList ***geoms);
// unsigned int CM_TempBoxModel@<eax>(;
// unsigned int CM_TempBrushModel@<eax>(cmodel_t **a1@<edx>, PhysGeomList *geoms);
bool CM_ClipHandleIsValid(unsigned int handle);
// cmodel_t *CM_ClipHandleToModel@<eax>(cmodel_t **a1@<edx>, unsigned int handle);
// int CM_ContentsOfModel@<eax>(cmodel_t **a1@<edx>, unsigned int handle);
void CM_TestBoxInBrush(const traceWork_t *tw, const cbrush_t *brush, trace_t *trace);
void CM_TestInLeafBrushNode_r(const traceWork_t *tw, cLeafBrushNode_s *node, trace_t *trace);
int CM_TestInLeafBrushNode(traceWork_t *tw, cLeaf_s *leaf, trace_t *trace);
void CM_TestCapsuleInCapsule(const traceWork_t *tw, trace_t *trace);
void CM_PositionTest(traceWork_t *tw, trace_t *trace, col_context_t *context);
void CM_TraceThroughBrush(const traceWork_t *tw, const cbrush_t *brush, trace_t *trace);
void CM_TraceThroughLeafBrushNode_r(;
bool CM_TraceThroughLeafBrushNode(const traceWork_t *tw, cLeaf_s *leaf, trace_t *trace);
void CM_TraceThroughLeaf(const traceWork_t *tw, cLeaf_s *leaf, trace_t *trace);
void CM_TestInTempBrush(const traceWork_t *tw, trace_t *trace);
void CM_TraceThroughTempBrush(const traceWork_t *tw, trace_t *trace);
int CM_TraceSphereThroughSphere(;
int CM_TraceCylinderThroughCylinder(;
void CM_TraceCapsuleThroughCapsule(const traceWork_t *tw, trace_t *trace);
void CM_TraceThroughTree(const traceWork_t *tw, int num, const vec4_t *p1_, const vec4_t *p2, trace_t *trace);
void CM_TraceThroughPrimitives(const traceWork_t *tw, trace_t *trace, col_context_t *context);
int CM_SightTraceThroughBrush(const traceWork_t *tw, const cbrush_t *brush, int brushNum, trace_t *trace);
int CM_SightTracePointThroughBrush(const TraceExtents *extents, const cbrush_t *brush);
int CM_SightTraceThroughLeafBrushNode_r(;
int CM_SightTraceThroughLeafBrushNode(const traceWork_t *tw, const cLeaf_s *leaf, trace_t *trace);
int CM_SightTraceThroughLeaf(const traceWork_t *tw, const cLeaf_s *leaf, trace_t *trace);
int CM_SightTraceSphereThroughSphere(;
int CM_SightTraceCylinderThroughCylinder(;
int CM_SightTraceCapsuleThroughCapsule(const traceWork_t *tw, trace_t *trace);
int CM_SightTraceThroughTree(;
void calc_closest(const vec3_t *v0, const vec3_t *v1, const vec3_t *v2, const vec3_t *p, vec3_t *res);
bool is_inside(const vec3_t *a, const vec3_t *b, const vec3_t *n, const vec3_t *p);
bool point_in_triangle(const vec3_t *p, const vec3_t *v0, const vec3_t *v1, const vec3_t *v2, const vec3_t *n);
char trace_sphere_through_triangle(;
void trace_sphere_through_partition(;
void trace_sphere_through_brush(;
void trace_sphere_through_brush(;
void trace_point_through_brush(;
char trace_point_through_triangle(;
void trace_sphere_through_partition(;
void trace_point_through_partition(;
void trace_point_vs_env(;
void trace_point_vs_env(;
void trace_point_vs_env(;
void trace_sphere_vs_env(;
void trace_sphere_vs_env(;
int collide_segment_brush(const vec3_t *p0, const vec3_t *p1, const cbrush_t *brush);
BOOL collide_segment_triangle(;
int collide_segment(const vec3_t *p0, const vec3_t *p1, col_context_t *context);
// bool CM_GetWaterForce@<al>(cmodel_t **plane@<edx>, const vec3_t *pt, vec3_t *dir, float *force);
void CM_GetClosestPointToBrush(const vec3_t *p, const cbrush_t *brush, vec3_t *result);
int CM_SightTraceThroughTempBrush(const traceWork_t *tw, trace_t *trace);
;
;
int CM_TransformedBoxSightTrace(;
;
;
;
void CM_BoxTrace(;
void CM_TransformedBoxTraceRotated(;
void CM_TransformedBoxTrace(;
void CM_TransformedBoxTraceExternal(;
;

//t6/code/src_noserver/qcommon/cm_tracebox.cpp
void CM_CalcTraceExtents(TraceExtents *extents);
int intersect_extents_aabb(const TraceExtents *extents, const vec3_t *mins, const vec3_t *maxs, float fraction);
int intersect_extents_aabb(;
BOOL intersect_extents_sphere(const TraceExtents *extents, const vec3_t *origin, float radius, float fraction);

//t6/code/src_noserver/qcommon/cm_world.cpp
void TRACK_cm_world();
unsigned __int16 CM_AllocWorldSector(vec2_t *mins, vec2_t *maxs);
int CM_ClearWorld();
void CM_UnlinkEntity(svEntity_s *ent);
void CM_AddEntityToNode(svEntity_s *ent, unsigned __int16 childNodeIndex);
void CM_AddStaticModelToNode(cStaticModel_s *staticModel, unsigned __int16 childNodeIndex);
void CM_SortNode(unsigned __int16 nodeIndex, vec2_t *mins, vec2_t *maxs);
void CM_LinkEntity(svEntity_s *ent, vec3_t *absmin, vec3_t *absmax, unsigned int clipHandle);
void CM_LinkAllStaticModels();
void CM_AreaEntities_r(unsigned int nodeIndex, areaParms_t *ap);
int CM_AreaEntities(const vec3_t *mins, const vec3_t *maxs, int *entityList, int maxcount, int contentmask);
void CM_PointTraceStaticModels_r(;
int CM_PointTraceStaticModelsComplete_r(;
void CM_ClipMoveToEntities_r(;
void CM_ClipMoveToEntities(moveclip_t *clip, trace_t *trace);
int CM_ClipSightTraceToEntities_r(;
int CM_ClipSightTraceToEntities(sightclip_t *clip);
void CM_PointTraceToEntities_r(;
void CM_PointTraceToEntities(pointtrace_t *clip, trace_t *trace, col_context_t *context);
int CM_PointSightTraceToEntities_r(;
int CM_PointSightTraceToEntities(sightpointtrace_t *clip);
void CM_LinkWorld();
;
void CM_PointTraceStaticModels(;

//t6/code/src_noserver/qcommon/common.cpp
void TRACK_common();
void Com_NTPSync_f();
bool Com_IsRunningMenuLevel(const char *name);
char Com_IsMenuLevel(const char *name);
void Com_BeginRedirect(char *buffer, unsigned int buffersize, void (*flush)(char *));
void Com_EndRedirect();
void Com_OpenLogFile();
void Com_LogPrintMessage(int channel, const char *msg);
void Com_PrintMessage(int channel, const char *msg, int error);
void Com_Printf(int channel, const char *fmt, ...);
void Com_DPrintf(int channel, const char *fmt, ...);
void Com_PrintError(int channel, const char *fmt, ...);
void Com_PrintWarning(int channel, const char *fmt, ...);
void Com_InitDynamicRender();
void Com_ShutdownDynamicMemorySystems();
double Com_GetTimeScale();
void Com_SetTimeScale(float timescale);
bool Com_ErrorIsNotice(const char *errorMessage);
void Com_SetLocalizedErrorMessage(const char *localizedErrorMessage, const char *titleToken);
void Com_SetErrorMessage(const char *errorMessage);
void Com_PrintStackTrace(int code, void (*cb)(const char *));
void __noreturn Com_ErrorAbort();
void Com_Error(errorParm_t code, const char *fmt, ...);
void Com_ParseCommandLine(char *commandLine);
int Com_SafeMode();
bool Com_StartupProcessSetCommand(int lineIndex, const char *match);
// void Com_StartupVariable(const char *a1@<edx>, const char *match);
void Com_AddStartupCommands();
void Info_Print(const char *s);
void *Com_AllocEvent(int size);
void Com_PacketEventLoop(LocalClientNum_t localClientNum, msg_t *netmsg);
;
void Com_ServerPacketEvent();
void Com_EventLoop();
void Com_Error_f();
void Com_Freeze_f();
void Com_Crash_f();
unsigned int Com_CompressWithZLib(;
unsigned int Com_DecompressWithZLib(;
const dvar_t *Com_InitDvars();
void Com_CheckForInvites_f();
void Com_RunAutoExec(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex);
void Com_ExecStartupConfigs(LocalClientNum_t localClientNum, const char *configFile);
void Com_WriteConfigToFile(LocalClientNum_t localClientNum, const char *filename);
BOOL Com_isFullyInitialized();
void Com_WriteConfig_f();
void Com_WriteKeyConfig_f();
void Com_WriteDefaults_f();
double Com_GetTimescaleForSnd();
void Com_SetSlowMotion(const float startTimescale, const float endTimescale, const int deltaMsec);
void Com_ResetSlowMotion();
void Com_SetSlowMotionDelayed(;
double Com_ViewScaleMsec(float sec);
void Com_Frame_Try_Block_Function();
char *Com_GetLevelSharedFastFile(const char *mapName);
void Com_LoadCommonFastFile();
void Com_UnloadLevelFastFiles();
void Com_LoadLevelFastFiles(const char *mapName);
void Com_LoadLevelFastFiles_BlockForOverlay(const char *mapName);
void Com_UnloadFrontEnd();
void Com_ResetFrametime();
void Com_CheckSyncFrame();
BOOL Com_LogFileOpen();
void Field_Clear(field_t *edit);
void Com_Restart();
void *CG_AllocAnimTree(int size);
XAnimTree_s *Com_XAnimCreateSmallTree(XAnim_s *anims);
void Com_XAnimFreeSmallTree(XAnimTree_s *animtree);
void Com_SetWeaponInfoMemory(int source);
void Com_FreeWeaponInfoMemory(int source);
int Com_GetWeaponInfoMemory();
int Com_AddToString(const char *add, char *msg, int len, int maxlen, int mayAddQuotes);
char Com_GetDecimalDelimiter();
void Com_LocalizedFloatToString(float f, char *buffer, unsigned int maxlen, unsigned int numDecimalPlaces);
void Com_SyncThreads();
const char *Com_DisplayName(const char *name, const char *clanAbbrev, int type);
char *CS_DisplayName(const clientState_s *cs, int type);
int Com_GetPrivateClients();
void NetAdr_SetType(netadr_t *addr, netadrtype_t type);
bool Com_UseRawUDP();
void Com_Quit_f();
void Com_InitDynamicMemorySystems();
void Com_ErrorCleanup();
void Com_Init_Try_Block_Function(ControllerIndex_t a1, dediUserData_t *a2);
void Com_Frame();
bool Com_SetPrivateClients();
void Com_Shutdown(const char *finalmsg);
void Com_Init(char *commandLine);

//t6/code/src_noserver/qcommon/com_bsp.cpp
void Com_UnloadWorld();

//t6/code/src_noserver/qcommon/com_bsp_api.h
ComPrimaryLight *Com_GetPrimaryLight(unsigned int primaryLightIndex);

//t6/code/src_noserver/qcommon/com_bsp_load_db.h
void Load_ComPrimaryLightArray(bool atStreamStart, int count);
void Load_ComWorld(bool atStreamStart);
void Load_ComWorldPtr(bool atStreamStart);
void Mark_ComWorldPtr();

//t6/code/src_noserver/qcommon/com_bsp_load_obj.cpp
unsigned int Com_GetBspLumpCountForVersion(const int version);
const void *Com_ValidateBspLumpData(;
const void *Com_GetBspLump(LumpType type, unsigned int elemSize, unsigned int *count);
const void *Com_ReadLumpOutOfBspAtOffset(;
const void *Com_ReadLumpOutOfBsp(int h, LumpType type, unsigned int elemSize, unsigned int *count);
const void *Com_LoadBspLump(const char *mapname, LumpType type, unsigned int elemSize, unsigned int *count);
void Com_UnloadBspLump(LumpType type);
BOOL Com_BspHasLump(LumpType type);
unsigned int Com_GetBspVersion();
unsigned int Com_GetBspChecksum();
bool Com_CheckVersionLumpCountError(int version);
void Com_LoadBsp(const char *filename);
void Com_UnloadBsp();
void Com_CleanupBsp();
const char *Com_EntityString(int *numEntityChars);
void Com_SaveLump(LumpType type, const void *newLump, unsigned int size, ComSaveLumpBehavior behavior);
const char *Com_GetHunkStringCopy(const char *string);
const char *Com_GetLightDefName(;
void Com_LoadWorld_FastFile(const char *name);
void Com_ShutdownWorld();
void Com_LoadPrimaryLights();
void Com_LoadWorld_LoadObj(const char *name);
void Com_LoadWorld();

//t6/code/src_noserver/qcommon/com_buildinfo.cpp
char *Com_GetBuildVersion();
int Com_GetBuildNumber();
const char *Com_GetBuildMachine();
const char *Com_GetBuildTime();
const char *Com_GetBuildDisplayName();
const char *Com_GetBuildDisplayNameR();
const char *Com_GetBuildName();
const char *Com_GetBuildBaseName();
const char *Com_GetBuildConfig();
const char *Com_GetBuildMode();
int Com_GetChangelist();
char *Com_GetBuildInfoName();
int Com_GetBuildInfoVersion();

//t6/code/src_noserver/qcommon/com_clients.cpp
void Com_LocalClients_AssignUIContextsForInGame();
int Com_LocalClient_GetUIContextIndex(LocalClientNum_t localClientNum);
int Com_LocalClient_GetControllerIndex(LocalClientNum_t localClientNum);
netsrc_t Com_LocalClient_GetNetworkID(LocalClientNum_t localClientNum);
void Com_LocalClient_SetControllerIndex(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex);
void Com_LocalClient_SetPrimary(LocalClientNum_t localClientNum, bool primary);
LocalClientNum_t Com_LocalClients_GetPrimary();
LocalClientNum_t Com_LocalClients_GetPrimaryDefault();
bool Com_LocalClient_IsPrimary(LocalClientNum_t localClientNum);
BOOL Com_LocalClient_IsPrimarySet();
bool Com_LocalClient_IsBeingUsed(LocalClientNum_t localClientNum);
void Com_LocalClient_SetBeingUsed(LocalClientNum_t localClientNum, bool beingUsed);
char Com_LocalClients_NoneBeingUsed();
int Com_LocalClients_GetUsedControllerCount();
LocalClientNum_t Com_ControllerIndex_GetLocalClientNum(ControllerIndex_t controllerIndex);
int Com_ControllerIndex_GetNetworkID(ControllerIndex_t controllerIndex);
int Com_ControllerIndex_GetUIContextIndex(ControllerIndex_t controllerIndex);
int Com_ControllerIndexes_GetPrimary();
int Com_NetworkID_GetControllerIndex(netsrc_t netID);
void Com_LocalClient_LastInput_Set(LocalClientNum_t localClientNum, LastInput_t currentInput);
LastInput_t Com_LocalClient_LastInput_Get(LocalClientNum_t localClientNum);
void Com_InitClientGameStates();
void SwapClients(LocalClientNum_t clientA, LocalClientNum_t clientB);
void Com_LocalClients_CompressClients();

//t6/code/src_noserver/qcommon/com_factions.cpp
const char *Com_FactionLookup(const char *mapName, int columnIndex);
BOOL Com_IsFactionFastfile(const char *mapName);
const char *Com_FactionLookupAxis(const char *a1, int columnIndex);
const char *Com_FactionLookupAllies(const char *a1, int columnIndex);
// char Com_FactionFastFileAxis@<al>(;
// char Com_FactionFastFileAllies@<al>(;

//t6/code/src_noserver/qcommon/com_gamemodes.cpp
const char *Com_GameMode_GetModeName();
BOOL Com_GameMode_IsModeSet();
bool Com_GameMode_IsMode(eGameModes mode);
void Com_GameMode_ResetModes();
int Com_GameMode_IsUsingXP();
BOOL Com_GameMode_IsUsingStats();
void Com_GameMode_WriteModes(msg_t *msg);
bool Com_GameMode_ReadModes(msg_t *msg);
bool ValidateGameModes();
void Com_GameMode_SetMode(eGameModes mode, bool value);

//t6/code/src_noserver/qcommon/com_gametypesettings.cpp
int Com_GametypeSetting_CacheDDLState();
const CACRoot *Com_GametypeSettings_GetCACRoot(const CACRoot *result, team_t team);
int Com_GametypeSettings_GetDDLMemberTypeForSetting(const char *settingName);
unsigned int Com_GametypeSettings_GetUInt(GameTypeSettingsType setting);
unsigned int Com_GametypeSettings_GetUInt(const char *settingName, bool getDefault);
double Com_GametypeSettings_GetFloat(const char *settingName, bool getDefault);
bool Com_GametypeSettings_SetUInt(const char *settingName, unsigned int newValue);
bool Com_GametypeSettings_SetFloat(const char *settingName, float newValue);
void Com_GametypeSettings_GametypeSetting_f();
bool Com_GametypeSettings_AreSettingsDirty();
void Com_GametypeSettings_ClearDirtyFlag();
char Com_GametypeSettings_Read(msg_t *msg);
void Com_GametypeSettings_Write(msg_t *msg);
int Com_GametypeSettings_ResetClassesToDefault();
team_t Com_GametypeSettings_GetCurrentPresetClassTeam();
bool Com_GametypeSettings_IsItemIndexRestricted(int itemIndex, bool getDefault);
bool Com_GametypeSettings_IsAttachmentIndexRestricted(int attachmentIndex, bool getDefault);
void Com_GametypeSettings_UploadSuccess(const ControllerIndex_t controllerIndex, unsigned __int64 fileID);
void Com_GametypeSettings_UploadFailure(const ControllerIndex_t controllerIndex);
bool Com_GametypeSetting_SetMetada(;
void Com_GametypeSetting_Upload(const ControllerIndex_t controllerIndex, int slot);
void Com_GametypeSetting_DownloadFailure();
void Com_GametypeSettings_Upload_f();
void Com_GametypeSettings_ClearUploadInfo_f();
void Com_GametypeSettings_SetName(const char *name);
void Com_GametypeSettings_SetDescription(const char *description);
void Com_GametypeSettings_SetGametype(const char *gametype, bool loadDefaultSettings);
void Com_GametypeSettings_SetGametype_f();
void Com_GametypeSettings_RestrictItem_f();
void Com_GametypeSettings_RestrictAttachment_f();
void Com_GametypeSetting_DownloadSuccess(;
void Com_GametypeSetting_Download(;
void Com_GametypeSettings_Download_f();
void Com_GametypeSettings_Init();

//t6/code/src_noserver/qcommon/com_loadutils.cpp
const char *Com_LoadInfoString_LoadObj(;
const char *Com_LoadInfoString_FastFile(const char *fileName, const char *fileDesc, const char *ident);
const char *Com_LoadInfoString(const char *fileName, const char *fileDesc, const char *ident);
char *Com_LoadRawTextFile_LoadObj(const char *fullpath);
const char *Com_LoadRawTextFile_FastFile(const char *fullpath);
const char *Com_LoadRawTextFile();
void Com_UnloadRawTextFile(const char *filebuf);

//t6/code/src_noserver/qcommon/com_profilemapload.cpp
void TRACK_com_profilemapload();
bool ProfLoad_IsActive();
void ProfLoad_BeginTrackedValueTicks(MapProfileElement *value, unsigned __int64 ticks);
void ProfLoad_BeginTrackedValue(MapProfileTrackedValue type);
void ProfLoad_EndTrackedValueTicks(MapProfileElement *value, unsigned __int64 ticks);
void ProfLoad_EndTrackedValue(MapProfileTrackedValue type);
void ProfLoad_Init();
void ProfLoad_Activate();
MapProfileEntry *Com_GetEntryForNewLabel(const char *label);
void ProfLoad_CalculateSelfTicks();
void ProfLoad_GetEntryRowText(const MapProfileEntry *entry, char *rowText, int sizeofRowText);
void ProfLoad_PrintTree();
BOOL ProfLoad_CompareHotSpotNames(const MapProfileHotSpot *hotSpot0, const MapProfileHotSpot *hotSpot1);
BOOL ProfLoad_CompareHotSpotTicks(const MapProfileHotSpot *hotSpot0, const MapProfileHotSpot *hotSpot1);
void ProfLoad_Begin(const char *label);
void ProfLoad_End();
void ProfLoad_DrawTree();
void ProfLoad_DrawOverlay(rectDef_s *rect);
void ProfLoad_PrintHotSpots();
void ProfLoad_Print();
void ProfLoad_Deactivate();

//t6/code/src_noserver/qcommon/com_sessionmodes.cpp
bool Com_SessionMode_IsMode(eSessionModes mode);
void Com_SessionMode_WriteModes(msg_t *msg);
bool Com_SessionMode_ReadModes(msg_t *msg);
;
bool Com_SessionMode_IsOnlineGame();
void Com_SessionMode_SetMode(eSessionModes mode, bool value);
bool Com_SessionMode_IsPrivateOnlineGame();
bool Com_SessionMode_IsPublicOnlineGame();
bool Com_SessionMode_IsZombiesGame();
bool Com_SessionMode_CanPauseZombiesGame();
void Com_SessionMode_ResetModes();
void Com_SessionMode_SetOnlineGame(bool onlineGame);
bool Com_SessionMode_IsPublicBotGame();

//t6/code/src_noserver/qcommon/console_mp.cpp
int Live_GetNecessaryBandwidth();
int Live_HowManyPlayersCanWeHost();

//t6/code/src_noserver/qcommon/content.cpp
ContentPackMetaData *Content_GetContentPackMetaDataList();
bool Content_IsContentPackAllowedToBeListed(int mask);
int Content_GetKnownContentPackCount();
int Content_GetIndexedContentPackID(int index);
int Content_GetIndexedContentPackMask(int index);
KnownContentPackData *Content_GetIndexedContentPackName(int index);
char Content_IsLoadFastfileLoaded(int index);
void Content_SetLoadFastfileLoaded(int index, bool value);
const char *Content_GetIndexedContentPackFilenameIdentifier(int index);
bool Content_IsDiscovered();
void Content_RegisterContentDvars();
bool Content_IsContentPackInvalid(int contentIndex);
int Content_GetAvailableContentPacks();
int Content_GetAvailableContentMapPackFlags();
SearchSessionMapPackCombinationData *Content_GetContentPacksFlagsString(int contentFlags);
bool Content_DoWeHaveContentPack(const int contentPack);
int Content_GetFreePackIndex();
void Content_InitializeContentPacks();
bool Content_PlayerHasDLCForMapPackIndex(dlcIndex_t mapPackTypeIndex);
const char *Content_GetPakNameForMap(const char *name);
void Content_ValidateTrialPackages();
int Content_GetMTXID(const char *name);
const char *Content_GetMTXContentOffer(const int mtxId);
const char *Content_GetMTXContentName(const int mtxId);
void Content_ClearMTX(ControllerIndex_t controllerIndex);
void Content_MTXFinalizeDiscovery();
bool Content_DoWeHaveMTX(ControllerIndex_t controllerIndex, const int mtxId);
char Content_DoesAnyoneHaveMTX(const int mtxId);
void Content_PurchaseMTX_f();
void Content_ForceMTX_f();
void Content_DumpMTX_f();
char Content_DetermineMTX(ControllerIndex_t controllerIndex, const char *name);
int Content_GetIndexedContentPackFromPakName(const char *pakName);
char Content_OwnsAnyByMask(const ControllerIndex_t controllerIndex, const int contentMask);
int Content_GetContentPackFromPakName(const char *pakName);
bool Content_DoWeHaveIndexedContentPack(int index);
bool Content_IsIndexedContentPackEnabled(int index);
unsigned int Content_GetEnabledContentPacks();
void Content_RegisterContentCmds();

//t6/code/src_noserver/qcommon/dobj_management.cpp
void TRACK_dobj_management();
DObj *Com_GetServerDObj(int handle);
unsigned int Com_GetFreeDObjIndex();
void Com_DObjDumpPrintEntry(int dobjIndex, bool *dobjChecked);
void Com_DObjDump();
void Com_ClientDObjClearAllSkel(LocalClientNum_t localClientNum);
DObj *Com_ServerDObjCreate(DObjModel_s *dobjModels, unsigned __int16 numModels, XAnimTree_s *tree, int handle);
void Com_SafeClientDObjFree(int handle, LocalClientNum_t localClientNum);
void Com_SafeServerDObjFree(int handle);
void Com_InitDObj();
void Com_ShutdownDObj();
DObj *Com_GetClientDObj(int handle, LocalClientNum_t localClientNum);
DObj *Com_ClientDObjCreate(;

//t6/code/src_noserver/qcommon/dvar_cmds.cpp
void TRACK_dvar_cmds();
void Cmd_GetCombinedString(char *combined, int first);
int Dvar_Command();
bool Dvar_ToggleSimple(const dvar_t *dvar);
bool Dvar_ToggleInternal();
;
void Dvar_TogglePrint_f();
void Dvar_Set_f();
void Dvar_RegisterBool_f();
void Dvar_RegisterInt_f();
void Dvar_RegisterFloat_f();
void Dvar_RegisterColor_f();
void Dvar_SetA_f();
void Dvar_SetToTime_f();
void Dvar_Reset_f();
void Dvar_WriteSingleVariable(const dvar_t *dvar, void *userData);
void Dvar_WriteVariables(int f);
void Dvar_WriteSingleDefault(const dvar_t *dvar, void *userData);
void Dvar_WriteDefaults(int f);
void Dvar_ListSingle(const dvar_t *dvar, void *userData);
void Dvar_List_f();
void Com_DvarDumpSingle(const dvar_t *dvar, void *userData);
void Com_DvarDump(int channel, const char *match);
void Dvar_Dump_f();
void SV_SetConfigDvar(const dvar_t *dvar, void *userData);
void SV_SetConfig(int start, int max, int bit);
void Dvar_InfoStringSingle(const dvar_t *dvar, void *userData);
void Dvar_InfoStringSingle_Big(const dvar_t *dvar, void *userData);
char *Dvar_InfoString(LocalClientNum_t localClientNum, int bit);
char *Dvar_InfoString_Big(int bit);
void Dvar_AddConfigFlag_f();
void Dvar_ListByCount_f();
void Dvar_AddCommands();

//t6/code/src_noserver/qcommon/files.cpp
void TRACK_files();
int FS_SV_FOpenFileWrite(const char *filename, const char *dir);
int FS_SV_FOpenFileRead(const char *filename, const char *dir, int *fp);
int FS_GetModList(char *listbuf, int bufsize);
void FS_Dir_f(int a1);
void FS_NewDir_f(int a1);
void FS_TouchFile_f();
int FS_iwIwd(const char *iwd, char *base);
void FS_RemoveCommands();
void FS_AddCommands();
void FS_SetRestrictions();
void FS_LoadedIwds(const char **checksums, const char **names);
char *FS_LoadedIwdPureChecksums();
void FS_ReferencedIwds(const char **checksums, const char **names);
char *FS_ReferencedIwdPureChecksums();
char FS_PureServerSetLoadedIwds(const char *iwdSums, const char *iwdNames);
int FS_ServerSetReferencedFiles(;
void FS_ServerSetReferencedIwds(const char *iwdSums, const char *iwdNames);
void FS_ServerSetReferencedFFs(const char *FFSums, const char *FFNames);
char *FS_GetMapBaseName(const char *mapname);

//t6/code/src_noserver/qcommon/gdt_remote.cpp
const char *GDTCmd_NextToken(const char *src, char *dst, unsigned int len);
// bool GDT_RemoteWeaponUpdate@<al>(char *a1@<edx>, const char *in);
// char GDT_RemoteAttachmentUpdate@<al>(char *a1@<edx>, const char *in);
// char GDT_RemoteAttachmentUniqueUpdate@<al>(char *a1@<edx>, const char *in);
// bool GDT_RemoteWeaponCamoUpdate@<al>(char *a1@<edx>, const char *in);
// bool GDT_RemoteFlametableUpdate@<al>(char *a1@<edx>, const char *in);
// bool GDT_TracerUpdate@<al>(char *a1@<edx>, const char *in);
// char GDT_ZBarrierUpdate@<al>(char *a1@<edx>, const char *in);
// char GDT_RemotePhysConstraintsUpdate@<al>(char *a1@<edx>, const char *in);
// char GDT_RemoteVehicleUpdate@<al>(char *a1@<edx>, const char *in);
char GDT_RemoteXModelUpdate(const char *in);
bool GDT_RemoteMaterialUpdate(const char *in);
char ProcessGDTCmds();

//t6/code/src_noserver/qcommon/graph.cpp
void GraphFloat_ParseBuffer(GraphFloat *graph, const char *buffer, const char *fileName);
void GraphFloat_Load(GraphFloat *graph, const char *fileName, float scale);
double GraphFloat_GetValue(const GraphFloat *graph, float fraction);
void GraphFloat_SaveToFile(const GraphFloat *graph);
void GraphFloat_DevGuiCB_Event(const DevGraph *graph, DevEventType event);
void GraphFloat_DevGuiCB_Text(const DevGraph *devGuiGraph, float inputX, float inputY, char *text);
void GraphFloat_CreateDevGui(GraphFloat *graph, const char *devguiPath);
GraphFloat *GraphFloat_Load(const char *fileName);

//t6/code/src_noserver/qcommon/huffman.cpp
void Huff_offsetReceive(nodetype *node, unsigned __int8 *ch, const unsigned __int8 *fin, int *_offset);
void huffman_send(nodetype *node, nodetype *child, unsigned __int8 *fout);
void Huff_offsetTransmit(huff_t *huff, int ch, unsigned __int8 *fout, int *offset);
void Huff_Init(huffman_t *huff);
int nodeCmp(const void *left, const void *right);
void Huff_BuildFromData(huff_t *huff, const int *msg_hData);

//t6/code/src_noserver/qcommon/keyvaluepairs.cpp
char KeyValuePairs_GetNextValue(const char *key, const char *namespaceKey, const char **outValue);
void KeyValuePairs_Add(KeyValuePairs *kvp, int zoneIndex);
void KeyValuePairs_Remove(KeyValuePairs *kvp);

//t6/code/src_noserver/qcommon/keyvaluepairs_load_db.h
void Load_KeyValuePairArray(bool atStreamStart, int count);
void Load_KeyValuePairs(bool atStreamStart);
void Load_KeyValuePairsPtr(bool atStreamStart);
void Mark_KeyValuePairsPtr();

//t6/code/src_noserver/qcommon/memory_block_load_db.h
void Load_MemoryBlockData();
void Load_MemoryBlock(bool atStreamStart);
void Load_MemoryBlockPtr(bool atStreamStart);
void Mark_MemoryBlockPtr();

//t6/code/src_noserver/qcommon/mem_track.cpp
void track_addbasicmeminfo(meminfo_t *sum, meminfo_t *in);
void track_static_alloc_internal_simple(void *ptr, int size, const char *name, int memTrack);
TempMemInfo *GetTempMemInfo(;
void track_flush_physical_alloc(const char *name, int type);
void track_z_alloc(int size, const char *name, int type, void *pos, int project, int overhead);
void track_z_free(int type, void *pos, int overhead);
void track_z_commit(int size, int type);
void track_temp_alloc(int size, int hunkSize, int permanent, const char *name);
void track_temp_free(int size, int permanent, const char *name);
void track_temp_clear(int permanent);
void track_temp_high_alloc(int size, int hunkSize, int permanent, const char *name);
void track_temp_high_clear(int permanent);
void track_userhunk_freerange(void *low, unsigned int size);
void track_userhunk_free(void *ptr);
void track_userhunk_alloc(int size, int pos, const char *name, int type);
void track_hunk_alloc(int size, int pos, const char *name, int type);
void track_hunk_allocLow(int size, int pos, const char *name, int type);
void track_set_hunk_size(int size);
void track_hunk_ClearToMarkHigh(int mark);
void track_hunk_ClearToMarkLow(int mark);
void track_hunk_ClearToStart();
int mem_track_compare(const void *elem1, const void *elem2);
void track_getbasicinfo(meminfo_t *info);
void track_printf(const char *fmt, ...);
void track_shutdown(int project);
void TRACK_memtrack();
void track_init();
void track_physical_alloc(int size, const char *name, int type, int location);
void track_PrintInfo();
void track_PrintAllInfo();

//t6/code/src_noserver/qcommon/mem_track.h
int track_IsNonSwapType(int type);
int track_IsNonSwapMinSpecType(int type);

//t6/code/src_noserver/qcommon/migration.cpp
void Migration_Init(unsigned __int8 *buffer, int len);
void Migration_Shutdown();
unsigned __int8 *Migration_GetBuffer();
int Migration_GetBufferSize();

//t6/code/src_noserver/qcommon/msg.cpp
;
int GetMinBitCountForNum(const unsigned int num);
void MSG_BeginReading(msg_t *msg);
void MSG_Discard(msg_t *msg);
void MSG_GetBytes(msg_t *msg, int where, unsigned __int8 *dest, int len);
int MSG_GetUsedBitCount(const msg_t *msg);
int MSG_GetNumBitsRead(const msg_t *msg);
void MSG_SetBookmark(const msg_t *msg, msg_bookmark_t *bookmark);
void MSG_GotoBookmark(msg_t *msg, const msg_bookmark_t *bookmark);
int MSG_ReadBit(msg_t *msg);
void showHuffmanData();
void MSG_RecordHuffmanDistribution();
int MSG_ReadBitsCompress(const unsigned __int8 *from, int fromSizeBytes, unsigned __int8 *to, int toSizeBytes);
void MSG_Embed(msg_t *dest, msg_t *src);
void MSG_UnEmbed(msg_t *msg);
void MSG_WriteByte(msg_t *msg, int c);
void MSG_WriteData(msg_t *buf, const void *data, int length);
void MSG_WriteFloat(msg_t *msg, float f);
void MSG_WriteAngle(msg_t *sb, int bits, float f);
void MSG_WriteAngle16(msg_t *sb, float f);
void MSG_WriteRangedFloatBits(msg_t *sb, float f, float begin, float end, int bits);
void MSG_WriteRiceGolomb(msg_t *sb, unsigned int c, int mbits);
void MSG_WriteExpGolomb0(msg_t *sb, unsigned int q);
void MSG_WriteSignedExpGolomb0(msg_t *sb, int c);
void MSG_WriteSignedExpGolomb(msg_t *sb, int c, int kbits);
void MSG_WriteSignedNonZeroExpGolomb0(msg_t *sb, int c);
void MSG_WriteSignedNonZeroExpGolomb(msg_t *sb, int c, int kbits);
void MSG_WriteBits64(msg_t *msg, __int64 value, int bits);
void MSG_WriteInt64(msg_t *msg, unsigned __int64 c);
void MSG_WriteString(msg_t *sb, const char *s);
void MSG_WriteBigString(msg_t *sb, const char *s);
int MSG_ReadByte(msg_t *msg);
int MSG_ReadShort(msg_t *msg);
int MSG_ReadLong(msg_t *msg);
unsigned __int64 MSG_ReadInt64(msg_t *msg);
double MSG_ReadFloat(msg_t *msg);
char *MSG_ReadString(msg_t *msg, char *string, unsigned int maxChars);
char *MSG_ReadBigString(msg_t *msg);
char *MSG_ReadStringLine(msg_t *msg, char *string, unsigned int maxChars);
double MSG_ReadAngle(msg_t *msg, int bits);
double MSG_ReadAngle16(msg_t *msg);
double MSG_ReadRangedFloatBits(msg_t *sb, float begin, float end, int bits);
int MSG_ReadRiceGolomb(msg_t *msg, int mbits);
int MSG_ReadExpGolomb0(msg_t *msg);
int MSG_ReadSignedExpGolomb0(msg_t *msg);
int MSG_ReadSignedNonZeroExpGolomb(msg_t *msg, int kbits);
int MSG_ReadSignedNonZeroExpGolomb0(msg_t *msg);
int MSG_ReadBits64(msg_t *msg, int bits);
void MSG_ReadData(msg_t *msg, void *data, int len);
void MSG_WriteDeltaKey(msg_t *msg, int key, int oldV, int newV, int bits);
int MSG_ReadDeltaKey(msg_t *msg, int key, int oldV, int bits);
void MSG_WriteKey(msg_t *msg, int key, int newV, int bits);
unsigned int MSG_ReadKey(msg_t *msg, int key, int bits);
void MSG_WriteDeltaKeyByte(msg_t *msg, int key, int oldV, int newV);
int MSG_ReadDeltaKeyByte(msg_t *msg, int key, int oldV);
void MSG_WriteDeltaKeyShort(msg_t *msg, int key, int oldV, int newV);
int MSG_ReadDeltaKeyShort(msg_t *msg, int key, int oldV);
int MSG_ReadDeltaTime(msg_t *msg, int timeBase);
int MSG_ReadDeltaEventField(msg_t *msg);
int MSG_ReadDeltaEventParamField(msg_t *msg);
int MSG_ReadEFlags(msg_t *msg, const int oldFlags);
double MSG_ReadOriginFloat(int bits, msg_t *msg, float oldValue);
double MSG_ReadOriginZFloat(msg_t *msg, float oldValue);
double MSG_ReadRangedFloat(;
int MSG_ReadEntityIndex(msg_t *msg, int indexBits);
void MSG_InitHuffman();
int MSG_ReadValueNoXor(msg_t *msg, const int bits);
int MSG_ReadValue(msg_t *msg, const int *fromF, int *toF, const int bits, const int size);
double MSG_ReadDeltaAngle(msg_t *msg, const float oldFloat);
int MSG_ReadLastChangedField(msg_t *msg, int totalFields);
int MSG_ReadNumFieldsSkipped(msg_t *msg, const int skippedFieldBits, const int maxVal);
void MSG_CopyFieldOver(const NetField *stateFields, const void *from, void *to, const int fieldNum);
void MSG_ReadDeltaFields(;
int MSG_ReadDeltaStruct(;
;
int MSG_ReadDeltaClient(;
int MSG_ReadDeltaActor(;
int MSG_ReadDeltaEntity(;
void MSG_Init(msg_t *buf, unsigned __int8 *data, int length);
void MSG_InitReadOnly(msg_t *buf, unsigned __int8 *data, int length);
void MSG_InitReadOnlySplit(msg_t *buf, unsigned __int8 *data, int length, unsigned __int8 *data2, int length2);
void MSG_SetDefaultUserCmd(playerState_s *ps, usercmd_s *cmd);

//t6/code/src_noserver/qcommon/msg.h
void SetField(int *i, int size, int value);
int MSG_GetField(const int *i, int size);
__int64 MSG_GetField64(const __int64 *i, int size);

//t6/code/src_noserver/qcommon/msg_crc.cpp
int MSG_CRCNetFields();
void MsgCRC_Init();
unsigned int MsgCRC_NetFieldChecksum();

//t6/code/src_noserver/qcommon/msg_mp.cpp
int MSG_ReadBits(msg_t *msg, int bits);
void MSG_WriteBits(msg_t *msg, int value, int bits);
void MSG_WriteBit0(msg_t *msg);
void MSG_WriteBit1(msg_t *msg);
int MSG_WriteBitsCompress(;
void MSG_WriteShort(msg_t *msg, int c);
void MSG_WriteLong(msg_t *msg, int c);
void MSG_ClearLastReferencedEntity(msg_t *msg);
BOOL HasMeleeChargeChanged(const usercmd_s *from, const usercmd_s *to);
int MSG_ReadDeltaGroundEntity(msg_t *msg);
double MSG_ReadDemoRoundedFloat(msg_t *msg, int bits, float oldValue, int diffBits, int fullBits);
void MSG_ReadDeltaField(;
int MSG_ReadDeltaEntityStruct(;
int MSG_ReadDeltaArchivedEntity(;
void MSG_ReadDeltaHudElems(msg_t *msg, const int time, const hudelem_s *from, hudelem_s *to, int count);
void MSG_ReadDeltaPlayerstate(;
void MSG_DumpNetFieldChanges_f();
void MSG_ReadDeltaUsercmdKey(msg_t *msg, int key, const usercmd_s *from, usercmd_s *to);
void MSG_WriteDeltaUsercmdKey(;

//t6/code/src_noserver/qcommon/net.h
void NET_ClearNetAdrIP(netadr_t *src);
void NET_CopyNetAdrIP(const netadr_t *src, netadr_t *dst);

//t6/code/src_noserver/qcommon/net_chan.cpp
char *NET_AdrToString(netadr_t a);
char *NET_AdrToStringDW(netadr_t a);
void NetProf_PrepProfiling(netProfileInfo_t *prof);
void NetProf_AddPacket(netProfileStream_t *pProfStream, int iSize, int bFragment);
void NetProf_NewRecievePacket(netchan_t *pChan, int iSize, int bFragment);
void NetProf_UpdateStatistics(netProfileStream_t *pStream);
void Net_DumpProfile_f();
void Net_GetQPort_f();
void Net_SetQPort_f();
void Net_DisplayProfile(LocalClientNum_t localClientNum);
void TRACK_net_chan();
void Netchan_Init(int port);
void Netchan_Setup(;
unsigned __int8 *Netchan_BorrowBuffer(netchan_t *chan, int size);
void Netchan_ReturnBuffer(netchan_t *chan, unsigned __int8 *ptr);
int NET_CompareBaseAdrSigned(netadr_t *a, netadr_t *b, bool skipLocalClient);
BOOL NET_CompareBaseAdr(netadr_t a, netadr_t b);
BOOL NET_CompareIPAdr(netadr_t a, netadr_t b);
int NET_CompareAdrSigned(netadr_t *a, netadr_t *b);
BOOL NET_CompareAdr(netadr_t a, netadr_t b);
BOOL NET_CompareXNAddr(XNADDR *a, XNADDR *b);
BOOL NET_IsLocalAddress(const netadr_t adr);
BOOL NET_IsLocalIP(const netadr_t adr);
BOOL NET_IsZeroIP(const netadr_t adr);
void NET_SetNetAdrLoopbackIP(netadr_t *src);
int NET_GetLoopPacket(netsrc_t sock, netadr_t *net_from, msg_t *net_message);
void NET_SendLoopPacket(netsrc_t sock, int length, const void *data, netadr_t to);
void NET_DeferPacketToClient(netadr_t *net_from, msg_t *net_message);
bool NET_GetDeferredClientPacket(netadr_t *net_from, msg_t *net_message);
void NET_DeferNonVoicePacket(netadr_t *net_from, msg_t *net_message);
bool NET_GetNonVoiceDeferred(netadr_t *net_from, msg_t *net_message);
bool NET_SendPacket(netsrc_t sock, int length, const void *data, netadr_t to);
bool NET_OutOfBandPrint(netsrc_t sock, netadr_t adr, const char *data);
BOOL NET_OutOfBandData(netsrc_t sock, netadr_t adr, const unsigned __int8 *format, int len);
BOOL NET_OutOfBandVoiceData(netsrc_t sock, netadr_t adr, unsigned __int8 *format, int len);
int NET_StringToAdr(const char *s, netadr_t *a);
void Int64ToString(__int64 int64, char *str);
void XUIDToString(const unsigned __int64 *xuid, char *str);
void XUIDToStringDecimal(const unsigned __int64 *xuid, char *str);
void StringToXUID(const char *str, unsigned __int64 *xuid);
void StringToXUIDDecimal(const char *str, unsigned __int64 *xuid);
void ByteArrayToString(const void *from, unsigned int fromSize, char *to, unsigned int toSize);
void StringToByteArray(const char *from, unsigned int fromSize, void *to, unsigned int toSize);
void XNAddrToString(const XNADDR *xnaddr, char *str);
void StringToXNAddr(const char *str, XNADDR *xnaddr);
unsigned __int16 Sys_Checksum(const unsigned __int8 *src, int len);
unsigned __int16 Sys_ChecksumCopy(unsigned __int8 *dest, const unsigned __int8 *src, int len);
// int Sys_VerifyPacketChecksum@<eax>(int a1@<edx>, const unsigned __int8 *payload, int paylen);
// unsigned int Sys_CheckSumPacketCopy@<eax>(;
char *XNKEYToString(const bdSecurityKey *xnkey);
char *XNAddrToString(const XNADDR *xnaddr);
int Netchan_TransmitFragment(netchan_t *chan, int fragmentLength, int fragmentIndex, int maxFragmentIndex);
bool Netchan_TransmitNextFragment(netchan_t *chan);
bool Netchan_Transmit(netchan_t *chan, int length, const unsigned __int8 *data, bool reliable_fragments);
int Netchan_Process(netchan_t *chan, msg_t *msg);
int NET_GetClientPacket(netadr_t *net_from, msg_t *net_message);
int NET_GetServerPacket(netadr_t *net_from, msg_t *net_message);
char *XSessionToString(const XSESSION_INFO *info);

//t6/code/src_noserver/qcommon/net_queue.cpp
PacketQueueEntry *PacketQueueBlock_Enqueue(;
bool PacketQueueBlock_Dequeue(PacketQueueBlock *block);
PacketQueueEntry *PacketQueueBlock_Peek(PacketQueueBlock *block);
bool PacketQueue_AddTailBlock(PacketQueue *queue);
void PacketQueue_RemoveHeadBlock(PacketQueue *queue);
PacketQueueEntry *PacketQueue_Peek(PacketQueue *queue);
PacketQueueEntry *PacketQueue_EnqueueInternal(;
bool PacketQueue_DequeueInternal(PacketQueue *queue);
PacketQueueEntry *PacketQueue_Enqueue(;
bool PacketQueue_Dequeue(;
void NET_InitQueues();
void NET_InitQueue(PacketQueue *queue, const char *name, bool emulation);
bool NET_DequeuePacket(;
bool NET_EnqueuePacket(PacketQueue *queue, unsigned int flags, netsrc_t sock, const netadr_t *addr, int length);
void NET_QueueCmd();

//t6/code/src_noserver/qcommon/qdb_load_db.h
void Load_Qdb(bool atStreamStart);
void Load_QdbPtr(bool atStreamStart);
void Mark_QdbPtr();

//t6/code/src_noserver/qcommon/radiant_remote.cpp
char *GetPairValue(const SpawnVar *spawnVar, const char *key);
void AddSavedCommand(const RadiantCommand *command);
void G_RegisterGUID(int guid, GUIDType type, void *data);
void G_FindGUID(int guid, GUIDType *type, void **data);
void RadiantRemoteInit();
gentity_t *G_FindEntity(int guid);
bool IsEntityType(const SpawnVar *spawnVar);
void G_ClearSelectedEntity();
bool G_IsSpawnPoint(const char *classname);
void G_ProcessEntityCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void G_ProcessCameraCommand(SpawnVar *spawnVar);
int G_FindMiscModel(const vec3_t *origin);
void G_ProcessMiscModelCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void G_ClearSelectedMiscModel();
int G_FindCorona(const vec3_t *origin);
void G_ProcessCoronaCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void G_ClearSelectedCorona();
void G_NotifyScriptsOfSelectedScriptStruct(unsigned int structId);
unsigned int G_FindStruct(SpawnVar *spawnVar);
void G_ProcessScriptStructCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void G_ClearSelectedScriptStruct();
void CG_NotifyScriptsOfSelectedScriptStruct(unsigned int structId);
unsigned int CG_FindStruct(SpawnVar *spawnVar);
void CG_ProcessScriptStructCommand(const RadiantCommand *command, SpawnVar *spawnVar);
void CG_ClearSelectedScriptStruct();
void G_RadiantDebugDraw();
void G_ClearSelection(void (*ignoreFunc)());
void CG_ClearSelection(void (*ignoreFunc)());
char CG_ProcessRadiantCmds();
int GetCommandProcessorType(const SpawnVar *spawnVar);
void G_ProcessRadiantCmd(const RadiantCommand *command);
char G_ProcessRadiantCmds();
void RunSavedRadiantCmds();

//t6/code/src_noserver/qcommon/rawfile_load_db.h
void Load_RawFile(bool atStreamStart);
void Load_RawFilePtr(bool atStreamStart);
void Mark_RawFilePtr();

//t6/code/src_noserver/qcommon/scriptparsetree_load_db.h
void Load_ScriptParseTree(bool atStreamStart);
void Load_ScriptParseTreePtr(bool atStreamStart);
void Mark_ScriptParseTreePtr();

//t6/code/src_noserver/qcommon/slug_load_db.h
void Load_Slug(bool atStreamStart);
void Load_SlugPtr(bool atStreamStart);
void Mark_SlugPtr();

//t6/code/src_noserver/qcommon/statmonitor.cpp
void StatMon_GetStatsArray(const statmonitor_s **array, int *count);
void StatMon_Reset();

//t6/code/src_noserver/qcommon/stream.cpp
int Stream_GetNextFileID();
void Stream_DoneWithFileID(int id);
stream_status Stream_GetStatus(int id);
void Stream_AddToQueue(streamInfo *newStreamInfo);
void Stream_RemoveFromQueue(;
char Stream_IsCancelledReadInProgress();
void Stream_CloseFile(int handle);
bool Stream_AddRequest(;
char Stream_AddCallbackOnlyRequest(;
char Stream_FreeRequest(int id, bool freeEvenIfLoadInProgress);
bool Stream_LoadFileSynchronously(streamInfo *stream);
void Stream_ProcessOpenRequests(callbackInfo *callbacks, int *numCallbacks);
streamInfo *Stream_GetNextStreamToLoad();
void __noreturn Stream_Thread(unsigned int threadContext);
void Stream_Shutdown();
void Stream_InternalSyncCallback(int id, stream_status result, unsigned int numBytesRead, void *user);
unsigned int Stream_Easy_Read(int handle, void *buf, unsigned int bufferSize, unsigned int *bytesRead);
unsigned int Stream_Easy_Tell(int handle);
unsigned int Stream_Easy_FileSize(int handle);
void Stream_ClumpCloseFile(int fhandle);
char Stream_ClumpSeekToFile(int fhandle, const char *filename, unsigned int *fileSize);
void *Stream_ClumpReadFile(int fhandle, const char *filename, HunkUser *hunk, unsigned int *bytesRead);
unsigned int SplitPath(const char *path, PathItem *items);
int PathItem_Path_r(PathItem *item, char **output, int outputLen);
int Stream_FindOverridePath(const char *original, char *result, int resultLength);
int Stream_OpenFile(const char *name, int flags);
bool Stream_Init();
int Stream_ClumpOpenFile(const char *clump);

//t6/code/src_noserver/qcommon/stream_platform.cpp
void Stream_CheckLockedFile(const char *name);
void Stream_SeekInternal(void *fh, unsigned __int64 offset);
char Stream_ReadInternal(;
void Stream_CloseInternal(void *fh);
int CG_Destructible_GetModelIndexFromLabel();
int Stream_OpenInternal(const char *name, int flags, void **fh, __int64 *fileSize);

//t6/code/src_noserver/qcommon/stringed_remote.cpp
char *GetString(const char *PackageAndStringReference);
char ProcessStringEdCmds();

//t6/code/src_noserver/qcommon/sv_msg_write.cpp
void TRACK_msg();
void MSG_LoopThroughFields(const NetFieldList *fieldToCheck);
void MSG_CheckForDuplicateOffsets();
const NetFieldList *MSG_GetStateFieldListForEntityType(const int eType, bool isDemoSnapshot);
const NetFieldList *MSG_GetNetFieldList(netFieldTypes_t fieldType, bool isDemoSnapshot);
void MSG_WriteReliableCommandToBuffer(;
void MSG_WriteOriginFloat(;
void MSG_WriteOriginZFloat(;
void MSG_WriteDemoRoundedFloat(msg_t *msg, int bits, float value, float oldValue, int diffBits, int fullBits);
bool MSG_CompareRangedFloat(;
bool MSG_ValuesAreEqual(const ClientNum_t clientNum, int bits, int size, const int *fromF, const int *toF);
bool MSG_ShouldSendPsViewAngles(;
bool MSG_ShouldSendPSField(;
void MSG_WriteEntityIndex(const SnapshotInfo_s *snapInfo, msg_t *msg, const int index, const int indexBits);
void MSG_WriteLastChangedField(msg_t *msg, const int lastChangedFieldNum, int numFields);
void MSG_WriteDeltaTime(const ClientNum_t clientNum, msg_t *msg, int timeBase, int time);
void MSG_WriteDeltaFrameTime(const ClientNum_t clientNum, msg_t *msg, int timeBase, int time);
void MSG_WriteEFlags(const ClientNum_t clientNum, msg_t *msg, const int oldFlags, const int newFlags);
void MSG_WriteEventNum(const ClientNum_t clientNum, msg_t *msg, int eventNum);
void MSG_WriteEventParam(const ClientNum_t clientNum, msg_t *msg, int eventParam);
int MSG_HighBitNumber(unsigned int v);
int MSG_WriteRangedFloat(;
PacketEntityType MSG_GetPacketEntityTypeForEType(int eType);
void MSG_EncodeSkippedFields(;
void MSG_WriteValueNoXor(const SnapshotInfo_s *snapInfo, msg_t *msg, int value, const int bits);
void MSG_WriteValue(;
void MSG_WriteDeltaAngle(;
// bool MSG_WriteDeltaField_Internal@<al>(;
bool MSG_WriteDeltaField(;
void MSG_WriteDeltaFields(;
void MSG_WriteEntityRemoval(;
int MSG_WriteEntityDeltaForEType(;
bool MSG_ShouldEntityFieldBeForcedSent(;
void MSG_GetEntityFieldInfoFlags(const entityState_s *es, EntityFieldInfoFlags *flags);
// char MSG_ShouldSendEntityField@<al>(;
void MSG_WriteDeltaClient(;
void MSG_WriteDeltaActor(;
BOOL MSG_WithinAllowedPredictionError(float dist, const playerState_s *to);
int MSG_GetLastChangedField(;
unsigned int MSG_GetBitFieldIndex(;
;
;
int MSG_WriteDeltaHudElems_LastChangedField(;
void MSG_WriteDeltaHudElems_ValidateHudElem(const hudelem_s *from, const hudelem_s *to);

//t6/code/src_noserver/qcommon/sv_msg_write_mp.cpp
bool MSG_EntityIsLinked(const entityState_s *ent);
void MSG_WriteGroundEntityNum(const ClientNum_t clientNum, msg_t *msg, const int groundEntityNum);
void MSG_WriteDeltaField_Default(;
int MSG_WriteDeltaStruct(;
int MSG_WriteAppendedDeltaStruct(;
void MSG_WriteEntityDeltaFields(;
int MSG_WriteEntityDelta(;
bool MSG_WriteDeltaArchivedEntity(;
void UpdateEntTimesForTimeDelta(entityState_s *ent, const int timeDelta);
void PrintChangedEntityFields(SnapshotInfo_s *snapInfo, const entityState_s *from, const entityState_s *to);
void SV_ValidateEntityState(const entityState_s *entState);
int MSG_WriteEntity(;
void MSG_WriteDeltaHudElems(;

//t6/code/src_noserver/qcommon/threads.cpp
void NET_Sleep(unsigned int timeInMs);
void Sys_SetEvent(void **event);
void Sys_ResetEvent(void **event);
void Sys_CreateEvent(int manualReset, int initialState, void **evt);
BOOL Sys_WaitForSingleObjectTimeout(void **event, unsigned int msec);
void Sys_WaitForSingleObject(void **event);
unsigned int Sys_GetCpuCount();
unsigned int Win_InitThreads();
void Sys_InitMainThread();
void Sys_InitThread(int threadContext);
unsigned int Sys_ThreadMain(void *parameter);
void Sys_CreateThread(void (*function)(unsigned int), unsigned int threadContext);
void Sys_TitleServerThreadData();
void Sys_InitDemoStreamingEvent();
void Sys_WaitForDemoStreamingEvent();
BOOL Sys_WaitForDemoStreamingEventTimeout(unsigned int msec);
void Sys_SetDemoStreamingEvent();
void Sys_InitWebMStreamingEvent();
void Sys_InitServerEvents();
void Sys_NotifyRenderer();
BOOL Sys_WaitServer(int timeout);
int Sys_IsDBPrintingSuppressed();
void Sys_StartGumpLoading();
int Sys_IsLoadingGump();
BOOL Sys_WaitForGumpLoad(int timeout);
BOOL Sys_WaitForGumpFlush(int timeout);
void Sys_WakeServer();
void Sys_ServerCompleted();
BOOL Sys_WaitStartServer(int timeout);
BOOL Sys_IsServerThread();
void Sys_DatabaseCompleted();
void Sys_WaitStartDatabase();
BOOL Sys_IsDatabaseReady();
void Sys_WakeDatabase();
void Sys_NotifyDatabase();
void Sys_DatabaseCompleted2();
BOOL Sys_IsDatabaseReady2();
void Sys_WakeDatabase2();
BOOL Sys_IsRenderThread();
BOOL Sys_IsMainThread();
int Sys_GetThreadContext();
void Sys_SetValue(int valueIndex, void *data);
void *Sys_GetValue(int valueIndex);
void Sys_SetWin32QuitEvent();
BOOL Sys_QueryWin32QuitEvent();
void Sys_SetRGRegisteredEvent();
BOOL Sys_QueryRGRegisteredEvent();
void Sys_SetRenderEvent();
void Sys_SetD3DShutdownEvent();
BOOL Sys_QueryD3DShutdownEvent();
char Sys_SpawnStreamThread();
void Sys_StreamSleep();
void Sys_ResetSndInitializedEvent();
BOOL Sys_QueryStreamPaused();
void Sys_WakeStream();
BOOL Sys_IsStreamThread();
void Sys_SetServerAllowNetworkEvent();
void Sys_ResetServerAllowNetworkEvent();
void Sys_SetServerNetworkCompletedEvent();
void Sys_ResetServerNetworkCompletedEvent();
void Sys_WaitServerNetworkCompleted();
unsigned int Sys_GetDefaultWorkerThreadsCount();
char Sys_SpawnServerThread();
char Sys_SpawnDatabaseThread();
void Sys_InitWorkerThreadContext();
void Sys_RenderCompleted();
void Sys_FrontEndSleep();
void Sys_WakeRenderer(void *data);
void Sys_SleepServer();
void Sys_SyncDatabase();
const char *Sys_GetCurrentThreadName();
void Sys_WaitAllowServerNetworkLoop();
void Sys_GumpPrint(const char *fmt, ...);
void Sys_GumpLoaded();
void Sys_GumpFlushed();

//t6/code/src_noserver/qcommon/threads_interlock.h
void Sys_LockWrite(FastCriticalSection *critSect);
void Sys_UnlockWrite(FastCriticalSection *critSect);

//t6/code/src_noserver/qcommon/tl_support.cpp
void TL_Warning(const char *Text);
bool TL_ReadFile();
void TL_ReleaseFile();
void TL_DebugPrint(const char *Text);
void *TL_MemAlloc(unsigned int Size, unsigned int Align);
void TL_MemFree(void *Ptr);
void TL_CriticalError(const char *msg);
void Sys_SetupTLCallbacks(int hunkMemSize);

//t6/code/src_noserver/qcommon/xglobals_load_db.h
void Load_gump_info_tArray(bool atStreamStart, int count);
void Load_overlay_info_tArray(bool atStreamStart, int count);
void Load_XGlobals(bool atStreamStart);
void Load_XGlobalsPtr(bool atStreamStart);
void Mark_XGlobalsPtr();

//t6/code/src_noserver/qcommon/zbarrier_load_db.h
void Mark_ZBarrierBoardArray(int count);
void Mark_ZBarrierDefPtr();
void Load_ZBarrierBoardArray(bool atStreamStart, int count);
void Load_ZBarrierDef(bool atStreamStart);
void Load_ZBarrierDefPtr(bool atStreamStart);

//t6/code/src_noserver/qcommon/zbarrier_load_obj.cpp
void ZBarrierDef_Strcpy(unsigned __int8 *pMember, const char *pKeyValue);
bool G_ZBarrierUpdateField(const char *zbarrierName, const char *keyValue);

//t6/code/src_noserver/ragdoll/ragdoll.cpp
void TRACK_ragdoll();
RagdollDef *Ragdoll_BodyDef(RagdollBody *body);
DObj *Ragdoll_BodyDObj(RagdollBody *body);
centity_t *Ragdoll_BodyPose(RagdollBody *body);
void Ragdoll_BodyRootOrigin(RagdollBody *body, vec3_t *origin);
void Ragdoll_GetRootOrigin(int ragdollHandle, vec3_t *origin);
void Ragdoll_SetFlag(int ragdollHandle, int flag, bool val);
bool Ragdoll_BindDef(int ragdollDef);
void Ragdoll_TransferBody(centity_t *from, centity_t *to);
void Ragdoll_InitDvars();
void Ragdoll_Register();
void Ragdoll_Init();
void Ragdoll_Shutdown();
;
int *Ragdoll_ReferenceDObjBody(int dobj);
int Ragdoll_CountPhysicsBodies();
RagdollBody *Ragdoll_GetUnusedBody();
void Ragdoll_FreeBody(int ragdollBody);
RagdollBody *Ragdoll_CreateRagdollForDObj(;
void Ragdoll_Remove(int ragdoll);

//t6/code/src_noserver/ragdoll/ragdoll.h
BOOL Ragdoll_BodyPoseValid(RagdollBody *body);

//t6/code/src_noserver/ragdoll/ragdoll_cmds.cpp
bool Ragdoll_ReadAxis(int arg, vec3_t *dest);
bool Ragdoll_ReadGeomType(int arg, BoneDef *bone);
bool Ragdoll_ReadJointType(int arg, JointDef *joint);
void Ragdoll_BaseLerpBone_f();
void Ragdoll_PinBone_f();
void Ragdoll_ResetBodiesUsingDef();
void Ragdoll_Clear_f();
void Ragdoll_Bone_f();
void Ragdoll_Joint_f();
void Ragdoll_Limit_f();
void Ragdoll_Selfpair_f();
void Ragdoll_InitCommands();

//t6/code/src_noserver/ragdoll/ragdoll_controller.cpp
BoneOrientation *Ragdoll_BodyBoneOrientations(RagdollBody *body);
BoneOrientation *Ragdoll_BodyPrevBoneOrientations(RagdollBody *body);
void Ragdoll_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);

//t6/code/src_noserver/ragdoll/ragdoll_quat.cpp
void Ragdoll_QuatMul(const vec4_t *qa, const vec4_t *qb, vec4_t *dest);
void Ragdoll_QuatInverse(const vec4_t *src, vec4_t *dest);
void Ragdoll_QuatPointRotate(const vec3_t *p, const vec4_t *q, vec3_t *dest);
void Ragdoll_Mat33ToQuat(const vec3_t *axis, vec4_t *quat);
void Ragdoll_QuatToAxisAngle(const vec4_t *quat, vec3_t *axisAngle);
void Ragdoll_QuatLerp(const vec4_t *qa, const vec4_t *qb, const float t, vec4_t *dest);
void Ragdoll_QuatMulInvSecond(const vec4_t *qa, const vec4_t *qb, vec4_t *dest);

//t6/code/src_noserver/ragdoll/ragdoll_update.cpp
void Ragdoll_CopyMirrorQuat(const vec4_t *src, bool mirror, vec4_t *dest);
bool Ragdoll_GetDObjWorldBoneOriginQuat(;
void Ragdoll_PoseInvAxis(const cpose_t *pose, vec3_t *invAxis);
void Ragdoll_AnimMatToMat43(const DObjAnimMat *mat, vec3_t *out);
void Ragdoll_SnapshotBaseLerpBones(RagdollBody *body, BoneOrientation *snapshot);
void Ragdoll_SnapshotBonePositions(RagdollBody *body, BoneOrientation *boneSnapshot);
void Ragdoll_SetCurrentPoseFromSnapshot(RagdollBody *body, BoneOrientation *snapshot);
char Ragdoll_ValidateBodyObj(RagdollBody *body);
void Ragdoll_DestroyPhysObjs(RagdollBody *body);
void Ragdoll_SnapshotBaseLerpOffsets(RagdollBody *body);
void Ragdoll_RemoveBodyPhysics(RagdollBody *body);
char Ragdoll_RebindBody(int ragdollHandle);
bool Ragdoll_ValidatePrecalcBoneDef(RagdollDef *def, BoneDef *bone);
void Ragdoll_Launch(;
void Ragdoll_SetInitialVelocities(RagdollBody *body);
void Ragdoll_EstimateInitialVelocities(RagdollBody *body);
void Ragdoll_Attach(;
bool Ragdoll_BoneTrace(trace_t *trace, trace_t *revTrace, const vec3_t *start, const vec3_t *end);
void Ragdoll_PrintTunnelFail(RagdollBody *body);
void Ragdoll_DebugRender(RagdollBody *body);
bool Ragdoll_CheckIdle(RagdollBody *body, int msec);
char Ragdoll_EnterDead(RagdollBody *body);
char Ragdoll_ExitDead(RagdollBody *body);
char Ragdoll_ExitDObjWait(RagdollBody *body, RagdollBodyState prevState, RagdollBodyState curState);
char Ragdoll_BodyNewState(RagdollBody *body, RagdollBodyState state);
void Ragdoll_BodyUpdate(int msec, RagdollBody *body);
void Ragdoll_SnapshotAnimOrientations(RagdollBody *body, BoneOrientation *snapshot);
bool Ragdoll_CreatePhysObj(RagdollBody *body, BoneDef *boneDef, Bone *bone);
bool Ragdoll_CreatePhysJoints(RagdollBody *body);
char Ragdoll_CreatePhysObjs(RagdollBody *body);
bool Ragdoll_CreateBodyPhysics(RagdollBody *body);
void Ragdoll_LaunchUpdate(RagdollBody *body);
;
char Ragdoll_EnterTunnelTest(RagdollBody *body);
void Ragdoll_UpdateVelocityCapture(RagdollBody *body);
void Ragdoll_UpdateFriction(RagdollBody *body);
char Ragdoll_ExitIdle(RagdollBody *body, RagdollBodyState curState, RagdollBodyState newState);
// char Ragdoll_EnterIdle@<al>(RagdollBody *body);
void Ragdoll_UpdateDObjWait(RagdollBody *body);
char Ragdoll_EnterDobjWait(RagdollBody *body);
// void Ragdoll_UpdateRunning(int a1@<edx>, RagdollBody *a2@<ecx>, RagdollBody *body);
void Ragdoll_Update(int msec);
void Ragdoll_RemoveConstraintsForRope(int rope_id);
// phys_free_list<RagdollBody>::T_internal_base *Ragdoll_GetRBForBone(int entnum, unsigned int boneName);
void Ragdoll_ExplosionEvent(;
void Ragdoll_JetThrustEvent(;

//t6/code/src_noserver/renderer/tr_types.h
void FX_SetMarkContextModelType_EntModel(GfxMarkContext *context, int dobjModelIndex, bool isViewmodel);

//t6/code/src_noserver/riotshield/riotshield.cpp
void Riotshield_RegisterDvars(int a1, dvarType_t a2);
void BG_SetRiotshieldModel(playerState_s *ps, bool redShader);
;

//t6/code/src_noserver/riotshield/riotshield_client.cpp
BOOL CG_EntityIsDeployedRiotshield(const centity_t *cent);
BOOL CG_EntityNumIsDeployedRiotshield(LocalClientNum_t localClientNum, int entnum);

//t6/code/src_noserver/riotshield/riotshield_server.cpp
gentity_t *G_DeployRiotshield(gentity_t *owner, gentity_t *shield_ent);
BOOL G_EntityIsDeployedRiotshield(const gentity_t *ent);
int G_RefreshRiotshieldAttach(gentity_t *player);

//t6/code/src_noserver/server/sv_client.cpp
bool SV_DoWeHaveAllStatsPackets(client_t *cl, int numCompressedPackets);
void SV_ReceiveStats(netadr_t from, msg_t *msg);
void SV_CacheClientStatChange(ClientNum_t clientNum, ddlState_t *searchState);
void SV_SetClientStat(ClientNum_t clientNum, ddlState_t *searchState, ddlValue_t value);
void SV_SetClientInt64Stat(ClientNum_t clientNum, ddlState_t *searchState, unsigned __int64 value);
void SV_SetClientFixedPointStat(ClientNum_t clientNum, ddlState_t *searchState, float value);
void SV_SetClientStringStat(ClientNum_t clientNum, ddlState_t *searchState, const char *value);
int SV_GetClientStat(ClientNum_t clientNum, ddlState_t *searchState, ddlValue_t *result);
int SV_GetClientIntStat(ClientNum_t clientNum, ddlState_t *searchState);
const GfxViewParms *SV_GetClientStringStat(ClientNum_t clientNum, ddlState_t *searchState);
ddlValue_t SV_GetClientInt64Stat(ClientNum_t clientNum, ddlState_t *searchState);
double SV_GetClientFixedPointStat(ClientNum_t clientNum, ddlState_t *searchState);
void SV_UploadStatsForClient(ClientNum_t clientNum);
void SV_UploadStats();
void SV_AuthClient(netadr_t from, msg_t *msg);
void SV_LogConfigStrings();
void SV_WriteConfigStrings(msg_t *msg);

//t6/code/src_noserver/server/sv_game.cpp
playerState_s *SV_GameClientNum(int num);
svEntity_s *SV_SvEntityForGentity(const gentity_t *gEnt);
void SV_GameSendServerCommand(ClientNum_t clientNum, svscmd_type type, const char *text);
void SV_GameDropClient(ClientNum_t clientNum, const char *reason);
void SV_SetMapCenter(vec3_t *mapCenter);
vec3_t *SV_GetMapCenter();
void SV_SetGameEndTime(int gameEndTime);
bool SV_SetBrushModel(gentity_t *ent);
BOOL SV_inSnapshot(const vec3_t *origin, int iEntityNum);
void SV_GetServerinfo(char *buffer, int bufferSize);
void SV_LocateGameData(;
void SV_GetUsercmd(ClientNum_t clientNum, usercmd_s *cmd);
void *SV_AllocXModelPrecache(int size);
void *SV_AllocXModelPrecacheColl(int size);
XModel *SV_XModelGet(const char *name);
void SV_DObjDumpInfo(gentity_t *ent);
void SV_ResetSkeletonCache();
char *SV_AllocSkelMemory(unsigned int size);
int SV_DObjCreateSkelForBone(DObj *obj, int boneIndex);
int SV_DObjCreateSkelForBones(DObj *obj, int *partBits);
void SV_DObjUpdateServerTime(gentity_t *ent, float dtime, int bNotify);
void SV_DObjInitServerTime(gentity_t *ent, float dtime);
int SV_DObjGetBoneIndex(const gentity_t *ent, unsigned int boneName);
int SV_DObjGetParentBoneIndex(const gentity_t *ent, int childBoneIndex);
DObjAnimMat *SV_DObjGetMatrixArray(const gentity_t *ent);
void SV_DObjDisplayAnim(gentity_t *ent, const char *header);
DObjAnimMat *SV_DObjGetRotTransArray(const gentity_t *ent);
int SV_DObjSetRotTransIndex(const gentity_t *ent, int *partBits, int boneIndex);
void SV_DObjGetBounds(gentity_t *ent, vec3_t *mins, vec3_t *maxs);
XAnimTree_s *SV_DObjGetTree(gentity_t *ent);
BOOL SV_MapExists(const char *name);
BOOL SV_DObjExists(gentity_t *ent);
void SV_track_shutdown();
void SV_SavePaths(unsigned __int8 *buf, int size);
int SV_GetGuid(ClientNum_t clientNum);
int SV_GetClientPing(ClientNum_t clientNum);
BOOL SV_IsLocalClient(ClientNum_t clientNum);
char SV_AllClientsAreLocal();
void SV_SetGametype();
void SV_InitGameVM(int restart, int registerDvars, int savegame);
void SV_ShutdownGameVM(int clearScripts);
void SV_RestartGameProgs(int savepersist);
void SV_InitGameProgs(int savepersist, int savegame);
int SV_GameCommand();
const char *SV_Archived_Dvar_GetVariantString(const char *dvarName);
int SV_Archived_Dvar_GetInt(int dvarHash);
double SV_Archived_Dvar_GetFloat(int dvarHash);
;
void SV_ShutdownGameProgs();

//t6/code/src_noserver/server/sv_main.cpp
void SV_MatchEnd();
void SVC_Info(;
void SVC_Info(netadr_t from);
char SVC_Info(netadr_t from);

//t6/code/src_noserver/server/sv_main_dw.cpp
void SV_Live_RemoveClient(client_t *cl, const char *reason);

//t6/code/src_noserver/server/sv_migration.cpp
bool SV_IsMigrating();
int SV_MigrationIsWaitingForPlayers();
void SV_MigrationReset();
void SV_MigrationInit();
netadr_t *ClientRemoteAddr(const ClientNum_t clientNum);
bool IsClientConnected(const ClientNum_t clientNum);
bool SendToClient(const ClientNum_t clientNum, const unsigned __int8 *data, int len);
void SendStartMessage(const ClientNum_t clientNum);
void CreateBlock(const int blockNum, Block *block);
bool SendBlock(const ClientNum_t clientNum, Block *block);
void SendSave();
void SendMigrateTo(const ClientNum_t clientNum);
void SendHeader();
void PickNewHost();
int SV_GetMigrationCount();
void SV_MigrationStart(const char *reason);
bool HasTimedOut(const ClientNum_t clientNum);
void TimedOut(const ClientNum_t clientNum);
void __thiscall CheckTimeouts(void *this);
void SendMigrateToMessages();
void SendFrame();
void SV_MigrationUpdateCount(const int count);
void SV_MigrationFrame();
void HandleRatingMsg(const ClientNum_t clientNum, msg_t *msg);
void HandleSaveAckMsg(const ClientNum_t clientNum, msg_t *msg);
void HandleHeaderAckMsg(const ClientNum_t clientNum);
void HandleMigrateToAckMsg(const ClientNum_t clientNum);
char SV_MigrationPacket(const char *cmd, netadr_t from, msg_t *msg);
void SV_MigrationEnd();

//t6/code/src_noserver/server/sv_snapshot.cpp
void SV_EmitPacketClients(;
void SV_EmitPacketActors(;
void SV_UpdateServerCommandsToClient(client_t *client, msg_t *msg);
void SV_UpdateServerCommandsToClient_PreventOverflow(client_t *client, msg_t *msg, int iMsgSize);
void SV_PrintServerCommandsForClient(client_t *client);
int SV_SnapshotRateHeuristic();
int SV_AdjustRateForClient(client_t *client, int rateMsec);
void SV_ResetRecordMessageSize();
void SV_RecordMessageSize(int compressedSize, int uncompressedSize);
void SV_SendMessageToClient(msg_t *msg, client_t *client, bool reliable);
void SV_BeginClientSnapshot(client_t *client, msg_t *msg, unsigned __int8 *buffer, int bufferSize);
void SV_EndClientSnapshot(client_t *client, msg_t *msg);
void SV_SetServerStaticHeader();
void SV_GetServerStaticHeader();

//t6/code/src_noserver/server/sv_snapshot_stats.cpp
int SV_AddModifiedStatsWithinOffset(ClientNum_t clientNum, int startOffset, int *endOffset, msg_t *msg);
void SV_StatSign_Init();
void SV_CalcStatsHash(;
unsigned __int8 (*getCachedStatsHashForClient(client_t *client))[24];
signedStatsHash_t *getCachedSignedStatsHashForClient(client_t *client);
char SV_StatSign_SetCheckSumForClient(client_t *client);
void actionOnBadStats(;
void SV_SignedStats_Breadcrumb(client_t *client);
;
void SV_AddModifiedStats(ClientNum_t clientNum);

//t6/code/src_noserver/server/sv_world.cpp
unsigned int SV_ClipHandleForEntity(const gentity_t *ent);
void SV_UnlinkEntity(gentity_t *gEnt);
void SV_TraceCapsuleToEntity(const moveclip_t *clip, svEntity_s *check, trace_t *trace);
void SV_TracePointToEntity(const pointtrace_t *clip, svEntity_s *check, trace_t *trace);
int SV_SightTraceCapsuleToEntity(const sightclip_t *clip, int entnum);
void SV_SetupIgnoreEntParams(IgnoreEntParams *ignoreEntParams, int baseEntity);
BOOL SV_SightTraceCapsule(;
BOOL SV_SightTracePoint(int *hitNum, const vec3_t *start, const vec3_t *end, col_context_t *context);
int SV_PointContents(const vec3_t *p, int passEntityNum, int contentmask);
;
;
;
void SV_TraceCapsule(;
void G_TraceCapsule(;
void G_LocationalTrace(;
void G_LocationalTraceAllowChildren(;

//t6/code/src_noserver/server_mp/sv_archive_mp.cpp
int GetFollowPlayerStateLocal(ClientNum_t clientNum, playerState_s *ps);
void SV_ArchiveSnapshot(msg_t *msg);

//t6/code/src_noserver/server_mp/sv_ccmds_mp.cpp
char SV_CheckMapExists(const char *map);
client_t *SV_GetPlayerByName();
client_t *SV_GetPlayerByNum();
char *SV_GetMapBaseName(const char *mapname);
void ShowLoadErrorsSummary(const char *mapName, unsigned int count);
void SV_Map_f();
void SV_ReconnectClients(int savepersist);
void SV_MapRestart(int fast_restart);
void SV_MapRestart_f();
void SV_FastRestart_f();
int SV_KickClient(client_t *cl, char *playerName, int maxPlayerNameLen);
int SV_KickUser_f(char *playerName, int maxPlayerNameLen);
client_t *SV_KickClient_f(char *playerName, int maxPlayerNameLen);
void SV_KickClientForReason_f();
void SV_TempBan_f();
void SV_Ban_f();
void SV_BanNum_f();
void SV_Drop_f();
void SV_DropNum_f();
void SV_TempBanNum_f();
void SV_Status_f();
void SV_AssembleConSayMessage(int firstArg, char *text, int sizeofText);
void SV_ConSay_f();
void SV_TeamStatus_f();
void SV_ConTell_f();
void SV_Heartbeat_f();
void SV_Serverinfo_f();
void SV_Systeminfo_f();
void SV_DumpUser_f();
void SV_KillServer_f();
void SV_ScriptUsage_f();
void SV_ScriptVarUsage_f_usage();
void SV_ScriptVarUsage_f();
;
void SV_SetPerk_f();
void SV_HostMigrationStart_f();
void SV_SendNoDelta_f();
void SV_SendNewBaseline_f();
void SV_AddDedicatedCommands();
void SV_AddOperatorCommands();

//t6/code/src_noserver/server_mp/sv_client_mp.cpp
int SV_CountClients();
void SV_GetChallenge(netadr_t from);
void SV_UpdateSplitscreenStateForAddr(netadr_t addr);
int SV_GetPlayerXuid(ClientNum_t clientNum);
void SV_FreeClientScriptPers();
void SV_SendDisconnect(client_t *client, int state, const char *reason);
void SV_DelayDropClient(client_t *drop, const char *reason);
void SV_ClientEnterWorld(client_t *client, usercmd_s *cmd);
void SV_VerifyIwds_f(client_t *cl);
void SV_ResetPureClient_f(client_t *cl);
void SV_SynchronizePlayerInfoForClients();
char SV_ValidateName(client_t *newcl, const char *name);
BOOL SV_SanitizeName(const char *name, char *sanitizedName, int size);
bool SegmentIntersectsSphere(;
double SV_FX_GetVisibility(const vec3_t *start, const vec3_t *end);
void SV_FX_SetVisBlocker(const gentity_t *ent, float radius);
void SV_FX_FreeVisBlocker(const gentity_t *ent);
void SV_ExecuteClientCommand(client_t *cl, const char *s, int clientOK, int fromOldServer);
void SV_ClientThink(client_t *cl, usercmd_s *cmd);
BOOL SV_IsTestClient(ClientNum_t clientNum);
void SV_FreeClient(client_t *cl);
void SV_FreeClients();
void SV_DropClient(client_t *drop, const char *reason, bool tellThem);
void SV_SendClientGameState(client_t *client);
void SV_Disconnect_f(client_t *cl);
void SV_UserinfoChanged(client_t *cl);
void SV_UpdateUserinfo_f(client_t *cl);
int SV_ProcessClientCommands(client_t *cl, msg_t *msg, int fromOldServer, int *lastCommand);
void SV_BanClient(client_t *cl);
void ReconnectMigratedClient(;
void SV_DirectConnect(netadr_t from);
void SV_MigrateTestClient(client_t *cl);
;
void SV_UserMove(client_t *cl, msg_t *msg, int delta);
void SV_ExecuteClientMessage(client_t *cl, msg_t *msg);

//t6/code/src_noserver/server_mp/sv_connection_log.cpp
void SV_ConnectionLog_SetMatchID(unsigned __int64 matchID);
ClientRecord *SV_ConnectionLog_NewClient(int clientNum);
int SV_ConnectionLog_NewSample(;
void SV_ConnectionLog_Init();
void SV_ConnectionLog_Upload();

//t6/code/src_noserver/server_mp/sv_init_mp.cpp
void SV_GetConfigstring(int index, char *buffer, int bufferSize);
unsigned int SV_GetConfigstringConst(int index);
void SV_SetUserinfo(int index, const char *val);
void SV_GetUserinfo(int index, char *buffer, int bufferSize);
void SV_BoundMaxClients(int minimum);
void SV_Startup();
void SV_ChangeMaxClients();
void SV_SetExpectedHunkUsage(char *mapname);
void SV_ClearServer();
void SV_InitArchivedSnapshot();
void SV_AllocateClientMemory(HunkUser *hunk, int maxLocalClients, int maxClients, int allocFlags);
void SV_FreeClientMemory(HunkUser *hunk);
BOOL SV_Loaded();
void SV_Init();
void SV_FinalMessage(const char *message);
void SV_DropAllClients();
void SV_Shutdown(const char *finalmsg);
void SV_ClearServerThreadOwnsGame();
void SV_IncServerThreadOwnsGame();
void SV_DecServerThreadOwnsGame();
void SV_CheckThread();
void SV_SetConfigstring(int index, const char *val);
void SV_SetConfigValueForKey(int start, int max, const char *key, const char *value);
void SV_SetXUIDConfigStrings();
void SV_SaveSystemInfo();
void SV_SpawnServer(ControllerIndex_t controllerIndex, const char *server, int mapIsPreloaded, int savegame);

//t6/code/src_noserver/server_mp/sv_main_mp.cpp
void TRACK_sv_main();
char *SV_ExpandNewlines(char *in);
int SV_IsFirstTokenEqual(const char *str1, const char *str2);
// int SV_CanReplaceServerCommand@<eax>(const char *a1@<edx>, client_t *client, const char *cmd);
void SV_CullIgnorableServerCommands(client_t *client);
void SV_AddServerCommand(;
void SV_SendServerCommand(client_t *cl, svscmd_type type, const char *fmt, ...);
client_t *SV_FindClientByAddress(netadr_t from, int qport);
void SVC_Status(netadr_t from);
char SVC_Ping(netadr_t from, msg_t *payload);
char SVC_Status(netadr_t from);
// char SVC_StatusScoreBoard@<al>(const char *a1@<edi>, netadr_t from);
char SVC_ClientUIDs(netadr_t from);
void SV_ConnectionlessPacket(netadr_t from, msg_t *msg);
void SV_PacketEvent(netadr_t from, msg_t *msg);
void SV_CalcPings();
bool SV_DoISuckAsHost();
void SV_ReportClientPings();
void SV_UpdateServerBoostingStats();
void SV_PrintRateBoostingDebugScores(bool boostWasEnabled);
bool SV_DoISuckSoMuchIShouldQuit();
void SV_FreeClientScriptId(client_t *cl);
int SV_CheckPaused();
void SV_UpdatePerformanceFrame(int time);
void SV_RunFrame();
void SV_RunEventLoop();
int SV_Perf_RecordPings();
void SV_InitSnapshot();
void SV_KillLocalServer();
char SV_CheckOverflow();
void SV_PreFrame();
void SV_AllowPackets(const bool allow);
unsigned int SV_GetAssignedTeam(ClientNum_t clientNum);
void SV_SetAssignedTeam(ClientNum_t clientNum, int team);
const char *SV_GetCustomTeamName(int team);
void SV_Live_RemoveAllClientsFromAddress(client_t *cl, const char *reason);
void SV_CheckTimeouts();
void SV_PostFrame();
void SV_WaitServer();
void SV_FrameInternal(ControllerIndex_t controllerIndex, int msec);
int SV_Frame(ControllerIndex_t controllerIndex, int msec);
void SV_UpdateBots();
void __noreturn SV_ServerThread(unsigned int threadContext);
void SV_InitServerThread();

//t6/code/src_noserver/server_mp/sv_main_pc_mp.cpp
int SV_GetSlotForPasswordIfFree(const char *password);
void SV_FreeReservedSlot(int slot);
bool SV_IsServerRanked(int licensetype);
void SVC_RemoteCommand(netadr_t from);
char SV_SetGroupCountsComplete();
char SV_GetGroupCountsComplete();
char SV_GroupsFailure();
bool Com_IsClientConsole();
clientplatform_t Com_GetClientPlatform();
void SV_SysLog_Init();
void SV_SysLog_ForceFlush();
void enqueueSyslogMessage(const char *msg);
void SV_SysLog_LogMessage(int severity, const char *msg);
void SV_SysLog_LogMessage_f();
void checkHandlersAreInited();
int validateAndGetCmd(msg_t *pktMsg);
// void SV_Query_Pump(int a1@<ebp>);
// int SV_Query_SendTo@<eax>(unsigned __int8 *payload, int paylen, int cmd, netadr_t *to);
void SV_Perf_GetPerfVals(unsigned int perfBits, msg_t *msg);
void SV_Perf_Update(perfValType_t perfValType, unsigned int value);
perfVal_t *resetPerfCounters();
void SV_Perf_Frame();
// char SVC_Perf@<al>(netadr_t from, msg_t *payload);
void SV_AutoShutdown_Init();
void SV_AutoShutdown_Frame();
void SV_MarkServerForShutdown();
int SV_GetLicenseType();
void SV_GetGroupCounts();
void SV_Groups_ParseGeos(const char *geoblob);
void SV_Query_Init();

//t6/code/src_noserver/server_mp/sv_net_chan_mp.cpp
bool SV_Netchan_TransmitNextFragment(client_t *client, netchan_t *chan);
bool SV_Netchan_Transmit(client_t *client, unsigned __int8 *data, int length, bool reliable);
void SV_Netchan_AddOOBProfilePacket(int iLength);

//t6/code/src_noserver/server_mp/sv_snapshot_build_mp.cpp
void SV_ClearBaselineFlagForAllClients();
int SV_AddEntitiesClientsCanSee();
int SV_CreateBaseline();
void SV_SaveSnapshotForTime(const int serverTime);
int SV_AddCachedEntitiesClientsCanSee(const int entCount, int firstEntityIndex);
bool SV_SaveSnapshotForArchivedTime(const int archiveTime);
void SV_BuildClientSnapshot(client_t *client);

//t6/code/src_noserver/server_mp/sv_snapshot_caching_mp.cpp
bool SV_FrameIsStillInArchivedSnapshotBuffer(const int frameStart);
cachedSnapshot_t *SV_GetCachedSnapshotInternal(int archivedFrame, int depth, bool expectedToSucceed);
cachedSnapshot_t *SV_GetCachedSnapshot(int *pArchiveTime);
int SV_GetCurrentClientInfo(;
void SV_GetClientPositionsFromCachedSnap(;
bool SV_GetClientPositionsAtTimeInternal(;
bool SV_GetClientPositionsAtTimeFromClientPositionArchive(;
// bool SV_GetClientPositionsAtTime@<al>(;
int SV_GetArchivedClientInfo(;
char SV_HasCachedSnapshotInternal(int archivedFrame, int callDepth);
int SV_GetEarliestArchivedClientInfoTime();

//t6/code/src_noserver/server_mp/sv_snapshot_mp.cpp
const entityState_s *SV_GetNextEnt(const int entCount, const int firstEntIndex, int curIndex);
bool SV_EntLinkedToEnt(;
bool SV_ShouldEntityGoToClient(;
void SV_EmitPacketEntities_Debug(SnapshotInfo_s *snapInfo, int *quickBits, msg_t *msg, const char *str, ...);
void SV_EmitPacketEntities(;
void SV_WritePerformanceData(const ClientNum_t clientNum, msg_t *msg);
void SV_WriteSnapshotToClient(;
int SV_RateMsec();
void SV_SetServerStaticHeader_Project();
void SV_GetServerStaticHeader_Project();
;

//t6/code/src_noserver/server_mp/sv_snapshot_profile_mp.cpp
void MSG_PacketAnalyze_SetPacketEntityType(;
const char *SV_GetEntityTypeString(const int packetEntityType);
void SV_PacketAnalyze_TrackETypeBytes(;
void SV_PacketAnalyze_TrackPS_ClearBits(int bits);
void SV_PacketAnalyze_TrackPS_FieldDeltasBits(int bits);
void SV_PacketAnalyze_TrackPS_HudelemBits(int bits);
void SV_PacketAnalyze_TrackPS_StatsBits(int bits);
void SV_PacketAnalyze_TrackPS_WeaponBits(int bits);
void SV_PacketAnalyze_TrackPS_AmmoPoolBits(int bits);
void SV_PacketAnalyze_TrackPS_AmmoClipBits(int bits);
void SV_PacketAnalyze_TrackPS_ObjectivesBits(int bits);
void SV_PacketAnalyze_AddVOIPWrittenBits(int bits);
void SV_PacketAnalyze_AddVOIPReadBits(int bits);
int SV_PacketAnalyze_GetVOIPWrittenBits();
int SV_PacketAnalyze_GetVOIPReadBits();
void SV_PacketAnalyze_ClearVoipBits();
void SV_PacketAnalyze_AddDemoUploadBits(int bits);
int SV_PacketAnalyze_GetDemoUploadBits();
void SV_PacketAnalyze_ClearDemoUploadBits();
void SV_PacketAnalyze_AddClientUploadBits(ClientNum_t clientNum, int bits);
int SV_PacketAnalyze_GetClientUploadBits(ClientNum_t clientNum);
void SV_PacketAnalyze_ClearClientUploadBits();

//t6/code/src_noserver/sound/sd_api.cpp
sd_mix_master_param *SD_GetMixParam(sd_mix_master_param *param);
sd_voice_param *SD_GetVoiceParam(int voiceIndex);
void SD_PrefetchAliasId(unsigned int aliasId, int timeTillPlayMs);
void SD_PreUpdate();
unsigned int SD_StartAlias(SndStartAliasInfo *info, int voiceIndex);
void SD_StopVoice(int voiceIndex);
void SD_UpdateVoice(int voiceIndex);
void SD_Sync();
void SD_Shutdown();
void SD_SetAuxCallback(bool (*callback)(float *, unsigned int, unsigned int));
void SD_SetVcsCallback(bool (*callback)(float *, unsigned int, unsigned int, bool *));

//t6/code/src_noserver/sound/sd_decode.cpp
void SD_DecoderShutdown();
sd_decoder *SD_DecoderAllocate(;
// sd_decoder *SD_DecoderAllocate@<eax>(;

//t6/code/src_noserver/sound/sd_mixer.cpp
sd_mix_master_param *SD_MixParamAllocate();
void SD_MixParamFree(sd_mix_master_param *param);
void SD_MixSetParam(sd_mix_master_param *param);

//t6/code/src_noserver/sound/sd_output_xa2.cpp
// void sd_xa2_callback::OnBufferEnd(sd_xa2_callback *this, void *pBufferContext);
void SD_OutputShutdown(bool reset);
void SD_OutputForceWakeup();
bool SD_XAudio2GetDeviceGUID(wchar_t *inGUID, _GUID *guid, char *outGUID, int size);
bool SD_XAudio2CheckDevice(;
void SD_SwitchDevice();
// ;
// char SD_XAudio2EnumerateDevices@<al>(int a1@<esi>);
// bool SD_XAudio2InitPC@<al>(int a1@<esi>);
// void SD_OutputInit(int a1@<esi>, bool reset);
void SD_Reset();

//t6/code/src_noserver/sound/sd_source.cpp
void SD_SourceInitStream(;

//t6/code/src_noserver/sound/sd_stream.cpp
void SD_StreamShutdown();
void SD_StreamBufferPreload(;
sd_stream_globals *SD_StreamAllocate(;
void SD_StreamDevhost();

//t6/code/src_noserver/sound/sd_voice.cpp
void SD_VoiceShutdown();
sd_voice_param *SD_VoiceParamAllocate();
void SD_VoiceParamFree(sd_voice_param *p);
sd_voice *SD_VoiceAllocate();
sd_voice *SD_VoiceAllocateRam(;
sd_voice *SD_VoiceAllocateStream(;
void SD_VoiceSetParam(sd_voice *voice, sd_voice_param *param);
BOOL SD_VoiceHasData(sd_voice *voice);
void SD_VoiceStart(sd_voice *voice, sd_voice_param *param);
BOOL SD_VoiceStarted(sd_voice *voice);
BOOL SD_VoiceDone(sd_voice *voice);
__int64 SD_VoicePosition(sd_voice *voice);

//t6/code/src_noserver/sound/snd.cpp
void SND_SetPosition(int index, const vec3_t *org);
unsigned int SND_ActiveListenerCount();
int SND_GetListenerIndexNearestToOrigin(const vec3_t *origin, float *minDistanceSq);
int SND_AcquirePlaybackId();
void DoLengthNotify(int msec, void *lengthNotifyData, SndLengthType id);
void SND_StartLengthNotify(int index, int totalMsec);
double SND_GetSeed(unsigned int key, unsigned int global_age);
void SND_SetVoiceStartFlux(SndVoice *voice, vec3_t *player);
void SND_SetVoiceStartSeeds(const SndAlias *alias, SndVoice *voice);
void SND_SetVoiceStartFades(;
void SND_UpdateVoicePosition(SndVoice *voice, const vec3_t *startPosition);
char SND_LosOcclusionCache(unsigned int channel, const vec3_t *position, float *value);
void SND_SetSoundFileVoiceInfo(;
float Snd_GetGlobalPriorityVolume(const SndAlias *alias, const vec3_t *org, int localClientGroupMask);
void Snd_GetLowestPriority(float *priority, int *channel, unsigned int start, unsigned int count);
void SND_ContinueLoopingSound_Internal(;
unsigned int SND_ContinueLoopingSound(;
SndAlias *SND_PickSoundAliasFromList(const SndAliasList *aliasList, int objectId, SndEntHandle sndEnt);
SndAlias *SND_PickSoundAlias(const char *name, int objectid, SndEntHandle sndEnt);
bool SND_CheckValidSecondary(const SndAlias *alias, const SndAlias *secondaryAlias);
void SND_GetPlayingInfo(;
bool SND_IsSoloAlias(const SndAlias *alias);
bool SND_IsMuteAlias(const SndAlias *alias);
void SND_PauseSounds();
int *SND_UnpauseSounds();
unsigned int SND_GetCurrentReverb();
void SND_UpdateRoomEffects(int frametime);
void SND_UpdatePreloads();
void SND_StopVoicePFutz(int voiceIndex);
void SND_SetStartPaused(SndVoice *voice, bool pause);
int SND_Active();
void SNDL_AddGlobals(SndDriverGlobals *globals);
void SNDL_RemoveGlobals(SndDriverGlobals *globals);
void SND_ErrorIfSoundGlobalsTrashed();
void SND_Init();
;
double SND_GetPitch(SndVoice *voice);
double SND_GetBaseLevel(const SndVoice *voice);
float SND_GetDryLevel(const SndVoice *voice, float baseLevel);
float SND_GetWetLevel(const SndVoice *voice, float baseLevel);
void SND_GetLevels(const SndVoice *voice, float *wet, float *dry);
double SND_GetDistance(const SndVoice *voice);
double SND_GetLpfLevel(const SndVoice *voice);
unsigned int SND_GetVoiceLength(int voiceIndex);
double SND_GetOmni(const SndVoice *voice);
SndVoice *SND_GetPlaybackVoice(int playbackId);
SndDuckActive *SND_DuckFindFree();
void SND_DuckRateLimit(;
void SND_SetDuckByCategory(;
SndDuckActive *SND_DuckStartAlias(const SndDuck *duck);
void SND_StopDuck(SndDuckActive *duck);
void SND_DuckUpdate(float dt);
unsigned int SND_GetCurrentGfutzId();
// char SND_AddLengthNotify@<al>(;
void SND_ResetVoiceInfo(int index);
void SND_ContinueLoopingPlayback(int id);
void SND_StopVoice(int voiceIndex);
void SND_ShutdownVoices();
void SND_UpdateVoiceDuck(SndVoice *voice);
void SND_UpdateVoice(SndVoice *voice, float dt);
void SND_DuckReset();
void SND_SetVoiceStartInfo(int index, SndStartAliasInfo *SndStartAliasInfo);
// int SND_FindFreeVoice@<eax>(const vec3_t *a1@<edx>, float volume@<xmm0>, SndStartAliasInfo *startAliasInfo);
bool SND_Limit(;
char SND_LimitVoice(const SndAlias *alias, SndEntHandle ent);
// unsigned int SND_PlaySoundAlias@<eax>(;
;
// void SNDL_Update(float a1@<edi>);
void SNDL_Shutdown();
void SND_SetGlobalFutz(unsigned int id, SndCallLocation callLocation);
void SND_SetStartPaused(int playbackId, bool pause);
void SND_SetGlobalFutz(const char *futzName, SndCallLocation callLocation);

//t6/code/src_noserver/sound/snd_alias_db.h
unsigned int SND_AliasGetDryCurve(const SndAlias *alias);
unsigned int SND_AliasGetIgnoreMaxDist(const SndAlias *alias);
unsigned int SND_AliasGetPfutzStartAliasId();
unsigned int SND_AliasGetPfutzLoopAliasId();
unsigned int SND_AliasGetNeverPlayedTwice(const SndAlias *alias);
void SND_AliasSetNeverPlayedTwice(SndAlias *alias, bool played);
unsigned int SND_AliasHasPlayed(const SndAlias *alias);

//t6/code/src_noserver/sound/snd_alias_load_db.h
void Load_SndAliasArray(bool atStreamStart, int count);
void Load_SndAliasListArray(bool atStreamStart, int count);

//t6/code/src_noserver/sound/snd_asset_bank.cpp
void SND_ChecksumToString(const unsigned __int8 *checksum, char *string);
char SND_AssetBankValidateHeader(;
char SND_AssetBankValidateEntry(;
int SND_EntryCompare(const void *va, const void *vb);
char SND_AssetBankFindEntry(;
unsigned int SND_AssetBankGetFrameRate(const SndAssetBankEntry *entry);
unsigned int SND_AssetBankGetChannelCount(const SndAssetBankEntry *entry);
BOOL SND_AssetBankGetLooping(const SndAssetBankEntry *entry);
unsigned int SND_AssetBankGetFrameCount(const SndAssetBankEntry *entry);
unsigned int SND_AssetBankGetLengthMs(const SndAssetBankEntry *entry);
char SND_AssetBankFindEntry(unsigned int id, SndAssetBankEntry **entry, int *fid, bool streamed);

//t6/code/src_noserver/sound/snd_asset_bank_load_db.h
void Load_SndLoadedAssets(bool atStreamStart);

//t6/code/src_noserver/sound/snd_bank.cpp
int SND_CompareAssetLoads(const void *a, const void *b);
void SND_AddAssetToLoad(;
SndAssetToLoad *SND_FindNextAssetToLoad();
void SND_LoadAssetCallback(int id, stream_status result, unsigned int numBytesRead, void *b);
void SND_LoadAssetUpdate();
int SND_AllocateEntries(const char *bankName, int entryCount);
void SND_GetRuntimeAssetBankFileName(;
char SND_AssetBankFindStreamed(unsigned int id, SndAssetBankEntry **entry, int *fid);
char SND_AssetBankFindLoaded(unsigned int id, SndAssetBankEntry **entry, void **data);
bool SND_FindInIndex(unsigned int key, const SndBank *bank, SndAliasList **result);
void SND_AssertBankIndexValid(const SndBank *bank);
void SNDL_RemovePatch(SndPatch *patch);
int SND_AliasCount();
SndAliasList *SND_AliasByIndex(unsigned int index);
SndAliasList *SND_BankAliasLookup(unsigned int key);
SndAliasList *SND_BankAliasLookupCache(unsigned int id);
unsigned int SND_FindAliasId(const char *name);
int SND_GetPlaybackTime(const char *name);
const SndRadverb *SND_GetRadverb(unsigned int id);
SndAliasList *SND_FindAliasFromId(unsigned int id);
SndVolumeGroup *SND_FindRowGroup(unsigned int id);
SndCurve *SND_FindRowCurve(unsigned int id);
SndPan *SND_FindRowPan(unsigned int id);
// int gjk_base_t::get_brush();
const SndDuck *SND_GetDuckById(unsigned int id);
const SndDuck *SND_FindRowDuckPatchLpf(unsigned int id);
SndContext *SND_FindRowContext(unsigned int id);
const SndRadverb *SND_FindRowRadverb(unsigned int id);
SndMaster *SND_FindRowMaster(unsigned int id);
void SND_PatchValue(unsigned int table, char *asset, unsigned int fieldIndex, unsigned int value);
void SND_PatchDuckValue(;
void SND_PatchApply(const SndPatch *patch);
void SNDL_ResetAliases();
void SND_BankReadCallback(int id, stream_status result, unsigned int numBytesRead, void *b);
void SND_StreamRead(SndBank *bank, int fileHandle, int offset, int size, void *data);
char SND_StartHeaderRead(bool streamed, SndRuntimeAssetBank *assetBank, SndBank *bank);
char SND_HeaderCheck(SndBank *bank, SndRuntimeAssetBank *assetBank);
char SND_StartTocRead(SndBank *bank, SndRuntimeAssetBank *assetBank);
char SND_TocCheck(SndBank *bank, SndRuntimeAssetBank *assetBank);
void SND_BankLoadError(SndBank *bank);
unsigned int SND_GetAliasIdFromScriptId(const unsigned int scriptId);
void SND_EnqueueLoadedAssets(SndBank *bank);
void SNDL_AddBank(SndBank *bank);
void SNDL_RemoveBank(SndBank *bank);
void SNDL_AddPatch(SndPatch *patch);
void SNDL_ApplyPatches();
SndAliasList *SND_FindAlias(const char *name);
void SND_EnqueueAssetLoads(SndBank *bank);
void SND_BankLoadUpdateState(SndBank *bank);
void SND_LoadSoundsWait();
char SND_BankUpdate();
bool SND_IsAliasNameLooping(const char *name);
int SND_GetPlaybackTime();

//t6/code/src_noserver/sound/snd_bank_load_db.h
void Load_SndBank(bool atStreamStart);
void Load_SndBankPtr(bool atStreamStart);
void Load_SndPatch(bool atStreamStart);
void Load_SndPatchPtr(bool atStreamStart);
void Mark_SndBankPtr();
void Mark_SndPatchPtr();

//t6/code/src_noserver/sound/snd_debug.cpp
void SND_DebugFini();
void DebugDrawWorldSound3D(;
void SND_DebugDrawWorldSounds(int debugDrawStyle);
int SND_GetSoundOverlay(SndOverlayInfo *info, int start, int count);
int SND_GetSoundOverlay(SndOverlayType type, SndOverlayInfo *info, int maxcount);

//t6/code/src_noserver/sound/snd_dsp.cpp
void SND_DspSqr(unsigned int count, const float *a, float *c);
void SND_DspMul(unsigned int count, const float *a, float *b);
void SND_DspCube(unsigned int count, const float *a, float *c);
void SND_DspMin(unsigned int count, const float *a, const float *b, float *c);
void SND_DspMax(unsigned int count, const float *a, const float *b, float *c);
void SND_DspScale(unsigned int count, float a, float *c);
void SND_DspConstant(unsigned int count, float a, float *c);
void SND_DspAdd(unsigned int count, const float *a, const float *b, float *c);
void SND_DspSub(unsigned int count, const float *a, const float *b, float *c);
void SND_DspSub(unsigned int count, const float *a, float *c);
void SND_DspBiquadInPlace(;
void SND_DspBiquadNormalize(float *a, float *b, SndDspBiQuadCoef *coef);
;

//t6/code/src_noserver/sound/snd_dsp_radverb.cpp
void SND_RvParamsDefault(SndRvParams *params);

//t6/code/src_noserver/sound/snd_dvar.cpp
void SND_InitDvar(int a1, dvarType_t a2);

//t6/code/src_noserver/sound/snd_globals.cpp
BOOL SND_IsInitialized();
SndVolumeGroup *SND_GetGroupByIndex(unsigned int index);
SndMaster *SND_GetMaster(unsigned int id);
SndMaster *SND_GetMasterByConfig();
SndMaster *SND_GetMasterCurrent();
SndSidechainDuck *SND_GetVoiceDuck(unsigned int id);
SndSidechainDuck *SND_GetCurrentVoiceDuck();
SndFutz *SND_GetFutz(unsigned int id);
SndCurve *SND_GetCurveByIndex(unsigned int i);
SndPan *SND_GetPanByIndex(int i);
int SND_FindContextIndex(unsigned int type);
char SND_IsValidContext(unsigned int type, unsigned int value);
int SND_GetDuckGroupIndex(unsigned int id);
SndMenuCategory SND_GroupCategory(unsigned int group);
double SND_GroupGetAttenuation(unsigned int group);

//t6/code/src_noserver/sound/snd_load_db.h
void Load_SndDuckArray(bool atStreamStart, int count);
void Load_SndDriverGlobals(bool atStreamStart);
void Load_SndDriverGlobalsPtr(bool atStreamStart);
void Mark_SndDriverGlobalsPtr();

//t6/code/src_noserver/sound/snd_local.cpp
int SNDL_Play(;
void StopSoundAliasesOnEnt(SndEntHandle sndEnt, unsigned int name);
void SNDL_StopSoundAliasOnEnt(SndEntHandle sndEnt, unsigned int name);
void SNDL_StopSoundsOnEnt(SndEntHandle sndEnt);
void SNDL_DisconnectListener(LocalClientNum_t localClientNum);
void SNDL_SetListener(;
void SNDL_StopSounds(SndStopSoundFlags which);
void SNDL_FadeOut();
void SNDL_FadeIn();
void SNDL_SetEnvironmentEffects(;
void SNDL_DeactivateEnvironmentEffects(int priority, int fademsec);
void SNDL_SetPlaybackAttenuation(int playbackId, float attenuation);
void SNDL_SetPlaybackAttenuationRate(int playbackId, float rate);
void SNDL_SetPlaybackPitch(int playbackId, float pitch);
void SNDL_SetPlaybackPitchRate(int playbackId, float rate);
void SNDL_SetStartPaused(int playbackId, bool pause);
void SNDL_StopPlayback(int playbackId);
void SNDL_SetDuck(SndDuckCategoryType cat, unsigned int id, float amount);
void SNDL_SetSideChainDuck(unsigned int id);
void SNDL_SetScriptTimescale(float value);
void SNDL_PlayLoopAt(unsigned int id, const vec3_t *origin);
void SNDL_StopLoopAt(unsigned int id, const vec3_t *origin);
void SNDL_PlayLineAt(unsigned int id, const vec3_t *origin0, const vec3_t *origin1);
void SNDL_StopLineAt(unsigned int id, const vec3_t *origin0, const vec3_t *origin1);
;
int SNDL_GetPlaybackTime(int playbackId);
void SNDL_GameReset();
void SNDL_SetContext(unsigned int type, unsigned int value);
;
void SNDL_SetEntContext(SndEntHandle handle, unsigned int type, unsigned int value);
// void SNDL_UpdateLoopingSounds(SndListener *a1@<edi>);
void SNDL_SetMusicState(unsigned int id);
void SNDL_PrefetchLoadedAlias(unsigned int aliasId);
void SNDL_SetGlobalFutz(unsigned int id, SndCallLocation callLocation);
void SNDL_SetFrontendMusic(unsigned int musicAlias);
void SNDL_SetLoopState(;
void SNDL_PlayLoops(int count, const SndEntLoop *loops);
void SNDL_SetGameState(;

//t6/code/src_noserver/sound/snd_log.cpp
void SND_LogMissingAliasId(unsigned int hash);

//t6/code/src_noserver/sound/snd_occlusion.cpp
void SND_LosOcclusionUpdate();
void SND_LosOcclusionSync();
void SND_LosOcclusionFini();
;
;
;
double SND_LosOcclusionTrace(bool fancy, int *cache, const vec3_t *listener, const vec3_t *playback);
void SND_LosOcclusionDoTraces(;
void SND_LosOcclusionMultipleCmd(snd_occlusion_multiple *cmd);
int snd_occlusionCallback_Implementation(jqBatch *batch, void *data);
int snd_occlusionCallback(jqBatch *batch);

//t6/code/src_noserver/sound/snd_public_async.cpp
void SND_PlayInternal(;
void SND_Play(;
void SND_Play(;
void SND_StopSoundAliasOnEnt(SndEntHandle ent, unsigned int alias_name);
void SND_StopSoundsOnEnt(SndEntHandle ent);
void SND_NotifyCinematicStart(float volume);
void SND_NotifyCinematicEnd();
void SND_DisconnectListener(LocalClientNum_t listener);
void SND_SetListener(;
void SND_FadeIn();
void SND_FadeOut();
void SND_SetEnvironmentEffects(int priority, const char *preset, float drylevel, float wetlevel, int fademsec);
void SND_DeactivateEnvironmentEffects(int priority, int fademsec);
void SND_SetPlaybackAttenuation(int id, float attenuation);
void SND_SetPlaybackAttenuationRate(int id, float rate);
void SND_SetPlaybackPitch(int playbackId, float pitch);
void SND_SetPlaybackPitchRate(int playbackId, float rate);
void SND_StopPlayback(int playbackId);
void SND_SetDuck(SndDuckCategoryType type, const char *name, float length, float amount);
void SND_SetSideChainDuck(const char *name);
void SND_SetEntState(SndEntHandle handle);
void SND_PlayLoopAt(unsigned int id, const vec3_t *origin);
void SND_StopLoopAt(unsigned int id, const vec3_t *origin);
void SND_PlayLineAt(unsigned int id, const vec3_t *origin0, const vec3_t *origin1);
void SND_StopLineAt(unsigned int id, const vec3_t *origin0, const vec3_t *origin1);
void SND_SetContext(const char *type, const char *value);
void SND_RestartDriver();
void SND_SetEntContext(SndEntHandle handle, const char *type, const char *value);
void SND_SetEntContext(SndEntHandle handle, const unsigned int type, const unsigned int value);
void SND_SetScriptTimescale(float value);
void SND_SetMusicState(const char *state);
void SND_AddBank(SndBank *bank);
void SND_AddPatch(SndPatch *patch);
void SND_AddGlobals(SndDriverGlobals *globals);
bool SND_WhizbyPath(;
void SND_Whizby(;
SndEntState **SND_FindEntState(SndEntHandle handle, bool createNew);
void SNDL_SetEntState(;
void SND_ResetEntState();
;
void SND_SubtitleNotify(const char *subtitle, unsigned int lengthMs);
void SND_LengthNotify(unsigned int ent, unsigned int lengthMs);
void SND_FreePlaybackNotify(SndPlayback *playback);
void SND_BankLoadedNotify();
SndPlayback *SND_AllocatePlayback(unsigned int aliasId, SndEntHandle entHandle);
void SND_FreePlayback(SndPlayback *p);
SndPlayback *SND_FindPlayback(int playbackId);
bool SND_IsPlaying();
bool SND_GetKnownLength(int playbackId, int *msec);
// int SND_Frame@<eax>(float a1@<edi>);
// int updatesound_workerCallback_Implementation@<eax>(float a1@<edi>);
void SND_PossiblyUpdate(int minUpdateMs);
void SND_Update();
void __thiscall SND_UpdateWait(void *this);
void SND_GameReset();
void SND_BeginFrame(;
void SND_SetFrontendMusic(const char *musicAlias);
void SND_SetLoopState(;
void SND_PlayLoops(int count, const SndEntLoop *loops);
void SND_EndFrame();
void SND_Shutdown();
int SND_PlaybackBundle(;
int SND_Playback(;
int SND_Playback(;
void SND_StopSounds(SndStopSoundFlags flags);
void SND_RemoveBank(SndBank *bank);
void SND_RemovePatch(SndPatch *patch);
void SND_RemoveGlobals(SndDriverGlobals *globals);
char SND_GetEntPosition(SndEntHandle handle, vec3_t *origin, vec3_t *velocity, vec3_t *orientation);
void SND_EntStateFrame();
int updatesound_workerCallback(jqBatch *batch);

//t6/code/src_noserver/sound/snd_public_async_q.cpp
SndCommand *SND_GetNewCommand();
void SND_CommandFreeBatch(SndCommand *start, SndCommand *end, int count);
void SND_CommandPush(SndCommand *cmd);
SndCommand *SND_CommandPeek();
void SND_CommandPop();
void SND_CommandProcess(const SndCommand *cmd);
SndNotify *SND_GetNewNotify();
void SND_NotifyFree(SndNotify *p);
void SND_NotifyProcess(const SndNotify *cmd);
void SND_NotifyPush(SndNotify *cmd);
SndNotify *SND_NotifyPeek();
void SND_NotifyPop();
void SND_NotifyPump();
bool SND_ShouldMuteAllSounds();
;

//t6/code/src_noserver/sound/snd_utils.cpp
unsigned int __thiscall SND_GetSpeakerConfigCount(gjk_double_sphere_t *this);
SndSpeakerConfig *Snd_GetSpeakerConfig(unsigned int index);
int Snd_GetMixChannelCount(unsigned int speakerConfig);
double Snd_PanMono(float angle);
// void SND_EqualPowerFadeCoefs(float a1@<edi>, float t, float *a, float *b);
void SND_GetNearestPointOnSegment(;
void SND_GetNearestPointOnStrip(const vec3_t *point, const vec3_t *verts, unsigned int count, vec3_t *position);
const char *SND_GetAliasName(const SndAliasList *alias);
double SND_LinearToDbSpl(float linear);
int SND_HashName(const char *name);
void Snd_SpeakerMapZero(SndSpeakerMap *map);
int Snd_SpeakerMapGetIndex(const SndSpeakerMap *map, int in, int out);
double Snd_SpeakerMapGetVolume(const SndSpeakerMap *map, int in, int out);
double Snd_GetGlobalPriority(const SndAlias *alias, float volume);
double Snd_CurveEval(const SndCurve *curve, float x);
unsigned int SND_HashAlias(const SndAliasList *alias);
void Snd_PanStereo(float angle, float boost, float *left, float *right);
void Snd_Pan(unsigned int speakerCount, const float *angles, float toSound, float *levels);
void Snd_SpeakerMapSetVolume(SndSpeakerMap *map, int in, int out, float volume);
void SND_PanToSpeakermap11(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap12(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap16(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap18(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap21(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap22(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap26(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap28(const SndPan *pan, SndSpeakerMap *map);
void SND_PanToSpeakermap(;
void Snd_Pan3dFast(;
double Snd_DistanceCurveEval(;
void SND_FixupStereoPan(SndSpeakerMap *pan);
void Snd_Pan3d(;

//t6/code/src_noserver/sound/snd_utils.h
void SND_FaderSetRate(SndFader *fader, float r);
void SND_FaderSetRateTime(SndFader *fader, float time);
void SND_FaderSetGoal(SndFader *fader, float g);
void SND_FaderUpdate(SndFader *fader, float dt);

//t6/code/src_noserver/steam/steam.cpp
void Steam_CreateSteamAppIdFile();

//t6/code/src_noserver/stringed/stringed_hooks.cpp
void SEH_UpdateCurrentLanguage();
int SEH_GetCurrentLanguage();
void SEH_InitLanguage();
unsigned int SEH_VerifyLanguageSelection(int iLanguageSelection);
;
;
const char *SE_GetString_FastFile(const char *psPackageAndStringReference);
const char *SEH_StringEd_GetString(const char *pszReference);
const char *SEH_SafeTranslateString(const char *pszReference);
int SEH_GetLocalizedTokenReference(;
void SEH_ParseDirective(const char *directive, char *resultName, char *resultArg0);
void SEH_GetBindingForDirective(LocalClientNum_t localClientNum, const char *directive, char *result);
bool SEH_ReplaceDirective(;
int SEH_ReplaceDirectiveInStringWithBinding(;
const char *SEH_LocalizeTextMessage(;
int SEH_DecodeLetter(;
int SEH_ReadCharFromString(const char **text);
int SEH_PrintStrlen(const char *string);
const char *SEH_GetLanguageName(const int iLanguage);
const char *SEH_GetLanguageNameAbbr(const int iLanguage);
int SEH_StringEd_SetLanguageStrings(int iLanguage);
void SEH_TranslateMessage(;
void SEH_UpdateLanguageInfo();

//t6/code/src_noserver/stringed/stringed_ingame.cpp
// char *__thiscall CStringEdPackage::Filename_WithoutExt(CStringEdPackage *this, const char *psFilename);
// char *__thiscall CStringEdPackage::Filename_WithoutPath(CStringEdPackage *this, const char *psFilename);
// int __thiscall CStringEdPackage::CheckLineForKeyword(;
// char __thiscall CStringEdPackage::IsStringFormatCorrect(CStringEdPackage *this, const char *string);
// void __thiscall CStringEdPackage::REMKill(CStringEdPackage *this, char *psBuffer);
// int __thiscall CStringEdPackage::ReadLine(CStringEdPackage *this, const char **psParsePos, char *psDest);
// const char *SE_GetFoundFile(std::string *strResult);
// void __thiscall CStringEdPackage::SetupNewFileParse(CStringEdPackage *this, const char *psFileName);
// void __thiscall CStringEdPackage::SetString(;
// std::string *SE_GetString_LoadObj(const char *psPackageAndStringReference);
// std::string *__thiscall CStringEdPackage::ConvertCRLiterals_Read(;
// std::string *__thiscall CStringEdPackage::InsideQuotes(CStringEdPackage *this, std::string *result, const char *psLine);
// void __thiscall CStringEdPackage::Clear(CStringEdPackage *this);
void SE_NewLanguage();
// void __thiscall CStringEdPackage::AddEntry(CStringEdPackage *this, const char *psLocalReference);
void SE_Init();
void SE_ShutDown();
// const char *__thiscall CStringEdPackage::ParseLine(CStringEdPackage *this, const char *psLine, bool forceEnglish);
char *SE_Load(const char *psFileName, bool forceEnglish);
char *SE_LoadLanguage(bool forceEnglish);
char ReadLine(_iobuf *fp);

//t6/code/src_noserver/stringed/stringed_interface.cpp
unsigned __int8 *SE_LoadFileData(const char *psFileName);
void SE_FreeFileDataAfterLoad(unsigned __int8 *psLoadedFile);
// void SE_R_ListFiles(const char *psExtension, const char *psDir, std::string *strResults);
// int SE_BuildFileList(const char *psStartDir, std::string *strResults);

//t6/code/src_noserver/stringed/stringed_load_db.h
void Load_LocalizeEntry(bool atStreamStart);
void Load_LocalizeEntryPtr(bool atStreamStart);
void Mark_LocalizeEntryPtr();

//t6/code/src_noserver/tracers/tracer.cpp
void Tracer_Spawn_ApplyOverrides(;
void Tracer_Spawn(;
void Tracer_Draw(;
int Tracer_UpdateDrawRate(const LocalClientNum_t localClientNum, const Weapon weapon, centity_t *attackerEnt);
TracerDef *Tracer_FindTracer(const char *tracerName);

//t6/code/src_noserver/tracers/tracer_load_db.h
void Mark_TracerDefPtr();
void Load_TracerDef(bool atStreamStart);
void Load_TracerDefPtr(bool atStreamStart);

//t6/code/src_noserver/tracers/tracer_load_obj.cpp
int Tracer_GetStringArrayIndex(const char *value, const char **stringArray, int arraySize);
// int BG_ParseTracerDefSpecificFieldType@<eax>(;
int Tracer_ValidateDef(const char *tracerFilePath, const TracerDef *trDef);
void Tracer_Load_StringCopy(char **strDest, const char *strSrc);
void Tracer_Load_StringCopy_BatchInternal(char **a1, const char *a2);
int Tracer_Load_ParseFile(const char *name, TracerDef *trDef);
TracerDef *Tracer_Load(const char *name);
TracerDef *Tracer_Register_LoadObj(const char *name);
TracerDef *Tracer_Register_FastFile(const char *name);
TracerDef *Tracer_Register(const char *name);
// bool BG_TracerUpdateField@<al>(;

//t6/code/src_noserver/turret/turret_placement.cpp
int Turret_PlaceTurret_UpdateFooting(;
;
;
int Turret_PlaceTurret_Client(;
int Turret_PlaceTurret_Server(playerState_s *ps, vec3_t *outOrigin, vec3_t *outAngles, gentity_t *turret);

//t6/code/src_noserver/ui/ui_atoms.cpp
void UI_DrawHandlePic(;
void UI_DrawHandlePicRotated(;
void UI_DrawHandlePicFramed(;
double UI_LoadBarProgress_LoadObj();
double UI_LoadBarProgress_FastFile();
void UI_ForceFullLoadBar(bool force);
void UI_DrawLoadBar(;
void UI_FillRectPhysical(float x, float y, float width, float height, const vec4_t *color);
void UI_FillRect(;
void UI_DrawSpinner(;
void UI_DrawSpinnerLoadbar(;

//t6/code/src_noserver/ui/ui_codtv.cpp
void UI_Codtv_Init();
codtvType_e UI_Codtv_GetType(const char *typeString);
codtvImageCategory_e UI_Codtv_GetImageCategory(const char *categoryString);
void UI_Codtv_FilterAll(codtvDWContent_t *content);
void UI_Codtv_FilterSelf(codtvDWContent_t *content);
void UI_Codtv_FilterOtherPlayer(codtvDWContent_t *content);
void UI_Codtv_FilterFriends(codtvDWContent_t *content);
void UI_Codtv_FilterPooled(codtvDWContent_t *content);
void UI_Codtv_FilterUser(codtvDWContent_t *content);
void UI_Codtv_FilterFilms(codtvDWContent_t *content);
void UI_Codtv_FilterClips(codtvDWContent_t *content);
void UI_Codtv_FilterScreenshots(codtvDWContent_t *content);
void UI_Codtv_FilterCustomGames(codtvDWContent_t *content);
void UI_Codtv_FilterEmblems(codtvDWContent_t *content);
void UI_Codtv_FilterBookmarked(codtvDWContent_t *content);
void UI_Codtv_FilterVictories(codtvDWContent_t *content);
void UI_Codtv_FilterHighestRated(codtvDWContent_t *content);
void UI_Codtv_FilterTrending(codtvDWContent_t *content);
void UI_Codtv_FilterStaffPick(codtvDWContent_t *content);
void UI_Codtv_FilterClan(codtvDWContent_t *content);
void UI_Codtv_FilterLeagueTeam(codtvDWContent_t *content);
void UI_Codtv_FilterIngameStore(codtvDWContent_t *content);
char UI_Codtv_ReadFolderContentDW(codtvFolder_t *folder);
char UI_Codtv_ReadFolderContentVideo(codtvFolder_t *folder);
char UI_Codtv_ReadCustomButtonAction(codtvFolder_t *folder);
char UI_Codtv_ReadFolderContent(codtvFolder_t *folder);
char UI_Codtv_ReadFolderType(codtvFolder_t *folder);
char UI_Codtv_ReadFolderImage(codtvFolder_t *folder);
char UI_Codtv_ReadFolderRef(codtvFolder_t *folder);
char UI_Codtv_ReadFolderName(codtvFolder_t *folder);
char UI_Codtv_ReadFolder(codtvFolder_t *parent);
char UI_Codtv_ReadRootVersion();
char UI_Codtv_ParseHeader();
bool UI_Codtv_ParseMenuFile(unsigned __int8 *buffer, jsmntok_t *parseTokens);
void UI_Codtv_Parse(unsigned __int8 *buffer);

//t6/code/src_noserver/ui/ui_emblem.cpp
emblemDownloadData_t *UI_EmblemPool_Get(unsigned __int64 fileID);
void UI_EmblemClampLayer(CompositeEmblemLayer *layer);
void UI_DrawCustomEmblem(UIContextIndex_t contextIndex, const rectDef_s *rect, const vec4_t *color);
void UI_DrawEmblemSelector(;
void UI_DrawEmblemIconThumbnail(UIContextIndex_t contextIndex, const rectDef_s *rect, const vec4_t *color);
void UI_EmblemUpdate();
int UI_EmblemGetSelectedLayer();
bool UI_EmblemCanOutlineLayer(int layer);
BOOL UI_EmblemCanDuplicateLayer(ControllerIndex_t controllerIndex);
void UI_EmblemDuplicate_f();
const GfxViewParms *UI_EmblemGetLayerName(int layer);
__int16 UI_EmblemGetSelectedBackgroundID();
const char *UI_EmblemGetStateDisplay(ControllerIndex_t controllerIndex, int idx);
char *UI_EmblemGetCategoryDisplay(ControllerIndex_t controllerIndex, int idx);
int UI_EmblemGetFilterCount(ControllerIndex_t controllerIndex, int state, int category);
__int16 UI_EmblemGetFilterIconID(ControllerIndex_t controllerIndex, int state, int category, int index);
bool UI_EmblemUpload_SetMetada(;
void UI_EmblemUploadToSlotSuccess(const ControllerIndex_t controllerIndex, unsigned __int64 fileID);
void UI_EmblemUploadToSlotFailure(const ControllerIndex_t controllerIndex);
void UI_EmblemUploadToSlot(const ControllerIndex_t controllerIndex, int slot, bool setToProfile);
void UI_EmblemSetName(const char *name);
void UI_EmblemSetDescription(const char *description);
void UI_EmblemClearUploadInfo_f();
void UI_EmblemSelect_f();
void UI_EmblemReset_f();
void UI_EmblemClear_f();
void UI_EmblemDelete_f();
void UI_EmblemClearAll_f();
void UI_EmblemClearClipboard_f();
void UI_EmblemRotate_f();
void UI_EmblemMove_f();
void UI_EmblemScale_f();
void UI_EmblemIcon_f();
void UI_EmblemSetSelectedLayerIconId_f();
void UI_EmblemSetEmptyBoxIconId_f();
void UI_EmblemPalette_f();
void UI_EmblemOutline_f();
void UI_EmblemToggleOutline_f();
void UI_EmblemFlip_f();
void UI_EmblemToggleFlip_f();
void UI_EmblemLayerIncreaseOpacity_f();
void UI_EmblemLayerDecreaseOpacity_f();
void UI_EmblemLayerSetOpacity_f();
void UI_EmblemSetScaleMode_f();
void UI_EmblemMoveLayer(ControllerIndex_t controllerIndex, int targetz);
void UI_EmblemSetLayerColorRGB_f();
void UI_EmblemSetSelectedRecentColor_f();
void UI_EmblemSetRecentColorRGBA_f();
void UI_EmblemSetRGBTweakedColor_f();
void UI_EmblemMoveLayer_f();
void UI_EmblemMoveLayerRelative_f();
void UI_EmblemCopy_f();
void UI_EmblemCopyLayer_f();
void UI_EmblemPasteLayer_f();
void UI_EmblemRevertColorChanges_f();
void UI_EmblemBeginEdit_f();
void UI_EmblemEndEdit_f();
void UI_EmblemSelectBackground_f();
void UI_EmblemDump_f();
;
void UI_EmblemSetAsDefault_f();
void UI_EmblemSetFromDefault_f();
void UI_EmblemUploadToSlot_f();
void UI_EmblemLoadFromFile_f();
void UI_EmblemSetLeagueIdentity_f();
void UI_EmblemSetClanIdentity_f();
void UI_EmblemMoveUpRepeatEnabled_f();
void UI_EmblemMoveDownRepeatEnabled_f();
void UI_EmblemMoveLeftRepeatEnabled_f();
void UI_EmblemMoveRightRepeatEnabled_f();
void UI_EmblemScaleUpRepeatEnabled_f();
void UI_EmblemScaleDownRepeatEnabled_f();
void UI_EmblemRotateLeftRepeatEnabled_f();
void UI_EmblemRotateRightRepeatEnabled_f();
void UI_EmblemRepeatBttnsLooseFocus_f();
void UI_EmblemSetPosition_f();
void UI_EmblemShowFileID_f();
vec4_t *UI_GetSlectedSwatchElementColor(vec4_t *result, int row, int column, int totalRows, int totalColumns);
void UI_EmblemSetLayerColorFromSwatch_f();
void UI_EmblemRegisterCmds();

//t6/code/src_noserver/ui/ui_feeders.cpp
void UI_BuildPlayerList(LocalClientNum_t localClientNum);
int UI_FeederCount(;
void UI_FeederItemColor(;
void UI_ResetSelectedPlayerXuid();
void UI_OverrideCursorPos_Gamemodes(UIContextIndex_t contextIndex, listBoxDef_s *listPtr);
void UI_OverrideCursorPos_Servers(;
char UI_OverrideKeyPress(;
void UI_OverrideCursorPos_DynamicMenu(UIContextIndex_t contextIndex, listBoxDef_s *listPtr);
// int UI_OverrideCursorPos_Default@<eax>(;
void UI_OverrideCursorPos(LocalClientNum_t localClientNum, UIContextIndex_t contextIndex, itemDef_s *item);
void UI_FeederSelection(;
bool UI_FeederDataExtended_DynamicMenu(;
bool UI_FeederDataExtended(;
void UI_AddToFeeder(itemDef_s *item, const char *eventName, int argCount, const char **args);
void UI_AddToFeederExtended(;
void UI_ChangeRowStatus(itemDef_s *item, int rowToChange, int newStatus);
void UI_ClearFeeder(UIContextIndex_t contextIndex, itemDef_s *item, bool resetCursorPos);
bool UI_FeederData(;
const char *UI_FeederItemText_DynamicMenu(;
void UI_RaiseFeederEvent(LocalClientNum_t localClientNum, itemDef_s *item, const char *eventName);
// const char *UI_FeederItemText@<eax>(;

//t6/code/src_noserver/ui/ui_friends.cpp
void UI_FriendsRegisterDvars();

//t6/code/src_noserver/ui/ui_keyboard.cpp
void UI_SetActiveKeyboardType(int keyboardType);
void UI_Keyboard_ClanTagEntered(LocalClientNum_t localClientNum, const char *clanTag);
BOOL UI_Keyboard_ParseEmail(const char *address);
void UI_Keyboard_CheckValidEmail();
void UI_Keyboard_EmailEntry_f();
void UI_KeyboardComplete(LocalClientNum_t localClientNum);
void UI_Keyboard_Complete_f();
void UI_Keyboard_Cancel_f();
void UI_Keyboard_New_f();

//t6/code/src_noserver/ui/ui_local.h
void UI_ClearUIVisibilityBit(LocalClientNum_t localClientNum, int bit);
BOOL UI_CheckUIVisibilityBit(LocalClientNum_t localClientNum, int bit);

//t6/code/src_noserver/ui/ui_localvars.cpp
void UILocalVar_Init(UILocalVarContext *context);
void UILocalVar_Shutdown(UILocalVarContext *context);
char UILocalVar_FindLocation(UILocalVarContext *context, const char *name, unsigned int *hashForName);
const UILocalVar *UILocalVar_Find(UILocalVarContext *context, const char *name);
UILocalVar *UILocalVar_FindOrCreate(UILocalVarContext *context, const char *name);
BOOL UILocalVar_GetBool(const UILocalVar *var);
// UILocalVar::<unnamed_type_u> UILocalVar_GetInt(const UILocalVar *var);
double UILocalVar_GetFloat(const UILocalVar *var);
char *UILocalVar_GetString(const UILocalVar *var, char *stringBuf, int size);
void UILocalVar_SetBool(const UILocalVar *var, bool b);
void UILocalVar_SetInt(const UILocalVar *var, int i);
void UILocalVar_SetFloat(const UILocalVar *var, float f);
void UILocalVar_SetString(const UILocalVar *var, const char *s);

//t6/code/src_noserver/ui/ui_main.cpp
UiContext *UI_UIContext_GetInfo(UIContextIndex_t contextIndex);
UiContext *UI_GetInfo(LocalClientNum_t localClientNum);
UILocalVarContext *UI_UIContext_GetLocalVarsContext(UIContextIndex_t contextIndex);
const char *UI_GetMonthAbbrev(int month);
void TRACK_ui_main();
void UI_RegisterDvars();
void UI_AssetCache();
char *GetMenuBuffer_LoadObj(const char *filename);
XModelPiece *GetMenuBuffer_FastFile(const char *filename);
char *UI_GetMenuBuffer();
void UI_GameModeHistory_AddMatchHistory();
void UI_GameModeHistory_Clear();
void UI_DrawSides(;
void UI_DrawTopBottom(;
void UI_DrawRect(;
void UI_DrawHighlightRect(;
int UI_TextWidth(LocalClientNum_t localClientNum, const char *text, int maxChars, Font_s *font, float scale);
int UI_TextHeight(Font_s *font, float scale);
void UI_DrawTextRotated(;
void UI_DrawTextWithGlow(;
void UI_DrawTextNoSnap(;
void UI_DrawTextWithCursor(;
Font_s *UI_GetFontHandleDefault(float scale);
Font_s *UI_GetFontHandle(const ScreenPlacement *scrPlace, int fontEnum, float scale);
void UI_UpdateTime(LocalClientNum_t localClientNum, int realtime);
bool UI_ShouldDrawBuildNumber(LocalClientNum_t localClientNum);
void UI_Shutdown(LocalClientNum_t localClientNum);
MenuList *Load_ScriptMenuInternal(const char *pszMenu, int imageTrack);
// int Load_ScriptMenu@<eax>(int a1@<edx>, const char *a2@<ecx>, LocalClientNum_t localClientNum);
void UI_VerifyLanguage();
bool UI_GetOpenOrCloseMenuOnDvarArgs(;
bool UI_DvarValueTest(const char *cmd, const char *dvarName, const char *testValue, bool wantMatch);
void UI_OpenMenuOnDvar(;
void UI_CloseMenuOnDvar(;
void UI_RunMenuScript(;
void UI_Pause(LocalClientNum_t localClientNum, int b);
void UI_UpdateMouseScreenPosition(LocalClientNum_t localClientNum, int x, int y);
void UI_MouseEvent(LocalClientNum_t localClientNum);
int UI_GetActiveMenu(LocalClientNum_t localClientNum);
int UI_IsFullscreen(LocalClientNum_t localClientNum);
double UI_GetBlurRadius(LocalClientNum_t localClientNum);
const char *UI_SafeTranslateString(const char *reference);
void UI_FormatStringWithCommas(char *outputString, int stringLength, unsigned __int64 value);
void UI_FilterStringForButtonAnimation(char *str, unsigned int strMaxSize);
void UI_ReplaceConversions(;
void UI_CloseFocusedMenu(LocalClientNum_t localClientNum);
bool Menu_IsMenuOpenAndVisible(const LocalClientNum_t localClientNum, const char *menuName);
void UI_ClosePopupScriptMenu(LocalClientNum_t localClientNum, bool allowResponse);
bool UI_AllowScriptMenuResponse(LocalClientNum_t localClientNum);
void UI_CloseInGameMenu(LocalClientNum_t localClientNum);
bool CheckCurrentChar(char charToCheck, const char *testChars);
;
bool UI_CheckClanTagAllowed(ControllerIndex_t controllerIndex, const char *clanTag);
void UI_SetClanName(ControllerIndex_t localControllerIndex, const char *clanName);
void UI_SetClanNameCmd();
void UI_CheckClanName();
void UI_CheckClanNameCmd();
int UI_OwnerDrawWidth(LocalClientNum_t localClientNum, int ownerDraw, Font_s *font, float scale);
void UI_DrawLocalTalking(;
int UI_GetTalkerClientNum(LocalClientNum_t localClientNum, UIContextIndex_t contextIndex, const int num);
void UI_DrawPartyStatus(;
char *GetXpLockDescription(const LocalClientNum_t localClientNum, const int playlistId);
void UI_DrawScrollingTextLong(;
void UI_DrawScrollingTextMOTD(;
void UI_DrawControllerIcon(;
void UI_OwnerDraw(;
void UI_InitUIInfos();
void UI_InitOnceForAllClients();
void UI_Init(LocalClientNum_t localClientNum);
bool UI_KeyEvent_CancelButtonPressed(;
bool UI_MenuInputAllowedForLocalClientNum(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
bool UI_KeyEvent_IsLocalClientInputAllowedForMenu(;
char UI_HandleLocalClientInput(;
void UI_CloseAll(LocalClientNum_t localClientNum);
void UI_UIContext_OpenToastPopup(;
void UI_OpenErrorPopup();
void UI_OpenMenu(LocalClientNum_t localClientNum, const char *menuName);
void UI_CloseMenu(LocalClientNum_t localClientNum, const char *menuName);
void UI_CloseFromMenuToTopOfStack(LocalClientNum_t localClientNum, const char *menuName);
void UI_OpenToastPopup(;
void UI_LoadIngameMenus(LocalClientNum_t localClientNum);
char *UI_ToUpper(const char *sourceString);
bool UI_KeysBypassMenu(const LocalClientNum_t localClientNum);
void UI_DrawTextPadding(;
void UI_DrawText(;
void UI_DrawMouseCursor(LocalClientNum_t localClientNum);
const char *UI_GetMapDisplayName(const char *pszMap);
const char *UI_GetMapDisplayNameFromPartialLoadNameMatch(const char *mapName, int *mapLoadNameLen);
const char *UI_GetGameTypeDisplayName(const char *pszGameType, const char *pszMap);
void UI_ShowAcceptInviteWarning(LocalClientNum_t localClientNum);
char *UI_ReplaceConversionStrings(const char *sourceString, int numStrings, const char **replaceStrings);
char *UI_ReplaceConversionInts(const char *sourceString, int numInts, int *replaceInts);
void UI_DrawKeyBindStatus(;
void UI_DrawTalkerNum(;
void UI_DrawReservedSlots(;
void UI_DrawLoggedInUser(;
void UI_DrawLoggedInUserName(;
void UI_OwnerDrawText(;
void UI_KeyEvent(LocalClientNum_t localClientNum, int key, int down);
void UI_DrawBuildNumber(LocalClientNum_t localClientNum, const UIContextIndex_t contextIndex);
void UI_DrawSessionAndGameModeLine(;
void UI_DrawSessionAndGameModes(LocalClientNum_t localClientNum, const UIContextIndex_t contextIndex);
void UI_DrawGameModeHistory_DrawMode_HostedOrPlayed(;
void UI_DrawGameModeHistory_DrawMode(;
void UI_DrawGameModeHistory(const LocalClientNum_t localClientNum);
void UI_Refresh(LocalClientNum_t localClientNum);
char *UI_ReplaceConversionString(const char *sourceString, const char *replaceString);
char *UI_ReplaceConversionInt(const char *sourceString, int replaceInt);
const char *GetPLevelLockDescription(const LocalClientNum_t localClientNum, const int playlistId);
const char *UI_GetPlaylistDescription(;
void UI_SecondsAsTimeDisplay(int seconds, char *output, int maxChars);

//t6/code/src_noserver/ui/ui_mem_track.cpp
void UI_track_init();

//t6/code/src_noserver/ui/ui_motd.cpp
char MOTD_ParseVersion();
char MOTD_ParseMOTDVersion();
char MOTD_ParseSingleView();
char MOTD_ParseExpiration();
char MOTD_ParseImageCategory();
char MOTD_ParseTitle();
char MOTD_ParseMessage();
char MOTD_ParseImage();
char MOTD_ParseAction();
char MOTD_ParseActionContext();
char MOTD_ParseActionString();
char MOTD_ParseBannerTitle();
char MOTD_ParseBannerMessage();
char MOTD_ParseBannerImage();
char MOTD_ParseBannerAction();
char MOTD_ParseBannerActionContext();
char MOTD_ParseBannerActionString();
char MOTD_ParseEliteImage();
char MOTD_ParseFounderImage();

//t6/code/src_noserver/ui/ui_playlists.cpp
const char *Playlist_GetPlaylistFilename();
char *Playlist_Strdup(const char *src);
const char *Playlist_Strdup_Newline(const char *src);
char *Playlist_BeginRules();
bool Playlist_AppendRules(const char *base, const char *token);
const char *Playlist_GetLanguage();
int Playlist_GetCategoryIdByName(const char *name);
int Playlist_GetSuperCategoryIdByName(const char *name);
int ParseIntRange(const char *field, const char **pData, int min, int max);
char Playlist_ParseRequiredDLC(const char **pData, const char *name, const char **string);
void Playlist_SetPlaylistEntry(;
int Playlist_GetNumEntries(int playlistId);
playlistEntry *Playlist_GetEntry(int playlistId, int entry);
int Playlist_GetLeagueID(int playlistId);
BOOL Playlist_IsLeaguePlaylist(int playlistId);
int Playlist_GetParkingPlaylistForRealPlaylist(int realPlaylist);
const char *Playlist_GetPlaylistDescription(const ControllerIndex_t controllerIndex, const int playlistId);
int Playlist_IsLocked(const ControllerIndex_t controllerIndex, const int playlistId);
int Playlist_CategoryIsLocked(const ControllerIndex_t controllerIndex, const int categoryId);
int Playlist_GetMapPacksUsedByPlaylist(const int playlistId);
char Playlist_CanWeHostThisPlaylist(const ControllerIndex_t controllerIndex);
void Playlist_ResetWeights(const int playlistId, const PartyData_s *party);
void Playlist_ResetWeights(const int playlistId);
int Playlist_CalcTotalWeights(const int playlistId, const int lastSelection, const int lastToLastSelection);
int Playlist_FindEntryByWeight(;
playlistGametype *Playlist_FindGametype(const char *gametypeInternalName);
playlistMapList *Playlist_FindMaplist(const char *name);
int Playlist_GetGametypeCount();
const char *Playlist_GetGametypeLocalizedName(int index);
const char *Playlist_GetGametypeInternalName(int index);
int Playlist_GetVersionNumber();
int Playlist_GetUnlockXp(const ControllerIndex_t localControllerIndex, const int playlistId);
int Playlist_GetUnlockPLevel(const ControllerIndex_t localControllerIndex, const int playlistId);
int Playlist_GetMaxPartySize(const ControllerIndex_t localControllerIndex, const int playlistId);
int Playlist_GetMinPartySize(const ControllerIndex_t localControllerIndex, const int playlistId);
bool Playlist_IsGametypeBannable(const ControllerIndex_t localControllerIndex, const int playlistId);
int Playlist_GetCategoryId(int playlistId);
int Playlist_GetCurrentId();
void Playlist_SetCurrentId(int newId);
const dvar_t *Playlist_RegisterDvars();
;
void Playlist_ParsePlaylists(const char *buffer);
const char *Playlist_GetCategoryLocalizedName(const ControllerIndex_t controllerIndex, const int categoryId);
const char *Playlist_GetPlaylistName(const ControllerIndex_t controllerIndex, const int playlistId);
// int Playlist_ChooseEntry@<eax>(;
int Playlist_ChooseEntry(int a1, const PartyData_s *a2);
void Playlist_MigrateHost(;
const GfxViewParms *Playlist_GetMapName(const ControllerIndex_t localControllerIndex, const int entryNum);
const GfxViewParms *Playlist_GetScriptGameTypeName(;
char Playlist_RunRules(const ControllerIndex_t localControllerIndex, const int entryNum);
bool Playlist_DoesMapMatchPlaylistEntry(const int entryNum, const char *mapname);
bool Playlist_DoesGametypeMatchPlaylistEntry(const int entryNum, const char *gametype);
const char *Playlist_GetLocalizedGametypeName(const ControllerIndex_t localControllerIndex, const int entryNum);

//t6/code/src_noserver/ui/ui_shared.cpp
// void __thiscall MenuNameHash_t::MenuNameHash_t(MenuNameHash_t *this, const char *s);
int UI_GetUTFHeaderSize(const char *buff);
void Item_Fade(UIContextIndex_t contextIndex, itemDef_s *item, int fadeOut);
void Item_SetColor(itemDef_s *item, const char *name, UIContextIndex_t contextIndex, vec4_t *color);
void Menu_Setup(UiContext *dc);
int Color_Parse(const char **p, vec4_t *c);
int String_Parse(const char **p, char *out, int len);
BOOL Command_Parse(const char **p, char *out, int len);
void Window_Paint(;
bool Item_IsModal(itemDef_s *item);
int Rect_ContainsPoint(UIContextIndex_t contextIndex, const rectDef_s *rect, float x, float y);
int Menu_ItemsMatchingGroup(menuDef_t *menu, const char *name);
itemDef_s *Menu_GetMatchingItemByNumber(menuDef_t *menu, int index, const char *name);
void Script_SetColor(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_SetBackground(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
itemDef_s *Menu_FindItemByName(menuDef_t *menu, const char *p);
itemDef_s *Menu_FindFirstFocusableItemByName(;
animParamsDef_t *Item_FindStateByName(itemDef_s *item, const char *p);
void Item_LerpAnimationParameters(;
void UI_SetShaderTime(LocalClientNum_t localClientNum);
void Script_SetItemColor(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Menu_ShowItemByName(;
void Menu_FadeItemByName(;
int Menus_RemoveFromStack(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *pMenu);
void Menus_AddToStack(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *pMenu);
int Menus_MenuIsInStack(UiContext *dc, menuDef_t *menu);
LocalClientNum_t Menus_MenuInStackLocalClientNum(UiContext *dc, menuDef_t *menu);
int Menus_FindIndexByHash(UiContext *dc, unsigned int hash);
menuDef_t *Menus_FindByHash(UiContext *dc, unsigned int hash);
menuDef_t *Menus_FindByName(const UiContext *dc, const char *p);
void Menus_HideByName(const UiContext *dc, const char *menuName);
void Menus_ShowByName(const UiContext *dc, const char *windowName);
void Menus_RemoveMenu(XAssetHeader header);
char Item_DoesEventExist(itemDef_s *item, const char *eventName);
char Menus_DoesEventExist(menuDef_t *menu, const char *eventName);
void UI_ClearErrors();
void Script_Show(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_Hide(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_FadeIn(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_FadeOut(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_ShowMenu(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_HideMenu(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_OpParse(int *operand, const char **args);
int Script_IntParse(UiContext *dc, const char **args);
const char *Script_TableLookupParse(UiContext *dc, const char **args);
void Script_SetDvarStringUsingTable(;
void Script_SetDvar(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_ResetDvar(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_AddTextWrapper(;
void Script_Exec(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_ExecNow(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_ConditionalExecHandler(;
void Script_ConditionalResponseHandler(;
BOOL Script_ExecIfStringsEqual(const char *dvarValue, const char *testValue);
bool Script_ExecIfIntsEqual(const char *dvarValue, const char *testValue);
BOOL Script_ExecIfFloatsEqual(const char *dvarValue, const char *testValue);
void Script_ExecOnDvarStringValue(;
void Script_ExecOnDvarIntValue(;
void Script_ExecOnDvarFloatValue(;
void Script_ExecNowOnDvarStringValue(;
void Script_ExecNowOnDvarIntValue(;
void Script_ExecNowOnDvarFloatValue(;
void Script_RespondOnDvarStringValue(;
void Script_RespondOnDvarIntValue(;
void Script_RespondOnDvarFloatValue(;
void Script_SetLocalVarBool(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_SetLocalVarInt(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_SetLocalVarFloat(;
void Script_SetLocalVarString(;
void Script_FeederTop(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void Script_SessionMode_SetOnlineGame(;
void Script_SessionMode_SetSystemLink(;
void Script_SessionMode_SetPrivate(;
void Script_GameMode_SetMode(;
;
;
void Script_ScriptMenuResponse(;
char Item_ArePrereqsSatisfied(GenericEventScript *eventScript, nestingStack_t *stack);
bool Item_IsConditionSatisfied(;
void Item_RunScript(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char *s);
void UI_SetLocalVarBool_f();
void UI_SetLocalVarInt_f();
void UI_SetLocalVarFloat_f();
void UI_SetLocalVarString_f();
void UI_FadeItem_f();
void UI_ShowItem_f();
void UI_HideItem_f();
void UI_ShowMenu_f();
void UI_HideMenu_f();
void UI_ChangeMenuOpenSlideDirection_f();
void UI_ChangeMenuCloseSlideDirection_f();
void UI_OpenToastPopup_f();
void UI_AddToFeeder_f();
void UI_AddToFeederExtended_f();
void UI_ClearFeeder_f();
void UI_ClearFeederWithoutResetCursor_f();
void UI_RaiseFeederEvent_f();
void UI_RefreshFeeder_f();
void UI_ChangeRowStatus_f();
void UI_ValidatePrivateMatchGametype_f();
void UI_SetActiveMenu_f();
void UI_KickPlayer_f();
float Item_ListBox_GetMaxHeight(;
// int Item_ListBox_Viewmax@<eax>(;
float Item_Slider_ThumbPosition(const LocalClientNum_t localClientNum, itemDef_s *item);
int Item_Slider_OverSlider(;
int Item_ListBox_GetIndexForMouse(UIContextIndex_t contextIndex, itemDef_s *item, float x, float y);
void Item_Listbox_Mouse_Column_Set(;
void Item_MouseLeave(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
bool Item_ShouldHandleKey(UiContext *dc, itemDef_s *item, int key);
bool Item_YesNo_IsActionKey(int key);
int Item_YesNo_HandleKey(UiContext *dc, itemDef_s *item, int key);
int Item_DvarEnum_CountSettings(itemDef_s *item);
int Item_Multi_FindDvarByValue(itemDef_s *item);
int Item_ProfileMulti_FindVarByValue(LocalClientNum_t localClientNum, itemDef_s *item);
const char *Item_Multi_Setting(itemDef_s *item);
const char *Item_ProfileMulti_Setting(LocalClientNum_t localClientNum, itemDef_s *item);
int Item_DvarEnum_EnumIndex(itemDef_s *item);
const char *Item_DvarEnum_Setting(LocalClientNum_t localClientNum, itemDef_s *item);
int Item_List_NextEntryForKey(int key, int current, int count);
int Item_Multi_HandleKey(UiContext *dc, itemDef_s *item, int key);
int Item_ProfileMulti_HandleKey(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, int key);
int Item_DvarEnum_HandleKey(UiContext *dc, itemDef_s *item, int key);
bool Item_IsTextField(const itemDef_s *item);
void Item_TextField_BeginEdit(;
void Item_TextField_EnsureCursorVisible(UIContextIndex_t contextIndex, itemDef_s *item, const char *text);
void Scroll_Slider_SetThumbPos(UiContext *dc, itemDef_s *item);
void Scroll_Slider_ThumbFunc(;
int Item_Slider_HandleKey(;
void Menus_PrintAllLoadedMenus(UiContext *dc);
int Display_VisibleMenuCount(UiContext *dc);
rectDef_s *Item_CorrectedTextRect(UIContextIndex_t contextIndex, itemDef_s *item);
bool Menu_ItemsAreAnimating(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
Font_s *Item_GetFont(UIContextIndex_t contextIndex, const itemDef_s *item);
void Item_SetTextExtents(;
void Item_TextColor(UiContext *dc, itemDef_s *item, vec4_t *newColor);
int UI_PickWordWrapLineWidth(;
void DrawWrappedText(;
void DrawWrappedTextScissored(;
void UI_DrawWrappedText(;
void UI_DrawWrappedTextScissored(;
void Item_Text_AutoWrapped_Paint(;
void GetPlatformCommand(LocalClientNum_t localClientNum, const char *command, const char **consoleCommand);
// int UI_GetKeyBindingLocalizedString@<eax>(;
void Item_Slider_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
int Display_KeyBindPending();
bool Item_Bind_IsActionKey(UiContext *dc, itemDef_s *item, int key);
int Item_Bind_HandleKey(;
float Item_GetTextAlignAdj(const int alignment, float width, float textWidth);
void Item_ListBox_PaintTextElem(;
void Item_ListBox_PaintBackground(;
void Item_ListBox_PaintHighlight(const UIContextIndex_t contextIndex, itemDef_s *item, float x, float y);
void Item_ListBox_PaintItemIndicators(;
void Item_GameMsgWindow_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
menuDef_t *Menu_GetFocused(UiContext *dc);
int Menus_AnyFullScreenVisible(UiContext *dc);
// char Menu_IsVisible@<al>(;
void UI_SetupTextShaderParams(Font_s *font, textDef_s *textDefPtr);
void UI_SetSystemCursorPos(UiContext *dc, float x, float y);
int Menu_OverActiveItem(UIContextIndex_t contextIndex, menuDef_t *menu, float x, float y);
void TRACK_ui_shared();
void UI_ClearLocalUIVisibilityBits(LocalClientNum_t localClientNum);
void UI_SetLocalUIVisbilityBit(LocalClientNum_t localClientNum, int bitShift, int value);
bool Menus_ActiveMenuAllowSignin(UiContext *dc);
char Menu_DoesMenuOrParentsHaveControlFlag(UiContext *dc, menuDef_t *menu, int controlFlag);
int Menu_GetSpecifiedControlFlagFromStack(UiContext *dc, menuDef_t *menu);
void Phys_ReEvalPriority();
void Script_SetUIVisibilityBit(;
void Item_RunSingleEventScript(;
void Item_RunEventScript(;
void UIAnimation_RunEventScript(;
void UI_RefreshFeederSelection_f();
void UI_PlaySound_f();
int Item_ListBox_MaxScroll(;
float Item_ListBox_ThumbPosition(;
float Item_ListBox_ThumbDrawPosition(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
int Item_ListBox_OverLB(;
void Item_ListBox_SetCursorPos(;
void Item_ListBox_Page(;
void Item_ListBox_Scroll(;
void Item_Action(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
int Menu_CheckOnKey(UiContext *dc, menuDef_t *menu);
void Item_Text_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void Item_TextField_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void Item_YesNo_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
char UI_GetSticksTranslatedString(LocalClientNum_t localClientNum, const char *command, char *keys);
void Item_Bind_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
// void Item_ListBox_Paint(float a1@<esi>, LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void Item_OwnerDraw_Paint(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void Menu_RunFocusScript(UiContext *dc, menuDef_t *menu);
void Menu_RunLeaveFocusScript(UiContext *dc, menuDef_t *menu);
itemDef_s *Menu_ClearFocus(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Item_UpdateAnimation(;
void Item_AnimateToState(;
void UI_AnimateItemInternal(;
void UI_AnimateItem(;
void UI_AnimateItemSysTime(;
void Menu_LoseFocusDueToOpen(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Menu_CallOnFocusDueToOpen(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Menu_GainFocusDueToClose(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Menu_RunCloseScript(UiContext *dc, menuDef_t *menu);
void Menus_CompleteItemAnimations(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Menus_Close(const LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Menus_CloseByName(const LocalClientNum_t localClientNum, UiContext *dc, const char *p);
void Menus_CloseAll(const LocalClientNum_t localClientNum, UiContext *dc);
void Menus_CloseAllBehindMain(const LocalClientNum_t localClientNum, UiContext *dc);
void Menus_CloseFromMenuToTopOfStack(;
bool RemoveMenuFromBlurStack(const LocalClientNum_t localClientNum, UiContext *dc, const char *menuName);
void Script_ActivateBlur(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void Script_DeactivateBlur(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
int GetBlurFocus(const LocalClientNum_t localClientNum, UiContext *dc);
void Script_Close(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_CloseImmediate(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_InGameClose(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_ChangeState(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_ExecKeyHandler(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_FeederBottom(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
void UI_CloseMenu_f();
void UI_CloseMenuImmediate_f();
void UI_MoveFeeder_f();
int Item_SetFocus(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, float x, float y);
void Item_ListBox_ModalSelection(;
void Item_ListBox_MouseEnter(;
void Item_MouseEnter(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, float x, float y);
int Item_ListBox_HandleKey(;
void Scroll_ListBox_AutoFunc(const LocalClientNum_t localClientNum, UiContext *dc, void *p);
void Scroll_ListBox_ThumbFunc(const LocalClientNum_t localClientNum, UiContext *dc, void *p);
void Item_StartCapture(const LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, int key);
int Item_HandleKey(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, int key, int down);
itemDef_s *Menu_SetPrevCursorItem(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
itemDef_s *Menu_SetNextCursorItem(;
// int Menu_HandleMouseMove@<eax>(;
void Menu_PerformTransitionEffects(;
// int Display_MouseMove@<eax>(menuDef_t *a1@<edi>, LocalClientNum_t localClientNum, UiContext *dc);
void UI_AddMenuList(const LocalClientNum_t localClientNum, UiContext *dc, MenuList *menuList, int close);
void Menus_SetFocusToItem(;
itemDef_s *Menu_FocusFirstSelectableItem(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Script_FocusFirstInMenu(;
void Script_SetFocus(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_SetFocusByDvar(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void UI_FocusItem_f();
int Item_TextField_HandleKey(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, int key);
void Menus_SetupOpenMenu(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
void Menus_HandleOOBClick(;
void Menu_HandleKey(;
void Item_Paint(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item);
// char Menu_Paint@<al>(;
void Script_ExecKeyPress(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Menus_Open(LocalClientNum_t localClientNum, UiContext *dc, menuDef_t *menu);
int Menus_OpenByName(LocalClientNum_t localClientNum, UiContext *dc, const char *p);
int Menus_OpenImmediateByName(LocalClientNum_t localClientNum, UiContext *dc, const char *p);
void Script_Open(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_OpenImmediate(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void Script_InGameOpen(LocalClientNum_t localClientNum, UiContext *dc, itemDef_s *item, const char **args);
void UI_OpenMenu_f();
void UI_OpenMenuImmediate_f();
void UI_RegisterCmds();
void Menu_PaintAll_AppendToVisibleList(char *stringBegin, unsigned int stringSize, const char *stringToAppend);
void Menu_PaintAll(LocalClientNum_t localClientNum, UiContext *dc);

//t6/code/src_noserver/ui/ui_shared_load_db.h
void Load_editFieldDef_ptr(bool atStreamStart);
void Load_multiDef_t(bool atStreamStart);
void Load_multiDef_ptr(bool atStreamStart);
void Load_profileMultiDef_t(bool atStreamStart);
void Load_profileMultiDef_ptr(bool atStreamStart);
void Load_enumDvarDef_ptr(bool atStreamStart);
void Load_MenuCellArray(bool atStreamStart, int count);
void Load_MenuRowArray(bool atStreamStart, int count);
void Load_imageDef_ptr(bool atStreamStart);
void Load_ownerDrawDef_ptr(bool atStreamStart);
void Load_gameMsgDef_ptr(bool atStreamStart);
void Load_rectData_t(bool atStreamStart);
void Mark_listBoxDef_t();
void Mark_focusItemDef_ptr();
void Mark_textDefData_t();
void Mark_itemDefData_t();
void Mark_itemDef_ptrArray(int count);
void Mark_menuDef_t();
void Mark_menuDef_ptr();
void Mark_menuDef_ptrArray(int count);
void Mark_MenuListPtr();
void Load_ScriptCondition(bool atStreamStart);
void Load_GenericEventScript(bool atStreamStart);
void Load_GenericEventHandler(bool atStreamStart);
void Load_ItemKeyHandler(bool atStreamStart);
void Load_animParamsDef_t(bool atStreamStart);
void Load_windowDef_t(bool atStreamStart);
void Load_animParamsDef_ptrArray(bool atStreamStart, int count);
void Load_listBoxDef_t(bool atStreamStart);
void Load_listBoxDef_ptr(bool atStreamStart);
void Load_focusDefData_t(bool atStreamStart);
void Load_focusItemDef_t(bool atStreamStart);
void Load_focusItemDef_ptr(bool atStreamStart);
void Load_textDefData_t(bool atStreamStart);
void Load_textDef_t(bool atStreamStart);
void Load_itemDefData_t(bool atStreamStart);
void Load_UIAnimInfo(bool atStreamStart);
void Load_itemDef_t(bool atStreamStart);
void Load_itemDef_ptrArray(bool atStreamStart, int count);
void Load_menuDef_t(bool atStreamStart);
void Load_menuDef_ptr(bool atStreamStart);
void Load_menuDef_ptrArray(bool atStreamStart, int count);
void Load_MenuList(bool atStreamStart);
void Load_MenuListPtr(bool atStreamStart);

//t6/code/src_noserver/ui/ui_shared_obj.cpp
void TRACK_ui_shared_obj();
void Menu_FreeItemMemory(itemDef_s *item);
void Menu_FreeMemory(menuDef_t *menu);
void Menus_FreeAllMemory(UiContext *dc);
void UI_MapLoadInfo(const char *filename);
void PC_SourceError(int handle, char *format, ...);
int PC_Float_Expression_Parse(int handle, float *f);
int PC_Int_ParseLine(int handle, int *i);
int PC_Flag_ParseOptional(int handle, int *i);
int PC_Int_Expression_Parse(int handle, int *i);
int PC_String_Parse(int handle, const char **out);
int PC_Script_Parse(int handle, const char **out);
int PC_CndStackPush(;
int PC_CndStackPopLevel();
int PC_CndStackAddConditionsToScript(GenericEventScript **baseScript, char *accumulatedScriptCommands);
int PC_EventScript_Parse(int handle, GenericEventScript **baseScript);
void Menu_Init(menuDef_t *menu, int imageTrack);
void Item_Init(itemDef_s *item, int imageTrack);
void Item_PostParse(itemDef_s *item);
int MenuParse_name(menuDef_t *menu, int handle);
int MenuParse_visible(menuDef_t *menu, int handle);
int MenuParse_visiblityBits(menuDef_t *menu, int handle);
int MenuParse_onFocus(menuDef_t *menu);
int MenuParse_leaveFocus(menuDef_t *menu);
int MenuParse_onOpen(menuDef_t *menu);
int MenuParse_onClose(menuDef_t *menu);
int MenuParse_onESC(menuDef_t *menu);
BOOL MenuParse_execExp(menuDef_t *menu, int handle);
int MenuParse_background(menuDef_t *menu, int handle);
int MenuParse_popup(menuDef_t *menu);
int MenuParse_outOfBounds(menuDef_t *menu);
int MenuParse_soundLoop(menuDef_t *menu, int handle);
void Item_ValidateTypeData(itemDef_s *item, int handle);
int MenuParse_execKey(menuDef_t *menu, int handle);
int MenuParse_legacySplitScreenScale(menuDef_t *menu);
int MenuParse_hiddenDuringScope(menuDef_t *menu);
int MenuParse_hiddenDuringFlashbang(menuDef_t *menu);
int MenuParse_hiddenDuringUI(menuDef_t *menu);
int MenuParse_allowedBinding(menuDef_t *menu, int handle);
int MenuParse_allowSignIn(menuDef_t *menu);
const char *UI_FileText(const char *fileName);
int ItemParse_name(itemDef_s *item, int handle);
int ItemParse_focusSound(itemDef_s *item);
int ItemParse_text(itemDef_s *item, int handle);
int ItemParse_textfile(itemDef_s *item, int handle);
int ItemParse_textsavegame(itemDef_s *item);
int ItemParse_textcinematicsubtitle(itemDef_s *item);
int ItemParse_group(itemDef_s *item, int handle);
int ItemParse_decoration(itemDef_s *item);
// int ItemParse_notselectable@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
// int ItemParse_noScrollBars@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
// int ItemParse_noBlinkingHighlight@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
// int ItemParse_usePaging@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
int ItemParse_autowrapped(itemDef_s *item);
int ItemParse_horizontalscroll(itemDef_s *item);
int ItemParse_visible(itemDef_s *item, int handle);
int ItemParse_visiblityBits(itemDef_s *item, int handle);
int ItemParse_modal(itemDef_s *item);
int ItemParse_background(itemDef_s *item, int handle);
// int ItemParse_doubleClick@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
// int ItemParse_rightClick@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
int ItemParse_onEnter(itemDef_s *item);
int ItemParse_onFocus(itemDef_s *item);
int ItemParse_leaveFocus(itemDef_s *item);
BOOL ItemParse_mouseEnter(itemDef_s *item);
BOOL ItemParse_mouseExit(itemDef_s *item);
BOOL ItemParse_mouseEnterText(itemDef_s *item);
BOOL ItemParse_mouseExitText(itemDef_s *item);
int ItemParse_action(itemDef_s *item);
int ItemParse_accept(itemDef_s *item);
int ItemParse_dvarTest(itemDef_s *item, int handle);
// int ItemParse_dvar@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_profile@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int Item_Parse_maxCharsGotoNext@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
// int ItemParse_dvarStrList@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_profileStrList@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_dvarEnumList@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_actionOnEnterPressOnly@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
// int ItemParse_enableDvar@<eax>(const char **a1@<edx>, int a2@<ecx>, itemDef_s *item);
// int ItemParse_disableDvar@<eax>(const char **a1@<edx>, int a2@<ecx>, itemDef_s *item);
// int ItemParse_showDvar@<eax>(const char **a1@<edx>, int a2@<ecx>, itemDef_s *item);
// int ItemParse_hideDvar@<eax>(const char **a1@<edx>, int a2@<ecx>, itemDef_s *item);
// int ItemParse_focusDvar@<eax>(const char **a1@<edx>, int a2@<ecx>, itemDef_s *item);
BOOL ItemParse_onEvent(itemDef_s *item, int handle);
int ItemParse_execKey(itemDef_s *item, int handle);
BOOL ItemParse_execExp(itemDef_s *item, int handle);
// int ItemParse_selectIcon@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_backgroundItemListbox@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_highlightTexture@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// listBoxDef_s *ItemParse_onListboxSelectionChange@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item);
void Menu_PostParse(menuDef_t *menu);
MenuList *UI_LoadMenus_FastFile(const char *menuFile);
int PC_Float_Parse(int handle, float *f);
int PC_Color_Parse(int handle, vec4_t *c);
int PC_Int_Parse(int handle, int *i);
// int PC_Rect_Parse@<eax>(float *a1@<edx>, int handle, rectDef_s *r);
int WindowParse_frame(windowDef_t *window, int handle);
// int MenuParse_fullscreen@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_rect@<eax>(float *a1@<edx>, menuDef_t *menu, int handle);
// int ItemParse_style@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// int ItemParse_border@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// int MenuParse_borderSize@<eax>(float *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_backcolor@<eax>(vec4_t *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_forecolor@<eax>(vec4_t *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_bordercolor@<eax>(vec4_t *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_focuscolor@<eax>(vec4_t *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_disablecolor@<eax>(vec4_t *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_outlinecolor@<eax>(vec4_t *a1@<edx>, menuDef_t *menu, int handle);
// int ItemParse_ownerdrawFlag@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// int MenuParse_ownerdraw@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_fadeClamp@<eax>(float *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_fadeAmount@<eax>(float *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_fadeInAmount@<eax>(float *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_fadeCycle@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_execKeyInt@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_blurWorld@<eax>(float *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_ui3dWindowId@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_priority@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_openSlideSpeed@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_closeSlideSpeed@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_openSlideDirection@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_closeSlideDirection@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_openFadingTime@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_closeFadingTime@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int MenuParse_control@<eax>(int *a1@<edx>, menuDef_t *menu, int handle);
// int ItemParse_rect@<eax>(float *a1@<edx>, itemDef_s *item, int handle);
// int ItemParse_origin@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// int ItemParse_type@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// listBoxDef_s *ItemParse_elementwidth@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// listBoxDef_s *ItemParse_elementheight@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
BOOL ItemParse_special(itemDef_s *item, int handle);
// int ItemParse_elementtype@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_columns@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
int ItemParse_menuColDef(listBoxDef_s *listPtr, int handle, MenuCell *cells, int cellCount);
// int ItemParse_menuItemsDef@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_menuarea@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_userarea@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// BOOL ItemParse_bordersize@<eax>(float *a1@<edx>, itemDef_s *item, int handle);
BOOL ItemParse_ownerdraw(itemDef_s *item, int handle);
BOOL ItemParse_align(itemDef_s *item, int handle);
int ItemParse_textalign(itemDef_s *item, int handle);
BOOL ItemParse_textalignx(itemDef_s *item, int handle);
BOOL ItemParse_textaligny(itemDef_s *item, int handle);
BOOL ItemParse_textscale(itemDef_s *item, int handle);
BOOL ItemParse_textpadding(itemDef_s *item, int handle);
int ItemParse_fontColor(itemDef_s *item, int handle);
int ItemParse_glowColor(itemDef_s *item, int handle);
int ItemParse_shadowColor(itemDef_s *item, int handle);
BOOL ItemParse_fontBlur(itemDef_s *item, int handle);
BOOL ItemParse_glowSize(itemDef_s *item, int handle);
BOOL ItemParse_shadowSize(itemDef_s *item, int handle);
int ItemParse_shadowOffset(itemDef_s *item, int handle);
BOOL ItemParse_textstyle(itemDef_s *item, int handle);
// BOOL ItemParse_rotation@<eax>(float *a1@<edx>, itemDef_s *item, int handle);
BOOL ItemParse_textfont(itemDef_s *item, int handle);
int ItemParse_backcolor(itemDef_s *item, int handle);
// int ItemParse_forecolor@<eax>(float *a1@<edx>, itemDef_s *item, int handle);
int ItemParse_bordercolor(itemDef_s *item, int handle);
int ItemParse_frame(windowDef_t *a1, int a2);
// BOOL ItemParse_outlinecolor@<eax>(vec4_t *a1@<edx>, itemDef_s *item, int handle);
// int ItemParse_profileFloat@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_maxChars@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_maxPaintChars@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_dvarFloat@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_dvarFloatList@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_profileFloatList@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_execKeyInt@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// int ItemParse_gameMsgWindowIndex@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// int ItemParse_gameMsgWindowMode@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
// listBoxDef_s *ItemParse_selectBorder@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// listBoxDef_s *ItemParse_elementHighlightColor@<eax>(;
// listBoxDef_s *ItemParse_elementBackgroundColor@<eax>(;
// listBoxDef_s *ItemParse_disableColor@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// listBoxDef_s *ItemParse_focusColor@<eax>(int a1@<edx>, itemDef_s *a2@<ecx>, itemDef_s *item, int handle);
// int ItemParse_ui3dWindowId@<eax>(int *a1@<edx>, itemDef_s *item, int handle);
int Asset_Parse(int handle, int imageTrack);
int Item_Parse(int handle, itemDef_s *item);
int MenuParse_itemDef(menuDef_t *menu, int handle);
void Menu_SetupKeywordHash();
int ItemParse_state(itemDef_s *item, int handle);
void Item_SetupKeywordHash();
int Menu_Parse(int handle, menuDef_t *menu);
bool Menu_New(int handle, int imageTrack);
bool UI_ParseMenuInternal(const char *menuFile, int imageTrack);
MenuList *UI_LoadMenu_LoadObj(const char *menuFile);
MenuList *UI_LoadMenu();
int Load_Menu(const char **p, int imageTrack);
MenuList *UI_LoadMenus_LoadObj(const char *menuFile);
MenuList *UI_LoadMenus();

//t6/code/src_noserver/ui/ui_ui3d_util.h
// void __thiscall ScopedScrPlaceViewStack::ScopedScrPlaceViewStack(;
// void __thiscall ScopedScrPlaceViewStack::~ScopedScrPlaceViewStack(ScopedScrPlaceViewStack *this);

//t6/code/src_noserver/ui/ui_utils.cpp
void TRACK_ui_utils();
void Window_SetDynamicFlags(UIContextIndex_t contextIndex, windowDef_t *w, const int flags);
void Window_AddDynamicFlags(UIContextIndex_t contextIndex, windowDef_t *w, const int newFlags);
void Window_RemoveDynamicFlags(UIContextIndex_t contextIndex, windowDef_t *w, const int newFlags);
void Window_SetStaticFlags(windowDef_t *w, const int flags);
void Menu_SetCursorItem(UIContextIndex_t contextIndex, menuDef_t *menu, int cursorItem);
BOOL Item_EnableShowViaDvar(const itemDef_s *item, int flag);
void Item_SetTextRect(UIContextIndex_t contextIndex, itemDef_s *item, const rectDef_s *textRect);
int Item_IsEditFieldDef(itemDef_s *item);
int Item_IsTextDefType(itemDef_s *item);
int Item_IsFocusDefType(itemDef_s *item);
BOOL Item_IsOwnerDrawDefType(itemDef_s *item);
editFieldDef_s *Item_GetEditFieldDef(itemDef_s *item);
multiDef_s *Item_GetMultiDef(itemDef_s *item);
profileMultiDef_s *Item_GetProfileMultiDef(itemDef_s *item);
ownerDrawDef_s *Item_GetOwnerDrawDef(itemDef_s *item);
textDef_s *Item_GetTextDef(itemDef_s *item);
focusItemDef_s *Item_GetFocusItemDef(itemDef_s *item);
listBoxDef_s *Item_GetListBoxDef(itemDef_s *item);
double Item_GetListBoxFeederID(const itemDef_s *item);
enumDvarDef_s *Item_GetEnumDvarName(itemDef_s *item);
gameMsgDef_s *Item_GetGameMsgDef(itemDef_s *item);
void Item_PropertiesToAnimState(itemDef_s *item, animParamsDef_t *animParams);
void Item_AnimStateToProperties(animParamsDef_t *animParams, itemDef_s *item);
int hashForString(const char *str);
void *UI_Alloc(int size, int alignment);
void String_Init();
char *String_Alloc(const char *p);
int Float_Parse(const char **p, float *f);
void UI_GetGameTypesList_LoadObj();
void UI_GetGameTypesList_FastFile();
void UI_GetGameTypesList();
char *UI_GetBusyDotsIndicator();
void UI_ListMenus_f();
void __thiscall CL_SelectStringTableEntryInDvar_f(const StringTable *this);
bool UI_VerifyString(const char *str);
int Item_IsVisible(const LocalClientNum_t localClientNum, UIContextIndex_t contextIndex, itemDef_s *item);
int Item_GetCursorPosOffset(UIContextIndex_t contextIndex, itemDef_s *item, const char *text, int delta);
BOOL ListBox_HasValidCursorPos(UIContextIndex_t contextIndex, itemDef_s *item);
void Item_SetScreenCoords(;
void Menu_UpdatePosition(UIContextIndex_t contextIndex, menuDef_t *menu);

//t6/code/src_noserver/ui/ui_utils.h
int Window_GetDynamicFlags(UIContextIndex_t contextIndex, const windowDef_t *w);
unsigned int Window_IsVisible(UIContextIndex_t contextIndex, const windowDef_t *w);
bool Window_HasFocus(UIContextIndex_t contextIndex, const windowDef_t *w);
int Menu_GetCursorItem(UIContextIndex_t contextIndex, menuDef_t *menu);
const rectDef_s *Item_GetTextRect(UIContextIndex_t contextIndex, const itemDef_s *item);
rectDef_s *Item_GetNonTextRect(UIContextIndex_t contextIndex, const itemDef_s *item);

//t6/code/src_noserver/ui/ui_utils_api.h
rectDef_s *Window_GetRect(const windowDef_t *w);

//t6/code/src_noserver/ui/ui_voting.cpp
bool Voting_SetBoolAttribute(bool *attribute, const char *string);
bool Voting_SetIntAttribute(int *attribute, const char *string);
bool Voting_SetStringAttribute(char *attribute, const char *string, int attributeSize);
bool Voting_SetStringRefAttribute(char *attribute, const char *string, int attributeSize);
char Voting_ParseVersion();
bool Voting_ParseVotingVersion(int *a1, const char *a2);
bool Voting_ParseExpiration(int *a1, const char *a2);
bool Voting_ParseVotingInterval(int *a1, const char *a2);
bool Voting_ParseImageCategory(int *a1, const char *a2);
bool Voting_ParseViewCount(int *a1, const char *a2);
bool Voting_ParseTitle(char *a1, const char *a2);
bool Voting_ParseSubtitle(char *a1, const char *a2);
bool Voting_ParseVoteForString(char *a1, const char *a2);
bool Voting_ParseVotingItem_ImageName(int a1, const char *a2);
bool Voting_ParseVotingItem_IsLocalImage(int a1, const char *a2);
bool Voting_ParseVotingItem_CounterName(int a1, const char *a2);
bool Voting_ParseVotingItem_SelectStringRef(int a1, const char *a2);
bool Voting_ParseVotingItem_Position(int a1, const char *a2);
char Voting_ParseKeys(int keyCount, votingHandler_t *keyHandlers, int numKeyHandlers);
char Voting_ParseVoteItemsArray();

//t6/code/src_noserver/ui_mp/ui_feeders_mp.cpp
int UI_GetMapCount();
int UI_Project_FeederCount(;
int UI_GetMapIdForNum(const int num);
const GfxViewParms *UI_FeederItemText_Maps(;
bool UI_FeederItemColor_InGamePlayerList(;
bool UI_FeederItemColor_ClanMembers(;
bool UI_FeederItemColor_AARScoreboard(;
void UI_Project_FeederItemColor(ControllerIndex_t,UIContextIndex_t,itemDef_s *,float,int,int,vec4_t &,bool);
int UI_GetCurrentIndexForSplitscreen(int index);
void UI_FeederDoubleClickDlcMaps(;
contentPackInfo *UI_GetMapLoadNameForCurrentIndex(int index);
void UI_OverrideCursorPos_Maps(UIContextIndex_t contextIndex, listBoxDef_s *listPtr);
void UI_OverrideCursorPos_Gametypes(;
void UI_OverrideCursorPos_Contracts(;
// bool UI_Project_OverrideCursorPos@<al>(;
void UI_FeederSelection_Maps(UIContextIndex_t contextIndex, float feederID, int index);
void UI_FeederSelection_GametypesBase(;
void UI_Project_FeederSelection(;
bool UI_Project_FeederDataExtended(;
void UI_FeederBackColor(;

//t6/code/src_noserver/ui_mp/ui_gameinfo_mp.cpp
void UI_LoadMaps();
void UI_LoadZombieGameMode();
void UI_LoadCustomMatchGameTypes();

//t6/code/src_noserver/ui_mp/ui_main_mp.cpp
const dvar_t *UI_Project_Zombie_RegisterDvars();
void UI_Project_RegisterDvars();
void UI_Project_AssetCache();
void UI_Project_Refresh(LocalClientNum_t localClientNum);
void UI_KeyClearStates_f();
void UI_SetMap(const char *mapname, const char *gametype);
void UI_DrawBlurMaterial(UIContextIndex_t contextIndex, rectDef_s *rect, vec4_t *color);
const char *UI_GetMapTableName();
const char *UI_GetMapName(const char *inputMapName, bool returnStringRef);
const char *UI_GetGameTypeName(const char *inputGameType, bool returnStringRef, const char *inputMapName);
const char *UI_GetZMMapStartLocName(const char *inputZMMapStartLoc, bool returnStringRef);
const char *UI_GetOverlayMapNameFromIndex(int mapIndex);
void UI_DrawWagerTier(;
// void EditPlaylistPopulationTexture::ReplaceTextureWithCpuWriteAccessTexture(GfxImage *img);
int CompareGeoPoint(const void *a, const void *b);
void UI_DrawPartyMemberDownloadProgress(;
void UI_DrawHeatMap(UIContextIndex_t contextIndex, const rectDef_s *rect, const vec4_t *color);
long double UI_CalculateDeclination();
void UI_StartServer(LocalClientNum_t localClientNum);
void UI_Project_RunMenuScript(;
void UI_Project_InitOnceForAllClients();
void UI_ShowErrorPopupIfNecessary(LocalClientNum_t localClientNum, uiInfo_s *uiInfo);
void UI_SetupLobby(;
int UI_SetActiveMenu(LocalClientNum_t localClientNum, int menu);
const char *UI_TranslateIntegerToOrdinal(int integer);
int UI_Popup(LocalClientNum_t localClientNum, const char *menu);
bool UI_ShouldDrawCrosshair();
const char *UI_GetGameTypeDisplayNameCaps(const char *pszGameType, const char *pszMap);
void UI_SetMapStartLocation(const char *mapStartLocation, bool isFromParty);
void UI_SetGameModeGroup(const char *gameMode);
const char *UI_GetMapDisplayNameCaps(const char *pszMap);
char *UI_GetMapLocationName(const char *pszMap);
void UI_DrawConnectScreen(LocalClientNum_t localClientNum);
void UI_GetGameTypeOnMapName(char *outputString, const char *inputMapName, const char *inputGameType);
void UI_DrawGameTypeOnMapName(;
// void __thiscall EditPlaylistPopulationTexture::EditPlaylistPopulationTexture(;
void UI_GeneratePlaylistPopulationTextureInternal(GfxImage *img, unsigned __int8 *heatmap);
void UI_GeneratePlaylistPopulationTexture();
void UI_DrawPlaylistPopulation(UIContextIndex_t contextIndex, const rectDef_s *rect, const vec4_t *color);
void UI_Project_OwnerDraw(;
void UI_Project_OwnerDrawText(;

//t6/code/src_noserver/universal/assertive.cpp
int HideWindowCallback(HWND__ *hwnd, int lParam);
void FixWindowsDesktop();
void TRACK_assertive();
char SkipLines(int lineCount, _iobuf *fp);
bool ParseMapFile(_iobuf *fp, unsigned int baseAddress, const char *mapName);
unsigned int GetModuleBase(const char *name);
void LoadMapFilesForDir(const char *dir);
int StackTrace_ResolveSymbols();
int StackTrace_Generate(int len, char *msg);
int StackTrace_Walk(int ignoreCount, void *context);
AddressInfo_s *StackTrace_GetAddressInfo(int *addressCount);
void StackTrace_ResetAddressInfo();
void CopyMessageToClipboard(const char *msg);
char AssertNotify(int type, AssertOccurance occurance);
int Assert_BuildAssertMessageWithStack(;
;
void RefreshQuitOnErrorCondition();
bool QuitOnError();

//t6/code/src_noserver/universal/blackbox.cpp
int BB_FindThrottledType(unsigned int hash, int *pos);
char BB_CheckThrottle(const char *name);
void BB_SetThrottle(const char *name, int throttle);
void BB_Print(ControllerIndex_t controllerIndex, const char *name, const char *fmt, ...);
void GScr_BBPrint();
void BB_WriteInstanceData(ControllerIndex_t controllerIndex);
int BB_RegisterHighWaterMark(const char *name);
void BB_SetHighWaterMark(int idx, unsigned int value);
void BB_SetupMsg();
void BB_Enable_f();
void BB_Disable_f();
void BB_Throttle_f();
void BB_Start();
void BB_Start_f();
void BB_Send(ControllerIndex_t controllerIndex, bool force, bool bandwidthLimited);
void BB_Alert(const char *filename, int line, const char *type, const char *msg);
void BB_Notify(bool daily, const char *recipient, const char *msg, bool immediate);
void BB_ResetHighWaterMarks();
void BB_ResetHighWaterMark(const char *name);
void BB_Send_f();
void BB_Init();

//t6/code/src_noserver/universal/blackbox_data.cpp
void BB_InitStringCache();
void BB_ClearStringCache();
unsigned int BB_HashString(const char *str, int len);
int BB_CacheString(const char *str, int len);
void BB_WriteString(bb_msg_t *msg, const char *str, int len);
void BB_MsgInit(bb_msg_t *msg, void *data, int maxsize);
void BB_MsgInitPPP(bb_msg_t *msg, void *pppHashTable, int size);
void BB_InitDefinitions();
void BB_RewriteDefinitions(bb_msg_t *a1, const void *a2);
int BB_BeginDefinition(const char *name);
unsigned __int8 BB_ParseParameter(const char *string, int len);
DefinitionMap *BB_GetDefinitionMap(unsigned int nameHash, unsigned int formatHash);
int BB_ParseAndCacheFormatString(;
void BB_WriteFormatParameters(;

//t6/code/src_noserver/universal/blackbox_data.h
void BB_Copy(bb_msg_t *msg, const void *_data, int len);
void BB_WriteVarUInt32(bb_msg_t *msg, unsigned int c);
void BB_WriteInt8(bb_msg_t *msg, int c);
void BB_WriteVarUInt64(bb_msg_t *msg, unsigned __int64 c);

//t6/code/src_noserver/universal/com_color.h
// void Byte4PackVertexColor(unsigned int a1@<ecx>, int a2@<ebp>, const vec4_t *from, unsigned __int8 *to);
void Byte4PackRgba(const vec4_t *from, unsigned __int8 *to);

//t6/code/src_noserver/universal/com_constantconfigstrings.cpp
void CCS_ClearConstantConfigStrings();
void CCS_ValidateChecksums(int serverChecksum, int clientChecksum);
int CCS_GetChecksum();
void CCS_LoadConstantConfigStrings(const char *mapname, const char *gametype);
const GfxViewParms *CCS_GetConfigStringValue(const int rowNum);
int CCS_FindConfigStringRow(const char *value, const int previousRow);

//t6/code/src_noserver/universal/com_convexhull.cpp
void Com_InitialHull(;
unsigned int Com_RecursivelyGrowHull(;
unsigned int Com_GrowInitialHull(;
void Com_TranslatePoints(vec2_t *points, unsigned int pointCount, vec2_t *offset);
// signed int Com_ConvexHull@<eax>(;

//t6/code/src_noserver/universal/com_encode.cpp
int Com_EncodeYEnc(unsigned __int8 *indata, int inlen, char *outdata, int outlen);
int Com_DecodeYEnc(const char *indata, unsigned __int8 *outdata, int outlen);

//t6/code/src_noserver/universal/com_expressions.cpp
char *GetOperandAsString(Operand operand);
void Expression_Free(ExpressionStatement *statement);
expressionEntry *Expression_Alloc(ExpressionAllocState *allocState, int size);
int Expression_ParseOperatorToken(const char *token);
// expressionEntry *Expression_HashOperand@<eax>(int a1@<edx>, ExpressionAllocState *a2@<ecx>, const char *str);
expressionRpn *MakeRPN(expressionEntry *entry, int *length);
char Expression_Parse(;
char Expression_Read(int handle, ExpressionStatement *statement);

//t6/code/src_noserver/universal/com_expressions_eval.cpp
void AddOperandToStack(OperandStack *dataStack, Operand *data, bool addAddress);
char *GetSourceString(Operand operand);
void StringCopyZ(char *buffer, const char *string, int size);
char *GetTempString();
char *CopyTempString(const char *string);
double GetSourceFloat(Operand *source);
int GetSourceInt(Operand *source);
__int64 GetSourceInt64(Operand *source);
const char *GetNameForValueType(expDataType valType);
void GetMilliseconds(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDualWield(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsFuelWeapon(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPartyMissingMapPack(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPartyMissingMapPackError(;
void IsInGame(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
const char *GetLocalizedTimeRemaining(int secondsRemaining);
void ShowBusyDotsIndicator(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetMaxRecommendedPlayers(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AreWeAcceptingInvite(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTimeLeft(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetGameTime(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetGametypeObjective(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetGametypeName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetGametypeInternal(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void UI_GetOnlineFriendCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFollowing(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanSpecCycle(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanSpecFree(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemSelectedLayer(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemPurchasedLayerCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemIsModified(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemBackgroundCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemSelectedBackground(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTotalPlayersOnlineString(;
void IsDemoPlaying(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoClipRecording(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoClipPlaying(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoClipPreviewRunning(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoMovieRendering(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoThirdPersonCamera(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoMovieCamera(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDisplayingPartyScoreboard(;
void GetDemoTitleName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoTitleDescription(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoAuthor(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoTimeInfo(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoDuration(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoSegmentCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsClipModified(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanStartDemoPlayback(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoCameraEditMode(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoDollyCamera(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetHighlightedCameraMarker(;
void IsRepositioningCameraMarker(;
void GetDollyCamMarkerCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemoHighlightReelMode(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsCurrentOrPreviousMapEntryAvailable(;
void GetCurrentMapTableName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCurrentMapName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCurrentGameType(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPreviousMapName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPreviousGameType(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsPartyReady(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void HowManyReadiesNeeded(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsExtraCamActive(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCurrentWeapon(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsExtraCamStatic(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void HasTacticalMaskOverlay(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void InVehicle(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTimeUntilNewContracts(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClanName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClanTagAndName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetXUID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetXUID_ull(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetSelfGamertag(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsProfileSignedIn(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
bool GetSearchState(ddlState_t *searchState, OperandList *operandList, int listStartIndex);
void GetStatValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetControllerType(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsStableStatsBufferInitialized(;
void GetIndexIntoMatchScoreboard(;
void GetNumWeaponUnlocks(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetNumFeatureUnlocks(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetRenderTooltip(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetMaxControllerCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFileshareRecentGamesCount(;
void MenuHasFocus(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetRank(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPrestige(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
bool IsClassBonusMatch(const char *tableData, const char *playerData);
const char *ClassBonusStatQuery(;
int FindClassBonusMatches(;
int GetClassBonusInternal(LocalClientNum_t localClientNum, const StringTable *table, const char *className);
void GetMachineID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetLocalClientNum(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsPrimaryLocalClient(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetSelectedEmblemLayer(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ValidateLocalizedStringRef(const char *token, int tokenLen);
void GetLeaderboardValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUsedControllerCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetNonUsedControllerCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPrimaryController(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsControllerBeingUsed(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SessionMode_IsOnlineGame(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SessionMode_IsSystemlinkGame(;
void SessionMode_IsPublicOnlineGame(;
void SessionMode_IsZombiesGame(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SessionMode_IsPrivateOnlineGame(;
void GetCurrentPlatform(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCurrentExe(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
int Expression_GetIndexForFunction(int func);
void Expression_Rebase(ExpressionStatement *statement);
void Expression_Error(const char *str, ...);
void Expression_Warn(const char *str, ...);
void Expression_TraceInternal(const char *str, ...);
char GetOperand(OperandStack *dataStack, Operand *data, Operand **address);
char GetOperandList(OperandStack *dataStack, OperandList *list);
void GetDvarValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDvarStringValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDvarBoolValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDvarIntValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDvarFloatValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetProfileValueAsString(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetProfileStringValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetProfileArrayStringValue(;
void GetProfileFloatValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetProfileIntValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetProfileBoolValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void FormatFloat(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
const UILocalVar *GetLocalVar(LocalClientNum_t localClientNum, Operand *source);
void GetLocalVarStringValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetLocalVarBoolValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetLocalVarIntValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetLocalVarFloatValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetSinValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCosValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlayerField(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFieldForTeam(;
void GetOtherTeamField(;
void GetTeamField(;
void GetTeamMarinesField(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTeamOpForField(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTeamThreeField(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUIActive(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsViewportLarge(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFlashbanged(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetScoped(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void InKillcam(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSelectingLocationalKillstreak(;
void isInGuidedMissile(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCrosshairTraceMeters(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsAirburstWeapon(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetAirburstMeters(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void isWeaponLockStarted(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void isWeaponLockSet(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTurretWeapon(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSelectingAirstrike(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSelectingArtillery(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSelectingNapalm(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSelectingMortar(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSelectingComlink(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetScoreboardVisible(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetIsIntermission(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetIsSuperUser(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUserTier(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetSelectingLocation(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ShowZombieMap(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void PrivatePartyHostInLobby(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AloneInPrivateParty(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AloneInPrivatePartyIgnoreSplitscreen(;
void AloneInLobby(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AloneInLobbyIgnoreSplitscreen(;
void GameHost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void InLobby(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void InPrivateParty(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsVisibilityBitSet(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void PrivatePartyHost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Splitscreen(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SplitscreenHost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SplitscreenNum(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsCinematicFinished(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsCinematicWebm(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemLocked(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemLockedForAll(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsClanTagFeatureLocked(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClanTagFeatureCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClanTagFeatureName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsClanTagFeaturePurchased(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClanTagFeaturePlevel(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemDualWieldLocked(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemDualWieldPurchased(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemNew(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemGroupNew(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetAttachmentsFormatted(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetAttachmentName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetAttachmentImage(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetAttachmentDesc(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsAttachmentAllowedOnItemIndex(;
void GetWeaponOptionImage(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWeaponOptionName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWeaponOptionGroupIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanRateFilmInTheater(const LocalClientNum_t locaClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoFileID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFileShareTotalVotes(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCounterTotal(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDownloadProgress(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUploadProgress(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUploadTimeRemaining(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void HostMigrationWaitingForPlayers(;
void GetWeaponOptionUnlockLvl(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWeaponOptionUnlockPLevel(;
void GetItemRef(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemImage(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemUnlockLevel(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemUnlockPLevel(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemMomentumCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemAllocationCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemDualWieldCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemAttachmentRecentlyUnlocked(;
void HasRecentItemAttachmentsUnlocked(;
void GetNumItemGroups(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetNumBulletWeapons(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemGroupByIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUnlockIndexFromGroupName(;
void GetUnlockLocString(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetRecentUnlocks(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemGroup(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemDesc(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemDualWieldIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemDualWieldBaseIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDefaultClassSlot(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetItemAttachment(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetNumLives(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void PlayersAlive(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlayerStatByName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetLowestLocalCP(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetKeyBinding(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetActionSlotUsable(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetHudFade(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsMenuOpen(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void WritingData(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void LogicalNot(const LocalClientNum_t localClientNum, Operand *source, Operand *result);
void BitwiseNot(const LocalClientNum_t localClientNum, Operand *source, Operand *result);
void BitShiftLeft(;
void BitShiftRight(;
void GetAdsJavelin(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWeapLockBlink(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWeapAttackTop(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWeapAttackDirect(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ToUpper(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsInputLockedByLUI(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlaylistName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlaylistCategoryName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SecondsAsTimeDisplay(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void SecondsAsCountdownDisplay(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetBombTime(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlaylistMaxPartySize(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetScore(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetGameMessageWindowActive(;
void GetClientInPlace(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlaceWithTiesForScore(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemLayerName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemLayerState(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemLayerCanOutline(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemLayerCanDuplicate(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemLayerCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemLayerUnlockLevel(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemIconName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemIconUnlockDesc(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemIconCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemIconState(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemBackgroundIsLocked(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemBackgroundIsClassified(;
void EmblemBackgroundIsPurchased(;
void EmblemBackgroundMaterial(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemPlayerBackgroundMaterial(;
void EmblemBackgroundName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemBackgroundUnlockDesc(;
void EmblemStateDisplay(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemCategoryDisplay(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemFilterCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemFilterIconID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void EmblemBackgroundCost(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GridMove(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClientName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ToOrdinal(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void FormatNumberWithCommas(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetScoreForClient(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoSegmentInformation(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoSaveScreenName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDemoSaveScreenDescription(;
void GetTheaterFilmNotSelectedMessage(;
void GetDollyCamMarkerInformationForTime(;
void GetDemoFreeCamModeName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void DoAllPlayersHaveMapForDemo(;
void IsUsingGamepad(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetNumSortedItemsEquipped(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemEquipped(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsItemPurchased(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ItemHasDualWield(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ItemIsDualWield(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetNumItemAttachmentsWithAttachPoint(;
void GetUserTagFromIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanShowContentFromUser(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsFFOTDFetched(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanRenderClip(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFileShareFilterList(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetLiveGroupCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsPlayerInvitable(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_FUNC_ISCLANMEMBER(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFlagCarrierForTeam(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFlagStatusForTeam(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetContractExpirationType(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetContractCombatTimeLeft(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetContractRewardText(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsTaskInProgress(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetIndexForNthActiveContract(;
void GetClanDateFounded(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPlayerCardTitle(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetRankByXUID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetPrestigeByXUID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDisplayLevelByXUID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsLocalPlayerXUID(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetMutedStatus(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSignedIn(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsSignedInToLive(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AnySignedIn(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AnySignedInToLive(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AnySignedInToLiveAndStatsFetched(;
void AreStatsFetched(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void AreContractsFetched(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsTimeSynced(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsAnyControllerMPRestricted(;
void IsContentRatingAllowed(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsDemonwareFetchingDone(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsFacebookLinked(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUIRect(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDStat(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetDStatArrayCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCareerDStat(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetStatForFriendOrSelf(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetToastPopupWidth(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetToastPopupIcon(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetToastPopupTitle(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetToastPopupDescription(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFloatAsFormattedString(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWagerWinningsFromMatchScoreboard(;
void GetScoreboardColumnHeader(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetWagerPlaceForMatchScoreboard(;
void lbGetStat(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void lbGetDeltaStat(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void lbGetCache(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void lbGetScoreboardStat(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetUnlockedWeaponItemIndex(;
void GetUnlockedFeatureItemIndex(;
void GetCacFactionNameWithButtons(;
void GetImageWidth(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetTextWidth(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void HasFocus(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsVisible(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFeederData(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsCompositeValid(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void TableLookupGetColumnValueForRow(;
void TableLookup(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void StatsTableLookup(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetClassBonus(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetCACItemIndex(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsFriendFromXuid(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void CanSwitchToLobby(const LocalClientNum_t locaClientNum, itemDef_s *item, OperandStack *dataStack);
void GetFeederCount(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetMapIndexByName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GetGamemodeIndexByName(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RandomIntRange(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void MinValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void MaxValue(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Select(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Choose(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void LocalizeString(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_FUNC_TOINT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_FUNC_TOSTRING(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_FUNC_TOFLOAT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_NOOP();
void RPN_FUNC_INVALID();
void RPN_OP_NOT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_BITWISENOT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_BITSHIFTLEFT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_BITSHIFTRIGHT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_NEGATE(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_MULTIPLY(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_DIVIDE(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_MODULUS(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_ADD(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_LESSTHAN(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_LESSTHANEQUALTO(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_GREATERTHAN(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_GREATERTHANEQUALTO(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_EQUALS(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_NOTEQUAL(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_AND(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_OR(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_BITWISEAND(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_BITWISEOR(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_SUBTRACT(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void RPN_OP_COMMA(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void ApproxEquals(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Add64(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Sub64(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Div64(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void Mul64(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void FileExists(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void GameMode_IsMode(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
bool EvaluateExpression(;
// const GfxViewParms *GetExpressionResultString@<eax>(;
// bool IsExpressionTrue@<al>(;
// __int64 GetExpressionInt64@<edx:eax>(;
// double GetExpressionFloat@<st0>(;
const GfxViewParms *GetExpressionResultStringCompile(;
int GetPlayerStatus(const ControllerIndex_t controllerIndex, unsigned __int64 playerXuid);
void IsPlayerJoinable(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);
void IsPlayerInTitle(const LocalClientNum_t localClientNum, itemDef_s *item, OperandStack *dataStack);

//t6/code/src_noserver/universal/com_expressions_load_db.h
void Load_expressionRpnArray(bool atStreamStart, int count);
void Load_ExpressionStatement(bool atStreamStart);

//t6/code/src_noserver/universal/com_files.cpp
void TRACK_com_files();
BOOL FS_Initialized();
void FS_CheckFileSystemStarted();
int FS_IwdIsPure(const iwd_t *iwd);
int FS_LoadStack();
BOOL FS_UseSearchPath(const searchpath_s *pSearch);
int FS_LanguageHasAssets(int iLanguage);
int FS_HashFileName(const char *fname, int hashSize);
int FS_HandleForFile(const char *name, FsThread thread);
int FS_HandleForFileCurrentThread(const char *filename);
_iobuf *FS_FileForHandle(int f);
__int64 FS_filelength(int f);
void FS_ReplaceSeparators(char *path);
void FS_BuildOSPathForThread(;
void FS_BuildOSPath(const char *base, const char *game, const char *qpath);
int FS_CreatePath(char *OSPath);
void FS_CopyFile(char *fromOSPath, char *toOSPath);
void FS_FCloseFile(int h);
void FS_FCloseLogFile(int h);
int FS_GetHandleAndOpenFile(const char *filename, const char *ospath, FsThread thread);
int FS_FOpenFileWriteToDirForThread(;
int FS_FOpenFileWriteToDir(const char *a1, const char *a2);
int FS_FOpenFileWrite(const char *a1, const char *a2);
// int FS_FOpenFileWriteCurrentThread@<eax>(FsThread a1@<edi>);
int FS_FOpenTextFileWrite(const char *filename);
int FS_FOpenFileAppend(const char *filename);
int FS_FilenameCompare(const char *s1, const char *s2);
BOOL FS_PureIgnoreFiles(const char *filename);
bool FS_SanitizeFilename(const char *filename, char *sanitizedName, int sanitizedNameSize);
char FS_FilesAreLoadedGlobally(const char *filename);
BOOL FS_Delete(const char *filename);
int FS_Read(void *buffer, int len, int h);
int FS_Write(const void *buffer, int len, int h);
int FS_WriteToDemo(const void *buffer, int len, int h);
void FS_Printf(int h, const char *fmt, ...);
int FS_Seek(int f, int offset, int origin);
void FS_ResetFiles();
// int FS_WriteFile@<eax>(;
// int FS_GetFileOsPath@<eax>(char *a1@<edx>, const char *a2@<ecx>, const char *filename, char *ospath);
// int FS_OpenFileOverwrite@<eax>(char *a1@<edx>, const char *a2@<ecx>, const char *qpath);
int FS_ReturnPath(const char *zname, char *zpath, int *depth);
int FS_AddFileToList(HunkUser *user, const char *name, const char **list, int nfiles);
const char **FS_ListFilteredFiles(;
bool FS_CheckLocation(const char *path, int lookInFlags);
int FS_GetFileList(;
void FS_ConvertPath(char *s);
void FS_SortFileList(const char **filelist, int numfiles);
void FS_DisplayPath(int bLanguageCull);
void FS_FullPath_f();
void FS_Path_f();
void FS_AddGameDirectory(const char *path, const char *dir, int bLanguageDirectory, int iLanguage);
void FS_AddLocalizedGameDirectory(const char *path, const char *dir);
void FS_ShutdownSearchPaths(searchpath_s *p);
void FS_ShutdownServerFileReferences(int *numFiles, const char **fileNames);
void FS_ShutdownServerIwdNames(int *a1, const char **a2);
void FS_ShutdownServerReferencedIwds(int *a1, const char **a2);
void FS_ShutdownServerReferencedFFs(int *a1, const char **a2);
void FS_Shutdown();
const dvar_t *FS_RegisterDvars();
void FS_AddDevGameDirs(const char *path, bool allow_devraw);
void FS_Startup(const char *gameName, const char *allow_devraw);
void FS_ClearIwdReferences();
void FS_AddIwdPureCheckReference(const searchpath_s *search);
void FS_ShutDownIwdPureCheckReferences();
// void FS_InitFilesystem(const char *a1@<edx>, const char *allow_devraw);
void FS_Restart(LocalClientNum_t localClientNum, int checksumFeed);
BOOL FS_IsInCompressedIwd(int f);
void FS_Flush(int f);
char Com_IsAddonMap(const char *mapName, const char **pBaseMapName);
void FS_DisablePureCheck(bool disable);
int FS_FOpenFileReadForThread(;
int FS_FOpenFileReadCurrentThread(const char *filename, int *file);
void Com_GetBspFilename(char *filename, int size, const char *mapname);
int FS_FOpenFileRead(const char *filename, int *file);
BOOL FS_TouchFile(const char *name);
// int FS_FOpenFileByMode@<eax>(;

//t6/code/src_noserver/universal/com_files_wrapper_stdio.h
_iobuf *FileWrapper_Open(const char *ospath, const char *mode);
int FileWrapper_Seek(int h, int offset, int origin);

//t6/code/src_noserver/universal/com_math.cpp
void TRACK_com_math();
long double I_normCDF(long double x);
double random();
double crandom();
int RandWithSeed(int *seed);
double LinearTrack(float tgt, float cur, float rate, float deltaTime);
double LinearTrackAngle(float tgt, float cur, float rate, float deltaTime);
double DiffTrack(float tgt, float cur, float rate, float deltaTime);
double DiffTrackAngle(float tgt, float cur, float rate, float deltaTime);
double GraphGetValueFromFraction(const int knotCount, const vec2_t *knots, const float fraction);
double Q_acos(const float c);
char ClampChar(const int i);
int ClampShort(const int i);
unsigned __int8 DirToByte(const vec3_t *dir);
void ByteToDir(const int b, vec3_t *dir);
int VecNCompareCustomEpsilon(const vec3_t *v0, const vec3_t *v1, float epsilon, int coordCount);
void Vec3ProjectionCoords(const vec3_t *dir, int *xCoord, int *yCoord);
void vectoyaw(vec2_t const &);
void vectosignedyaw(vec2_t const &);
void vectopitch(vec3_t const &);
void vectoangles(vec3_t const &,vec3_t &);
void YawVectors(float yaw, vec3_t *forward, vec3_t *right);
void YawVectors2D(float yaw, vec2_t *forward, vec2_t *right);
void PerpendicularVector(const vec3_t *src, vec3_t *dst);
double PointToLineSegmentDistSq2D(const vec2_t *point, const vec2_t *start, const vec2_t *end);
double PointToLineSegmentDistSq(const vec3_t *point, const vec3_t *start, const vec3_t *end);
int BoxInPlanes(const vec4_t *planes, unsigned int numPlanes, const vec3_t *mins, const vec3_t *maxs);
int SphereInPlanes(const vec4_t *planes, unsigned int numPlanes, const vec3_t *center, const float radius);
void MatrixIdentity33(vec3_t *out);
void MatrixIdentity44(vec4_t *out);
void MatrixMultiply(const vec3_t *in1, const vec3_t *in2, vec3_t *out);
void MatrixVecMultiply(const vec3_t *mulMat, const vec3_t *mulVec, vec3_t *solution);
void MatrixVecMultiplyProject(const vec4_t *mulMat, const vec3_t *mulVec, vec3_t *solution);
void MatrixMultiply43(const vec3_t *in1, const vec3_t *in2, vec3_t *out);
void MatrixMultiply44(const vec4_t *in1, const vec4_t *in2, vec4_t *out);
void MatrixTranspose(const vec3_t *in, vec3_t *out);
void MatrixTranspose44(const vec4_t *in, vec4_t *out);
void MatrixInverse(const vec3_t *in, vec3_t *out);
void MatrixInverseOrthogonal43(const vec3_t *in, vec3_t *out);
void MatrixInverse44(const vec4_t *mat, vec4_t *dst);
void MatrixTransformVector44(const vec4_t *vec, const vec4_t *mat, vec4_t *out);
void MatrixTransformVector43(const vec3_t *in1, const vec3_t *in2, vec3_t *out);
void MatrixTransposeTransformVector43(const vec3_t *in1, const vec3_t *in2, vec3_t *out);
void MatrixTransformVector43Equals(vec3_t *out, const vec3_t *in);
void VectorAngleMultiply(vec2_t *vec, float angle);
void UnitQuatToAxis(const vec4_t *quat, vec3_t *axis);
void UnitQuatToForward(const vec4_t *quat, vec3_t *forward);
// void QuatSlerp(float a1@<edi>, const vec4_t *from, const vec4_t *to, float frac, vec4_t *result);
long double RotationToYaw(const vec2_t *rot);
void FinitePerspectiveMatrix(float tanHalfFovX, float tanHalfFovY, float zNear, float zFar, vec4_t *mtx);
;
;
void SpotLightProjectionMatrix(float cosFov, float zNear, float zFar, vec4_t *mtx);
void InfinitePerspectiveMatrix(float tanHalfFovX, float tanHalfFovY, float zNear, vec4_t *mtx);
void MatrixForViewer(const vec3_t *origin, const vec3_t *axis, vec4_t *mtx);
void AnglesSubtract(const vec3_t *v1, const vec3_t *v2, vec3_t *v3);
void AnglesSubtract(const vec2_t *v1, const vec2_t *v2, vec2_t *v3);
double AngleNormalize360(const float angle);
double RadiusFromBounds2DSq(const vec2_t *mins, const vec2_t *maxs);
void ExtendBounds(vec3_t *mins, vec3_t *maxs, const vec3_t *offset);
void ExpandBoundsToWidth(vec3_t *mins, vec3_t *maxs);
void AddPointToBounds(const vec3_t *v, vec3_t *mins, vec3_t *maxs);
void AddPointToBounds2D(const vec2_t *v, vec2_t *mins, vec2_t *maxs);
BOOL BoundsOverlap(const vec3_t *mins0, const vec3_t *maxs0, const vec3_t *mins1, const vec3_t *maxs1);
void ExpandBounds(const vec3_t *addedmins, const vec3_t *addedmaxs, vec3_t *mins, vec3_t *maxs);
void AxisClear(vec3_t *axis);
void AxisCopy(const vec3_t *in, vec3_t *out);
void AxisTranspose(const vec3_t *in, vec3_t *out);
void AxisTransformVec3(const vec3_t *axes, const vec3_t *vec, vec3_t *out);
void YawToAxis(float yaw, vec3_t *axis);
void AxisToAngles(const vec3_t *axis, vec3_t *angles);
void Axis4ToAngles(const vec4_t *axis, vec3_t *angles);
int IntersectPlanes(const float **planein, vec3_t *xyz);
int ProjectedWindingContainsCoplanarPoint(;
int PlaneFromPoints(vec4_t *plane, const vec3_t *v0, const vec3_t *v1, const vec3_t *v2);
void ProjectPointOnPlane(const vec3_t *p, const vec3_t *normal, vec3_t *dst);
void SetPlaneSignbits(cplane_s *out);
;
int IsPosInsideArc(;
double Q_rint(const float in);
double ColorNormalize(const vec3_t *in, vec3_t *out);
void ColorSRGBtoLinear(vec3_t const &,vec3_t &);
long double PitchForYawOnNormal(const float fYaw, const vec3_t *normal);
void NearestPitchAndYawOnPlane(const vec3_t *angles, const vec3_t *normal, vec3_t *result);
void Rand_Init(int seed);
unsigned int *GetRandSeed();
double flrand(float min, float max);
int irand(int min, int max);
void AxisToQuat(const vec3_t *mat, vec4_t *out);
void QuatLerp(const vec4_t *qa, const vec4_t *qb, float frac, vec4_t *out);
bool CullBoxFromCone(;
bool CullBoxFromSphere(;
char CullBoxFromConicSectionOfSphere(;
bool CullSphereFromCone(;
// int colorTempToXYZ@<eax>(int result@<eax>, float a2@<xmm0>);
// void colorTempMatrix(__m128 a1@<xmm6>, vec4_t *finalMatrix, float colorTemp);
;
void colorSaturationMatrix(vec4_t *finalMatrix, float saturation);
long double I_fnormPDF(float x);
float I_fnormCDF(float x);
void RotatePointAroundVector(vec3_t *dst, const vec3_t *dir, const vec3_t *point, const float degrees);
void Vec3Basis_RightHanded(const vec3_t *forward, vec3_t *left, vec3_t *up);
void UnitQuatToAngles(const vec4_t *quat, vec3_t *angles);
long double RadiusFromBounds(const vec3_t *mins, const vec3_t *maxs);
long double RadiusFromBounds2D(const vec2_t *mins, const vec2_t *maxs);
void SnapPointToIntersectingPlanes(const float **planes, vec3_t *xyz, float snapGrid, float snapEpsilon);

//t6/code/src_noserver/universal/com_math.h
double I_fclamp(float val, float min, float max);
double AngleNormalize180(const float angle);
double AngleDelta(const float a1, const float a2);
int I_max(int x, int y);
int I_min(int x, int y);
double LerpAngle(const float from, const float to, const float frac);
void LerpAngleVector(const vec3_t *from, const vec3_t *to, const float frac, vec3_t *result);
double I_rsqrt(const float number);
double I_fmax(float x, float y);
double I_fmin(float x, float y);
double ClampFloat(const float x, const float min, const float max);
void MatrixTransformVector(const vec3_t *in1, const vec3_t *in2, vec3_t *out);
int ClampInt(const int x, const int min, const int max);
void QuatMultiply(const vec4_t *in1, const vec4_t *in2, vec4_t *out);
void PitchToQuat(float pitch, vec4_t *quat);
void MatrixTransformVectorQuatTrans(const vec3_t *in, const DObjAnimMat *mat, vec3_t *out);
double I_fmodulus(float f, float mod);
unsigned int CountBitsEnabled(unsigned int num);
double I_fsign(float val);
void ConvertQuatToInverseSkelMat(const DObjAnimMat *mat, DObjSkelMat *skelMat);
void MatrixTransformVectorQuatTransEquals(const DObjAnimMat *in, vec3_t *inout);
double I_fres(float val);
void ConvertQuatToInverseMat(const DObjAnimMat *mat, vec3_t *axis);
double I_fmap(float minx, float maxx, float miny, float maxy, float x);
BOOL PointInBounds(const vec3_t *v, const vec3_t *mins, const vec3_t *maxs);

//t6/code/src_noserver/universal/com_math_anglevectors.cpp
void AngleVectors(const vec3_t *angles, vec3_t *forward, vec3_t *right, vec3_t *up);
void AnglesToAxis(const vec3_t *angles, vec3_t *axis);
void AnglesToQuat(const vec3_t *angles, vec4_t *quat);
void QuatToAxis(const vec4_t *quat, vec3_t *axis);
void vectosignedangles(vec3_t const &,vec3_t &);
void vectosignedpitch(vec3_t const &);
// void AxisToSignedAngles(long double a1@<esi:edi>, const vec3_t *axis, vec3_t *angles);

//t6/code/src_noserver/universal/com_memory.cpp
void TRACK_com_memory();
int Z_TryVirtualCommitInternal(void *ptr, int size);
;
void *Hunk_FindDataForFileInternal(int type, const char *name, int hash);
void Hunk_ClearDataFor(fileData_s **pFileData, unsigned __int8 *low, unsigned __int8 *high);
void Hunk_ClearData();
void DB_EnumXAssets_LoadObj(XAssetType type, void (*func)(XAssetHeader, void *), void *inData);
char DB_EnumXAssetsTimeout_LoadObj(XAssetType type, void (*func)(XAssetHeader, void *), void *inData);
void Hunk_AddAsset(XAssetHeader header, void *data);
void DB_EnumXAssets();
int DB_EnumXAssetsTimeout();
void Com_TempMeminfo_f();
int DB_GetAllXAssetOfType_LoadObj(XAssetType type, XAssetHeader *assets, int maxCount);
int DB_GetAllXAssetOfType();
unsigned __int8 *Hunk_AllocAlign(int size, int alignment, const char *name, int type);
unsigned __int8 *Hunk_AllocLowAlign(int size, int alignment, const char *name, int type);
unsigned __int8 *Hunk_Alloc(int size, const char *name, int type);
unsigned __int8 *Hunk_AllocLow(int size, const char *name, int type);

//t6/code/src_noserver/universal/com_pack.cpp
PackedUnitVec Vec3PackUnitVec(const vec3_t *unitVec);
void Vec3UnpackUnitVec(const PackedUnitVec in, vec3_t *out);
int Vec4PackQuat(const vec4_t *in);
PackedTexCoords Vec2PackTexCoords(const vec2_t *in);
PackedLmapCoords Vec2PackLmapCoords(const vec2_t *in);
void Vec2UnpackTexCoords(const PackedTexCoords in, vec2_t *out);
void Vec2UnpackLmapCoords(const PackedLmapCoords in, vec2_t *out);

//t6/code/src_noserver/universal/com_shared.cpp
char Com_Filter(const char *filter, const char *name, int casesensitive);
char Com_FilterPath(const char *filter, const char *name, int casesensitive);
const char *Com_HashKey(const char *string, int maxlen);
void Com_GetQTime(int time, qtime_s *qtime, bool useLocalTime);
int Com_RealTime(qtime_s *qtime, bool useLocalTime);
void Com_Memset(void *dest, const int val, int count);

//t6/code/src_noserver/universal/com_stringtable.cpp
int StringTable_FirstHashIndex(const StringTable *table, int hash);
int StringTable_LookupNearestRowNumForValue(;
int StringTable_LookupRowNumForValue(const StringTable *table, const int comparisonColumn, const char *value);
int StringTable_LookupRowNumForValue(;
const GfxViewParms *StringTable_GetColumnValueForRow(const StringTable *table, const int row, const int column);
const GfxViewParms *StringTable_Lookup(;
const GfxViewParms *StringTable_Lookup(;
const GfxViewParms *StringTable_Lookup(;
int StringTable_Find(;
int StringTable_RowCount(const StringTable *table);
unsigned int StringTable_Checksum(const StringTable *table, unsigned int initialCrc);
void StringTable_GetAsset_FastFile(const char *filename, const StringTable **tablePtr);
void StringTable_GetAsset();
void StringTable_GetCoreAsset(CoreStringTable id, const StringTable **tablePtr);
int StringTable_FindCoreAssetIndex(const char *stringTableName);
int CellCompare(const void *a, const void *b);
void StringTable_ResortHashTable(StringTable *table);
bool Scr_GetAssetFromScriptParam(scriptInstance_t inst, const StringTable **tablePtr);
void Scr_TableLookupFindCoreAsset(scriptInstance_t inst);
void Scr_TableLookupRowNum(scriptInstance_t inst);
void Scr_TableLookupColumnForRow(scriptInstance_t inst);
void Scr_TableLookup(scriptInstance_t inst);
void Scr_TableLookupIString(scriptInstance_t inst);

//t6/code/src_noserver/universal/com_stringtable_load_db.h
void Load_StringTableCellArray(bool atStreamStart, int count);
void Load_StringTable(bool atStreamStart);
void Load_StringTablePtr(bool atStreamStart);
void Mark_StringTablePtr();

//t6/code/src_noserver/universal/com_stringtable_obj.cpp
int StringTable_HashString(const char *string);
unsigned __int8 *StringTable_Alloc(int size);
void StringTable_ParseFileIntoTable(const char *filename, StringTable *table);
void StringTable_GetAsset_LoadObj(const char *filename, const StringTable **tablePtr);

//t6/code/src_noserver/universal/com_tasks.cpp
int ChunkAllocate(int index, int blocks);
void ChunkFree(int index, int blocks);
int Task_Allocate(int bytes);
void Task_Deallocate(void *ptr, int bytes);
BOOL TaskManager2_GetTaskRuleErrors();
bool TaskManager2_IsTimedIn(TaskRecord *task);
void TaskManager2_ProcessXOverlappedTask(TaskRecord *task);
void TaskManager2_RevertTask(TaskRecord *task);
void TaskManager2_ClearTask(TaskRecord *task);
void TaskManager2_ClearTasks(const TaskDefinition *definition);
void TaskManager2_SkipCallbacksForTaskAfterComplete(TaskRecord *task);
void TaskManager2_SkipCallbacksForTasksAfterComplete(const TaskDefinition *definition);
char TaskManger2_TaskGetInProgressForControllerByName(;
BOOL TaskManager2_TaskIsPending(const TaskRecord *task);
void TaskManager2_DumpTasks();
void TaskManager2_RunTaskRules(TaskRecord *task);
void TaskManager2_RecordTaskInfo(TaskRecord *task);
void TaskManager2_Init();
void TaskManager2_ReportTaskComplete(;
void TaskManager2_FreeAllPendingTasksInternal(const ControllerIndex_t localControllerIndex);
void TaskManager2_HandleTimedOutTask(TaskRecord *TimedOutTask);
void TaskManager2_ProcessLocalTask(TaskRecord *task);
void TaskManager2_CancelEndlessTasks(ControllerIndex_t localControllerIndex);
void TaskManager2_ProcessDemonwareTask(TaskRecord *task);
void TaskManager2_ProcessNestedTask(TaskRecord *task);
TaskRecord *TaskManager2_CreateTask(;
void TaskManager2_EnumTasksInProgress(void (*func)(TaskRecord *, void *), void *inData);
TaskRecord *TaskManager2_TaskGetInProgressForController(;
TaskRecord *TaskManager2_TaskGetInProgress(const TaskDefinition *definition);
TaskRecord *TaskManager2_TaskGetInProgressCallBackSkipCallbacks(const TaskDefinition *definition);
BOOL TaskManager2_TaskIsInProgressForController(;
BOOL TaskManager2_TaskIsInProgress(const TaskDefinition *definition);
int TaskManager2_CountTasksInProgress(const TaskDefinition *definition);
int TaskManager2_CountTasksInProgressForControllerByType(;
void TaskManager2_FreeDeadTasks(const ControllerIndex_t localControllerIndex);
void TaskManager2_ProcessTasks(const ControllerIndex_t localControllerIndex);
void TaskManager2_StartTask(TaskRecord *task);
TaskRecord *TaskManager2_SetupNestedTask(;
TaskRecord *TaskManager2_SetupRemoteTask(;
void TaskManager2_ComErrorCleanup();

//t6/code/src_noserver/universal/com_utf.cpp
int utf32_tocase(int wc, int lower);
int utf32_toupper(int wc);
char *utf8_to_utf32(char *in, int len, int *result);
char *utf32_to_utf8(int in, char *out, int len);

//t6/code/src_noserver/universal/com_vector.h
double Vec2Normalize(vec2_t *v);
double Vec2NormalizeTo(const vec2_t *v, vec2_t *out);
double Vec3LengthSq(const vec3_t *v);
BOOL Vec3NotZero(const vec3_t *a);
double Vec3Normalize(vec3_t *v);
void Vec3Cross(const vec3_t *v0, const vec3_t *v1, vec3_t *cross);
double Vec3NormalizeTo(const vec3_t *v, vec3_t *out);
void Vec3RotateTranspose(const vec3_t *in, const vec3_t *matrix, vec3_t *out);
BOOL Vec3Compare(const vec3_t *a, const vec3_t *b);
BOOL Vec3IsNormalized(const vec3_t *v);
void Vec3Rotate(const vec3_t *in, const vec3_t *matrix, vec3_t *out);
BOOL Vec4Compare(const vec4_t *a, const vec4_t *b);
double Vec3Dir(const vec3_t *p1, const vec3_t *p2, vec3_t *dir);
void Vec2NormalizeFast(vec2_t *v);
BOOL Vec3IsNormalizedEpsilon(const vec3_t *v, float epsilon);

//t6/code/src_noserver/universal/com_workercmds.cpp
void Sys_WorkerCmdInit();
bool Sys_IsWorkerCmdReady();
unsigned int *jqCommitMemory(jqBatch *batch, void *input, unsigned int dataSize);
void jqSafeFlush(jqBatchGroup *group, unsigned __int64 batchCount);
unsigned int *jqCallbackPre(jqBatch *batch, const char *name);
void jqCallbackPost(jqBatch *batch, void *data, bool finished);
void Sys_AddWorkerCmdToQueueInternal(;
void Sys_AddWorkerCmdInternal(jqWorkerCmd *name, void *data, WorkerCmdConditional *cond);
void Sys_AddWorkerCmdGroupedToQueueInternal(;
void Sys_AddWorkerCmdGroupedInternal(;
void Sys_WaitWorkerCmdInternal(jqWorkerCmd *name);
BOOL Sys_AssistSingleCallback(void *context);
void Sys_AssistSingle();
bool Sys_AssistNeeded();
int Sys_GetWorkerQueuedCountInternal(jqWorkerCmd *name);
BOOL R_FinishedFrontendWorkerCmds();
void R_WaitFrontendWorkerCmds();
void Sys_AssistAndWaitWorkerCmdInternal(jqBatchGroup *group);
void Sys_AssistAndWaitWorkerCmdInternal(jqWorkerCmd *name);
void R_WaitDrawWorkerCmdsOfType(GfxWorkerData *workerData, unsigned __int8 cmdbufType);

//t6/code/src_noserver/universal/curve.cpp
void GetPositionOnCubic(;
// void __thiscall cCurve::Reset(cCurve *this);
// void __thiscall cCurve::Reinit(cCurve *this);
// void __thiscall cCurve::AddNode(cCurve *this, vec3_t *p);
// void __thiscall cCurve::AddNode(cCurve *this, vec3_t *p, float timePeriod);
// void __thiscall cCurve::GetPosition(cCurve *this, float time, vec3_t *pos);
// int cCurve::CurveSortCompare(const void *e1, const void *e2);
// void __thiscall cCurve::Sort(cCurve *this, vec3_t *p, bool is_increasing_sort_order);
// void __thiscall cCurve::BuildBSpline(cCurve *this);
// void __thiscall cCurve::GetPos(cCurve *this, float t, vec3_t *p);
// double __thiscall cCurve::GetLength(cCurve *this);
// void __thiscall cCurve::SetDraw(cCurve *this, const vec4_t *userColor);
// void __thiscall cCurve::cCurve(cCurve *this);
// void __thiscall cCurve::BuildNonUniform(cCurve *this);
// void __thiscall cCurve::Build(cCurve *this);

//t6/code/src_noserver/universal/curvemanager.cpp
// int cCurveManager::GetFreeCurve();
// void cCurveManager::AddNodeToCurve(int curve, vec3_t *p);
// void cCurveManager::AddNodeToCurve(int curve, vec3_t *p, float t);
// void cCurveManager::SortCurve(int curve, vec3_t *p, bool is_increasing_sort_order);
// void cCurveManager::BuildCurve(int curve);
// void cCurveManager::FreeCurve(int curve);
// void cCurveManager::SetCurveBSpline(int curve);
// void cCurveManager::SetCurveDraw(int curve, const vec4_t *color);
// void cCurveManager::GetPos(int curve, float t, vec3_t *p);
// double cCurveManager::GetCurveLength(int curve);

//t6/code/src_noserver/universal/dvar.cpp
void TRACK_dvar();
void Dvar_SetInAutoExec(bool inAutoExec);
bool Dvar_IsSystemActive();
char Dvar_IsValidName(const char *dvarName);
void Dvar_CopyString(const char *string, DvarValue *value);
void Dvar_WeakCopyString(const char *string, DvarValue *value);
bool Dvar_ShouldFreeCurrentString(dvar_t *dvar);
bool Dvar_ShouldFreeLatchedString(dvar_t *dvar);
bool Dvar_ShouldFreeResetString(dvar_t *dvar);
void Dvar_FreeString(DvarValue *value);
void Dvar_AssignCurrentStringValue(dvar_t *dvar, DvarValue *dest, const char *string);
void Dvar_AssignLatchedStringValue(dvar_t *dvar, DvarValue *dest, const char *string);
void Dvar_AssignResetStringValue(dvar_t *dvar, DvarValue *dest, const char *string);
const GfxViewParms *Dvar_EnumToString(const dvar_t *dvar);
const GfxViewParms *Dvar_IndexStringToEnumString(const dvar_t *dvar, const char *indexString);
const char *Dvar_ValueToString(const dvar_t *dvar, DvarValue value);
bool Dvar_StringToBool(const char *string);
int Dvar_StringToInt(const char *string);
__int64 Dvar_StringToInt64(const char *string);
float Dvar_StringToFloat(const char *string);
void Dvar_StringToVec2(const char *string, vec2_t *vector);
void Dvar_StringToVec3(const char *string, vec3_t *vector);
void Dvar_StringToVec4(const char *string, vec4_t *vector);
int Dvar_StringToEnum(const DvarLimits *domain, const char *string);
void Dvar_StringToColor(const char *string, unsigned __int8 *color);
DvarValue *Dvar_StringToValue(const dvarType_t type, const DvarLimits domain, const char *string);
const char *Dvar_DisplayableValue(const dvar_t *dvar);
const char *Dvar_DisplayableResetValue(const dvar_t *dvar);
const char *Dvar_DisplayableLatchedValue(const dvar_t *dvar);
DvarValue *Dvar_ClampValueToDomain(;
bool Dvar_ValueInDomain(dvarType_t type, DvarValue value, DvarLimits domain);
void Dvar_VectorDomainToString(int components, DvarLimits domain, char *outBuffer, int outBufferLen);
;
// const char *Dvar_DomainToString_GetLines@<eax>(;
// void Dvar_PrintDomain(char *a1@<edx>, dvarType_t type, DvarLimits domain);
int Dvar_ValuesEqual(dvarType_t type, DvarValue val0, DvarValue val1);
void Dvar_SetLatchedValue(dvar_t *dvar, DvarValue value);
BOOL Dvar_HasLatchedValue(const dvar_t *dvar);
dvarCallBack_t *findCallBackForDvar(const dvar_t *dvar);
dvar_t *Dvar_FindMalleableVar(int dvarHash);
dvar_t *Dvar_FindVar(const char *dvarName);
dvar_t *__thiscall Dvar_FindVar(void *this);
void Dvar_ClearModified(const dvar_t *dvar);
void Dvar_SetModified(const dvar_t *dvar);
bool Dvar_GetModified(const dvar_t *dvar);
dvar_t *__thiscall Dvar_GetInt(void *this);
const dvar_t *Dvar_GetUnsignedInt(const dvar_t *dvar);
double __thiscall Dvar_GetFloat(void *this);
void Dvar_GetVec2(const dvar_t *dvar, vec2_t *result);
void Dvar_GetVec3(const dvar_t *dvar, vec3_t *result);
void Dvar_GetVec4(const dvar_t *dvar, vec4_t *result);
const GfxViewParms *Dvar_GetString(const dvar_t *dvar);
const char *__thiscall Dvar_GetVariantString(void *this);
const char *Dvar_GetVariantString(const dvar_t *dvar);
void Dvar_GetUnpackedColor(;
void Dvar_GetColor(const dvar_t *dvar, unsigned __int8 *color);
// double Dvar_GetColorRed@<st0>(unsigned __int8 *a1@<edx>, const dvar_t *dvar);
double __thiscall Dvar_GetColorRed(void *this);
// double Dvar_GetColorGreen@<st0>(unsigned __int8 *a1@<edx>, const dvar_t *dvar);
double __thiscall Dvar_GetColorGreen(void *this);
// double Dvar_GetColorBlue@<st0>(unsigned __int8 *a1@<edx>, const dvar_t *dvar);
double __thiscall Dvar_GetColorBlue(void *this);
// double Dvar_GetColorAlpha@<st0>(unsigned __int8 *a1@<edx>, const dvar_t *dvar);
double __thiscall Dvar_GetColorAlpha(void *this);
bool Dvar_GetLatchedBool(const dvar_t *dvar);
int Dvar_GetLatchedInt(const dvar_t *dvar);
double Dvar_GetLatchedFloat(const dvar_t *dvar);
void Dvar_GetLatchedVec2(const dvar_t *dvar, vec2_t *result);
void Dvar_GetLatchedVec3(const dvar_t *dvar, vec3_t *result);
void Dvar_GetLatchedVec4(const dvar_t *dvar, vec4_t *result);
void Dvar_GetLatchedColor(const dvar_t *dvar, unsigned __int8 *color);
int Dvar_GetResetInt(const dvar_t *dvar);
const char *Dvar_GetResetString(const dvar_t *dvar);
void Dvar_GetResetVec3(const dvar_t *dvar, vec3_t *result);
const char **Dvar_GetDomainEnumStrings(const dvar_t *dvar);
int Dvar_GetDomainEnumStringCount(const dvar_t *dvar);
int Dvar_GetDomainIntMin(const dvar_t *dvar);
int Dvar_GetDomainIntMax(const dvar_t *dvar);
__int64 Dvar_GetDomainInt64Min(const dvar_t *dvar);
__int64 Dvar_GetDomainInt64Max(const dvar_t *dvar);
double Dvar_GetDomainFloatMin(const dvar_t *dvar);
double Dvar_GetDomainFloatMax(const dvar_t *dvar);
double Dvar_GetDomainVecMin(const dvar_t *dvar);
double Dvar_GetDomainVecMax(const dvar_t *dvar);
dvarType_t Dvar_GetType(const dvar_t *dvar);
DvarValue *Dvar_GetCurrent(DvarValue *result, const dvar_t *dvar);
DvarLimits *Dvar_GetDomain(DvarLimits *result, const dvar_t *dvar);
const char *Dvar_GetDescription(const dvar_t *dvar);
const dvar_t *Dvar_GetFlags(const dvar_t *dvar);
const char *Dvar_GetName(const dvar_t *dvar);
void Dvar_Shutdown();
void Dvar_PerformUnregistration(dvar_t *dvar);
void Dvar_UpdateResetValue(dvar_t *dvar, DvarValue value);
void Dvar_ChangeResetValue(const dvar_t *dvar, DvarValue value);
void Dvar_UpdateValue(dvar_t *dvar, DvarValue value);
;
void Dvar_ReinterpretDvar(;
const dvar_t *Dvar_RegisterNew(;
void Dvar_AddFlags(const dvar_t *dvar, int flags);
int Com_SaveDvarsToBuffer(const char **dvarnames, unsigned int numDvars, char *buffer, unsigned int bufsize);
void Dvar_SetModifiedCallback(const dvar_t *dvar, void (*callback)(const dvar_t *));
void Dvar_SetCanSetConfigDvars(bool canSetConfigDvars);
bool Dvar_CanSetConfigDvar(const dvar_t *dvar);
bool Dvar_CanChangeValue(const dvar_t *dvar, DvarValue value, DvarSetSource source);
void Dvar_SetVariant(dvar_t *dvar, DvarValue value, DvarSetSource source);
void Dvar_UpdateEnumDomain(const dvar_t *dvar, const char **stringTable);
bool Dvar_GetBool(const dvar_t *dvar);
int Dvar_GetInt(const dvar_t *dvar);
int Dvar_GetInt64(const dvar_t *dvar);
double Dvar_GetFloat(const dvar_t *dvar);
void Dvar_MakeLatchedValueCurrent(const dvar_t *dvar);
;
;
const dvar_t *_Dvar_RegisterBool(const char *dvarName, bool value, unsigned int flags, const char *description);
;
;
;
;
;
;
// const dvar_t *_Dvar_RegisterString@<eax>(;
;
const dvar_t *_Dvar_RegisterColor(;
;
;
void Dvar_SetBoolFromSource(const dvar_t *dvar, bool value, DvarSetSource source);
void Dvar_SetIntFromSource(const dvar_t *dvar, int value, DvarSetSource source);
void Dvar_SetInt64FromSource(const dvar_t *dvar, __int64 value, DvarSetSource source);
void Dvar_SetFloatFromSource(const dvar_t *dvar, float value, DvarSetSource source);
void Dvar_SetVec2FromSource(const dvar_t *dvar, float x, float y, DvarSetSource source);
void Dvar_SetVec3FromSource(const dvar_t *dvar, float x, float y, float z, DvarSetSource source);
void Dvar_SetVec4FromSource(const dvar_t *dvar, float x, float y, float z, float w, DvarSetSource source);
void Dvar_SetStringFromSource(const dvar_t *dvar, const char *string, DvarSetSource source);
void Dvar_SetColorFromSource(const dvar_t *dvar, float r, float g, float b, float a, DvarSetSource source);
void Dvar_SetBool(const dvar_t *dvar, bool value);
void Dvar_SetInt(const dvar_t *dvar, int value);
void Dvar_SetFloat(const dvar_t *dvar, float value);
void Dvar_SetVec2(const dvar_t *dvar, float x, float y);
void Dvar_SetVec3(const dvar_t *dvar, float x, float y, float z);
void Dvar_SetVec4(const dvar_t *dvar, float x, float y, float z, float w);
void Dvar_SetVec4FromVec4(const dvar_t *dvar, vec4_t *vecin);
// void Dvar_SetString(const char *a1@<edx>, const dvar_t *a2@<ecx>, const dvar_t *dvar, const char *value);
// const dvar_t *Dvar_SetOrRegisterString@<eax>(;
void Dvar_SetColor(const dvar_t *dvar, float r, float g, float b, float a);
;
void Dvar_SetFromString(const dvar_t *dvar, const char *string);
// dvar_t *Dvar_SetFromStringByNameFromSource@<eax>(;
// void Dvar_SetFromStringByName(dvarType_t a1@<edx>, const char *dvarName, const char *string);
// void Dvar_SetCommand(dvarType_t a1@<edx>, const char *dvarName, const char *string);
void Dvar_Reset(const dvar_t *dvar, DvarSetSource setSource);
void Dvar_SetCheatState();
;
;
void Dvar_LoadDvars(MemoryFile *memFile);
void Dvar_LoadScriptInfo(MemoryFile *memFile);
void Dvar_ResetDvars(unsigned int filter, DvarSetSource setSource);
int Com_LoadDvarsFromBufferOptional(;
void Dvar_SetBoolIfChanged(const dvar_t *dvar, bool value);
void Dvar_SetIntIfChanged(const dvar_t *dvar, int value);
void Dvar_SetFloatIfChanged(const dvar_t *dvar, float value);
void Dvar_SetStringIfChanged(const dvar_t *dvar, const char *newString);
void Dvar_DoModifiedCallbacks();
int Com_LoadDvarsFromBuffer(;
void Dvar_Sort();
void Dvar_ForEach(void (*callback)(const dvar_t *, void *), void *userData);
void Dvar_ForEachName(void (*callback)(const char *));
void Dvar_ForEachName(;

//t6/code/src_noserver/universal/eval.cpp
void Eval_PrepareBinaryOpSameTypes(Eval *eval);
void Eval_PrepareBinaryOpIntegers(Eval *eval);
void Eval_PrepareBinaryOpBoolean(Eval *eval);
bool Eval_AnyMissingOperands(const Eval *eval);
bool Eval_EvaluationStep(Eval *eval);
bool Eval_PushOperator(Eval *eval, EvalOperatorType op);
char Eval_PushInteger(Eval *eval, int value);
char Eval_PushNumber(Eval *eval, long double value);
EvalValue *Eval_Solve(EvalValue *result, Eval *eval);
bool Eval_OperatorForToken(const char *text, EvalOperatorType *op);

//t6/code/src_noserver/universal/memfile.cpp
void MemFile_CommonInit(;
const unsigned __int8 *MemFile_GetSegmentAddess(MemoryFile *memFile, int index);
// void MemFile_MoveToSegment(int a1@<edx>, MemoryFile *a2@<ecx>, MemoryFile *memFile, int index);
void MemFile_WriteDataFlushInternal(MemoryFile *memFile);
void MemFile_WriteDataInternal(MemoryFile *memFile, int byteCount, const void *p);
void MemFile_ReadData(MemoryFile *memFile, int byteCount, void *p);
void MemFile_InitForReading(MemoryFile *memFile, int size, void *buffer, bool compress_enabled);
const GfxViewParms *MemFile_ReadCString(MemoryFile *memFile);

//t6/code/src_noserver/universal/memfile.h
int MemFile_ReadInt(MemoryFile *memFile);
void MemFile_ArchiveData(MemoryFile *memFile, int bytes, void *data);
double MemFile_ReadFloat(MemoryFile *memFile);

//t6/code/src_noserver/universal/mem_firstfit.cpp
HunkUser *Hunk_FirstFitInit(;
void Hunk_FirstFitReset(HunkUser *_user);
void Hunk_FirstFitDestroy(HunkUser *_user);
void *Hunk_FirstFitAlloc(HunkUser *_user, int size, int alignment);
void Hunk_FirstFitFree(HunkUser *_user, void *ptr);

//t6/code/src_noserver/universal/mem_fixed.cpp
HunkUser *Hunk_FixedInit(;
void Hunk_FixedReset(HunkUser *_user);
void Hunk_FixedDestroy(HunkUser *_user);
const char *Hunk_FixedAlloc(HunkUser *_user);
void Hunk_FixedFree(HunkUser *_user, void *ptr);

//t6/code/src_noserver/universal/mem_largelocal.cpp
void LargeLocalEnd(int startPos);
void LargeLocalEndRight(int startPos);
// void __thiscall LargeLocal::~LargeLocal(LargeLocal *this);
void LargeLocalReset();
int LargeLocalBegin(int size);
int LargeLocalBeginRight(int size);
unsigned __int8 *LargeLocalGetBuf(int startPos, int size);
// void __thiscall LargeLocal::LargeLocal(LargeLocal *this, int sizeParam);
// unsigned __int8 *__thiscall LargeLocal::GetBuf(LargeLocal *this);

//t6/code/src_noserver/universal/mem_userhunk.cpp
HunkUser *Hunk_UserDebugInit(;
void Hunk_UserDebugReset(HunkUser *_user);
void Hunk_UserDebugDestroy(HunkUser *_user);
void *Hunk_UserDebugAlloc(HunkUser *_user, int size, int alignment);
void Hunk_UserDebugFree(HunkUser *_user, void *ptr);
HunkUser *Hunk_UserDefaultInit(;
void Hunk_UserDefaultDestroy(HunkUser *_user);
void Hunk_UserDefaultFree(HunkUser *user, void *ptr);
HunkUser *Hunk_UserNullInit(;
void Hunk_UserNullReset(HunkUser *_user);
void Hunk_UserNullDestroy(HunkUser *_user);
void *Hunk_UserNullAlloc(HunkUser *_user, int size, int alignment);
void Hunk_UserNullFree(HunkUser *user);
HunkUser *Hunk_UserCreateFromBuffer(;
HunkUser *Hunk_UserCreate(;
HunkUser *Hunk_UserCreateNull(HunkUserNull *user);
void *Hunk_UserAlloc(HunkUser *user, int size, int alignment, const char *name);
void Hunk_UserFree(HunkUser *user, void *ptr);
void Hunk_UserReset(HunkUser *user);
void Hunk_UserDestroy(HunkUser *user);
void Hunk_UserSetPos(HunkUser *_user, void *pos);
char *Hunk_CopyString(HunkUser *user, const char *in);
void Hunk_UserDefaultReset(HunkUser *_user);
int Hunk_UserDefaultAlloc(HunkUser *_user, int size, int alignment, const char *name);
void Hunk_UserStartup();
void Hunk_UserShutdown();

//t6/code/src_noserver/universal/physicalmemory.cpp
void PMem_InitPhysicalMemory(;
// void PMem_Init(bool a1@<dil>);
void PMem_BeginAllocInPrim(PhysicalMemoryPrim *prim, const char *name, EMemTrack memTrack);
void PMem_BeginAlloc(const char *name, unsigned int allocType, EMemTrack memTrack);
void PMem_EndAlloc(const char *name, unsigned int allocType);
void PMem_FreeIndex(PhysicalMemory *pmem, unsigned int allocIndex, int allocType, int location);
void PMem_Free(const char *name);
int PMem_GetOverAllocatedSize();
unsigned __int8 *_PMem_AllocNamed(;
unsigned __int8 *_PMem_Alloc(;

//t6/code/src_noserver/universal/profile_mem.cpp
void TRACK_profileMem();

//t6/code/src_noserver/universal/query.cpp
void query_Init();

//t6/code/src_noserver/universal/q_parse.cpp
void TRACK_q_parse();
ParseThreadInfo *Com_GetParseThreadInfo();
void Com_InitParse();
void Com_BeginParseSession(const char *filename);
void Com_EndParseSession();
void Com_ResetParseSessions();
void Com_SetSpaceDelimited(int spaceDelimited);
void Com_SetKeepStringQuotes(int keepStringQuotes);
void Com_SetCSV(int csv);
void Com_SetParseNegativeNumbers(int negativeNumbers);
int Com_GetCurrentParseLine();
void Com_SetScriptErrorPrefix(const char *prefix);
const GfxViewParms *Com_GetScriptErrorPrefix();
void Com_SetScriptWarningPrefix(const char *prefix);
const GfxViewParms *Com_GetScriptWarningPrefix();
void Com_ScriptErrorDrop(const char *msg, ...);
void Com_ScriptError(const char *msg, ...);
void Com_ScriptWarning(const char *msg, ...);
void Com_UngetToken();
void Com_ParseSetMark(const char **text, com_parse_mark_t *mark);
void Com_ParseReturnToMark(const char **text, com_parse_mark_t *mark);
int Com_Compress(char *data_p);
const char *Com_GetLastTokenPos();
parseInfo_t *Com_ParseCSV(const char **data_p, int allowLineBreaks);
parseInfo_t *Com_ParseExt(const char **data_p, int allowLineBreaks);
parseInfo_t *Com_Parse(const char **data_p);
parseInfo_t *Com_ParseOnLine(const char **data_p);
ParseTokenType Com_GetTokenType();
int Com_MatchToken(const char **buf_p, const char *match, int warning);
int Com_SkipBracedSection(const char **program, unsigned int startDepth, const int iMaxNesting);
void Com_SkipRestOfLine(const char **data);
int Com_GetArgCountOnLine(const char **data_p);
char *Com_ParseRestOfLine(const char **data_p);
float Com_ParseFloat(const char **buf_p);
float Com_ParseFloatOnLine(const char **buf_p);
int Com_ParseInt(const char **buf_p);
int Com_ParseIntOnLine(const char **buf_p);
unsigned int Com_ParseUIntOnLine(const char **buf_p);
void Com_Parse1DMatrix(const char **buf_p, int x, float *m);

//t6/code/src_noserver/universal/q_shared.cpp
void TRACK_q_shared();
int ColorIndex(unsigned __int8 c);
const char *Com_GetFilenameSubString(const char *pathname);
const char *Com_GetExtensionSubString(const char *filename);
void Com_StripExtension(const char *in, char *out);
__int16 BigShort(__int16 l);
int BigLong(int l);
unsigned __int64 BigLong64(unsigned __int64 l);
__int16 LittleShort(__int16 l);
int LittleLong(int l);
int LittleFloatWrite(float l);
int ShortSwap(__int16 l);
__int16 ShortNoSwap(__int16 l);
int LongSwap(int l);
unsigned __int64 Long64Swap(unsigned __int64 l);
unsigned __int64 Long64NoSwap(unsigned __int64 ll);
double FloatReadNoSwap(int n);
void Swap_Init();
unsigned int I_atoui(const char *str);
__int64 I_atoi64(const char *str);
BOOL I_islower(int c);
BOOL I_isupper(int c);
BOOL I_isdigit(int c);
BOOL I_isalnum(int c);
BOOL I_isforfilename(int c);
void I_strncpyz(char *dest, const char *src, int destsize);
int I_strnicmp(const char *s0, const char *s1, int n);
int I_strncmp(const char *s0, const char *s1, int n);
const char *I_stristr(const char *s0, const char *substr);
int I_stricmp(const char *s0, const char *s1);
int I_strcmp(const char *s0, const char *s1);
int I_stricmpwild(const char *wild, const char *s);
char *I_strlwr(char *s);
char *I_strupr(char *s);
BOOL I_iscsym(int c);
void I_strncat(char *dest, int size, const char *src);
int I_DrawStrlen(const char *str);
bool I_IsSpecialToken(const char *buf);
int I_IsSpecialTokenRecursive(const char *buf);
char *I_CleanChat(char *string);
char *I_CleanStr(char *string);
char I_CleanChar(char character);
int Com_sprintf(char *dest, int size, const char *fmt, ...);
int Com_sprintfPos(char *dest, const int destSize, int *destPos, const char *fmt, ...);
BOOL CanKeepStringPointer(const char *string);
char *I_itoa(int value, char *buf, int bufsize);
char *va(const char *format, ...);
void Com_InitThreadData(int threadContext);
const GfxViewParms *Info_ValueForKey(const char *s, const char *key);
void Info_NextPair(const char **head, char *key, char *value);
void Info_RemoveKey(char *s, const char *key);
void Info_RemoveKey_Big(char *s, const char *key);
BOOL Info_Validate(const char *s);
void Info_SetValueForKey(char *s, const char *key, const char *value);
void Info_SetValueForKey_Big(char *s, const char *key, const char *value);
int KeyValueToField(;
// BOOL ParseConfigStringToStruct@<eax>(;
BOOL ParseConfigStringToStructMerged(;
long double GetLeanFraction(const float fFrac);
long double UnGetLeanFraction(const float fFrac);
void AddLeanToPosition(;
void OrientationConcatenate(const orientation_t *orFirst, const orientation_t *orSecond, orientation_t *out);
void OrientationInvert(const orientation_t *orient, orientation_t *out);
BOOL Com_IsLegacyXModelName(const char *name);
void Com_DefaultExtension(char *path, int maxSize, const char *extension);
double CMD_GetAnalogButtonValue(usercmd_s *cmd, int whichBit);

//t6/code/src_noserver/universal/q_shared.h
// void AssignToSmallerType<short>(__int16 *dest, int src);
BOOL Com_BitCheckAssert(const unsigned int *array, int bitNum, int size);
BOOL Com_IsRagdollTrajectory(const trajectory_t *trajectory);
BOOL Com_OnSameTeam(team_t team1, team_t team2);
// renderOptions_s __thiscall renderOptions_s::GetStowedRenderOptions(;
void Com_BitSetAssert(unsigned int *array, int bitNum, int size);
void Com_BitClearAssert(unsigned int *array, int bitNum, int size);
int Com_HashString(const char *fname, int len);
// void AssignToSmallerType<signed char>(char *dest, int src);
int Com_HashLowerString(const char *fname);
int Com_HashCatString(int hash, const char *fname, int len);

//t6/code/src_noserver/universal/reliablemsg.cpp
int RMsg_FindMessageSlot(const int clientSlot, unsigned __int8 sequenceNum);
int RMsg_FindOldestSeq(const int clientSlot);
int RMsg_FindSlotForAddr(netadr_t *to);
void __thiscall RMsg_DropAllPacketsToAddr(netadr_t *this);
void RMsg_Init();
void RMsg_AddMessageAtMsgSlot(;
void RMsg_ShiftMessagesBackInBuffer(reliableClient *client, int bytesShifted);
char RMsg_AddMessageForClient(;
char RMsg_AddMessage(netsrc_t from, netadr_t *to, msg_t *msg);
char RMsg_AddPrint(netsrc_t from, netadr_t *to, const char *line);
void RMsg_AckSequence(netadr_t *from, unsigned __int8 sequenceNum);
int RMsg_CountOutstandingMessages(const int clientSlot);
void RMsg_AckMsgSlot(reliableClient *client, int clientSlot, int msgSlot);
void RMsg_MarkPacketReceived(netadr_t *from, unsigned __int8 sequenceNum);

//t6/code/src_noserver/universal/surfaceflags.cpp
int Com_SurfaceTypeFromName(const char *name);
const char *Com_SurfaceTypeToName(int iTypeIndex);
bool Com_SurfaceBurns(int iTypeIndex);
bool Com_SurfaceFloats(int iTypeIndex);
double Com_SurfaceDensity(int iTypeIndex);
double Com_SurfaceFrictionScale(int iTypeIndex);
double Com_SurfaceBounceScale(int iTypeIndex);

//t6/code/src_noserver/universal/techset_helper.cpp
char GetFullTechsetName(;

//t6/code/src_noserver/universal/timing.cpp
void InitTiming();
void NTP_hton(const NTPMessage *src, NTPMessage *dest);
unsigned __int64 NTP_Milliseconds();
char NTP_Sync(const char *server);

//t6/code/src_noserver/universal/win_common.cpp
void TRACK_win_common();
void Sys_Mkdir(const char *path);
void Sys_MkdirEx(const char *_path);
char *Sys_Cwd();
const GfxViewParms *Clan_GetName();
char *Sys_DefaultHomePath();
char *Sys_DefaultInstallPath();
bool Sys_FileExists(const char *path);
void Sys_ListFilteredFiles(;
char **Sys_ListFiles(;
int Sys_DirectoryHasContents(const char *directory);
void Sys_InitializeCriticalSections();
void Sys_EnterCriticalSection(CriticalSection critSect);
BOOL Sys_TryEnterCriticalSection(CriticalSection critSect);
void Sys_LeaveCriticalSection(CriticalSection critSect);

//t6/code/src_noserver/vcs/vcs.cpp
void AddressROM(Machine *machine, unsigned __int16 address);
void RunDPC(Machine *machine);
void WriteDPC(Machine *machine, unsigned __int16 address, unsigned __int8 b);
unsigned __int8 ReadDPC(Machine *machine, unsigned __int16 address);
unsigned __int8 ReadROM(Machine *machine, unsigned __int16 address);
void InitAudio(Machine *machine);
unsigned __int8 RunAudioChannel(AudioState *audio);
void RunAudio(TIAState *TIA, int cycles);
void UpdatePlayField(TIAState *TIA);
int AdjustPlayerX(int pX, unsigned __int8 NUSIZ);
void UpdateXCache(TIAState *TIA, int i);
unsigned __int8 *UpdateGRPCache(TIAState *TIA, int i, unsigned __int8 GRP);
void DrawTIA(TIAState *TIA, const int y, const int xStart, const int xEnd);
void RunTIA(Machine *machine, int extra);
void ModifyAudio(TIAState *TIA, int index);
void RunPIA(Machine *machine);
unsigned __int8 ReadPIA(Machine *machine, unsigned __int16 address);
;
;
unsigned __int8 ReadByte(Machine *machine, unsigned __int16 address);
unsigned __int16 ReadWord(Machine *machine, unsigned __int16 address);
void WriteByte(Machine *machine, unsigned __int16 address, unsigned __int8 b);
void SetNZ(MOSState *MOS, unsigned __int8 value);
;
unsigned __int8 PopByte(Machine *machine);
void PushWord(Machine *machine, unsigned __int16 w);
unsigned __int16 PopWord(Machine *machine);
unsigned __int8 ReadOperand(Machine *machine, Operand *operand);
void WriteOperand(Machine *machine, Operand *operand, unsigned __int8 b);
unsigned __int8 GetBCD(int v);
unsigned __int8 AddWithCarry(unsigned __int8 a, unsigned __int8 b, unsigned __int8 c, unsigned __int8 *SR);
void RunMOS(Machine *machine);
Machine *VCS_CreateMachine();
// void VCS_ResetMachine(unsigned __int16 a1@<dx>, Machine *a2@<ecx>, Machine *machine);
char VCS_InitMachine(Machine *machine, ROMInfo *info);
char VCS_GetAudioData(Machine *machine, float *data, int sampleCount, int rate);
char VCS_RunFrame(Machine *machine);

//t6/code/src_noserver/vcs/vcs_hooks.cpp
char VCS_AudioCallback(float *out, unsigned int frameCount, unsigned int channelCount, bool *isGlove);
void VCS_Start(const LocalClientNum_t localClientNum, const char *rom, int target3D);
void VCS_Stop();
int VCS_RunFrameFuncCallback_Implementation();
void VCS_Start_f();
void VCS_Init();
int VCS_RunFrameFuncCallback(jqBatch *batch);

//t6/code/src_noserver/vehicle/nitrous_vehicle.cpp
// bool __thiscall NitrousVehicle::is_peeling_out(NitrousVehicle *this);
// void __thiscall NitrousVehicle::destructible_damage(NitrousVehicle *this, const char *notifyLabel, int damageStage);
// phys_vec3 *__thiscall NitrousVehicle::get_velocity(NitrousVehicle *this, phys_vec3 *result);
// double __thiscall NitrousVehicle::_get_stuck_accel_factor(NitrousVehicle *this, float delta_t);
// void __thiscall NitrousVehicle::remove_wheels(NitrousVehicle *this);
// void __thiscall NitrousVehicle::update_braking_and_acceleration(NitrousVehicle *this, const float __formal);
// double __thiscall NitrousVehicle::get_max_speed(NitrousVehicle *this, bool include_perks);
// void __thiscall NitrousVehicle::update_control_from_network(NitrousVehicle *this, LerpEntityStateVehicle *vehicleState);
// void __thiscall NitrousVehicle::GetEntityPose(;
void CG_SetVehDriverInputs(const LocalClientNum_t localClientNum, playerState_s *ps, usercmd_s *cmd);
int Phys_ObjCreateNitrousVehicle(;
// void __thiscall NitrousVehicle::pause_physics(NitrousVehicle *this, bool shutdown);
// void NitrousVehicle::_setup_wheels(;
// void __thiscall NitrousVehicle::_update_orientation_constraint(NitrousVehicle *this);
// ;
// void __thiscall NitrousVehicle::_update_boost(NitrousVehicle *this, const float delta_t);
// void __thiscall NitrousVehicle::_update_friction(NitrousVehicle *this, const float delta_t);
// void __thiscall NitrousVehicle::_update_fakey_stuff(NitrousVehicle *this, const float delta_t);
// void __thiscall NitrousVehicle::start_path(NitrousVehicle *this, int attach_mode);
// void __thiscall NitrousVehicle::end_path(NitrousVehicle *this);
// ;
// void NitrousVehicle::update_steering(;
// ;
void G_SetVehDriverInputs(const LocalClientNum_t localClientNum, playerState_s *ps, usercmd_s *cmd);
// void __thiscall NitrousVehicle::init(NitrousVehicle *this, gentity_t *owner, const VehicleParameter *parameter);
// void __thiscall NitrousVehicle::init(;
// ;
// void NitrousVehicle::frame_epilog_all_systems(const float delta_t);
// void NitrousVehicle::reinit_parms(int a2@<edi>);
// void NitrousVehicle::debug_render_all(int a1@<ebp>);
void G_ClearVehicleInputs();
// void __thiscall NitrousVehicle::unpause_physics(NitrousVehicle *this);
// void __thiscall NitrousVehicle::_update_prolog(NitrousVehicle *this, const float delta_t);
// void NitrousVehicle::frame_prolog_all_systems(const float delta_t);
// void NitrousVehicle::reset_vehicle_physics();
// void NitrousVehicle::remove_vehicle(NitrousVehicle *const v);
void Vehicle_Launch(;
// void __thiscall NitrousVehicle::NitrousVehicle(NitrousVehicle *this);
// NitrousVehicle **NitrousVehicle::add_vehicle(int id);
void debug_render(unsigned int a1, PhysObjUserData *userData);

//t6/code/src_noserver/vehicle/nitrous_vehicle.h
// void __thiscall NitrousVehicle::set_steer_factor(NitrousVehicle *this, float steer_factor, float physics_steer_scale);
// void __thiscall NitrousVehicle::set_throttle(NitrousVehicle *this, float throttle);
// void __thiscall NitrousVehicle::set_brake(NitrousVehicle *this, float braking);
// void __thiscall NitrousVehicle::set_hand_brake(NitrousVehicle *this, float braking);

//t6/code/src_noserver/vehicle/nitrous_vehicle_constraint.cpp
rigid_body_constraint_custom_path *path_constraint_create(rigid_body *rb);
void path_constraint_destroy(rigid_body_constraint_custom_path *vpc);
void path_constraint_update(rigid_body_constraint_custom_path *vpc, const NitrousVehicle *nitrousVehicle);

//t6/code/src_noserver/vehicle/nitrous_vehicle_controller.cpp
// void __thiscall NitrousVehicleController::UpdateControlsTank(NitrousVehicleController *this, NitrousVehicle *rbveh);
// double __thiscall NitrousVehicleController::GetJumpCharge(NitrousVehicleController *this);
// ;
float StunRandomBrake(const usercmd_s *cmd, float desired_brake, float last_brake);
// void __thiscall NitrousVehicleController::UpdateStun(;
// void NitrousVehicleController::UpdateControlsDefault(;
// ;
// void __thiscall NitrousVehicleController::SetScriptTarget(;
// ;
// ;
// ;
// void __thiscall NitrousVehicleController::UpdateControlsStrafeMode(;
// void __thiscall NitrousVehicleController::UpdateControlsHorse(;
// void __thiscall NitrousVehicleController::UpdateControls(;

//t6/code/src_noserver/vehicle/nitrous_vehicle_effects.cpp
void GetWheelStateColor(WheelEffectState state, vec4_t *color, float rate);
// void __thiscall NitrousVehicle::_update_wheel_effect_states(NitrousVehicle *this, const float delta_t);
// ;

//t6/code/src_noserver/win32/windm.cpp
// int `anonymous namespace'::ReadFromSocket(unsigned int socket, void *buffer, int size, bool blocking);
// void `anonymous namespace'::HandleBinaryRequest(winDmCommand command);
// void `anonymous namespace'::HandleCommand(winDmCommand command);
// unsigned int `anonymous namespace'::SocketUpdateThread(void *lpParameter);
void winDmInitServer();
char *winDmRegisterCommandProcessor(;

//t6/code/src_noserver/win32/win_configure.cpp
int Sys_SystemMemoryMB();
// void Sys_DetectVideoCard(int a1@<esi>, int descLimit, char *description);
void Sys_CopyCpuidString(char *dest, const char *source, unsigned int maxLen);
void Sys_DetectCpuVendorAndName(char *vendor, char *name);
unsigned int Sys_AddApicIdIfUnique(;
void Sys_GetPhysicalCpuCount(SysInfo *sysInfo);
long double Sys_BenchmarkGHz();
void Sys_SetAutoConfigureGHz(SysInfo *sysInfo);

//t6/code/src_noserver/win32/win_content.cpp
void Content_FindContentPacks(const ControllerIndex_t controllerIndex);
dlcIndex_t ContentPack2ContentIndex(const int contentPack);
void Content_InitPack(const int contentPack);
void Content_CheckDLCs();
void Content_Disable_f();
void Content_Enable_f();
void Content_Mount_f();
void Content_Init();
char Content_PurchaseMTX(ControllerIndex_t controllerIndex, const int mtxId);

//t6/code/src_noserver/win32/win_gamepad.cpp
void TRACK_win_gamepad();
void GPad_UpdateDigitals(ControllerIndex_t portIndex, const _XINPUT_GAMEPAD *xpad);
void GPad_UpdateAnalogs(ControllerIndex_t portIndex, const _XINPUT_GAMEPAD *xpad);
void GPad_ConvertStickToFloat(__int16 inX, __int16 inY, float *outX, float *outY);
void GPad_UpdateSticksDown(GamePad *gPad);
// void GPad_UpdateSticks(__int16 a1@<dx>, ControllerIndex_t portIndex, const _XINPUT_GAMEPAD *xpad);
void GPad_StopRumbles(ControllerIndex_t portIndex);
BOOL GPad_InUse(LocalClientNum_t localClientNum);
bool GPad_IsActive(ControllerIndex_t portIndex);
double GPad_GetButton(ControllerIndex_t portIndex, GamePadButton button);
bool GPad_ButtonRequiresUpdates(ControllerIndex_t portIndex, GamePadButton button);
BOOL GPad_IsButtonPressed(ControllerIndex_t portIndex, GamePadButton button);
BOOL GPad_IsButtonReleased(ControllerIndex_t portIndex, GamePadButton button);
double GPad_GetStick(ControllerIndex_t portIndex, GamePadStick stick);
void GPad_SetLowRumble(ControllerIndex_t portIndex, float rumble);
void GPad_SetHighRumble(ControllerIndex_t portIndex, float rumble);
bool GPad_GetStickChangedToPressedState(;
// bool GPad_IsStickPressed@<al>(;
// bool GPad_IsStickReleased@<al>(;
void GPad_RefreshAll();
void GPad_UpdateAll();

//t6/code/src_noserver/win32/win_input.cpp
void IN_GamepadsMove();
void IN_RecenterMouse();
void IN_ActivateMouse(int force);
void IN_ClampMouseMove(tagPOINT *curPos);
HWND IN_MouseMove();
void IN_SetCursorPos(int x, int y);
void IN_ShowSystemCursor(int show);
int IN_DeactivateWin32Mouse();
void IN_Shutdown();
void IN_Frame();

//t6/code/src_noserver/win32/win_localize.cpp
_iobuf *Win_InitLocalization(bool isZombies);
void Win_ShutdownLocalization();
char *Win_LocalizeRef(const char *ref);
const char *Win_GetLanguage();

//t6/code/src_noserver/win32/win_main.cpp
// void Sys_FindInfo(int a1@<esi>);
void __noreturn Sys_OutOfMemErrorInternal(const char *filename, int line);
void Sys_QuitAndStartProcess(const char *exeName, const char *parameters);
void Sys_SpawnQuitProcess();
void __noreturn Sys_Error(const char *error, ...);
void Sys_Print(const char *msg);
char *Sys_GetClipboardData();
void Sys_FreeClipboardData(char *text);
void Sys_QueEvent(int time, sysEventType_t type, int value, int value2, int ptrLength, void *ptr);
void Sys_ShutdownEvents();
// sysEvent_t *Win_GetEvent@<eax>(_QWORD *a1@<esi>);
// void Sys_LoadingKeepAlive(int a1@<ebp>);
sysEvent_t *Sys_GetEvent(sysEvent_t *result);
;
void Sys_Init();
int PrivateUnhandledExceptionFilter(_EXCEPTION_POINTERS *ExceptionInfo);
char Sys_ReadIdentity(const char *id);
char *Sys_GetIdentityParam(IdentityParam p);
char *getArgFromString(const char *src, const char *marker, char *dst, unsigned int dstSize);
void checkcmdlineValid();
void DedicatedInit(const char *cmdline);
void InitMiniDumper(char *lpCmdLine);
char *Win_GetTheOtherExeName(const char *mode);
void Win_CheckForEnv(const char *cmdline);
bool Win_CheckForZombieMode(const char *cmdline);
void Sys_CheckQuitRequest();
void __noreturn Sys_Quit();
int WinMain(HINSTANCE__ *hInstance, HINSTANCE__ *hPrevInstance, char *lpCmdLine, int nCmdShow);

//t6/code/src_noserver/win32/win_mini_dumper.cpp
char UploadMinidump(const char *minidumpFile);
bool Sys_IsMiniDumpStarted();
// void __thiscall miniDumper::setMiniDumpFileName(miniDumper *this, const char *tag);
// BOOL __thiscall miniDumper::enablePrivilege(;
// BOOL __thiscall miniDumper::restorePrivilege(miniDumper *this, void *hToken, _TOKEN_PRIVILEGES *ptpOld);
// int __thiscall miniDumper::writeMiniDump(;
void Sys_SetMiniDumpDir(const char *path);
void SetDumpDir_f();
// int miniDumper::unhandledExceptionHandler(_EXCEPTION_POINTERS *pExceptionInfo);
bool Sys_WriteMiniDump(void *info, const char *tag, int type, bool prompt, bool upload);
void Sys_StartMiniDump(bool prompt);

//t6/code/src_noserver/win32/win_net.cpp
void TRACK_win_net();
char *NET_ErrorString();
int Sys_StringToSockaddr(const char *s, sockaddr *sadr);
void NetadrToSockadr(netadr_t *a, sockaddr *s);
void SockadrToNetadr(sockaddr *s, netadr_t *a);
int Sys_StringToAdr(const char *s, netadr_t *a);
int Sys_GetPacket(netadr_t *net_from, msg_t *net_message);
bool Sys_SendPacket(netsrc_t sock, int length, const void *data, netadr_t to);
void Sys_ShowIP();
SOCKET NET_IPSocket(const char *net_interface, int port);
int NET_GetLocalAddress();
void NET_OpenIP();
int NET_GetDvars();
void Sys_CheckForNATOverflow();
int Sys_SocketPool_GetPacket(netadr_t *net_from, msg_t *net_message);
void NET_Config(int enableNetworking);
void NET_Restart();
char Xenon_RegisterRemoteXenon(const XSESSION_INFO *info, netadr_t *addr);
int NET_IsWinsockReady();
void NET_Init(const char *a1, dvarType_t a2);
// XNADDR *Xenon_GetXNAddr(bdReference<bdCommonAddr> renew);
int dwPlatformInit(bdNetStartParams *params);

//t6/code/src_noserver/win32/win_remote.cpp
HRESULT NET_DebugConsoleBinarySendHandler(_DM_CMDCONT *pdmcc);
char *NET_DebugConsoleBinaryReceiveHandler(_DM_CMDCONT *pdmcc);
DataNode *NET_AllocNode();
unsigned int NET_InitDataNodes();
HRESULT NET_DebugConsoleCmdProcessor(;
void NET_InitDebug();
int Sys_IsRemoteDebugServer();
void Sys_EndWriteDebugSocket();
void Sys_RegisterDebugSocketDataHunk(HunkUser *hunk);
void Sys_AckDebugSocket();
void NET_ShutdownDebug();
void NET_RestartDebug();
void Sys_DebugSocketError(const char *message);
char Sys_StartRemoteDebugServer();
void Sys_FlushDebugSocketData();
int Sys_ReadDebugSocketData(void **buffer, int *len);
const GfxViewParms *Sys_ReadDebugSocketString();
int Sys_ReadDebugSocketInt();
void Sys_WriteDebugSocketData(const void *buffer, int len);
void Sys_WriteDebugSocketMessageType(unsigned __int8 type);
void Sys_WriteDebugSocketString(const void *text);
void Sys_WriteDebugSocketInt(int value);
void Sys_WriteDebugSocketFloat(float value);
int Sys_UpdateDebugSocket();

//t6/code/src_noserver/win32/win_shared.cpp
DWORD Sys_Milliseconds();
;
void Sys_SnapVector(float *v);

//t6/code/src_noserver/win32/win_splash.cpp
void Sys_HideSplashWindow();
void Sys_DestroySplashWindow();

//t6/code/src_noserver/win32/win_syscon.cpp
void TRACK_win_syscon();
LRESULT ConWndProc(HWND__ *hWnd, unsigned int uMsg, unsigned int wParam, int lParam);
LRESULT InputLineWndProc(HWND__ *hWnd, unsigned int uMsg, unsigned int wParam, int lParam);
int Conbuf_CleanText(const char *source, char *target, int sizeofTarget);
void Sys_CreateConsole(HINSTANCE__ *hInstance);
void Sys_DestroyConsole();
void Sys_ShowConsole();
char *Sys_ConsoleInput();
void Conbuf_AppendText(const char *pMsg);
void Conbuf_AppendTextInMainThread(const char *msg);
void Sys_SetErrorText(const char *buf);

//t6/code/src_noserver/win32/win_voice.cpp
void Voice_StopClientSamples();
int Voice_IncomingVoiceData_Platform(;
bool Voice_IsClientTalking(ClientNum_t clientNum);
unsigned int Mixer_GetRecordLevel(unsigned int mixerID, unsigned int waveInLineID);
int Mixer_GetMuteState(unsigned int mixerID, unsigned int waveInLineID);
BOOL Voice_IsLocalClientTalking();
BOOL Voice_IsHeadsetPresent();
bool Voice_IsXuidTalking(SessionData *session, ControllerIndex_t localControllerIndex, unsigned __int64 xuid);
UINT Mixer_InitWaveInLineInfo();
void Mixer_SetWaveInRecordLevels(int newLevel);
void Mixer_RestoreWaveInRecordLevels();
void Mixer_SetWaveInMuteStates(int muteState);
void Mixer_RestoreWaveInMuteStates();
char Voice_Init();
void Voice_Shutdown();
void Voice_Playback(ControllerIndex_t a1, const char *a2);

//t6/code/src_noserver/win32/win_workercmds.cpp
int nuge_physicsCallback_Implementation(jqBatch *batch, void *data);
void IW_task_manager_add_batch(physBatch *ptr);
void IW_task_manager_flush();
// int `anonymous namespace'::SetupWorkerThread(jqBatch *batch);
void R_InitWorkerCmds();
;
int nuge_physicsCallback(jqBatch *batch);

//t6/code/src_noserver/xanim/dobj.cpp
;
void DObjShutdown();
void DObjDumpCreationInfo(DObjModel_s *dobjModels, unsigned int numModels);
void DObjGetHierarchyBits(const DObj *obj, int boneIndex, int *partBits);
BOOL DObjSkelIsBoneUpToDate(DObj *obj, int boneIndex);
void DObjComputeBounds(DObj *obj);
void DObjCalcBounds(DObj *dobj, vec3_t *mins, vec3_t *maxs);
void DObjSkelClear(const DObj *obj);
LocalClientNum_t DObjGetLocalClientIndex(const DObj *obj);
void DObjGetBounds(const DObj *obj, vec3_t *mins, vec3_t *maxs);
void DObjPhysicsGetBounds(const DObj *obj, vec3_t *mins, vec3_t *maxs);
double DObjGetRadius(const DObj *obj);
PhysPreset *DObjGetPhysPreset(const DObj *obj);
const char *DObjGetName(const DObj *obj);
const char *DObjGetBoneName(const DObj *obj, int boneIndex);
const char *DObjGetModelParentBoneName(const DObj *obj, int modelIndex);
XAnimTree_s *DObjGetTree(const DObj *obj);
int DObjBad(const DObj *obj);
void DObjTracelinePartBits(DObj *obj, int *partBits);
;
void DObjGeomTracelinePartBits(DObj *obj, int contentmask, int *partBits);
int DObjHasContents(DObj *obj, int contentmask);
int DObjGetContents(const DObj *obj);
BOOL DObjHasCollmap(const DObj *obj);
PhysGeomList *DObjGetCollmap(DObj *obj);
XModel *DObjGetXModel(DObj *obj, int index);
int DObjSetLocalBoneIndex(DObj *obj, int *partBits, int boneIndex, const vec3_t *trans, const vec3_t *angles);
int DObjGetModelBoneIndex(const DObj *obj, const char *modelName, unsigned int name, unsigned __int8 *index);
void DObjGetBasePoseMatrix(const DObj *obj, unsigned __int8 boneIndex, DObjAnimMat *outMat);
void DObjSetHidePartBits(DObj *obj, const unsigned int *partBits);
BOOL DObjHasFlag(const DObj *obj, unsigned __int8 flag);
void DObjSetFlag(DObj *obj, unsigned __int8 flag, int val);
int DObjHasIKActiveFlag(const DObj *obj);
void DObjSetIKActiveFlag(DObj *obj, int val);
void DObjSetIKBypassFlag(DObj *obj, int val);
void DObjSetIKState(DObj *obj, const unsigned __int8 *pIKState);
void DObjDumpInfo(const DObj *obj);
void DObjCreateDuplicateParts(DObj *obj, DObjModel_s *dobjModels, unsigned int numModels);
void DObjFree(DObj *obj);
BOOL DObjIsServer(const DObj *obj);
int DObjIsLocalPlayer(const DObj *obj);
int DObjIsPlayerShadow(const DObj *obj);
BOOL DObjIsLeftHandGripIKActive(const DObj *obj);
;
void DObjSetTree(DObj *obj, XAnimTree_s *tree);
void DObjCreate(;
void DObjCreateExt(;
int DObjGetModelBoneIndex(const DObj *obj, int model_index, unsigned int name, unsigned __int8 *index);

//t6/code/src_noserver/xanim/dobj_skel.cpp
void GetControlAndDuplicatePartBits(;
const unsigned __int8 *CalcSkelDuplicateBones(;
void CalcSkelRootBonesNoParentOrDuplicate(;
void CalcSkelRootBonesWithParent(;
void DObjCalcBaseAnim(const DObj *obj, DObjAnimMat *mat, int *partBits);
void CalcSkelNonRootBones(;
void DObjCalcSkel(const DObj *obj, int *partBits);
// void DObjCalcBaseSkel(DObjAnimMat *a1@<edx>, const DObj *obj, DObjAnimMat *mat, int *partBits);

//t6/code/src_noserver/xanim/dobj_utils.cpp
DObjAnimMat *DObjGetRotTransArray(const DObj *obj);
DObjAnimMat *DObjGetRotTransArrayMain(const DObj *obj);
int DObjGetNumModels(const DObj *obj);
unsigned __int16 DObjGetEntNum(const DObj *obj);
int DObjGetSurfaces(const DObj *obj, int *partBits, const char *lods);
void DObjGetBoneInfo(const DObj *obj, XBoneInfo **boneInfo);
int DObjNumBones(const DObj *obj);
void DObjGetSetBones(const DObj *obj, int *setPartBits);
int DObjSetRotTransIndex(const DObj *obj, const int *partBits, int boneIndex);
char DObjSetSkelRotTransIndex(const DObj *obj, const int *partBits, int boneIndex);
XModel *DObjGetModel(const DObj *obj, int modelIndex);
int DObjHasCollision(const DObj *obj);
XModel *DObjGetModelRemote(const DObj *obj, int modelIndex);
void DObjSetAngles(DObjAnimMat *rotTrans, const vec3_t *angles);
void DObjSetTrans(DObjAnimMat *rotTrans, const vec3_t *trans);
void DObjCompleteHierarchyBits(const DObj *obj, int *partBits);
int DObjSetControlRotTransIndex(const DObj *obj, const int *partBits, int boneIndex);
BOOL DObjSkelExists(const DObj *obj, int timeStamp);
void DObjClearSkel(const DObj *obj);
int DObjSkelAreBonesUpToDate(const DObj *obj, int *partBits);
void DObjSkelSetSkel(const DObj *obj, int *partBits);
int DObjGetAllocSkelSize(const DObj *obj);
void DObjCreateSkel(const DObj *obj, char *buf, int timeStamp);
DObjAnimMat *I_dmaGetDObjSkel(const DObj *obj);
void DObjGetHidePartBits(const DObj *obj, unsigned int *partBits);
int DObjGetBoneIndex(const DObj *obj, unsigned int name, unsigned __int8 *index, int modelNum);
int DObjGetParentBone(const DObj *obj, unsigned __int8 childBoneIndex);
int DObjGetChildBones(const DObj *obj, unsigned __int8 parentBone, unsigned __int8 *children, int maxChildren);
void DObjLock(const DObj *obj);
void DObjUnlock(const DObj *obj);
int DObjIsRecorded(const DObj *obj);
void DObjGetSurfaceData(const DObj *obj, const vec3_t *origin, const float scale, char *lods);
unsigned int DObjGetRootBoneCount(const DObj *obj);
void DObjSetLocalTagInternal(const DObj *obj, const vec3_t *trans, const vec3_t *angles, int boneIndex);
void DObjSetControlTagAngles(const DObj *obj, int *partBits, unsigned int boneIndex, vec3_t *angles);
void DObjSetLocalTag(;

//t6/code/src_noserver/xanim/xanim.cpp
BOOL XAnimTreeHasInfo(const XAnimTree_s *tree);
void XAnimInit();
void XAnimShutdown();
void XAnimFree(XAnimParts *parts);
XAnimParts *XAnimFindData_LoadObj(const char *name, void *(*Alloc)(int));
XAnimParts *XAnimFindData_FastFile(const char *name);
XAnimParts *XAnimClone(XAnimParts *fromParts, void *(*Alloc)(int));
XAnimParts *XAnimPrecache(const char *name, void *(*Alloc)(int));
void XAnimCreate(XAnim_s *anims, unsigned int animIndex, const char *name);
void XAnimBlend(;
void XAnimSetParamValue(XAnim_s *anims, unsigned int paramIndex, const char *strParamName, float paramValue);
void XAnimSetValueSection(;
XAnim_s *XAnimCreateAnimsWithValues(;
void XAnimFreeList(XAnim_s *anims);
XAnimTree_s *XAnimCreateTree(XAnim_s *anims, void *(*Alloc)(int));
XAnim_s *XAnimGetAnims(const XAnimTree_s *tree);
int XAnimGetAnimIndex(XAnim_s *anims, const char *name);
void XAnimInitModelMap(XModel *const *models, unsigned int numModels, XModelNameMap *modelMap);
;
void XAnimFreeInfo(XAnimTree_s *tree, unsigned int infoIndex);
void XAnimCheckFreeInfo(XAnimTree_s *tree, unsigned int infoIndex, int hasWeight);
double XAnimGetAverageRateFrequency(const XAnimTree_s *tree, unsigned int infoIndex);
signed int XAnimGetNextNotifyIndex(const XAnimParts *parts, float time);
float XAnimGetNotifyFracLeaf(const XAnimState *state, const XAnimState *nextState, float time, float dtime);
XAnimParts *XAnimGetPartsForNotify(const XAnimTree_s *tree, XAnimInfo *info);
void XAnimAddClientNotify(unsigned int notetrackName, float frac, unsigned int notifyType);
void XAnimAddClientNotifyNamed(unsigned int notetrackName, float frac, unsigned int notifyName);
void XAnimProcessClientNotify(;
void XAnimResetTime(unsigned int infoIndex);
// void NotifyServerNotetrack(int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<edi>, float a4@<xmm0>);
// void XAnimProcessServerNotify(XAnimInfo *a1@<edx>, const DObj *obj, XAnimInfo *info, float time);
double XAnimGetLength(const XAnim_s *anims, unsigned int animIndex);
int XAnimGetFrameCount(const XAnim_s *anims, unsigned int animIndex);
int XAnimGetLengthMsec(const XAnim_s *anims, unsigned int anim);
unsigned int XAnimGetInfoIndex_r(unsigned int animIndex, unsigned int infoIndex);
// unsigned int XAnimGetInfoIndex@<eax>(unsigned int a1@<edx>, const XAnimTree_s *tree);
// double XAnimGetTime@<st0>(unsigned int a1@<edx>, const XAnimTree_s *tree, unsigned int animIndex);
// double XAnimGetWeight@<st0>(unsigned int a1@<edx>, const XAnimTree_s *tree, unsigned int animIndex);
// bool XAnimHasFinished@<al>(unsigned int a1@<edx>, const XAnimTree_s *tree, unsigned int animIndex);
int XAnimGetNumChildren(const XAnim_s *anims, unsigned int animIndex);
unsigned int XAnimGetChildAt(const XAnim_s *anims, unsigned int animIndex, unsigned int childIndex);
const char *XAnimGetAnimName(const XAnim_s *anims, unsigned int animIndex);
bool XAnimIsDefault(XAnimParts *animParts);
char *XAnimGetAnimDebugName(const XAnim_s *anims, unsigned int animIndex);
unsigned int XAnimGetAnimTreeSize(const XAnim_s *anims);
void DObjClearServerNotifies();
void DObjSetServerNotifies(XAnimServerNotifyList *pNotifyList);
void DObjClearClientNotifies();
void DObjSetClientNotifies(XAnimClientNotifyList *pNotifyList);
XAnimClientNotifyList *DObjGetClientNotifies();
unsigned int XAnimAllocInfoWithParent(;
unsigned int XAnimEnsureGoalWeightParent(DObj *obj, unsigned int animIndex, int cmdIndex);
void XAnimClearGoalWeightInternal(;
void XAnimClearGoalWeight(;
void XAnimClearTreeGoalWeightsInternal(;
void XAnimClearTreeGoalWeights(;
void XAnimClearTreeGoalWeightsStrict(;
void XAnimClearGoalWeightKnobInternal(;
void XAnimClearTree(XAnimTree_s *tree);
unsigned int XAnimGetDescendantWithGreatestWeight(const XAnimTree_s *tree, unsigned int infoIndex);
int XAnimSetGoalWeightNode(;
void XAnimSetupSyncNodes_r(XAnim_s *anims, unsigned int animIndex, int parFlags);
void XAnimSetupSyncNodes(XAnim_s *anims);
BOOL XAnimHasTime(const XAnim_s *anims, unsigned int animIndex);
bool XAnimIsPrimitive(XAnim_s *anims, unsigned int animIndex);
// void XAnimSetAnimRate(unsigned int a1@<edx>, XAnimTree_s *tree, unsigned int animIndex, float rate);
bool XAnimIsLooped(const XAnim_s *anims, unsigned int animIndex);
unsigned __int8 XAnimGetBoneCount(const XAnim_s *anims, unsigned int animIndex);
int XAnimHasBone(const XAnim_s *anims, unsigned int animIndex, unsigned __int16 boneName);
int XAnimIsClientNode(const XAnim_s *anims, unsigned int animIndex);
int XAnimIsClientNode(XAnimTree_s *tree, unsigned int animIndex);
char XAnimNotetrackExists(const XAnim_s *anims, unsigned int animIndex, unsigned int name);
void XAnimAddNotetrackTimesToScriptArray(const XAnim_s *anims, unsigned int animIndex, unsigned int name);
char XAnimDoesNoteTrackExistAtPosAfterTime(;
void XAnimCloneAnimInfo(XAnimTree_s *toTree, const XAnimInfo *from, XAnimInfo *to);
void XAnimCloneAnimTree_r(;
void XAnimCloneAnimTree(const XAnimTree_s *from, XAnimTree_s *to);
XAnimInfo *GetAnimInfo(int infoIndex);
char XAnimGetParamValue(const XAnim_s *anims, unsigned int animIndex, const char *paramName, float *outValue);
bool XAnimGetParamValueTree(;
bool XAnimGetParamValue(XAnimTree_s *tree, unsigned int animIndex, const char *paramName, float *outValue);
XAnim_s *XAnimCreateAnims(const char *debugName, int size, void *(*Alloc)(int));
void XAnimFreeTree(XAnimTree_s *tree, void (*Free)(void *, int));
;
void XAnimUpdateInfoSync(;
void XAnimUpdateTimeAndNotetrackLeaf(;
void XAnimUpdateTimeAndNotetrackSyncSubTree(;
void XAnimUpdateTimeAndNotetrack(;
unsigned int XAnimCloneInitTime(;
unsigned int XAnimInitTime(XAnimTree_s *tree, unsigned int infoIndex, float goalTime, int cmdIndex);
void XAnimUpdateOldTime(;
void XAnimCalcDeltaTree(;
void DObjInitServerTime(DObj *obj, float dtime);
void DObjUpdateClientInfo(DObj *obj, float dtime, int notifyFlags);
void DObjUpdateServerInfo(DObj *obj, float dtime, int notifyFlags);
void XAnimDisplay(;
void DObjDisplayAnimToBuffer(const DObj *obj, const char *header, char *buffer, int bufferSize);
void DObjDisplayAnim(const DObj *obj, const char *header);
void XAnimCalcDelta(DObj *obj, unsigned int animIndex, vec2_t *rot, vec3_t *trans, bool bUseGoalWeight);
void XAnimCalcAbsDelta(DObj *obj, unsigned int animIndex, vec4_t *rot, vec3_t *trans);
void XAnimGetRelDelta(const XAnim_s *anims, unsigned int animIndex, vec2_t *rot, vec3_t *trans);
void XAnimGetAbsDelta(const XAnim_s *anims, unsigned int animIndex, vec4_t *rot, vec3_t *trans);
int XAnimSetCompleteGoalWeightNode(;
void XAnimSetTime(;
unsigned int XAnimRestart(XAnimTree_s *tree, unsigned int infoIndex, float goalTime, int cmdIndex);
unsigned int XAnimGetAnimMap(const XAnimParts *parts, const XModelNameMap *modelMap);
void XAnimResetAnimMapLeaf(const XModelNameMap *modelMap, unsigned int infoIndex);
void XAnimResetAnimMap_r(;
void XAnimResetAnimMap(const DObj *obj, unsigned int infoIndex);
unsigned int XAnimAllocInfoIndex(unsigned int animIndex);
XAnimInfo *XAnimAllocInfo(DObj *obj, unsigned int animIndex);
// int XAnimSetCompleteGoalWeightKnob@<eax>(;
// int XAnimSetGoalWeightKnob@<eax>(;
// int XAnimSetGoalWeight@<eax>(;
// int XAnimSetCompleteGoalWeight@<eax>(;
int XAnimSetGoalWeightKnobAll(;
int XAnimSetCompleteGoalWeightKnobAll(;

//t6/code/src_noserver/xanim/xanim_calc.cpp
void XAnim_CalcPosDeltaEntire(const XAnimDeltaPart *animDelta, __m128 *posDelta);
void XAnimClearRotTransArray(const DObj *obj, DObjAnimMat *rotTransArray, XAnimCalcAnimInfo *info);
void XAnimCalcNonLoopEnd(;
void XAnimScaleRotTransArray(int numBones, const XAnimCalcAnimInfo *info, DObjAnimMat *rotTransArray);
void XAnimNormalizeRotScaleTransArray(;
void XAnimMadRotTransArray(;
void XAnimApplyAdditives(;
void XAnim_CalcDeltaForTime(;
void XAnim_CalcDelta3DForTime(;
void XAnimCalcLeafInternal(;
void XAnimCalcLeaf(;
void XAnimCalc(;
void DObjCalcAnim(const DObj *obj, int *partBits);

//t6/code/src_noserver/xanim/xanim_clientnotify.cpp
// void __thiscall XAnimClientNotifyList::XAnimClientNotifyList(XAnimClientNotifyList *this);
// void __thiscall XAnimClientNotifyList::GetNotifyList(bdTrulyRandomImpl *this);
// BOOL __thiscall XAnimClientNotify::IsClientAnimNotify(XAnimClientNotify *this);
// const char *__thiscall XAnimClientNotify::GetNotifyStringName(XAnimClientNotify *this);
// unsigned int __thiscall XAnimClientNotify::GetNotifyType(XAnimClientNotify *this);
// unsigned int __thiscall XAnimClientNotify::GetNotifyName(XAnimClientNotify *this);
// void __thiscall XAnimClientNotifyList::~XAnimClientNotifyList(XAnimClientNotifyList *this);
// void __thiscall XAnimClientNotifyList::AddNotify(XAnimClientNotifyList *this, const ClientNotifyData *notifyData);

//t6/code/src_noserver/xanim/xanim_load_db.h
void Load_XAnimIndices();
void Load_XAnimDynamicIndicesDeltaQuat2(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataFrames2(bool atStreamStart);
void Load_XAnimDeltaPartQuat2(bool atStreamStart);
void Load_XAnimDynamicIndicesDeltaQuat(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataFrames(bool atStreamStart);
void Load_XAnimDeltaPartQuat(bool atStreamStart);
void Load_XAnimDynamicIndicesTrans(bool atStreamStart);
void Load_XAnimDynamicFrames();
void Load_XAnimPartTransFrames(bool atStreamStart);
void Load_XAnimPartTrans(bool atStreamStart);
void Load_XAnimNotifyInfoArray(bool atStreamStart, int count);
void Mark_XAnimParts();
void Mark_XAnimPartsPtr();
void Load_XAnimDeltaPart(bool atStreamStart);
void Load_XAnimParts(bool atStreamStart);
void Load_XAnimPartsPtr(bool atStreamStart);

//t6/code/src_noserver/xanim/xanim_load_obj.cpp
void ConsumeQuat(const unsigned __int8 **pos, __int16 *out);
void ConsumeQuat2(const unsigned __int8 **pos, __int16 *out);
void ReadNoteTracks(;
const unsigned __int8 *GetDeltaQuaternions2(;
// const unsigned __int8 *GetDeltaQuaternions@<eax>(;
const unsigned __int8 *LoadTrans(;
const unsigned __int8 *GetDeltaTranslations(;
void *XAnimTempAlloc(int size);
// unsigned __int8 *GetQuaternions@<eax>(;
const unsigned __int8 *GetTranslations(;
int XAnimCompareQuatParts(const void *p0, const void *p1);
int XAnimCompareTransParts(const void *p0, const void *p1);
int XAnimIsHighPrecisionPart(const char *name);
void XAnimEmitFrameIndices(;
XAnimParts *XAnimLoadFile(const char *name, void *(*Alloc)(int), bool streamedVersion);

//t6/code/src_noserver/xanim/xanim_readwrite.cpp
void XAnimLoadAnimTree(DObj *obj, MemoryFile *memFile);

//t6/code/src_noserver/xanim/xmodel.cpp
BOOL XModelBad(const XModel *model);
void TRACK_xmodel();
void XModelReleaseResources(XModel *model);
void XModelPartsFree(XModelPartsLoad *modelParts);
void XModelMakeDefault(XModel *model);
XModelPartsLoad *XModelPartsFindData(const char *name);
void XModelPartsSetData(const char *name, XModelPartsLoad *modelParts, void *(*Alloc)(int));
XModel *XModelPrecache_LoadObj(const char *name, void *(*Alloc)(int), void *(*AllocColl)(int));
XModel *XModelPrecache_FastFile(const char *name);
XModel *XModelPrecache();
unsigned __int16 *XModelBoneNames(XModel *model);
double XModelGetRadius(const XModel *model);
void XModelGetBounds(const XModel *model, vec3_t *mins, vec3_t *maxs);
void XModelRenderString(const vec3_t *pos, const char *string);
;
void XModelTraceLineAnimatedPartBits(;
void XSurfaceVisitTrianglesInAabb_ConvertAabb(;
bool XSurfaceVisitTrianglesInAabb_ProcessVertices(XSurfaceGetTriCandidatesLocals *locals);
bool XSurfaceVisitTrianglesInAabb_ProcessTriangles(XSurfaceGetTriCandidatesLocals *locals);
;
bool XSurfaceVisitTrianglesInAabb_ProcessLeaf(XSurfaceGetTriCandidatesLocals *locals);
char XSurfaceVisitTrianglesInAabb_ProcessNode(XSurfaceGetTriCandidatesLocals *locals);
char XSurfaceVisitTrianglesInAabb(;

//t6/code/src_noserver/xanim/xmodel_load_db.h
void Load_XModelCollSurfArray(bool atStreamStart, int count);
void Load_BrushWrapper(bool atStreamStart);
void Load_PhysGeomInfoArray(bool atStreamStart, int count);
void Load_CollmapArray(bool atStreamStart, int count);
void Mark_XModel();
void Mark_XModelPtr();
void Mark_XModelPieceArray(int count);
void Load_XModel(bool atStreamStart);
void Load_XModelPtr(bool atStreamStart);
void Load_XModelPtrArray(bool atStreamStart, int count);
void Load_XModelPieceArray(bool atStreamStart, int count);
void Load_XModelPieces(bool atStreamStart);

//t6/code/src_noserver/xanim/xmodel_load_obj.cpp
PhysConstraints *XModel_PhysConstraintsPrecache(const char *name, void *(*Alloc)(int));
void ConsumeQuatNoSwap(const unsigned __int8 **pos, __int16 *out);
bool XModelLoadConfigFile(const char *name, const unsigned __int8 **pos, XModelConfig *config);
void XModelLoadCollData(;
void XModelCopyXModelParts(const XModelPartsLoad *modelParts, XModel *model);
void R_GetXModelBounds(XModel *model, const vec3_t *axes, vec3_t *mins, vec3_t *maxs);
int XModelGetFlags(const XModel *model);
XModelPieces *XModelPiecesLoadFile(const char *name, void *(*Alloc)(int));
XModelPieces *XModelPiecesPrecache(const char *name, void *(*Alloc)(int));
int XModelGetStaticBounds(const XModel *model, const vec3_t *axis, vec3_t *mins, vec3_t *maxs);
int XModelGetStaticBoundsExact(const XModel *model, const vec3_t *axis, vec3_t *mins, vec3_t *maxs);
int XModelGetStaticBounds(const XModel *model, vec3_t *mins, vec3_t *maxs);
void XModelCalcBasePose(XModelPartsLoad *modelParts);
XModelPartsLoad *XModelPartsLoadFile(;
XModelPartsLoad *XModelPartsPrecache(;
XModel *XModelLoadFile(;
XModel *XModelLoad(const char *name, void *(*Alloc)(int), void *(*AllocColl)(int));

//t6/code/src_noserver/xanim/xmodel_load_phys_collmap.cpp
char RemoveDuplicateBrushPlanes(;
bool SnapAxialVector(vec3_t *normal);
void SnapPlane(vec4_t *plane);
unsigned int GetPlaneIntersections(;
bool Map_SkipNamedFlags(const char **file, const char *key);
void GetCollisionMaterial(const char *name, collision_material_t *cmat);
int IsAxisAligned(vec3_t *normal);
bool Xmodel_ParsePhysicsBrush(;
bool Xmodel_ParsePhysicsBox(const char **file, PhysGeomInfo *geom);
bool Xmodel_ParsePhysicsCylinder(const char **file, PhysGeomInfo *geom);
char SkipEpair(const char *token, const char **file);
bool AddBoneName(unsigned int *boneNameArray, const int boneNameLen, const char *boneName);
int Xmodel_CountPhysicsCollMaps(;
unsigned int Xmodel_CountPhysicsCollMapGeoms(const char **file, const char *name, unsigned int boneHash);
PhysGeomList *Xmodel_ParsePhysicsCollMap(;
void XModel_LoadCollMap(const char *name, void *(*Alloc)(int), XModel *model, const char *xmodelName);

//t6/code/src_noserver/xanim/xmodel_utils.cpp
const char *XModelGetName(const XModel *model);
int XModelGetSurfaces(const XModel *model, XSurface **surfaces, int submodel);
XModelLodInfo *XModelGetLodInfo(const XModel *model, int lod);
unsigned int XModelGetSurfCount(const XModel *model, int lod);
Material **XModelGetSkins(const XModel *model, int lod);
XModelLodRampType XModelGetLodRampType(const XModel *model);
int XModelGetNumLods(const XModel *model);
double XModelGetLodOutDist(const XModel *model);
LocalClientNum_t XModelNumBones(const cpose_t *pose);
int XModelGetBoneIndex(const XModel *model, unsigned int name, unsigned int offset, unsigned __int8 *index);
int XModelGetParentBoneName(const XModel *model, unsigned int name);
DObjAnimMat *XModelGetBasePose(const XModel *model);
int XModelGetLodForDist_Internal(const XModel *model, float dist);
int XModelGetLodForDist(const XModel *model, float adjustedDist, float baseDist, int noLodCullOut);
void XModelSetTestLods(int lodLevel, float dist);
int XModelGetContents(const XModel *model);
BOOL XModelHasCollmap(const XModel *model);
BOOL XModelHasCollision(const XModel *model);
PhysGeomList *XModelGetCollmap(const XModel *model, int collMapIndex);
PhysGeomList *XModelGetCollmapForBoneIndex(const XModel *model, int boneIndex);
int XModelGetBoneIndex(const XModel *model, unsigned int name, unsigned __int8 *index);

//t6/code/src_noserver/zlib/deflate.cpp
void putShortMSB(internal_state *s, unsigned int b);
void flush_pending(z_stream_s *strm);
void lm_init(internal_state *s);
unsigned int longest_match_fast(internal_state *s, unsigned int cur_match);
void fill_window(internal_state *s);
int deflate_stored(internal_state *s, int flush);
int deflate_fast(internal_state *s, int flush);

//t6/code/src_noserver/zlib/inffast.cpp
void inflate_fast(z_stream_s *strm, unsigned int start);

//t6/code/src_noserver/zlib/inflate.cpp
int updatewindow(z_stream_s *strm, unsigned int out);

//t6/code/src_noserver/zlib/inftrees.cpp
int inflate_table(;

//t6/code/src_noserver/zlib/trees.cpp
void init_block(internal_state *s);
void pqdownheap(internal_state *s, ct_data_s *tree, int k);
void gen_bitlen(internal_state *s, tree_desc_s *desc);
void scan_tree(internal_state *s, ct_data_s *tree, int max_code);
void send_tree(internal_state *s, ct_data_s *tree, int max_code);
void send_all_trees(internal_state *s, int lcodes, int dcodes, int blcodes);
void compress_block(internal_state *s, ct_data_s *ltree, ct_data_s *dtree);
void set_data_type(internal_state *s);
void bi_flush(internal_state *s);
void bi_windup(internal_state *s);
void copy_block(internal_state *s, char *buf, unsigned int len, int header);
void _tr_init(internal_state *s);
void gen_codes(ct_data_s *tree, int max_code, unsigned __int16 *bl_count);
void build_tree(internal_state *s, tree_desc_s *desc);
int build_bl_tree(internal_state *s);
// void _tr_stored_block(int a1@<edx>, internal_state *s, char *buf, unsigned int stored_len, int eof);
void _tr_align(internal_state *s);
void _tr_flush_block(;

//t6/code/src_noserver/zlib/unzip.cpp
int unzlocal_GetCurrentFileInfoInternal(;
int unzlocal_CheckCurrentFileCoherencyHeader(;

//t6/code/src_noserver/zlib/zutil.cpp
unsigned __int8 *zcalloc(unsigned __int8 *opaque, unsigned int items, unsigned int size);
void zcfree(unsigned __int8 *opaque, unsigned __int8 *ptr);

