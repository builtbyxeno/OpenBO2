#include "types.h"
#include "functions.h"

/*
==============
GlassPhysics::InitStatics
==============
*/
/*void GlassPhysics::InitStatics()
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassPhysics::AddForce
==============
*/
/*void __thiscall GlassPhysics::AddForce(GlassPhysics *this, const vec3_t *worldPos, const vec3_t *impulse)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassPhysics::tensor_transform_principle
==============
*/
/*void __thiscall GlassPhysics::tensor_transform_principle(GlassPhysics *this, const phys_vec3 *diag, const phys_mat44 *mat, phys_mat44 *tensor)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::Add
==============
*/
/*bool __thiscall GlassOutline::Add(GlassOutline *this, const vec2_t *pos)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::Add
==============
*/
/*bool __thiscall GlassOutline::Add(GlassOutline *this, const vec2_t *dir, float len)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::AddSafe
==============
*/
/*void __thiscall GlassOutline::AddSafe(GlassOutline *this, float x, float y, bool isOriginalEdge)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::EdgeRatio
==============
*/
/*double __thiscall GlassOutline::EdgeRatio(GlassOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::GetBBox
==============
*/
/*void __thiscall GlassOutline::GetBBox(GlassOutline *this, vec2_t *mn, vec2_t *mx)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::Recenter
==============
*/
/*void __thiscall GlassOutline::Recenter(GlassOutline *this, vec2_t *offset)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::HasNarrowAngle
==============
*/
/*BOOL __thiscall GlassOutline::HasNarrowAngle(GlassOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::IsNarrow
==============
*/
/*bool __thiscall GlassOutline::IsNarrow(GlassOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::DoesIntersect
==============
*/
/*char __thiscall GlassOutline::DoesIntersect(GlassOutline *this, const vec2_t *start, const vec2_t *dir, float len, float padding)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::GetNearestDistances
==============
*/
/*void __thiscall GlassOutline::GetNearestDistances(GlassOutline *this, const vec2_t *p, GlassOutline::EdgeDistance *dists, int nDists)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
compareOutlines
==============
*/
int compareOutlines(const void *o1, const void *o2)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}

/*
==============
GlassPackedOutline::Init
==============
*/
/*int __thiscall GlassPackedOutline::Init(GlassPackedOutline *this, void *ptr, unsigned __int8 num)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassPackedOutline::GetStreamSize
==============
*/
/*int __thiscall GlassPackedOutline::GetStreamSize(GlassPackedOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassPackedOutline::StreamOut
==============
*/
/*unsigned __int8 *__thiscall GlassPackedOutline::StreamOut(GlassPackedOutline *this, unsigned __int8 *streamBuff)
{
	UNIMPLEMENTED(__FUNCTION__);
	return NULL;
}*/

/*
==============
GlassPackedOutline::GetBBox
==============
*/
/*void __thiscall GlassPackedOutline::GetBBox(GlassPackedOutline *this, vec2_t *mn, vec2_t *mx)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassPackedOutline::Recenter
==============
*/
/*void __thiscall GlassPackedOutline::Recenter(GlassPackedOutline *this, vec2_t *offset)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassPackedOutline::EdgeRatio
==============
*/
/*double __thiscall GlassPackedOutline::EdgeRatio(GlassPackedOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::Mesh::Init
==============
*/
/*void __thiscall GlassShard::Mesh::Init(GlassShard::Mesh *this, const GlassPackedOutline *outline, float thickness, const vec3_t *tangt)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::Mesh::InitVertexList
==============
*/
/*
{
	UNIMPLEMENTED(__FUNCTION__);
	 tmp;
	return tmp;
}*/

/*
==============
GlassShard::Triangles::Triangulate
==============
*/
/*bool __thiscall GlassShard::Triangles::Triangulate(GlassShard::Triangles *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::Init
==============
*/
/*void __thiscall GlassShard::Init(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::ToLocal
==============
*/
/*void __thiscall GlassShard::ToLocal(GlassShard *this, const vec3_t *pos, const vec3_t *dir, vec3_t *localPos, vec3_t *localDir)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::GetLocalBBox
==============
*/
/*void __thiscall GlassShard::GetLocalBBox(GlassShard *this, vec3_t *mins, vec3_t *maxs)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::UpdateBBox
==============
*/
/*void __thiscall GlassShard::UpdateBBox(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::GenerateVerts
==============
*/
/*void __thiscall GlassShard::GenerateVerts(GlassShard *this, const GlassRenderer *renderer, bool highLod, GfxPackedVertex *baseVerts, unsigned __int16 vertsBaseIndex, unsigned __int16 *idxOut)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::GetMass
==============
*/
/*double __thiscall GlassShard::GetMass(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::DestroyPhysicsObj
==============
*/
/*void __thiscall GlassShard::DestroyPhysicsObj(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::AddForce
==============
*/
/*void GlassShard::AddForce(GlassShard *this@<ecx>, const char *a2@<edi>, const vec3_t *pos, const vec3_t *forceIn)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::SetVelocity
==============
*/
/*void __thiscall GlassShard::SetVelocity(GlassShard *this, const vec3_t *t_vel, const vec3_t *a_vel)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GetNumIntersections<GlassOutline>
==============
*/
/*int GetNumIntersections<GlassOutline>(const GlassOutline *_this, const vec2_t *start, const vec2_t *dir, float *nearestDist, int *nearestedge)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GetNumIntersections<GlassPackedOutline>
==============
*/
/*int GetNumIntersections<GlassPackedOutline>(const GlassPackedOutline *_this, const vec2_t *start, const vec2_t *dir, float *nearestDist, int *nearestedge)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassPhysics::CreateAxis
==============
*/
/*void GlassPhysics::CreateAxis(GlassPhysics *this, float position, const vec3_t *a3, const vec3_t *axis, const vec3_t *tVel, const vec3_t *aVel, float mass, const vec3_t *localBBoxMin, const vec3_t *localBBoxMax)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassPhysics::IntegrateVelocity
==============
*/
/*void GlassPhysics::IntegrateVelocity(GlassPhysics *this, int a2, float deltaTime)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassPhysics::GetPosition
==============
*/
/*void __thiscall GlassPhysics::GetPosition(GlassPhysics *this, vec3_t *position, vec3_t *axis)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::operator=
==============
*/
/*GlassOutline *__thiscall GlassOutline::operator=(GlassOutline *this, const GlassOutline *o)
{
	UNIMPLEMENTED(__FUNCTION__);
	return NULL;
}*/

/*
==============
GlassOutline::CloseOutline
==============
*/
/*bool __thiscall GlassOutline::CloseOutline(GlassOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::Reverse
==============
*/
/*void __thiscall GlassOutline::Reverse(GlassOutline *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::InitSplitOutlines
==============
*/
/*int __thiscall GlassOutline::InitSplitOutlines(GlassOutline *this, GlassOutline *newOutline, GlassOutline *outline1, GlassOutline *outline2, float minShardSize)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::StreamIn
==============
*/
/*const unsigned __int8 *__thiscall GlassOutline::StreamIn(GlassOutline *this, const unsigned __int8 *streamBuff)
{
	UNIMPLEMENTED(__FUNCTION__);
	return NULL;
}*/

/*
==============
GlassPackedOutline::LeaveOnEdge
==============
*/
/*bool __thiscall GlassPackedOutline::LeaveOnEdge(GlassPackedOutline *this, float stickiness)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::Destroy
==============
*/
/*void __thiscall GlassShard::Destroy(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::AllocateMemory
==============
*/
/*char __thiscall GlassShard::AllocateMemory(GlassShard *this, unsigned int numVerts, const GlassShard::Triangles *triangles)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::Intersect
==============
*/
/*bool __thiscall GlassShard::Intersect(GlassShard *this, const vec3_t *pos, const vec3_t *dir, vec2_t *hitPoint)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::LeaveOnEdge
==============
*/
/*bool __thiscall GlassOutline::LeaveOnEdge(GlassOutline *this, float stickiness)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::IsOnBottomEdge
==============
*/
/*bool __thiscall GlassOutline::IsOnBottomEdge(GlassOutline *this, const GlassShard *shard)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassPhysics::Step
==============
*/
/*void GlassPhysics::Step(GlassPhysics *this, int a2, float deltaTime)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::GlassOutline
==============
*/
/*void __thiscall GlassOutline::GlassOutline(GlassOutline *this, const GlassPackedOutline *other, GlassOutline::Vertex *_verts, unsigned __int8 _maxVerts)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::GlassOutline
==============
*/
/*void __thiscall GlassOutline::GlassOutline(GlassOutline *this, const Glass *glass, GlassOutline::Vertex *v, unsigned __int8 mv)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::Split
==============
*/
/*int __thiscall GlassOutline::Split(GlassOutline *this, GlassOutline *newOutline, float minShardSize, unsigned int startEdge, float startEdgeParam)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::Chip
==============
*/
/*int __thiscall GlassOutline::Chip(GlassOutline *this, GlassOutline *newOutline, const GlassOutline::EdgeDistance *dist, const vec2_t *hitPoint, float minShardSize)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassOutline::HitPoint
==============
*/
/*int __thiscall GlassOutline::HitPoint(GlassOutline *this, const GlassShard *shard, GlassOutline **newOutlines, int maxNewOutlines, float minShardSize, float maxShardSize, const vec2_t *hitPoint2d)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassPackedOutline::Init
==============
*/
/*void __thiscall GlassPackedOutline::Init(GlassPackedOutline *this, const GlassOutline *other, const GlassShard *shard)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::Remove
==============
*/
/*void __thiscall GlassShard::Remove(GlassShard *this, GlassShard::RemoveReason reason, bool delay)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::Init
==============
*/
/*char __thiscall GlassShard::Init(GlassShard *this, const GlassOutline *outline, const vec2_t *offset, float _thickness, float _uvScale, const vec2_t *_uvOffset, float _binormalSign, unsigned __int16 _glassIndex, const vec3_t *_axis, const vec3_t *_origin)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::DisableCollisions
==============
*/
/*void __thiscall GlassShard::DisableCollisions(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassOutline::Shatter
==============
*/
/*unsigned int __thiscall GlassOutline::Shatter(GlassOutline *this, FixedSizeAllocator<TempPackedOutline> *newOutlines, unsigned int maxNewOutlines, float maxShardSize, float minShardSize)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::Create
==============
*/
/*GlassShard *GlassShard::Create(const Glass *glass, GlassOutline *outline)
{
	UNIMPLEMENTED(__FUNCTION__);
	return NULL;
}*/

/*
==============
GlassShard::Create
==============
*/
/*GlassShard *GlassShard::Create(const Glass *glass, GlassPackedOutline *outline)
{
	UNIMPLEMENTED(__FUNCTION__);
	return NULL;
}*/

/*
==============
GlassShard::InitPhysicsObj
==============
*/
/*bool __thiscall GlassShard::InitPhysicsObj(GlassShard *this, bool enableCollisions)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::InitPhysics
==============
*/
/*char __thiscall GlassShard::InitPhysics(GlassShard *this, bool enableCollisions, const vec3_t *hitPos, const vec3_t *hitDir, float glassSize, float stickiness)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::DrawOutline
==============
*/
/*void __thiscall GlassShard::DrawOutline(GlassShard *this)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::InitPhysics
==============
*/
/*void GlassShard::InitPhysics(GlassShard **newShards, int numNewShards, float glassExtent, const vec3_t *pos, const vec3_t *dir)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::ExplosionEvent
==============
*/
/*void __thiscall GlassShard::ExplosionEvent(GlassShard *this, const vec3_t *expOrigin, const float damageInner, const float damageOuter, const float radius, int mod)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::TracePoint
==============
*/
/*char __thiscall GlassShard::TracePoint(GlassShard *this, const vec3_t *p0, const vec3_t *p1, const vec3_t *dir, float length, const vec3_t *mins, const vec3_t *maxs)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::DelayedUpdate
==============
*/
/*char __thiscall GlassShard::DelayedUpdate(GlassShard *this, float deltaTime)
{
	UNIMPLEMENTED(__FUNCTION__);
	return 0;
}*/

/*
==============
GlassShard::UpdateInternal
==============
*/
/*void __thiscall GlassShard::UpdateInternal(GlassShard *this, GlassRenderer *localRenderer, float deltaTime)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

/*
==============
GlassShard::Update
==============
*/
/*void __thiscall GlassShard::Update(GlassShard *this, float deltaTime, GlassUpdateCmd *cmd)
{
	UNIMPLEMENTED(__FUNCTION__);
}*/

