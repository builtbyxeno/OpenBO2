#pragma once

#include "types.h"

//t6/code/src_noserver/glass/glass_allocator.cpp
// void __thiscall SmallAllocator::Init(SmallAllocator *this, void *buffer, unsigned int bs, unsigned int nb);
// void **__thiscall SmallAllocator::Allocate(SmallAllocator *this, unsigned int size);
// char __thiscall Allocator::Memory::MakeFree(Allocator::Memory *this);
// void __thiscall Allocator::FreeAll(Allocator *this);
// int __thiscall Allocator::GetMemorySize(Allocator *this, void *ptr);
// void __thiscall Allocator::Split(Allocator *this, Allocator::Memory *mem, int size);
// void __thiscall Allocator::Merge(Allocator *this, Allocator::Memory *mem1, Allocator::Memory *mem2);
// int __thiscall Allocator::Defrag(Allocator *this, void (*func)(void *), int count);
// int __thiscall Allocator::GetFree(Allocator *this);
// int __thiscall Allocator::GetLargestFree(Allocator *this);
// void __thiscall SmallAllocator::Free(SmallAllocator *this, void *ptr, unsigned int num);
// void __thiscall Allocator::Init(Allocator *this, void *buf, int size);
// Allocator::Memory **__thiscall Allocator::Allocate(Allocator *this, int size, void *userData);
// void __thiscall Allocator::Free(Allocator *this, void *ptr);

//#include "glass/glass_allocator.h"

//t6/code/src_noserver/glass/glass_client.cpp
// void *GlassesClient::Allocate(int size, int align, const char *file, int line);
// void GlassesClient::Free(void *ptr);
// unsigned int GlassesClient::GetFreeMem();
// GlassClient *__thiscall GlassesClient::GetGlass(GlassesClient *this, int idx);
// void __thiscall GlassesClient::WriteDemoSnapshot(GlassesClient *this, msg_t *msg);
int compareOutlineEdges(const void *s1, const void *s2);
// void __thiscall GlassClient::PlayShatterFX(GlassClient *this, LocalClientNum_t localClientNum, const vec3_t *hitPos, const vec3_t *hitDir);
bool GlassIsVisible(LocalClientNum_t localClientNum, const Glass *glass);
// void __thiscall GlassClient::SetBrushMaterial(GlassClient *this, GlassState::State state);
void GlassCl_WriteDemoSnapshot(msg_t *msg);
void GlassCl_BeginGenerateVerts(LocalClientNum_t localClientNum, unsigned int viewIndex);
void GlassCl_WaitUpdate();
void GlassCl_GenerateVerts(LocalClientNum_t localClientNum, unsigned int viewIndex);
void GlassCl_ExplosionEvent(LocalClientNum_t localClientNum, const vec3_t *origin, const float damageInner, const float damageOuter, const float radius, int mod);
void GlassCl_MeleeEvent(LocalClientNum_t localClientNum, int attackerEntNum);
void GlassCl_DrawDebug(LocalClientNum_t localClientNum);
// unsigned int __thiscall GlassesClient::AreaGlasses(GlassesClient *this, const vec3_t *mins, const vec3_t *maxs, const Glass **glss, unsigned int maxGlasses);
// void __thiscall GlassesClient::ClipMoveTrace(GlassesClient *this, const moveclip_t *clip, trace_t *results);
// void __thiscall GlassesClient::Update(GlassesClient *this, LocalClientNum_t localClientNum);
// void __thiscall GlassClient::Init(GlassClient *this, const Glass *gls);
// void __thiscall GlassClient::SetState(GlassClient *this, LocalClientNum_t localClientNum, GlassState::State newState, const vec3_t *hitPos, const vec3_t *hitDir, bool gameState);
// unsigned int __thiscall GlassClient::Outlines::InitShards(GlassClient::Outlines *this, const Glass *glass, GlassShard **shards, int maxNewShards);
void GlassCl_Update(LocalClientNum_t localClientNum);
// void __thiscall GlassesClient::TracePoint(GlassesClient *this, const pointtrace_t *clip, trace_t *results);
unsigned int GlassCl_AreaGlasses(const vec3_t *mins, const vec3_t *maxs, const Glass **glasses, unsigned int maxGlasses);
void GlassCl_ClipMoveTrace(const moveclip_t *clip, trace_t *results);
// void __thiscall GlassesClient::GlassesClient(GlassesClient *this, const Glasses *glss);
// void __thiscall GlassesClient::Reset(GlassesClient *this);
// void __thiscall GlassesClient::ParseSnapshot(GlassesClient *this, LocalClientNum_t localClientNum, msg_t *msg, bool gameState);
// void __thiscall GlassClient::Outlines::SaveOutlines(GlassClient::Outlines *this, FixedSizeAllocator<TempPackedOutline> *newOutlines);
void GlassCl_AllocateMemory();
void GlassCl_FreeMemory();
void GlassCl_Reset(LocalClientNum_t localClientNum);
void GlassCl_ReadGameState(LocalClientNum_t localClientNum, msg_t *msg);
void GlassCl_ParseSnapshot(LocalClientNum_t localClientNum, msg_t *msg);
void GlassCl_TracePoint(const pointtrace_t *clip, trace_t *results);
// char __thiscall GlassClient::Shatter(GlassClient *this, GlassShard **newShards, int *numNewShards);
// void __thiscall GlassesClient::PreShatterNext(GlassesClient *this);
// void __thiscall GlassClient::Shatter(GlassClient *this, const vec3_t *pos, const vec3_t *dir);

//#include "glass/glass_load_db.h"

//t6/code/src_noserver/glass/glass_load_obj.cpp
Glasses *GetGlasses_LoadObj();
XModelPieces *GetGlasses_FastFile();
Glasses *GetGlasses();

//t6/code/src_noserver/glass/glass_renderer.cpp
;
// void *GlassRenderer::operator new(unsigned int size);
// void GlassRenderer::operator delete(void *ptr);
// void __thiscall GlassRenderer::InitShardMeshVertexLists(GlassRenderer *this);
// GlassShardMeshVertex *__thiscall GlassRenderer::GetVertexList(GlassRenderer *this, unsigned int numOutlineVerts);
// void __thiscall GlassRenderer::AddGroupChange(GlassRenderer *this, GlassShard *shard);
int GroupChangeSort(const void *a, const void *b);
// int __thiscall GlassRenderer::CalcPackedPos(GlassRenderer *this, const vec3_t *pos);
// Allocator::Memory **__thiscall GlassRenderer::AllocateShardMemory(GlassRenderer *this, unsigned int size, GlassShard *shard);
// void __thiscall GlassRenderer::FreeShardMemory(GlassRenderer *this, void *ptr);
// int __thiscall GlassRenderer::ShardMemorySize(GlassRenderer *this, void *ptr);
// void __thiscall GlassRenderer::AddShatterAction(GlassRenderer *this, GlassClient *glass, const vec3_t *hitPos, const vec3_t *hitDir, bool gameState);
// void __thiscall GlassRenderer::AddExplosionAction(GlassRenderer *this, const vec3_t *origin, const float damageInner, const float damageOuter, const float radius, int mod);
// void __thiscall GlassRenderer::AddTraceAction(GlassRenderer *this, const vec3_t *p0, const vec3_t *p1);
// void __thiscall GlassRenderer::AddMeleeAction(GlassRenderer *this, const vec3_t *eyePos, const vec3_t *forward, const vec3_t *right, const vec3_t *up, float range);
// void __thiscall GlassRenderer::AddUsedShardMaterial(GlassRenderer *this, Material *material);
// void __thiscall sd_xa2_callback::OnLoopEnd(bdLobbyEventHandler *this, unsigned __int64 __formal);
// void __thiscall ShardGroup::UpdateBBox(ShardGroup *this);
// void __thiscall ShardGroup::GenerateVertsInternal(ShardGroup *this, const GlassRenderer *renderer);
// void __thiscall ShardGroup::FreeRenderMemory(ShardGroup *this);
// int __thiscall ShardGroup::TracePoint(ShardGroup *this, const vec3_t *p0, const vec3_t *p1);
// void __thiscall GlassRenderer::~GlassRenderer(GlassRenderer *this);
// void GlassRenderer::CrashGlassCmd();
// void __thiscall GlassRenderer::PrintHwm(GlassRenderer *this);
// void __thiscall ShardGroup::Add(ShardGroup *this, GlassShard *shard);
// void __thiscall ShardGroup::Update(ShardGroup *this, float deltaTime, GlassUpdateCmd *cmd);
// void __thiscall ShardGroup::GenerateVertsFinish(ShardGroup *this);
// void __thiscall GlassRenderer::Reset(GlassRenderer *this);
// GlassShard *__thiscall GlassRenderer::AllocShard(GlassRenderer *this);
// void __thiscall GlassRenderer::FreeShard(GlassRenderer *this, GlassShard *shard);
// GlassPhysics *__thiscall GlassRenderer::AllocPhysics(GlassRenderer *this);
// void __thiscall GlassRenderer::FreePhysics(GlassRenderer *this, GlassPhysics *phys);
// void __thiscall GlassRenderer::AddDelayedPhysicsShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::RemoveDelayedPhysicsShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::DoDelayedPhysics(GlassRenderer *this, float deltaTime);
// void __thiscall GlassRenderer::ExplosionEvent(GlassRenderer *this, const vec3_t *origin, const float damageInner, const float damageOuter, const float radius, int mod);
// int __thiscall GlassRenderer::TracePoint(GlassRenderer *this, const vec3_t *p0, const vec3_t *p1);
// void __thiscall GlassRenderer::Melee(GlassRenderer *this, const vec3_t *eyePos, const vec3_t *forward, const vec3_t *right, const vec3_t *up, float range);
// ShardGroup *__thiscall GlassRenderer::GetShardGroup(GlassRenderer *this, unsigned int packedPos, const GlassDef *glassDef);
// void GlassRenderer::PrintHwmCmd();
// void __thiscall GlassRenderer::Broom(GlassRenderer *this);
// void __thiscall GlassRenderer::DrawDebug(GlassRenderer *this, LocalClientNum_t localClientNum);
// void __thiscall ShardGroup::Remove(ShardGroup *this, GlassShard *shard);
// void __thiscall ShardGroup::GenerateVerts(ShardGroup *this, bool firstView, LocalClientNum_t localClientNum, GlassGenVertsCmd *cmd);
// void __thiscall GlassRenderer::DoGroupChanges(GlassRenderer *this);
// ShardGroup *__thiscall GlassRenderer::GetShardGroup(GlassRenderer *this, const vec3_t *pos, const GlassDef *glassDef);
// void __thiscall GlassRenderer::RemoveColidingShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::GlassRenderer(GlassRenderer *this, const Glasses *glasses);
// void __thiscall GlassRenderer::RemoveGlassShards(GlassRenderer *this, unsigned int glassIndex);
// GlassShard *__thiscall GlassRenderer::GetSmallestColidingShard(GlassRenderer *this);
// void __thiscall GlassRenderer::SortedShardsList::Insert(GlassRenderer::SortedShardsList *this, GlassShard *shard);
// void __thiscall GlassRenderer::SortedShardsList::InsertReverse(GlassRenderer::SortedShardsList *this, GlassShard *shard);
// BOOL __thiscall GlassRenderer::AddColidingShard(GlassRenderer *this, GlassShard *shard);
// void __thiscall GlassRenderer::GetSmallestShards(GlassRenderer *this, unsigned int maxShards, bool checkVisible, bool isVisible);
// void __thiscall GlassRenderer::GetLargestShards(GlassRenderer *this, unsigned int maxShards, bool checkVisible, bool isVisible);
// void __thiscall GlassRenderer::DoMaintenance(GlassRenderer *this);
// void __thiscall GlassRenderer::CrashGlass(GlassRenderer *this);
// void __thiscall GlassRenderer::RemovePhysicsShards(GlassRenderer *this);
// void __thiscall GlassRenderer::ExecuteActions(GlassRenderer *this);
// char __thiscall GlassRenderer::Update(GlassRenderer *this);
// void __thiscall GlassRenderer::GenerateVerts(GlassRenderer *this, LocalClientNum_t localClientNum, unsigned int viewIndex);
// void *operator new(unsigned int size);

//t6/code/src_noserver/glass/glass_server.cpp
// void __thiscall GlassesServer::Load(GlassesServer *this, MemoryFile *memFile);
// void __thiscall GlassesServer::ResetAll(GlassesServer *this);
void GlassSv_Shutdown();
unsigned int GlassSv_AreaGlasses(const vec3_t *mins, const vec3_t *maxs, const Glass **glasses, unsigned int maxGlasses);
void GlassSv_ClipMoveTrace(const moveclip_t *clip, trace_t *results);
void GlassSv_PointTrace(const pointtrace_t *clip, trace_t *results);
void GlassSv_Damage(unsigned int glassId, int damage, int mod, const vec3_t *pos, const vec3_t *dir);
void GlassSv_RadiusDamage(const vec3_t *origin, float radius, float coneAngleCos, vec3_t *coneDirection, float innerDamage, float outerDamage, int mod);
GlassServer *GlassSv_GetGlassByIndex(unsigned int index);
// void __thiscall GlassesServer::WriteSnapshotToClient(GlassesServer *this, msg_t *msg, int sinceTime);
void GlassSv_WriteSnapshotToClient(msg_t *msg, int sinceTime);
void GlassSv_WriteEmptySnapshotToClient(msg_t *msg);
void GlassSv_WriteGameState(msg_t *msg);
void GlassSv_Load(MemoryFile *memFile);
// void __thiscall GlassesServer::Update(GlassesServer *this);
// void __thiscall GlassesServer::ShatterAll(GlassesServer *this);
// void GlassesServer::ResetAllCmd();
void GlassSv_Update();
void GlassSv_Touch(unsigned int glassId, gentity_t *other);
void GlassSv_PredictTouch(gentity_t *other);
// void GlassesServer::ShatterAllCmd();
// void GlassesServer::Init(GlassesServer *this@<ecx>, const char *a2@<ebx>);
void GlassSv_Init();

//t6/code/src_noserver/glass/glass_shard.cpp
// void GlassPhysics::InitStatics();
// void __thiscall GlassPhysics::AddForce(GlassPhysics *this, const vec3_t *worldPos, const vec3_t *impulse);
// void __thiscall GlassPhysics::tensor_transform_principle(GlassPhysics *this, const phys_vec3 *diag, const phys_mat44 *mat, phys_mat44 *tensor);
// bool __thiscall GlassOutline::Add(GlassOutline *this, const vec2_t *pos);
// bool __thiscall GlassOutline::Add(GlassOutline *this, const vec2_t *dir, float len);
// void __thiscall GlassOutline::AddSafe(GlassOutline *this, float x, float y, bool isOriginalEdge);
// double __thiscall GlassOutline::EdgeRatio(GlassOutline *this);
// void __thiscall GlassOutline::GetBBox(GlassOutline *this, vec2_t *mn, vec2_t *mx);
// void __thiscall GlassOutline::Recenter(GlassOutline *this, vec2_t *offset);
// BOOL __thiscall GlassOutline::HasNarrowAngle(GlassOutline *this);
// bool __thiscall GlassOutline::IsNarrow(GlassOutline *this);
// char __thiscall GlassOutline::DoesIntersect(GlassOutline *this, const vec2_t *start, const vec2_t *dir, float len, float padding);
// void __thiscall GlassOutline::GetNearestDistances(GlassOutline *this, const vec2_t *p, GlassOutline::EdgeDistance *dists, int nDists);
int compareOutlines(const void *o1, const void *o2);
// int __thiscall GlassPackedOutline::Init(GlassPackedOutline *this, void *ptr, unsigned __int8 num);
// int __thiscall GlassPackedOutline::GetStreamSize(GlassPackedOutline *this);
// unsigned __int8 *__thiscall GlassPackedOutline::StreamOut(GlassPackedOutline *this, unsigned __int8 *streamBuff);
// void __thiscall GlassPackedOutline::GetBBox(GlassPackedOutline *this, vec2_t *mn, vec2_t *mx);
// void __thiscall GlassPackedOutline::Recenter(GlassPackedOutline *this, vec2_t *offset);
// double __thiscall GlassPackedOutline::EdgeRatio(GlassPackedOutline *this);
// void __thiscall GlassShard::Mesh::Init(GlassShard::Mesh *this, const GlassPackedOutline *outline, float thickness, const vec3_t *tangt);
// ;
// bool __thiscall GlassShard::Triangles::Triangulate(GlassShard::Triangles *this);
// void __thiscall GlassShard::Init(GlassShard *this);
// void __thiscall GlassShard::ToLocal(GlassShard *this, const vec3_t *pos, const vec3_t *dir, vec3_t *localPos, vec3_t *localDir);
// void __thiscall GlassShard::GetLocalBBox(GlassShard *this, vec3_t *mins, vec3_t *maxs);
// void __thiscall GlassShard::UpdateBBox(GlassShard *this);
// void __thiscall GlassShard::GenerateVerts(GlassShard *this, const GlassRenderer *renderer, bool highLod, GfxPackedVertex *baseVerts, unsigned __int16 vertsBaseIndex, unsigned __int16 *idxOut);
// double __thiscall GlassShard::GetMass(GlassShard *this);
// void __thiscall GlassShard::DestroyPhysicsObj(GlassShard *this);
// void GlassShard::AddForce(GlassShard *this@<ecx>, const char *a2@<edi>, const vec3_t *pos, const vec3_t *forceIn);
// void __thiscall GlassShard::SetVelocity(GlassShard *this, const vec3_t *t_vel, const vec3_t *a_vel);
// int GetNumIntersections<GlassOutline>(const GlassOutline *_this, const vec2_t *start, const vec2_t *dir, float *nearestDist, int *nearestedge);
// int GetNumIntersections<GlassPackedOutline>(const GlassPackedOutline *_this, const vec2_t *start, const vec2_t *dir, float *nearestDist, int *nearestedge);
// void GlassPhysics::CreateAxis(GlassPhysics *this, float position, const vec3_t *a3, const vec3_t *axis, const vec3_t *tVel, const vec3_t *aVel, float mass, const vec3_t *localBBoxMin, const vec3_t *localBBoxMax);
// void GlassPhysics::IntegrateVelocity(GlassPhysics *this, int a2, float deltaTime);
// void __thiscall GlassPhysics::GetPosition(GlassPhysics *this, vec3_t *position, vec3_t *axis);
// GlassOutline *__thiscall GlassOutline::operator=(GlassOutline *this, const GlassOutline *o);
// bool __thiscall GlassOutline::CloseOutline(GlassOutline *this);
// void __thiscall GlassOutline::Reverse(GlassOutline *this);
// int __thiscall GlassOutline::InitSplitOutlines(GlassOutline *this, GlassOutline *newOutline, GlassOutline *outline1, GlassOutline *outline2, float minShardSize);
// const unsigned __int8 *__thiscall GlassOutline::StreamIn(GlassOutline *this, const unsigned __int8 *streamBuff);
// bool __thiscall GlassPackedOutline::LeaveOnEdge(GlassPackedOutline *this, float stickiness);
// void __thiscall GlassShard::Destroy(GlassShard *this);
// char __thiscall GlassShard::AllocateMemory(GlassShard *this, unsigned int numVerts, const GlassShard::Triangles *triangles);
// bool __thiscall GlassShard::Intersect(GlassShard *this, const vec3_t *pos, const vec3_t *dir, vec2_t *hitPoint);
// bool __thiscall GlassOutline::LeaveOnEdge(GlassOutline *this, float stickiness);
// bool __thiscall GlassOutline::IsOnBottomEdge(GlassOutline *this, const GlassShard *shard);
// void GlassPhysics::Step(GlassPhysics *this, int a2, float deltaTime);
// void __thiscall GlassOutline::GlassOutline(GlassOutline *this, const GlassPackedOutline *other, GlassOutline::Vertex *_verts, unsigned __int8 _maxVerts);
// void __thiscall GlassOutline::GlassOutline(GlassOutline *this, const Glass *glass, GlassOutline::Vertex *v, unsigned __int8 mv);
// int __thiscall GlassOutline::Split(GlassOutline *this, GlassOutline *newOutline, float minShardSize, unsigned int startEdge, float startEdgeParam);
// int __thiscall GlassOutline::Chip(GlassOutline *this, GlassOutline *newOutline, const GlassOutline::EdgeDistance *dist, const vec2_t *hitPoint, float minShardSize);
// int __thiscall GlassOutline::HitPoint(GlassOutline *this, const GlassShard *shard, GlassOutline **newOutlines, int maxNewOutlines, float minShardSize, float maxShardSize, const vec2_t *hitPoint2d);
// void __thiscall GlassPackedOutline::Init(GlassPackedOutline *this, const GlassOutline *other, const GlassShard *shard);
// void __thiscall GlassShard::Remove(GlassShard *this, GlassShard::RemoveReason reason, bool delay);
// char __thiscall GlassShard::Init(GlassShard *this, const GlassOutline *outline, const vec2_t *offset, float _thickness, float _uvScale, const vec2_t *_uvOffset, float _binormalSign, unsigned __int16 _glassIndex, const vec3_t *_axis, const vec3_t *_origin);
// void __thiscall GlassShard::DisableCollisions(GlassShard *this);
// unsigned int __thiscall GlassOutline::Shatter(GlassOutline *this, FixedSizeAllocator<TempPackedOutline> *newOutlines, unsigned int maxNewOutlines, float maxShardSize, float minShardSize);
// GlassShard *GlassShard::Create(const Glass *glass, GlassOutline *outline);
// GlassShard *GlassShard::Create(const Glass *glass, GlassPackedOutline *outline);
// bool __thiscall GlassShard::InitPhysicsObj(GlassShard *this, bool enableCollisions);
// char __thiscall GlassShard::InitPhysics(GlassShard *this, bool enableCollisions, const vec3_t *hitPos, const vec3_t *hitDir, float glassSize, float stickiness);
// void __thiscall GlassShard::DrawOutline(GlassShard *this);
// void GlassShard::InitPhysics(GlassShard **newShards, int numNewShards, float glassExtent, const vec3_t *pos, const vec3_t *dir);
// void __thiscall GlassShard::ExplosionEvent(GlassShard *this, const vec3_t *expOrigin, const float damageInner, const float damageOuter, const float radius, int mod);
// char __thiscall GlassShard::TracePoint(GlassShard *this, const vec3_t *p0, const vec3_t *p1, const vec3_t *dir, float length, const vec3_t *mins, const vec3_t *maxs);
// char __thiscall GlassShard::DelayedUpdate(GlassShard *this, float deltaTime);
// void __thiscall GlassShard::UpdateInternal(GlassShard *this, GlassRenderer *localRenderer, float deltaTime);
// void __thiscall GlassShard::Update(GlassShard *this, float deltaTime, GlassUpdateCmd *cmd);

//#include "glass/glass_shard.h"

