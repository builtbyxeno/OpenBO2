#pragma once

#include "types.h"

//t6/code/src_noserver/cgame/cg_ammocounter.cpp
void CG_AmmoCounterRegisterDvars();
void GetBaseRectPos(LocalClientNum_t localClientNum, const rectDef_s *rect, vec2_t *base);
Weapon GetWeaponAltIndex(const cg_t *cgameGlob, Weapon weapon);
void AmmoColor(cg_t *cgameGlob, vec3_t *color, Weapon weapon);
float AmmoCounterFadeAlpha(LocalClientNum_t localClientNum, cg_t *cgameGlob);
void DrawClipAmmoMagazine(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoShortMagazine(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoShotgunShells(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoRockets(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoBeltfed(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
;
void CG_DrawAmmoCounterSingle(LocalClientNum_t localClientNum, rectDef_s *rect, vec4_t *color, bool last);
void CG_DrawPlayerWeaponAmmoStock(char *a1, LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle);
void CG_DrawFuelTankPercentage(char *a1, LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle, float text_x, float text_y);
void CG_DrawPlayerWeaponAmmoClip(char *a1, LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle, float text_x, float text_y, int textAlignMode);
void CG_DrawPlayerWeaponAmmoClipDualWield(char *a1, LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle);
void DpadIconDims(const rectDef_s *rect, unsigned int slotIdx, weaponIconRatioType_t dpadIconRatio, float *x, float *y, float *w, float *h);
void DpadTextPos(LocalClientNum_t localClientNum, const rectDef_s *rect, unsigned int slotIdx, weaponIconRatioType_t dpadIconRatio, float *x, float *y);
bool ActionSlotIsActive(LocalClientNum_t localClientNum, unsigned int slotIdx);
float DpadFadeAlpha(LocalClientNum_t localClientNum, cg_t *cgameGlob);
double CG_GetHudAlphaDPad(cg_t *a1, LocalClientNum_t a2, LocalClientNum_t localClientNum);
double CG_GetHudAlphaAmmoCounter(cg_t *a1, LocalClientNum_t a2, LocalClientNum_t localClientNum);
char CG_ActionSlotIsUsable(const LocalClientNum_t localClientNum, unsigned int slotIdx);
void CG_DrawPlayerActionSlotDpad(LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color, Material *material);
void CG_DrawPlayerActionSlotCarousel(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t color, int textStyle);
void CG_DrawPlayerActionSlotBack(LocalClientNum_t localClientNum, const rectDef_s *rect, unsigned int slotIdx, const vec4_t *color, Material *material);
void CG_DrawPlayerActionSlotArrow(LocalClientNum_t localClientNum, const rectDef_s *rect, unsigned int slotIdx, vec4_t *color, Material *material);
void CG_DrawPlayerActionSlot(LocalClientNum_t localClientNum, const rectDef_s *rect, unsigned int slotIdx, vec4_t *color, Font_s *textFont, float textScale, int textStyle);
void CG_DrawPlayerWeaponBackground(LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color, Material *material);
void CG_DrawPlayerWeaponAmmoClipGraphic(cg_t *a1, LocalClientNum_t a2, LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color);
void CG_DrawPlayerWeaponAmmoClipGraphicDualWield(cg_t *a1, LocalClientNum_t a2, LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color);
void DrawStretchPicGun(const ScreenPlacement *scrPlace, const rectDef_s *rect, const vec4_t *color, Material *material, weaponIconRatioType_t ratio);
void CG_DrawPlayerWeaponIcon(cg_t *a1, LocalClientNum_t a2, LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color);
void CG_DrawPlayerWeaponLowAmmoWarning(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float textScale, int textStyle, float text_x, float text_y, int textAlignMode, Material *material);

//t6/code/src_noserver/cgame/cg_bolt.cpp
void CG_InitBolt(LocalClientNum_t localClientNum);
void CG_UpdateBolt(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_camera.cpp
void InterpolateAnglesSmooth(vec3_t *curAngles, const vec3_t *initialAngles, const vec3_t *targetAngles, float t);
void CG_StartCameraTween(LocalClientNum_t localClientNum, float tweenTime);
float CG_UpdateCameraTweenFOV(LocalClientNum_t localClientNum, float currentFov);
void CG_UpdateCameraTween(LocalClientNum_t localClientNum);
void CG_UpdateVehicleInitView(LocalClientNum_t localClientNum, CameraMode newMode);
void CG_SetSoundFutz(LocalClientNum_t localClientNum);
void CG_UpdateSoundFutz(LocalClientNum_t localClientNum, CameraMode newMode);
void CG_UpdateCameraTransition(LocalClientNum_t localClientNum, CameraMode oldMode, CameraMode newMode, bool useTagCamera);
int CG_RemapVehicleButton(LocalClientNum_t localClientNum, int *twokeys, int button, Bind_t vehicleBinding);
;
bool CG_RenderPlayerFromMissilePOV(LocalClientNum_t localClientNum);
bool CG_SpikeCameraViewActive(LocalClientNum_t localClientNum);
bool CG_ScriptedExtraCamActive(LocalClientNum_t localClientNum);
float CG_ScriptedExtraCamFov(LocalClientNum_t localClientNum);
char ShouldDoCameraTransition(cg_t *cgameGlob, CameraMode prevMode, CameraMode newMode, bool useTagCamera);
char ShouldDoThirdPersonVehicle(LocalClientNum_t localClientNum, const cg_t *cgameGlob, const playerState_s *ps);
CameraMode CG_UpdateCameraMode(LocalClientNum_t localClientNum);
CameraMode CG_GetExtraCamMode(LocalClientNum_t localClientNum);
void CG_ApplyViewAnimation(LocalClientNum_t localClientNum);
bool CG_ShouldDefaultViewFov(LocalClientNum_t localClientNum);
float CG_GetWeaponViewFov(LocalClientNum_t localClientNum, const playerState_s *ps, Weapon weapon, float viewFov, bool forWeapon);
double CG_GetTurretViewFov(LocalClientNum_t localClientNum, const playerState_s *ps);
float CG_GetViewFov(LocalClientNum_t localClientNum, const playerState_s *forWeapon);
;
;
void CG_CalculateGunnerOffset_Sway(const vec3_t *playerViewAngles, Weapon weapon, vec3_t *swayViewAngles, vec3_t *swayOffset, vec3_t *swayAngles, float ssSwayScale, int frametime);
;
void CG_GetExtraCamOrigin(LocalClientNum_t localClientNum, vec3_t *out);
void CG_CalcExtraCamViewValues(LocalClientNum_t localClientNum);
void RemoteEyesShake(cg_t *cgameGlob, centity_t *possessedEnt);
bool GetWeaponviewEyeValues(LocalClientNum_t localClientNum);
void CG_GetMissileViewOrigin(LocalClientNum_t localClientNum, vec3_t *out);
void CG_CalcScriptedExtraCamViewValues(LocalClientNum_t localClientNum);
void CG_CalcMissileAngleValues(float localClientNum, LocalClientNum_t a2);
long double CG_Player3rdPersonVehicle_GetPitchOffsetRelativeToADirection(const vec3_t *angles, vec3_t *direction);
bool CG_Player3rdPersonVehicle_GetViewAngles(const cg_t *cgameGlob, const playerState_s *ps, const centity_t *vehicle, const VehicleDef *info, const vec3_t *lookAtPos, vec3_t *angles, bool setPlayerAngles, bool lerpViewBackToForward);
void CG_Player3rdPersonVehicle_GetLookAtPosition(const centity_t *vehicle, const VehicleDef *info, vec3_t *origin);
float CG_Player3rdPersonVehicle_GetDampedSpringDistance(cg_t *cgameGlob, const centity_t *vehicle, const VehicleDef *info, float camDefaultDist);
int CG_Get3rdPersonVehicleMask(int vehicleType);
void CG_OffsetVehicleView(LocalClientNum_t localClientNum, CameraMode camMode);
int CG_ScrCamActive(LocalClientNum_t localClientNum);
void CG_ScrCamCalcView(LocalClientNum_t localClientNum);
void CG_ExtraCamDebug_SetView(LocalClientNum_t localClientNum);
void CG_ExtraCamDebug_SaveView(LocalClientNum_t localClientNum);
void CG_CalcFov_ExtraCam(float localClientNum, LocalClientNum_t a2);
BOOL InScriptExtraCamDebugMode3();
void CG_ExtraCam_GetViewOrigin(LocalClientNum_t localClientNum, ExtraCamLodInfo *extraCamLodInfo);
void CG_UpdateScriptExtraCams(LocalClientNum_t localClientNum);
void CG_ResetScriptExtraCam(ScriptExtraCam *scriptExtraCam);
bool CG_ExtraCamIsActive(LocalClientNum_t localClientNum);
BOOL CG_IsUsingMultiExtraCam(LocalClientNum_t localClientNum);
// void __thiscall ExtraCamClientStateRestore::ExtraCamClientStateRestore(ExtraCamClientStateRestore *this, LocalClientNum_t localClientNum);
// void __thiscall ExtraCamClientStateRestore::~ExtraCamClientStateRestore(ExtraCamClientStateRestore *this);
void CG_GetClientExtraCamParms(LocalClientNum_t localClientNum, GfxExtraCamParms *extraCamParms);
void CG_CaptureCameraOffset(LocalClientNum_t localClientNum);
;
void CG_CalcMissileViewValues(LocalClientNum_t localClientNum);
bool CG_ShouldVehicleCamAutoRecenter(LocalClientNum_t localClientNum, const VehicleDef *info);
// void CG_CalcVehicleViewValues(char *a1@<edi>, LocalClientNum_t localClientNum);
void CG_Calc3rdPersonVehicleViewValues(LocalClientNum_t localClientNum);
void CG_RadiantCamCalcView(LocalClientNum_t localClientNum);
char GetRemoteEyeValues(LocalClientNum_t localClientNum);
bool CG_CalcRemoteEyesViewValues(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_camerashake.cpp
void TRACK_cg_camerashake();
int CG_UpdateCameraShake(const cg_t *cgameGlob, CameraShake *shake);
void CG_StartShakeCamera(CameraShake *a1, const cg_t *a2, LocalClientNum_t localClientNum, float p, int duration, const vec3_t *src, float radius);
void CG_ShakeCamera(CameraShake *a1, const cg_t *a2, LocalClientNum_t localClientNum);
void CG_ClearCameraShakes(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_colltree.cpp
void TRACK_CG_CollWorld();
void CG_ClearEntityCollWorld(LocalClientNum_t localClientNum);
void CG_AddEntityToCollSector(LocalClientNum_t localClientNum, int entIndex, unsigned __int16 sectorIndex);
unsigned __int16 CG_AllocEntityCollSector(LocalClientNum_t localClientNum, const vec2_t *mins, const vec2_t *maxs);
void CG_SortEntityCollSector(LocalClientNum_t localClientNum, unsigned __int16 sectorIndex, const vec2_t *mins, const vec2_t *maxs);
void CG_UnlinkEntityColl(LocalClientNum_t localClientNum, int entIndex);
void CG_LinkEntityColl(LocalClientNum_t localClientNum, int entIndex, const vec3_t *absMins, const vec3_t *absMaxs);

//t6/code/src_noserver/cgame/cg_compass.cpp
void CG_CompassRegisterDvars();
bool CG_IsSelectingLocation(LocalClientNum_t localClientNum);
void CG_ApplySplitScreenCompassScale(CompassType compassType, float *x, float *y, float *w, float *h);
bool CG_WorldPosToCompass(CompassType compassType, const cg_t *cgameGlob, const rectDef_s *mapRect, const vec2_t *north, const vec2_t *playerWorldPos, const vec2_t *in, vec2_t *out, vec2_t *outClipped);
void CG_CompassCalcDimensions(CompassType compassType, const cg_t *cgameGlob, const rectDef_s *parentRect, const rectDef_s *rect, float *x, float *y, float *w, float *h);
double CG_FadeCompass(LocalClientNum_t localClientNum, int displayStartTime, CompassType compassType);
void CG_DrawPlayerPopUps(float localClientNum, LocalClientNum_t a2, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle, itemDef_s *item, const char *text, bool doSwing);
void CG_DrawPlayerCOD7TypeWriter(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle, itemDef_s *item, const char *text);
void CG_DrawPlayerRedationText(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle, itemDef_s *item, const char *text);
void CG_DrawPlayerPopInText(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, vec4_t *color, Material *material, int textStyle, itemDef_s *item, const char *text);
void CG_CompassDrawPlayerNorthCoord(LocalClientNum_t localClientNum, CompassType compassType, const rectDef_s *parentRect, const rectDef_s *rect, Font_s *font, Material *material, vec4_t *color, int textStyle);
void CG_CompassDrawPlayerEastCoord(LocalClientNum_t localClientNum, CompassType compassType, const rectDef_s *parentRect, const rectDef_s *rect, Font_s *font, Material *material, vec4_t *color, int textStyle);
void CG_CompassDrawPlayerNCoordScroll(LocalClientNum_t localClientNum, CompassType compassType, const rectDef_s *parentRect, const rectDef_s *rect, Font_s *font, Material *material, vec4_t *color, int textStyle);
void CG_CompassDrawPlayerECoordScroll(LocalClientNum_t localClientNum, CompassType compassType, const rectDef_s *parentRect, const rectDef_s *rect, Font_s *font, Material *material, vec4_t *color, int textStyle);
void CG_UpdateEnemyScramblerAlpha(LocalClientNum_t localClientNum);
void CG_CompassDrawRound(LocalClientNum_t localClientNum, const rectDef_s *rect, Material *material, vec4_t *color);
void CalcCompassPointerSize(CompassType compassType, float *w, float *h);
void DrawIconDistanceText(LocalClientNum_t localClientNum, float distance, float iconX, float iconY, float iconH, const rectDef_s *rect, const vec4_t *color, Font_s *textFont, float textScale, int textStyle);
void CG_CompassDrawTickertape(LocalClientNum_t localClientNum, CompassType compassType, const rectDef_s *parentRect, const rectDef_s *rect, Material *material, const vec4_t *color, Font_s *textFont, float textScale, int textStyle, bool drawObjectives);
void CG_SetGridTable();
void CG_GetGridFromPos(LocalClientNum_t localClientNum, vec3_t *pos, char *gridName);
double CG_GetHudAlphaCompass(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_drawtools.cpp
double CG_GetPicWidth(Material *mat);
void CG_DrawRotatedPicPhysicalW(const ScreenPlacement *scrPlace, float x, float y, float w, float width, float height, float angle, const vec4_t *color, Material *material);
void CG_DrawRotatedPicPhysical(const ScreenPlacement *scrPlace, float x, float y, float width, float height, float angle, const vec4_t *color, Material *material);
void CG_DrawRotatedPicW(const ScreenPlacement *scrPlace, float x, float y, float w, float width, float height, int horzAlign, int vertAlign, float angle, const vec4_t *color, Material *material);
void CG_DrawRotatedPic(const ScreenPlacement *scrPlace, float x, float y, float width, float height, int horzAlign, int vertAlign, float angle, const vec4_t *color, Material *material);
void CG_DrawRotatedQuadPic(const ScreenPlacement *scrPlace, float x, float y, const vec2_t *verts, float angle, const vec4_t *color, Material *material);
void CG_DrawStringExt(const ScreenPlacement *scrPlace, float x, float y, const char *string, const vec4_t *setColor, int forceColor, int shadow, float charHeight);
int CG_DrawDevString(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float x, float y, float xScale, float yScale, const char *s, const vec4_t *color, int align, Font_s *font);
int CG_DrawSmallDevStringColor(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float x, float y, const char *s, const vec4_t *color, int align);
double CG_FadeAlpha(int timeNow, int startMsec, int totalMsec, int fadeMsec);
vec4_t *CG_FadeColor(int timeNow, int startMsec, int totalMsec, int fadeMsec);
void CG_MiniMapChanged(LocalClientNum_t localClientNum);
void CG_NorthDirectionChanged(LocalClientNum_t localClientNum);
void CG_RelativeTeamColor(ClientNum_t clientNum, vec4_t *color, LocalClientNum_t localClientNum);
int CG_DrawBigDevString(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float x, float y, const char *s, float alpha, int align);

//t6/code/src_noserver/cgame/cg_draw_debug.cpp
void CG_DrawScriptUsage(const ScreenPlacement *scrPlace);
int CG_CompareSndInfoChannel(const void *va, const void *vb);
int CG_CompareSndInfoPriority(const void *va, const void *vb);
int CG_CompareSndInfoAlias(const void *va, const void *vb);
int CG_CompareSndInfoDryLevel(const void *va, const void *vb);
int CG_CompareSndInfoDistance(const void *va, const void *vb);
int CG_CompareSndInfoEntity(const void *va, const void *vb);
void CG_DrawSoundOverlay(const ScreenPlacement *scrPlace);
void CG_DrawPerformanceWarnings(LocalClientNum_t localClientNum);
void CG_DrawModelBoneAxis(LocalClientNum_t localClientNum);
void CG_DrawFxText(const char *text, vec2_t *profilePos);
void CG_DrawFxPriorityText(const char *text, vec2_t *profilePos);
void CG_DrawDebugPlayerHealth(LocalClientNum_t localClientNum);
void CG_DrawDebugPlayerSprint(LocalClientNum_t localClientNum);
void CG_DrawEntDObjBoneDebug(LocalClientNum_t localClientNum, int entNum);
void CG_DrawDebugOverlays(LocalClientNum_t localClientNum);
void CG_DrawFullScreenDebugOverlays(LocalClientNum_t localClientNum);
void CG_DrawGfxStatsLine(const ScreenPlacement *scrPlace, float line, const char *header, const vec4_t *color, int surfs, int mats, int prims, int tris);
void CG_DrawGfxStatsMatrix(const ScreenPlacement *scrPlace, GfxPrimStatsCounters counter);
;
void CG_DrawVersion(LocalClientNum_t localClientNum);
void CG_QuickPrintFlush();
double CG_GetCornerDebugPrintScale_X();
double CG_GetCornerDebugPrintScale_Y();
double CG_CornerDebugPrint(LocalClientNum_t localClientNum, const ScreenPlacement *sP, float posX, float posY, float labelWidth, const char *text, const char *label, const vec4_t *color, Font_s *font);
char *DebugSessionInfo();
void CG_DrawTaskErrorDebugInfo(LocalClientNum_t localClientNum);
void CG_DrawHostDebugInfo(LocalClientNum_t localClientNum);
void CG_DrawChangelistMismatch(LocalClientNum_t localClientNum);
void CG_DebugLineVertical(const vec3_t *p, const vec4_t *color, int depthTest, int duration);
void CG_DebugStarWithText(const vec3_t *point, const vec4_t *starColor, const vec4_t *textColor, const char *string, float fontsize, int duration);
void CG_DebugBox(const vec3_t *origin, const vec3_t *mins, const vec3_t *maxs, float yaw, const vec4_t *color, int depthTest, int duration);
void CG_DebugBoxOriented(const vec3_t *origin, const vec3_t *mins, const vec3_t *maxs, const vec3_t *rotation, const vec4_t *color, int depthTest, int duration);
float CG_CornerDebugPrintCaption(LocalClientNum_t localClientNum, const ScreenPlacement *sP, float posX, float posY, float labelWidth, const char *text, const vec4_t *color);
float CG_DrawSnapshot(LocalClientNum_t localClientNum, float posY);
float CG_DrawViewpos(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float CG_DrawCullDistDebugText(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float CG_DrawShadowMapDebugText(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float DrawEntityCounts(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float posY);
double CG_DrawAnimTagInfo(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float posY);
double CG_DrawFPS(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float y, meminfo_t *meminfo);
void CG_QuickPrint(const char *fmt, ...);
void CG_DrawUpperRightDebugInfo(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_indicators.cpp
void CG_GrenadeIndicator_GetPlayerPosition(const cg_t *cgameGlob, vec3_t *playerOrigin);
void CG_DrawFriendlyIndicators(int a1, int a2, LocalClientNum_t localClientNum);
void CG_DrawFlashDamage(const cg_t *cgameGlob);
bool CG_ShouldDrawDamageDirectionIndicators(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_DrawDamageDirectionIndicators(LocalClientNum_t localClientNum);
void CG_DrawWarningPointer(LocalClientNum_t localClientNum, float centerX, float centerY, const vec3_t *grenadeOffset, const vec4_t *color, const float radiusOffset, const float scaleFactor);
void CG_DrawWarningIcon(LocalClientNum_t localClientNum, float centerX, float centerY, const vec3_t *grenadeOffset, const vec4_t *color, Material *material, const float radiusOffset, const float scaleFactor);
void CG_ClearHudGrenades();
double CG_AddHudGrenade_PositionCheck(vec3_t *a1, const cg_t *a2, const cg_t *cgameGlob, const centity_t *grenadeEnt, const WeaponDef *weapDef);
void CG_AddHudGrenade(const cg_t *cgameGlob, const centity_t *grenadeEnt);
void CG_DrawGrenadeIndicators(float localClientNum, LocalClientNum_t a2);

//t6/code/src_noserver/cgame/cg_draw_names.cpp
void TRACK_cg_draw_names();
void CG_ClearOverheadFade();
OverheadFade *CG_GetOverheadFade(LocalClientNum_t localClientNum);
void CG_ClearPlayerDetails();
void CG_InitPlayerDetails(LocalClientNum_t localClientNum, int targetClientNum);
bool CG_CalcNamePosition(LocalClientNum_t localClientNum, const vec3_t *origin, float *xOut, float *yOut);
int CG_GetZombiePlayerColorIndex(LocalClientNum_t localClientNum, ClientNum_t currentClientNum);
void CG_DrawOverheadNames(LocalClientNum_t localClientNum, const centity_t *cent, float alpha, int mode);
bool CG_CanSeeFriendlyHeadInView(LocalClientNum_t localClientNum, const centity_t *cent, const vec3_t *start, const vec3_t *end);
void CG_GetFriendlyHeadPos(LocalClientNum_t localClientNum, const centity_t *cent, vec3_t *end);
int CG_CheckIfDrivingRemoteControlVehicle(LocalClientNum_t localClientNum, unsigned __int16 EntId);
;
void CG_ScanForCrosshairEntity(LocalClientNum_t localClientNum);
int compareEntityDist(const void *v1, const void *v2);
void CG_AddDrawName(LocalClientNum_t localClientNum, int entnum, float alpha, team_indicator teamIndicator);
void CG_DrawNames(LocalClientNum_t localClientNum);
bool CG_IsValidCrosshairEntity(LocalClientNum_t localClientNum, const cg_t *cgameGlob, const centity_t *cent, int entNum);
bool ShouldDrawCrosshairNames(LocalClientNum_t localClientNum);
void CG_DrawCrosshairNames(LocalClientNum_t a1, int a2, LocalClientNum_t localClientNum);
bool activeKillstreakWithLineOfSightOverlay(LocalClientNum_t localClientNum, const cg_t *cgameGlob, int entnum);
bool PlayerCanSeeEnemyNames(LocalClientNum_t localClientNum, int entnum);
bool ShouldDrawPlayerName(LocalClientNum_t localClientNum, int entnum, int team);
bool ShouldDrawFriendlyName(LocalClientNum_t localClientNum, const centity_t *cent, int entnum, int team);
int GetVehicleDriverEntNum(const cg_t *cgameGlob, const centity_t *cent, int entnum);
;
bool CG_CanSeeFriendlyHead(vec3_t *a1, LocalClientNum_t localClientNum, const centity_t *cent);
void CG_DrawActorName(LocalClientNum_t localClientNum, const centity_t *cent, bool flashed);
;
void CG_DrawFriendlyNames(LocalClientNum_t localClientNum);
void CG_DrawVisibleNames(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_reticles.cpp
void CG_CalcCrosshairPosition(const cg_t *cgameGlob, float *x, float *y);
char CG_GetWeapReticleZoom(const cg_t *cgameGlob, float *zoom);
void CG_DrawFrameOverlay(float innerLeft, float innerRight, float innerTop, float innerBottom, const vec4_t *color, Material *material, LocalClientNum_t localClientNum);
void CG_DrawNightVisionOverlay(LocalClientNum_t localClientNum);
bool CG_UsingLowResViewPort(LocalClientNum_t localClientNum);
void CG_UpdateScissorViewport(refdef_t *refdef, vec2_t *drawPos, vec2_t *drawSize);
void CG_DrawAdsOverlay(LocalClientNum_t localClientNum, Weapon weapon, const vec4_t *color, const vec2_t *crosshairPos);
void CG_DrawWeapReticle(LocalClientNum_t localClientNum);
void CG_CalcCrosshairColor(const LocalClientNum_t localClientNum, float alpha, vec4_t *color);
void CG_DrawTurretCrossHair(LocalClientNum_t localClientNum);
float CG_GetVehicleCrossHairAlpha(LocalClientNum_t localClientNum);
bool ShouldShowCrosshairOnVehicle(const cg_t *cgameGlob, const WeaponDef *weapDef);
bool CG_DrawVehicleCrossHair(LocalClientNum_t localClientNum);
bool AllowedToDrawCrosshair(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState);
void CG_DrawAdsAimIndicator(LocalClientNum_t localClientNum, const WeaponDef *weapDef, const vec4_t *color, float centerX, float centerY, float transScale);
void CG_TransitionToAds(const cg_t *cgameGlob, const WeaponDef *weapDef, float posLerp, float *transScale, float *transShift);
bool CG_DrawReticleCenter(LocalClientNum_t localClientNum, const Weapon weapon, const vec4_t *color, float centerX, float centerY, float centerW, float transScale);
void CG_CalcReticleSpread(const cg_t *cgameGlob, const Weapon weapon, const vec2_t *drawSize, float transScale, vec2_t *spread);
void CG_CalcReticleColor(LocalClientNum_t localClientNum, const vec4_t *baseColor, float alpha, float aimSpreadScale, vec4_t *reticleColor);
void CG_DrawReticleSides(LocalClientNum_t localClientNum, Weapon weapon, const vec4_t *baseColor, float centerX, float centerY, float centerW, float transScale);
bool ShouldDrawCrosshair(const cg_t *cgameGlob, const playerState_s *ps);
;

//#include "cgame/cg_effects_load_db.h"

//t6/code/src_noserver/cgame/cg_effects_load_obj.cpp
const char *CG_FleshTypeToName(int fleshTypeId);
int CG_AddImpactFileToList(const char *filePath, int index, char **fileList, int *fileCount, int maxFiles);
int CG_GetIncludesForFile(const char *file, char **list, int *count, int max);
;
int CG_ProcessFileList(char **list, int count, EffectFile *effectFile);
void CG_RegisterImpactEffectsForFile(const char *filePath, EffectFile *effectFile, char *listbuf);
FxImpactTable *CG_RegisterImpactEffects_FastFile();
int CG_RegisterImpactEffects_NonFlesh(const char **szEffectFile, const char *const pszTypeName, const FxEffectDef **fx);
FxImpactTable *CG_RegisterImpactEffects_LoadObj(const char *filePath);
FxImpactTable *CG_RegisterImpactEffects();

//t6/code/src_noserver/cgame/cg_event.cpp
void CG_Obituary(LocalClientNum_t localClientNum, const entityState_s *ent);
void RemoteMissileBoostEvent(LocalClientNum_t localClientNum, centity_t *cent, int eventParm);
void CG_ObituaryRevive(LocalClientNum_t localClientNum, const entityState_s *ent);
void CG_DirectionalHitIndicator(LocalClientNum_t localClientNum, const entityState_s *ent);
void CG_ItemPickup(LocalClientNum_t localClientNum, Weapon weapon);
void CG_SetWetness(LocalClientNum_t localClientNum, int entNum, float wetness, int invert);
void CG_ExplosionEvent(LocalClientNum_t localClientNum, centity_t *eventEnt, const vec3_t *origin, const float damageInner, const float damageOuter, float radius, int mod, const char *weaponName);
void CG_ProjectileExplosionEvent(LocalClientNum_t localClientNum, centity_t *cent, Weapon weapon, const vec3_t *position, int mod);
const DObj *CG_GetBoneIndex(LocalClientNum_t localClientNum, const int dobjHandle, unsigned int boneName, unsigned __int8 *boneIndex);
unsigned int CG_PlayBoltedEffect(LocalClientNum_t localClientNum, const FxEffectDef *fxDef, int dobjHandle, unsigned int boneName);
unsigned int CG_PlayBoltedEffectRelative(LocalClientNum_t localClientNum, const FxEffectDef *fxDef, int dobjHandle, unsigned int boneName, const vec3_t *offset, const vec3_t *offsetaxis);
void CG_PlayFx(LocalClientNum_t localClientNum, centity_t *cent, const vec3_t *angles);
void CG_PlayFxOnTag(LocalClientNum_t localClientNum, centity_t *cent, int eventParm);
void CG_SetInvalidCmdHint(cg_t *cgameGlob, InvalidCmdHintType hintType);
void CG_SetInvalidStanceHint(cg_t *cgameGlob, invalid_cmd_hint_t type);
void CG_StopWeaponSound(const LocalClientNum_t localClientNum, bool isPlayerView, const WeaponDef *weaponDef, const int entitynum, weaponstate_t weaponstate);
bool CG_IsSoundEventLouder(LocalClientNum_t localClientNum, centity_t *cent);
void CG_DoJumpEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, int surfaceType, bool quiet);
void CG_DoLandEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, int surfaceType, bool quiet, bool damagePlayer);
void CG_GibEvent(LocalClientNum_t localClientNum, centity_t *cent, unsigned int eventParm);
;
void CG_PhysLaunch(LocalClientNum_t localClientNum, centity_t *cent, const entityState_s *es);
bool CG_CheckIfDualWieldEmpty(playerState_s *ps, Weapon weapon);
;
// void CG_CheckEvents(char *a1@<edi>, LocalClientNum_t localClientNum, centity_t *cent);
void CG_CheckEntEvents(LocalClientNum_t localClientNum, centity_t *cent);

//#include "cgame/cg_footstepfxtable_load_db.h"

//#include "cgame/cg_footsteptable_load_db.h"

//t6/code/src_noserver/cgame/cg_hudelem.cpp
void CG_HudElemRegisterDvars();
void DirectiveFakeIntroSeconds(LocalClientNum_t localClientNum, const char *arg0, char *result);
void ParseDirective(const char *directive, char *resultName, char *resultArg0);
void GetHudelemDirective(LocalClientNum_t localClientNum, const char *directive, char *result, bool press, bool cap, bool limit, bool anim);
char ReplaceDirective(LocalClientNum_t localClientNum, unsigned int *searchPos, unsigned int *dstLen, char *dstString);
void CG_TranslateHudElemMessage(LocalClientNum_t localClientNum, const char *message, const char *messageType, char *hudElemString);
void SafeTranslateHudElemString(LocalClientNum_t localClientNum, int index, char *hudElemString);
float HudElemStringWidth(LocalClientNum_t localClientNum, const char *string, const hudelem_s *elem, const cg_hudelem_t *cghe);
int GetHudElemTime(const hudelem_s *elem, int timeNow);
const char *HudElemTimerString(const hudelem_s *elem, int timeNow);
const char *HudElemTenthsTimerString(const hudelem_s *elem, int timeNow);
float HudElemMaterialWidth(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
float HudElemMaterialHeight(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
;
float HudElemHeight(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
void GetHudElemOrg(const ScreenPlacement *scrPlace, int alignOrg, int alignScreen, float xVirtual, float yVirtual, float width, float height, float *orgX, float *orgY);
;
float OffsetHudElemY(const hudelem_s *elem, const cg_hudelem_t *cghe, float offsetY);
void ConsolidateHudElemText(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe, char *hudElemString);
void CopyStringToHudElemString(const char *string, char *hudElemString);
;
void HudElemColorToVec4(const hudelem_color_t *hudElemColor, vec4_t *resultColor);
void DrawHudElemString(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, const char *text, const hudelem_s *elem, cg_hudelem_t *cghe);
void DrawHudElemClock(LocalClientNum_t localClientNum, const hudelem_s *elem, const cg_hudelem_t *cghe);
void DrawHudElemMaterial(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe);
float HudElemWaypointHeight(LocalClientNum_t localClientNum, const hudelem_s *elem);
char WorldPosToScreenPos(LocalClientNum_t localClientNum, const vec3_t *worldPos, vec2_t *outScreenPos);
char WorldPosToExtraCamScreenPos(LocalClientNum_t localClientNum, const vec3_t *worldPos, vec2_t *outScreenPos);
BOOL ClampScreenPosToEdges(LocalClientNum_t localClientNum, vec2_t *point, float padLeft, float padRight, float padTop, float padBottom, vec2_t *resultNormal, float *resultDist);
float GetScaleForDistance(LocalClientNum_t localClientNum, const vec3_t *worldPos);
float WaypointFadeGetTimeFrac(const cg_t *cgameGlob, int currentTime);
void WaypointTargetFade(LocalClientNum_t localClientNum, const hudelem_s *elem, const vec2_t *screenPos, vec4_t *color);
void DrawOffscreenViewableWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem);
float DrawHudElemPerk(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe, int activePerkCategoryCount, int *specialtyCollectionIndexArray, int specialtyTypeCount);
;
void DrawHudElemPerks(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, const hudelem_s *elem, cg_hudelem_t *cghe);
void DrawSingleHudElem2d(LocalClientNum_t localClientNum, const hudelem_s *elem);
int compare_hudelems(const void *pe0, const void *pe1);
int GetSortedHudElems(LocalClientNum_t localClientNum, hudelem_s **elems);
int GetSortedDebugHudElems(hudelem_s **elems);
void CG_Draw2dHudElemList(hudelem_s **elems, int elemCount, LocalClientNum_t localClientNum, int foreground, bool playerAlive, bool inKillCam);
;
void AddDrawSurfForHudElemWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem);
bool RB_AddWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem, int slot);
void RB_AddWaypoints(LocalClientNum_t localClientNum);
void RB_ClearWaypoints(LocalClientNum_t localClientNum);
void CG_AddDrawSurfsFor3dHudElems(LocalClientNum_t localClientNum);
void CG_AddWaypoint(LocalClientNum_t localClientNum, Material *material, const vec4_t *color, const vec3_t *origin, float radius, bool screenSize, bool alignBottom, bool forceNear);
int RB_NumDrawWaypoints(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_info.cpp
void CG_LoadingString(LocalClientNum_t localClientNum, const char *s);
BOOL CG_IsShowingProgress_LoadObj();
BOOL CG_IsShowingProgress_FastFile();
void CG_DrawInformation(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_laser.cpp
laser_cache_t *get_laser_cache(int entnum);
void CG_LaserRegisterDvars();
bool CG_LaserForceOnEnabled();
void AddCore(LocalClientNum_t localClientNum, centity_t *cent, orientation_t *orient, const vec3_t *viewerPos, LaserOwnerEnum laserOwner, LaserLightEnum laserLightEnum, float beamAlpha, bool laserSourceHidden);
void CG_AddCore(const vec3_t *viewerPos, vec3_t laserBegin, vec3_t laserEnd, float lengthFraction, float beamAlpha, float beamRadius);
void CG_LaserDraw(LocalClientNum_t localClientNum, Weapon weapon, centity_t *cent, DObj *obj, cpose_t *pose, const vec3_t *viewerPos, LaserOwnerEnum laserOwner, LaserLightEnum laserLightEnum);
void CG_LaserClearAll();
void CG_LaserAdd(LocalClientNum_t localClientNum, int entnum);
void CG_LaserDrawAll(LocalClientNum_t localClientNum);

//#include "cgame/cg_local.h"

//t6/code/src_noserver/cgame/cg_localents.cpp
void TRACK_cg_localents();
void CG_InitLocalEntities(const LocalClientNum_t localClientNum);
localEntity_s *CG_AllocLocalEntity(const LocalClientNum_t localClientNum);
void CG_AddMovingTracer(const cg_t *cgameGlob, localEntity_s *le);
void CG_AddLocalEntityTracerBeams(localEntity_s *next, const LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_main.cpp
void TRACK_cg_main();
int CG_irand(int min, int max);
double CG_flrand(float min, float max);
;
bool CG_HasClientSystemBeenInitialzed();
bool CG_HaveClientScriptsBeenRun();
void CG_ClientDoneWithInitialization();
void CG_ResetClientInitializationState();
void CG_ResetClientScriptsRunStatus();
void CG_SetClientScriptsRunStatus();
void CG_UpdateUIDeviceContexts(LocalClientNum_t localClientNum, int time);
void CG_UpdateFov(float value);
char CG_IsThirdPerson(LocalClientNum_t localClientNum);
BOOL CG_IsEntWalkable(LocalClientNum_t localClientNum, int entityNum);
BOOL CG_IsCreateFX();
int CScriptMover_UpdateMove(trajectory_t *pTr, vec3_t *vCurrPos, const float fSpeed, const float fMidTime, const float fDecelTime, const vec3_t *vPos1, const vec3_t *vPos2, const vec3_t *vPos3);
void CG_InitScreenDimensions(LocalClientNum_t localClientNum);
int CScr_LoadScriptAndLabel(const char *filename, const char *label);
void CG_AddFootstepEvent(LocalClientNum_t localClientNum, centity_t *cent, unsigned __int16 notetrack, unsigned __int16 bone);
void CG_AddPlayerFootstepEvent(LocalClientNum_t localClientNum, centity_t *cent, bool playerView, int movementType, int surface, bool quiet, bool footprint);
void CG_ProcessFootstepEvents(LocalClientNum_t localClientNum, cg_t *cgameGlob);
char CG_IsSonarAttachment(LocalClientNum_t localClientNum);
void CG_SetupSonar(LocalClientNum_t localClientNum);
void CG_UpdateVehicleBindings_f();
void CG_InitConsoleCommands();
void CG_ShutdownConsoleCommands();
float CG_GetDefaultFovForView(LocalClientNum_t localClientNum);
void CG_SetThirdPersonForAllLocalClients(bool value);
void CG_SetThirdPerson(LocalClientNum_t localClientNum, bool value);
void CG_UpdateFovCallBack();
void CG_RegisterDvars();

//t6/code/src_noserver/cgame/cg_mem_track.cpp
void CG_track_init();

//t6/code/src_noserver/cgame/cg_perf.cpp
void UpdateData(CG_PerfData *data, int value);
void CG_PerfInit();
void CG_PerfUpdate();

//t6/code/src_noserver/cgame/cg_playerstate.cpp
void CG_DamageFeedback(LocalClientNum_t localClientNum, int yawByte, int pitchByte, int damage);
void CG_Respawn(LocalClientNum_t localClientNum, int spectate);
void CG_ResetSpectatorViewAngles(LocalClientNum_t localClientNum);
void CG_CheckPlayerstateEvents(LocalClientNum_t localClientNum, playerState_s *ps, const transPlayerState_t *ops);
;
void CG_ClearTransPlayerState(transPlayerState_t *transPs);
void CG_ExtractTransPlayerState(const playerState_s *ps, transPlayerState_t *transPs);

//t6/code/src_noserver/cgame/cg_pose.cpp
void BG_Player_DoControllers(const CEntPlayerInfo *player, const DObj *obj, int *partBits);
void CG_Player_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Vehicle_DoControllersAir(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Destructible_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Turret_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Actor_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_DoBaseOriginController(const cpose_t *pose, const DObj *obj, int *setPartBits);
void CG_Vehicle_PostDObjCalcSkel(const cpose_t *pose, const DObj *obj, int *partBits);
;
void CG_Vehicle_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
DObjAnimMat *CG_DObjCalcPose(const cpose_t *remote_pose, const DObj *obj, int *partBits);

//#include "cgame/cg_pose.h"

//t6/code/src_noserver/cgame/cg_pose_utils.cpp
void CG_UsedDObjCalcPose(const cpose_t *pose);
void CG_CullIn(const cpose_t *pose);

//t6/code/src_noserver/cgame/cg_rumble.cpp
void Rumble_Strcpy(unsigned __int8 *member, const char *keyValue);
bool ParseRumbleGraph(RumbleGraph *graph, const char *buffer, const char *fileName);
bool ReadRumbleGraph(RumbleGraph *graph, const char *rumbleFileName);
char LoadRumbleGraph(const char *a1, RumbleGraph *a2, RumbleGraph *rumbleGraphArray, RumbleInfo *info, const char *highRumbleFileName, const char *lowRumbleFileName);
bool CG_LoadRumble(RumbleGraph *rumbleGraphArray, RumbleInfo *info, const char *name, int rumbleNameIndex);
void CG_RegisterRumbles(LocalClientNum_t localClientNum);
void DrawActiveRumbles(LocalClientNum_t localClientNum, const ActiveRumble *activeRumbleArray);
void RemoveInactiveRumbles(LocalClientNum_t localClientNum, ActiveRumble *activeRumbleArray);
void CalcActiveRumbles(LocalClientNum_t localClientNum, ActiveRumble *activeRumbleArray, const vec3_t *rumbleReceiverPos);
int GetRumbleInfoIndexFromName(LocalClientNum_t localClientNum, const char *rumbleName);
bool DuplicateRumbleExists(const cg_t *cgameGlob, ActiveRumble *arArray, const RumbleInfo *info, bool loop, RumbleSourceType type, int entityNum, const vec3_t *pos);
ActiveRumble *NextAvailableRumble(const cg_t *cgameGlob, ActiveRumble *arArray);
;
void CG_PlayRumbleOnEntity(LocalClientNum_t localClientNum, const char *rumbleName, int entityNum);
void CG_PlayRumbleOnPosition(LocalClientNum_t localClientNum, const char *rumbleName, const vec3_t *pos);
void CG_PlayRumbleLoopOnEntity(LocalClientNum_t localClientNum, const char *rumbleName, int entityNum);
void CG_PlayRumbleLoopOnPosition(LocalClientNum_t localClientNum, const char *rumbleName, const vec3_t *pos);
void CG_PlayRumbleOnClient(LocalClientNum_t localClientNum, const char *rumbleName);
void CG_PlayLoopRumbleOnClient(LocalClientNum_t localClientNum, const char *rumbleName);
void CG_StopRumble(LocalClientNum_t localClientNum, int entityNum, const char *rumbleName);
void CG_StopAllRumbles(LocalClientNum_t localClientNum);
void CG_SetRumbleReceiver(LocalClientNum_t localClientNum, int entityNum, const vec3_t *position);
void CG_DrawRumbleDebug(LocalClientNum_t localClientNum);
void RumbleGraphEventCallback(const DevGraph *graph, DevEventType event, LocalClientNum_t localClientNum);
void RumbleGraphTextCallback(const DevGraph *graph, const float inputX, const float inputY, char *text);
void InitDevguiRumbleGraphInteral(const char *rumbleName, RumbleGraph *rumbleGraph, RumbleInfo *rumbleInfo);
void CG_InitDevguiRumbleGraph(dvarType_t a1, LocalClientNum_t localClientNum);
;

//t6/code/src_noserver/cgame/cg_scr_main.cpp
unsigned __int16 CScr_GetMeansOfDeathConstString(int mod);
void CScr_Notify(LocalClientNum_t localClientNum, centity_t *ent, unsigned __int16 stringValue, unsigned int paramcount);
void CScr_ToLower();
void CScr_ReadOnly(centity_t *cent, const cent_field_s *pField);
void CScr_GetType(centity_t *cent, const cent_field_s *pField);
void CScr_GetWeaponName(centity_t *cent, const cent_field_s *pField);
void CScr_SetOrigin(centity_t *cent, const cent_field_s *pField);
void CScr_SetAngles(centity_t *cent, const cent_field_s *pField);
void CScr_GetModel(centity_t *cent, const cent_field_s *pField);
void VehicleCScr_GetVehicleDefField(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleClass(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleTreadFxArray(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleLightFXArray(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleLightFXTagArray(centity_t *cent, const cent_field_s *pField);
void CScr_FreeFakeEntity(LocalClientNum_t localClientNum, int entNum);
void CScr_DeleteFakeEnt();
void CScr_IsString();
void CScr_IsArray();
void assertCmd();
void assertmsgCmd();
void debugBreakCmd();
void print();
void println();
void CScr_IPrintLnBold();
void CScr_Print3D();
void CScr_RandomInt();
void CScr_RandomFloat();
void CScr_RandomIntRange();
void CScr_RandomFloatRange();
void CScr_VectorFromLineToPoint();
void CScr_PointOnSegmentNearestToPoint();
char CScr_Distance();
void CScr_Distance2D();
void CScr_DistanceSquared();
void CScr_Length();
void CScr_LengthSquared();
void CScr_Closer();
void CScr_VectorDot();
void CScr_VectorCross();
void CScr_VectorNormalize();
void CScr_VectorLerp();
void CScr_LerpFloat();
void CScr_LerpVector();
void CScr_GetMinBitCountForNum();
void CScr_CombineAngles();
void CScr_AbsAngleClamp180();
int Effect_Index(LocalClientNum_t clientNum, const char *name);
void CScr_LoadedFX();
void CScr_BulletTracer();
void CScr_AnimateUI();
void CScr_GetAnimLength();
void CScr_ShowUI();
void CScr_GetSystemTime();
void CScr_GetServerTime();
void CScr_ClientHasSnapShot();
void CScr_GetMapCenter();
char CScr_SetDvar();
void CScr_SetSavedDvar();
void CScr_IsStereoOn();
void CScr_IsMatureContentEnabled();
void CScr_GetDebugDvar();
void CScr_GetDebugDvarInt();
void CScr_GetDebugDvarFloat();
void CScr_SetDvarBool();
void CScr_SetDvarFloat();
void CScr_SetDvarInt();
void CScr_PlaySound();
void CScr_PlaySoundOnEntity(scr_entref_t entref);
void CScr_PlayLoopSoundOnEntity(scr_entref_t entref);
void CScr_StopLoopSoundOnEntity(scr_entref_t entref);
void CScr_IsPlayingLoopSound(scr_entref_t entref);
void CScr_SetSoundContext();
void CScr_SetSoundEntContext(scr_entref_t entref);
void CScr_SetLoopState(scr_entref_t entref);
void robot_mixer_behavior(_mixerLight_t *pMixer, const cg_t *cgameGlob);
void CG_MixerLightNotifyListener(unsigned int objectId, unsigned int notifyString);
void CScr_AllocateMixerLights();
void CScr_IsMixerLightBehaviorHardCoded();
void CScr_IsMixerBehaviorHardCoded();
void CG_FreeMixerLights();
void CG_TurnOffMixerExploder(_mixerLight_t *pMixer);
void CG_TurnOnMixerExploder(_mixerLight_t *pMixer);
void CG_SetMixerLightIntensity(_mixerLight_t *pMixer, _lightParams_t *pChannel, float intensity, bool bDominant);
void CG_DeleteLightModels(_lightModel_t *lightModel);
void CG_CreateLightModelsAndFX(_mixerLight_t *pMixer, _lightModel_t *pLightModel, __int16 modelIndex, const FxEffectDef *fxDef, unsigned int tag);
void CScr_AllocateSoundRandoms();
void CG_FreeSoundRandoms();
void CG_AddSoundRandomToActiveList(soundRandom_t *soundRandom);
void CG_RunSoundRandoms();
void CScr_CreateSoundRandom();
void CScr_SoundSetMusicState();
void CScr_SoundLoopEmitter();
void CScr_SoundStopLoopEmitter();
void CScr_SoundLineEmitter();
void CScr_SoundStopLineEmitter();
void CScr_GetAliasName();
void CScr_GetAliasCount();
void CScr_IsAliasLoop();
void CScr_StopLocalSound();
void CScr_SoundTimescale();
void CScr_SoundPlaying();
void CScr_SetSoundVolume();
void CScr_SetSoundPitch();
void CScr_SetSoundVolumeRate();
void CScr_SetSoundPitchRate();
void CScr_GetRealTime();
void CScr_GetPlaybackTime();
void CScr_GetKnownLength();
void CScr_SetGroupSnapshot();
void CScr_SetAmbientSnapshot();
void CScr_SetAmbientSideChainDuck();
void CScr_SetGlobalFutz();
void CScr_SetHealthSnapshot();
void CScr_SetLevelFadeSnapshot();
void CScr_StopSound();
void CScr_ScaleSpeed();
void CScr_DeactivateReverb();
void CScr_SetReverb();
void CScr_GetArrayKeys();
void CScr_GetFirstArrayKey();
void CScr_GetNextArrayKey();
void CScr_GetLastArrayKey();
void CScr_GetPrevArrayKey();
void CScr_GetLocalClientPos();
void CScr_AimingAtFriendly();
void CScr_SplitArgs();
void CScr_SetThirdPerson();
void CScr_sin();
void CScr_cos();
void CScr_tan();
void CScr_asin();
void CScr_acos();
void CScr_atan();
void CScr_min();
void CScr_max();
void CScr_floor();
void CScr_ceil();
void CScr_sqrt();
void CScr_CastInt();
void CScr_CastFloat();
void CScr_CastIString();
void CScr_GetLocalClientEyePos();
void CScr_GetLocalClientAngles();
char CScr_Spawn();
void CScr_IsAlive();
void CScr_GetWeaponAmmoClip();
void CScr_IsThrowingGrenade();
void CScr_IsMeleeing();
void CScr_IsSwitchingWeapons();
void CScr_IsOnTurret();
void CScr_IsSubStr();
void CScr_GetSubStr();
void CScr_StrTok();
void CScr_MakeLocalizedString();
void CScr_GetSpecies(centity_t *cent, const cent_field_s *pField);
void CScr_GetIsDog(centity_t *cent, const cent_field_s *pField);
void CScr_GetIsBigDog(centity_t *cent, const cent_field_s *pField);
void CScr_PlayerJumpEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, int surfaceType, bool quiet, bool isLouder);
void CScr_PlayerLandEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, int surfaceType, bool quiet, bool damagePlayer, bool isLouder);
void CScr_PlayerFoliageEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, bool quiet);
void CScrCmd_GetThrottle(scr_entref_t entref);
void CScrCmd_GetBrake(scr_entref_t entref);
void CScrCmd_GetMaxSpeed(scr_entref_t entref);
void CScrCmd_GetSteering(scr_entref_t entref);
void CScrCmd_GetMaxReverseSpeed(scr_entref_t entref);
void CScrCmd_IsDriving(scr_entref_t entref);
void CScrCmd_IsLocalPlayerWeaponViewOnlyLinked(scr_entref_t entref);
void CScrCmd_IsLocalPlayerViewLinked(scr_entref_t entref);
void CScrCmd_IsLocalClientDriver(scr_entref_t entref);
void CScrCmd_GetLocalClientDriver(scr_entref_t entref);
void CScrCmd_GetWheelSurface(scr_entref_t entref);
void CScrCmd_IsWheelSliding(scr_entref_t entref);
void CScrCmd_IsWheelColliding(scr_entref_t entref);
void CScrCmd_GetLocalGunnerAngles(scr_entref_t entref);
void CScrCmd_SetStunned(scr_entref_t entref);
void CScr_IsInVehicle();
void CScr_IsXenon();
void CScr_GetSurfaceStrings();
void CScr_FindStaticModelIndex();
void CScr_HideStaticModel();
void CScr_UnhideStaticModel();
void CScr_GetFootstepStrings();
void CScrCmd_IsVehiclePeelingOut(scr_entref_t entref);
void CScr_line();
void CScr_box();
void CScr_PixBeginEvent();
void CScr_debugstar();
void CScr_GetMaxLocalClients();
void CScr_GetActiveLocalClients();
void CScr_LocalClientActive();
void CScr_IsSplitScreenHost();
void CScr_IsSplitScreen();
void CScr_StopBink();
void CScr_GetBinkLength();
void CScr_IsBinkFinished();
void CScr_FxParamError(LocalClientNum_t localClientNum, int paramIndex, const char *errorString, int fxId);
void CScr_SetFxAngles(int givenAxisCount, vec3_t *axis, vec3_t *angles);
unsigned int CScr_PlayFXInternal(LocalClientNum_t localClientNum, int fxId, vec3_t *angles, vec3_t *pos, int time, float primaryLightFraction, int lightingOriginOffset);
void CScr_PlayFX();
void CScr_StopFX();
void CScr_IsFXPlaying();
void CScr_DisableImpactMarks();
void CScr_EnableImpactMarks();
void CScr_GetGenericEnt(LocalClientNum_t localClientNum, int offset, const char *pName);
;
void CScrCmd_IsAlive(scr_entref_t entref);
void CScr_GetEntByNum();
void CScr_GetEntArray();
void CScr_GetLocalPlayers();
void CScr_GetLocalPlayer();
void CScr_GetNonPredictedLocalPlayer();
void CScr_PrecacheRumble();
void CScr_PlayRumbleOnPosition_Internal();
;
char CScr_TracePoint();
void CScr_OpenFile();
void CScr_CloseFile();
void CScr_FPrint_internal(bool commaBetweenFields);
void CScr_FPrintln();
void CScr_FPrintFields();
void __thiscall CScr_FReadLn(const char *this);
void CScr_FGetArg();
void CScr_SetUI3DTextureWindow();
void CScr_GetWeaponModel();
void CScr_CreateNewArray();
void CScr_ArrayRemoveValue();
void CScr_ArrayRemoveIndex();
void CScr_ArrayInsert();
void CScr_ArrayCombine();
void CScr_ArrayCopy();
void CScr_IsInArray();
void CScr_SessionModeIsOnlineGame();
void CScr_SessionModeIsPrivateOnlineGame();
void CScr_SessionModeIsPrivate();
void CScr_SessionModeIsSystemlink();
void CScr_SessionModeIsZombiesGame();
void CScr_GameModeIsMode();
void CScr_GameModeIsUsingXP();
void CScr_GameModeIsUsingStats();
void CScr_TriggerFX();
char CScr_VisionSetNaked();
bool CScr_VisionSetNakedLerp();
void CScr_GetVisionSetNaked();
void CScr_SetRippleWave();
void CScr_Project2DTo3D(unsigned int a1);
void CScr_ForwardRotateAroundUpByAngle();
int CScr_ScriptCallbackOnFootstepEvent();
char *CScr_UseFootstepTable();
char *CScr_UseFootstepFXTable();
char CScr_FootstepDoNothing();
char CScr_FootstepDoEverything();
void CScr_FootstepDoSound();
void CScr_FootstepDoFootstepFX();
void CScr_SetDemoLockOnValues();
void CScr_TableLookupFindCoreAsset();
void CScr_TableLookupRowNum();
void CScr_TableLookupColumnForRow();
void CScr_TableLookup();
void CScr_TableLookupIString();
void BG_EvalVehicleName();
void CScr_CreateQRCode();
void CScr_DeleteQRCode();
void CScr_ForceAmbientRoom();
void CScr_ForceAmbientPackage();
void CScr_SetAmbientPackage();
void CScr_SetAmbientRoomContext();
void CScr_RopePulse();
void CScr_SetForceNotSimple(scr_entref_t entref);
void CScrCmd_GetCamPosByLocalClientNum();
void CScrCmd_GetCamAnglesByLocalClientNum();
void CScrCmd_DemoIsAnyFreeMoveCamera();
void CScrCmd_DemoIsMovieCamera();
void CScrCmd_DemoIsEditCamera();
void CScrCmd_DemoIsDollyCamera();
void CScrCmd_GetScreenWidth();
void CScrCmd_GetScreenHeight();
void (*CScr_GetFunction(const char **pName, int *type, int *min_args, int *max_args))();
;
void CScrCmd_SetModel(scr_entref_t entref);
void CScrCmd_SetScale(scr_entref_t entref);
void CScr_Attach(scr_entref_t entref);
void CScrCmd_GetSpeed(scr_entref_t entref);
void CScrCmd_GetStance();
void CScrCmd_GetWeaponPosFrac();
void CScrCmd_GetEntNum(scr_entref_t entref);
void CScrCmd_GetEntityNumber(scr_entref_t entref);
void CScrCmd_MakeLight(scr_entref_t entref);
void CScr_GetLightColor(scr_entref_t entref);
void CScr_SetLightColor(scr_entref_t entref);
void CScr_GetLightIntensity(scr_entref_t entref);
void CScr_SetLightIntensity(scr_entref_t entref);
void CScr_GetLightRadius(scr_entref_t entref);
void CScr_SetLightRadius(scr_entref_t entref);
void CScr_GetLightFovInner(scr_entref_t entref);
void CScr_GetLightFovOuter(scr_entref_t entref);
void CScr_SetLightFovRange(float entref, scr_entref_t entref_4);
void CScr_GetLightExponent(scr_entref_t entref);
void CScr_SetLightExponent(scr_entref_t entref);
void CScr_MakeLightSlave(scr_entref_t entref);
void CScrCmd_PlayRumbleOnEntity_Internal(scr_entref_t entref, int event);
void CScrCmd_PlayRumbleOnEntity(scr_entref_t entref);
void CScrCmd_PlayRumbleLoopOnEntity(scr_entref_t entref);
void CScrCmd_StopRumble(scr_entref_t entref);
void CScrCmdGetCommandTimes(float *pfTotalTime, float *pfAccelTime, float *pfDecelTime);
void CScriptMover_SetupMove(cg_t *cgameGlob, trajectory_t *pTr, const vec3_t *vPos, const float fTotalTime, const float fAccelTime, const float fDecelTime, vec3_t *vCurrPos, float *pfSpeed, float *pfMidTime, float *pfDecelTime, vec3_t *vPos1, vec3_t *vPos2, vec3_t *vPos3);
void CScriptMover_SetupMoveSpeed(cg_t *cgameGlob, trajectory_t *pTr, const vec3_t *vSpeed, const float fTotalTime, const float fAccelTime, const float fDecelTime, vec3_t *vCurrPos, float *pfSpeed, float *pfMidTime, float *pfDecelTime, vec3_t *vPos1, vec3_t *vPos2, vec3_t *vPos3);
void CScriptMover_MoveGravity(cg_t *cgameGlob, trajectory_t *pTr, const vec3_t *velocity, const float fTotalTime, vec3_t *vCurrPos);
void CScrCmd_MoveGravity(scr_entref_t entref);
void CScrCmd_MoveTo(scr_entref_t entref);
void CScrEnt_MoveAxis(scr_entref_t entref, int iAxis);
void CScrEntCmd_MoveX(scr_entref_t entref);
void CScrEntCmd_MoveY(scr_entref_t entref);
void CScrEntCmd_MoveZ(scr_entref_t entref);
void CScriptEnt_RotateAxis(scr_entref_t entref, int iAxis);
void CScrCmd_RotatePitch(scr_entref_t entref);
void CScrCmd_RotateYaw(scr_entref_t entref);
void CScrCmd_RotateRoll(scr_entref_t entref);
void CScrCmd_RotateTo(scr_entref_t entref);
;
void CScr_StartPoisoning(scr_entref_t entref);
void CScr_StopPoisoning(scr_entref_t entref);
void CScr_IsPoisoned(scr_entref_t entref);
void CScrCmd_GetCamPos(scr_entref_t entref);
void CScrCmd_GetCamAngles(scr_entref_t entref);
void CScr_UseAnimTree(scr_entref_t entref);
XAnimTree_s *CScr_GetEntAnimTree(centity_t *ent);
void CScr_HasAnimTree(scr_entref_t entref);
void CScr_ClearAnim(scr_entref_t entref);
void CScr_ClearAnimLimited(scr_entref_t entref);
void CScr_HandleAnimError(int error);
void CScr_SetAnimKnobInternal(scr_entref_t entref, unsigned int flags, bool bFlagged);
void CScr_SetAnimKnob(scr_entref_t entref);
void CScr_SetAnimKnobLimited(scr_entref_t entref);
void CScr_SetAnimKnobRestart(scr_entref_t entref);
void CScr_SetAnimKnobLimitedRestart(scr_entref_t entref);
void CScr_SetAnimKnobAllInternal(scr_entref_t entref, unsigned int flags, bool bFlagged);
void CScr_SetAnimKnobAll(scr_entref_t entref);
void CScr_SetAnimKnobAllLimited(scr_entref_t entref);
void CScr_SetAnimKnobAllRestart(scr_entref_t entref);
void CScr_SetAnimKnobAllLimitedRestart(scr_entref_t entref);
void CScr_SetAnimInternal(scr_entref_t entref, unsigned int flags, __int16 bFlagged, bool scripted);
void CScr_SetAnim(scr_entref_t entref);
void CScr_SetAnimLimited(scr_entref_t entref);
void CScr_SetAnimRestart(scr_entref_t entref);
void CScr_SetAnimLimitedRestart(scr_entref_t entref);
void CScr_SetFlaggedAnim(scr_entref_t entref);
void CScr_SetFlaggedAnimLimited(scr_entref_t entref);
void CScr_SetFlaggedAnimRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimLimitedRestart(scr_entref_t entref);
void CScr_AnimScripted(scr_entref_t entref);
void CScr_AnimFlaggedScripted(scr_entref_t entref);
void CScr_SetFlaggedAnimKnob(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobLimited(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobLimitedRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobAll(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobAllRestart(scr_entref_t entref);
void CScr_AnimGetChildAt(scr_entref_t entref);
void CScr_AnimGetNumChildren(scr_entref_t entref);
void CScr_GetAnimTime(scr_entref_t entref);
void CScr_GetAnimCurrFrameCount(scr_entref_t entref);
void CScr_SetAnimTime(scr_entref_t entref);
void CScr_SetEntityAnimRate(scr_entref_t entref);
void CScr_GetEntityAnimRate(scr_entref_t entref);
void CScrCmd_IsPlayer(scr_entref_t entref);
void CScrCmd_IsLocalPlayer(scr_entref_t entref);
void CScrCmd_IsAI(scr_entref_t entref);
void CScr_HasDObj(scr_entref_t entref);
void CScr_SetCompassIcon(scr_entref_t entref);
void CScrCmd_IsSplitScreenHost(scr_entref_t entref);
void CScrCmd_UnderWater(scr_entref_t entref);
void CScrCmd_LinkTo(scr_entref_t entref);
void CScrCmd_Unlink(scr_entref_t entref);
void CScr_Map_Material(scr_entref_t entref);
void CScr_Set_Filter_Pass_Material(scr_entref_t entref);
void CScr_Set_Filter_Pass_Enabled(scr_entref_t entref);
void CScr_Set_Filter_Pass_Quads(scr_entref_t entref);
void CScr_Set_Filter_Pass_Constant(scr_entref_t entref);
void CScr_Set_Filter_Bit_Flag(scr_entref_t entref);
void CScr_Set_Overlay_Material(scr_entref_t entref);
void CScr_Set_Overlay_Constant(scr_entref_t entref);
void CScr_SetInfraredVisionset(scr_entref_t entref);
void CScr_SetSonarEnabled(scr_entref_t entref);
void CScr_ForceInfraredMaterialsStreaming(scr_entref_t entref);
void CScr_Set_Overlay_Enabled(scr_entref_t entref);
void CScr_LaunchRagdoll(scr_entref_t entref);
void CScr_Show(scr_entref_t entref);
void CScr_Hide(scr_entref_t entref);
void CScrCmd_GetEye(scr_entref_t entref);
void CScrCmd_GetEyeApprox(scr_entref_t entref);
void CScrCmd_GetLocalClientNumber(scr_entref_t entref);
void CScr_MapShaderConstant(scr_entref_t entref);
void CScr_SetShaderConstant(scr_entref_t entref);
void CScr_MakeMixerLight(scr_entref_t entref);
void CScr_ActivateMixer(scr_entref_t entref);
int CG_GetMixerLightSide(int param);
void CScr_SetMixerLightModels(scr_entref_t entref);
void CScr_SetMixerSpinModels(scr_entref_t entref);
void CScr_SetMixerLightBehavior(scr_entref_t entref);
void CScr_SetMixerExploderId(scr_entref_t entref);
void CScr_SetMixerBehavior(scr_entref_t entref);
void CScr_SetMixerLightParam(scr_entref_t entref);
void CScr_SetMixerParam(scr_entref_t entref);
void CScr_SetMixerL2RRampSpeed(scr_entref_t entref);
void CScr_SetMixerR2LRampSpeed(scr_entref_t entref);
void CScr_SetMixerLightRotateTime(scr_entref_t entref);
void CScr_SetMixerLightIntensity(scr_entref_t entref);
void CScr_SetMixerLightColor(scr_entref_t entref);
void CScr_SetMixerLightExponent(scr_entref_t entref);
void CScr_SetMixerLightRadius(scr_entref_t entref);
void CScr_SetMixerLightFovRange(scr_entref_t entref);
team_t GetTeam(centity_t *cent);
void CScr_GetTeamName(centity_t *cent, const cent_field_s *pField);
void CScr_GetPlayerName(centity_t *cent, const cent_field_s *pField);
void CScrCmd_GetCharacterIndex(scr_entref_t entref);
void CScr_SetMaterialOverride(scr_entref_t entref);
void CScr_ClearMaterialOverride(scr_entref_t entref);
void CScr_SetStepTriggerSound(scr_entref_t entref);
void CScr_ClearStepTriggerSound(scr_entref_t entref);
void CScr_GetMovementType(scr_entref_t entref);
void CScr_IsInsideHeightLock(scr_entref_t entref);
void CScr_SetAmbientTrigger(scr_entref_t entref);
void CScr_SoundSetAmbientState(const char *roomName, const char *packageName, centity_t *roomColliderCent, centity_t *packageColliderCent, bool defaultRoom);
void CScr_SoundPlayUiDecodeLoop(const char *decodeString, const int playTimeMs);
void CScr_IsGrenadeDud(scr_entref_t entref);
void (*CScr_GetMethod(const char **pName, int *type, int *min_args, int *max_args))(scr_entref_t);
void CScr_LoadLevel(bool bPrecacheGameType);
void CScr_FreeScripts();
unsigned int CG_SetEntityScriptVariableInternal(const char *key, const char *value);
unsigned int CG_SpawnStruct(const SpawnVar *spawnVar);
void CG_SpawnNode();
void CScr_GlassSmash(const vec3_t *pos, const vec3_t *dir);
void CScr_BuildClientsideAITypeList(bool bRestarting);
void CScr_GetPlayerFootstepTables();
void *CScr_LoadEntityscriptAlloc(int size);
void CScr_LoadEntityScripts();
void *CScr_SetupClientZBarrierIndicesAlloc(int size);
void CScr_SetupClientZBarrierIndices();
int CScr_UpdateTagInternal(centity_t *ent, unsigned int tagName, cached_tag_mat_t *cachedTag, int showScriptError);
void CScr_LoadStructs();
unsigned __int16 CScr_ExecEntThread(centity_t *ent, int handle, unsigned int paramcount);
;
void CG_DoTouchTriggers(centity_t *ent, LocalClientNum_t localClientNum);
void CScr_GetField(centity_t *ent, cent_field_s *fieldarray, unsigned int offset);
void CScr_GetEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_SetField(centity_t *ent, cent_field_s *fieldarray, unsigned int offset);
int CScr_SetEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_GetObjectField(unsigned int classnum, int entnum, LocalClientNum_t clientNum, int offset);
;
void CScr_PostLoadScripts();
unsigned int CScr_GetFakeEntity(LocalClientNum_t localClientNum);
void CScr_SpawnFakeEnt();
centity_t *CScr_SetFakeEntOrg();
int CScr_PlayLoopedFX();
void CScr_PlayLoopSound();
unsigned int CScr_StopLoopSound();
void firecaster_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void fire_flicker_internal(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void fire_flicker_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void flickerthenstop_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void explode_then_flicker_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void electrical_flicker_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void generic_strobe_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void generic_double_strobe_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void light_off_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void generic_pulsing_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void television_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
void generic_flickering_light_behavior(_mixerLight_t *pMixer, _lightParams_t *pParams, const cg_t *cgameGlob, bool bDominant);
;
void CG_RunMixerLights(float a1);
void CScr_SpawnPlane();
;
void CScrCmd_Delete(scr_entref_t entref);
void CScrCmd_SetViewModelRenderFlag(scr_entref_t entref);
void CScrCmd_ForceDelete(scr_entref_t entref);
void CScrCmd_GetVelocity(unsigned int a1, scr_entref_t entref);
void CScrCmd_IsTouching(scr_entref_t entref);
void CG_FreeEntityDelay(centity_t *ed);

//#include "cgame/cg_scr_main.h"

//t6/code/src_noserver/cgame/cg_shellshock.cpp
void CG_PerturbCamera(cg_t *cgameGlob);
void SaveScreenToBuffer(LocalClientNum_t localClientNum);
int CG_DrawShellShockSavedScreenBlendBlurred(LocalClientNum_t localClientNum, const shellshock_parms_t *parms, int start, int duration);
int CG_DrawShellShockSavedScreenBlendFlashed(LocalClientNum_t localClientNum, const shellshock_parms_t *parms, int start, int duration);
void EndShellShockSound(LocalClientNum_t localClientNum);
void EndShellShockLookControl(LocalClientNum_t localClientNum);
void EndShellShockCamera(LocalClientNum_t localClientNum);
void EndShellShockScreen(LocalClientNum_t localClientNum);
void EndShellShock(LocalClientNum_t localClientNum);
void UpdateShellShockSound(LocalClientNum_t localClientNum, const shellshock_parms_t *parms, int time, int duration);
void UpdateShellShockLookControl(LocalClientNum_t localClientNum, const shellshock_parms_t *parms, int time, int duration);
void UpdateShellShockCamera(LocalClientNum_t localClientNum, const shellshock_parms_t *parms, int time, int duration);
void UpdateShellShockVisionSet(LocalClientNum_t localClientNum, const shellshock_parms_t *parms, int time, int duration);
;
void CG_StartShellShock(cg_t *cgameGlob, const shellshock_parms_t *parms, int start, int duration);
bool CG_Flashbanged(LocalClientNum_t localClientNum);
bool CG_Flared(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_sound.cpp
void CG_RegisterSoundDvars();
void CG_ClearSoundPlaybackTracking();
bool CG_ShouldPlaySoundOnLocalClient(LocalClientNum_t localClientNum, int entitynum, const vec3_t *origin, unsigned int aliasname);
SndEntHandle CG_SndEntHandle(LocalClientNum_t localClientNum, int entIndex);
void CG_PlaySound(LocalClientNum_t localClientNum, int entitynum, const vec3_t *origin, int fadeMs, bool doNotify, float attenuation, unsigned int id);
void CG_PlaySound(LocalClientNum_t localClientNum, int entitynum, const vec3_t *origin, int fadeMs, bool doNotify, float attenuation, const char *name);
void CG_PlaySound(LocalClientNum_t localClientNum, const vec3_t *origin, int fadeMs, bool doNotify, float attenuation, const char *name);
int CG_PlaySoundWithHandle(LocalClientNum_t localClientNum, int entitynum, const vec3_t *origin, int fadeMs, bool doNotify, float volume, unsigned int id);
int CG_PlaySoundWithHandle(LocalClientNum_t localClientNum, int entitynum, const vec3_t *origin, int fadeMs, bool doNotify, float attenuation, const char *name);
void CG_FlushLoops();
void CG_PumpEntityLoopSound(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_PlayAnimScriptSoundAlias(ClientNum_t clientIndex, SndAliasList *aliasList);
void CG_SubtitlePrint(int msec, const char *subtitle);
void CG_SubtitleSndLengthNotify(int msec, const char *lengthNotifyData);
void CG_ScriptSndLengthNotify(int msec, int lengthNotifyData);
void CG_CopySoundEntityOrientation(LocalClientNum_t localClientNum, int entIndex, vec3_t *origin_out, vec3_t *axis_out);
unsigned int CG_SoundGetUseCount(const SndEntHandle sndEnt);
void CG_GetSoundEntityOrientation(const SndEntHandle sndEnt, vec3_t *origin_out, vec3_t *axis_out, vec3_t *velocity_out);
void CG_StopSoundAlias(LocalClientNum_t localClientNum, int entityNum, unsigned int aliasName);
void CG_SndFireReset();
void CG_SndUpdateFire();
void CG_FlameSourceUpdate(LocalClientNum_t localClientNum, int entityNum, const vec3_t *sourcePosition, const vec3_t *flamePosition, snd_flame_source_flags flags, const char *flameOffLoopSound, const char *flameIgniteSound, const char *flameOnLoopSound, const char *flameCooldownSound);
void CG_SoundWhizby(LocalClientNum_t localClientNum, const WeaponDef *weapDef, const vec3_t *shotPosition, const vec3_t *shotDirection, const vec3_t *position);
void CG_SndUpdate();
void CG_SoundUpdateListeners(LocalClientNum_t localClientNum);
void CG_GetLoopingSoundPosition(LocalClientNum_t localClientNum, centity_t *cent, vec3_t *sndOrigin);
void CG_UpdateLoopingFireSounds(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_CheckADSRaiseAndLower(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_Turret_UpdateTurretRotationSound(LocalClientNum_t localClientNum, centity_t *cent);
void CG_SoundForceAmbientRoomChange(bool forceChange, bool defaultRoom, unsigned int roomHash);
void CG_SoundForceAmbientPackageChange(bool forceChange, bool defaultPackage, unsigned int packageHash);
void CG_SoundInitAmbientColliders();
void CG_SoundSetAmbientData(const snd_ambient_script_data *ambData);
void CG_SoundSetAmbientContext(const unsigned int roomName, const char *ctxType, const char *ctxValue, const bool defaultRoom);
void CG_GetHighestPriorityRoomIndices(cg_t *cgameGlob, snd_ambient_collider *currentCollider);
void CG_SoundAmbientCheckOverrides(cg_t *cgameGlob, snd_ambient_collider *collider);
void CG_SoundUpdateAmbient();
void CG_StopZombieVoxSounds(LocalClientNum_t localClientNum, int entityNum);
bool CG_SoundEntInUse(const SndEntHandle sndEnt);
void CG_SndGameReset();

//t6/code/src_noserver/cgame/cg_spawn.cpp
const char *CG_GetEntityTypeName(centity_t *cent);
int CG_GetModelIndex(const char *name, LocalClientNum_t localClientNum);
void CScr_FreeFields(const cent_field_t *fields, unsigned __int8 *base);
void CScr_FreeEntityFields(centity_t *cent);
void CG_ParseEntityFields(LocalClientNum_t localClientNum, centity_t *ent, SpawnVar *spawnVar, int ignoreModel);
void CG_InitScriptMover(centity_t *cent);
bool CG_SetTriggerBrushModel(LocalClientNum_t localClientNum, centity_t *ent);
void CG_InitSentientTrigger(centity_t *self, int spawnflags);
bool CG_IsPositionInZeroGravity(const vec3_t *position);
void CG_PrintEntities(LocalClientNum_t localClientNum);
centity_t *CG_Spawn(LocalClientNum_t localClientNum);
void CG_Free(LocalClientNum_t localClientNum, int entNum);
void CG_ShutdownFakeEntities(LocalClientNum_t localClientNum);
bool CG_InitTrigger(LocalClientNum_t localClientNum, centity_t *self);
void CG_SP_trigger_multiple(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_once(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_radius(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_box(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_CallSpawn(LocalClientNum_t localClientNum, SpawnVar *spawnVar);
void CG_SpawnEntitiesFromString(LocalClientNum_t localClientNum);
void CG_InitFakeEntities(LocalClientNum_t localClientNum, bool spawnEntsFromMap);

//t6/code/src_noserver/cgame/cg_vehicle.cpp
cgVehicleTurretLoopState_t CG_VehicleComputeTurretRotationState(float angularVel, cgVehicle_t *vehicle);
void CG_Vehicle_UpdateTurretRotateSounds(LocalClientNum_t localClientNum, centity_t *cent);
bool CG_ShouldLockTurretToPlayerView(const centity_t *cent, const VehicleDef *info, const playerState_s *ps);
void CG_UpdateVehicleSoundOrigins(centity_t *cent, const DObj *obj);
void CG_InitAntenna(centity_t *cent, const DObj *obj);
int GetSoundInfoForVehicle(LocalClientNum_t localClientNum, const centity_t *cent, float *slideRate);
void CG_CrossFadeVehicleMaterialEffects(LocalClientNum_t localClientNum, const centity_t *cent, const VehicleDef *info, int groundEffectIndex, int surfType, float ratio, int fadeTime);
void CG_UpdateWheeledSurfaceSounds(LocalClientNum_t localClientNum, centity_t *cent, const VehicleDef *info, bool isLocalPlayersVehicle);
void CG_UpdateSurfaceSounds(LocalClientNum_t localClientNum, centity_t *cent, const VehicleDef *info, bool isLocalPlayersVehicle);
void CG_UpdateVehicleNotifies(LocalClientNum_t localClientNum, centity_t *cent);
char CG_VehicleOccupiedByPlayer(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Vehicle_GetSoundOriginForGun(centity_t *cent, int gunIndex, vec3_t *sndOrigin);
bool CircleLineIntersect(vec3_t *p1, vec3_t *p2, vec3_t *center, float radius, float *t0, float *t1);
bool CG_Vehicle_GetWheelBone(LocalClientNum_t localClientNum, const centity_t *cent, int wheelIndex, int *wheelBone);
void CG_Vehicle_GetBoneOrigin(LocalClientNum_t localClientNum, const centity_t *cent, int boneIndex, vec3_t *result);
int CG_Vehicle_GetVehicleDefIndex(const centity_t *cent);
const VehicleDef *CG_Vehicle_GetVehicleDef(const centity_t *cent);
bool CG_Vehicle_IsDefRemoteControl(int index);
bool CG_Vehicle_IsRemoteControl(const centity_t *cent);
BOOL CG_Vehicle_IsGunnerTurretFiring(const centity_t *cent, int gunnerIndex);
bool CG_Vehicle_IsGunFiring(const centity_t *cent, int gunIndex);
void CG_Vehicle_RegisterMaterials();
void CG_Vehicle_UpdateEngine(LocalClientNum_t localClientNum, centity_t *cent, const VehicleDef *info, float throttle);
void CG_Vehicle_UpdateMaterialTime(centity_t *cent, int dt, float speed);
void CG_VehicleDebug(centity_t *cent, const DObj *obj);
void CG_Vehicle_UpdateAntennas(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_Vehicle_UpdateMinigun(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_AllocClientVehicle(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_UpdateVehicleEngineSounds(LocalClientNum_t localClientNum, centity_t *cent, const VehicleDef *info, bool isPlayerVehicle, bool isLocalPlayersVehicle);
void CG_UpdateVehicleTags(centity_t *ent);
void CG_TriggerLoopingVehFire(LocalClientNum_t localClientNum, centity_t *cent, Weapon weapon, const WeaponDef *weaponDef, int gunIndex, const bool isPlayerControlled);
;
void CG_UpdateDriveBySounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateVehicleSounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Vehicle_Init();
void CG_Vehicle_SetupCollisionCache(cg_t *cgameGlob, centity_t *cent, bool uses_vehicle_cache);
void CG_Vehicle_PreControllersAir(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent, unsigned int *hidePartBits);
;
;

//t6/code/src_noserver/cgame/cg_vehicle_hud.cpp
void CG_TargetsChanged(LocalClientNum_t localClientNum, int num);
void CG_ParseAllTargets(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_visionsets.cpp
void CG_RegisterVisionSetsDvars();
const char *RawBufferOpen(const char *path, const char *backupPath);
bool ApplyTokenToField(int fieldNum, const char *token, visionSetVars_t *settings);
bool LoadVisionSettingsFromBuffer(const char *buffer, const char *filename, visionSetVars_t *settings);
bool LoadVisionFile(const char *name, visionSetVars_t *resultSettings);
bool GetVisionSet(LocalClientNum_t localClientNum, const char *name, visionSetVars_t *resultSettings);
bool LerpBool(bool from, bool to, float fraction, visionSetLerpStyle_t style);
int LerpInteger(int from, int to, const float fraction, visionSetLerpStyle_t style);
float LerpStepFloat(float from, float to, const float fraction, visionSetLerpStyle_t style);
float LerpFloat(float from, float to, float fraction, visionSetLerpStyle_t style);
;
;
bool CG_VisionSetStartLerp_To(LocalClientNum_t localClientNum, visionSetMode_t mode, visionSetLerpStyle_t style, const char *nameTo, int duration);
char CG_VisionSetLerp_To(const char *a1, char *a2, LocalClientNum_t localClientNum, visionSetMode_t mode, visionSetLerpStyle_t style, const char *nameTo, const char *nameFrom, float lerpFraction);
void SetDefaultVision(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_Naked(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_Night(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_LastStand(LocalClientNum_t localClientNum);
;
bool CG_InLastStandVision(const LocalClientNum_t localClientNum);
bool CG_InFlareVision(const LocalClientNum_t localClientNum);
char CG_LookingThroughNightVision(const LocalClientNum_t localClientNum);
void DrawVisionSetDebug(LocalClientNum_t localClientNum, visionSetMode_t curChannel);
void CG_VisionSetApplyToRefdef(LocalClientNum_t localClientNum, bool isExtracam);
void UpdateVarsLerpCustom(float lerpFraction, const visionSetVars_t *from, const visionSetVars_t *to, visionSetLerpData_t *lerpData, visionSetVars_t *result);
void UpdateVarsLerp(visionSetLerpStyle_t a1, int time, const visionSetVars_t *from, const visionSetVars_t *to, visionSetLerpData_t *lerpData, visionSetVars_t *result);
void CG_InitVisionSets(LocalClientNum_t localClientNum);
// void CG_VisionSetsUpdate(char *a1@<edi>, LocalClientNum_t localClientNum);
;
void CG_VisionSetUpdateTweaksFromFile_Film();
void CG_VisionSetUpdateTweaksFromFile_CharPrimary();
void CG_VisionSetUpdateTweaksFromFile_Bloom();

//t6/code/src_noserver/cgame/cg_weapons.cpp
void CG_RegisterWeaponDvars();
float GetWeaponAnimRate(LocalClientNum_t localClientNum, const Weapon weapon, XAnim_s *anims, int animIndex);
float GetWeaponAnimTimeFrac(LocalClientNum_t localClientNum, const Weapon weapon, XAnim_s *anims, int animIndex);
void StartWeaponAnim(LocalClientNum_t localClientNum, const Weapon weapon, DObj *obj, int animIndex, float transitionTime, int newPlayerstate);
;
void StopCameraAnim(DObj *obj);
void PlayIdleAnim(LocalClientNum_t localClientNum, const playerState_s *ps, ViewModelInfo *viewModelInfo, DObj *obj, Weapon weapon, float transitionTime, int newPlayerstate);
void PlayLeftIdleAnim(LocalClientNum_t localClientNum, const playerState_s *ps, ViewModelInfo *viewModelInfo, DObj *obj, Weapon weapon, float transitionTime, int newPlayerstate);
void PlayADSAnim(LocalClientNum_t localClientNum, float weaponPosFrac, Weapon weapon, DObj *obj, int animIndex, bool bIsAltScope);
bool CG_JavelinADS(LocalClientNum_t localClientNum);
bool CG_UICheckWeapLockBlink(LocalClientNum_t localClientNum, float blinkPerSec);
bool CG_UICheckWeapLockAttackTop(LocalClientNum_t localClientNum);
bool CG_UICheckWeapLockAttackDirect(LocalClientNum_t localClientNum);
int CheckForValidAnimIDDW(int animID);
void EnsureValidLeftAnim(LocalClientNum_t localClientNum, DObj *obj, ViewModelInfo *viewModelInfo, XAnimTree_s *pAnimTree, Weapon weapon, int newPlayerstate);
;
void CG_ResetWeaponAnimTrees(LocalClientNum_t localClientNum, const playerState_s *ps, int newPlayerstate);
int CG_WeaponDObjHandle(LocalClientNum_t localClientNum);
void CG_CreateWeaponViewModelXAnim(const char **animArray, const char **dwAnimArray, XAnim_s *pAnims);
Weapon RemoveAltAttachmentFromWeapon(const Weapon weapon);
void CG_CreateWeaponViewModelXAnimDefs(const Weapon weapon, const Weapon lastWeaponAltModeSwitch, ViewModelInfo *viewModelInfo);
void CG_SetWeaponHidePartBits(const Weapon weapon, ViewModelInfo *viewModelInfo, DObj *obj, int modelNum);
void CG_FreeWeapons(LocalClientNum_t localClientNum);
void CG_RegisterWeapon(LocalClientNum_t localClientNum, Weapon weapon);
bool ShouldRebuildTree(LocalClientNum_t localClientNum, const ClientPlayerWeaponInfo *weapInfo, Weapon weapon, unsigned __int8 weaponModel, XModel *newHands);
char ShouldRebuildAnims(LocalClientNum_t localClientNum, const ViewModelInfo *viewModelInfo, Weapon weapon);
void PlayViewmodelAdsAnim(ViewModelInfo *viewModelInfo, Weapon weapon, int animIndex);
;
bool ViewmodelRocketShouldBeAttached(LocalClientNum_t localClientNum, Weapon weapon);
XModel *CG_GetHandViewmodel(cg_t *cgameGlob);
void PlayNoteMappedSoundAliases(LocalClientNum_t localClientNum, const char *noteName, const WeaponDef *weapDef);
void ProcessWeaponNoteTracks(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState, bool isViewArms);
void CG_RegisterItems(LocalClientNum_t localClientNum);
void CalculateWeaponPostion_PositionToADS(cg_t *cgameGlob, playerState_s *ps);
void PlayWeaponFx(LocalClientNum_t localClientNum, int dobjHandle, const FxEffectDef *def, unsigned int flashTag, const vec3_t *offset, const vec3_t *offsetrot);
void WeaponFlash(LocalClientNum_t localClientNum, int dobjHandle, Weapon weapon, int bViewFlash, unsigned int flashTag);
void PlayWeaponContinuousFireFx(LocalClientNum_t localClientNum, int dobjHandle, Weapon weapon, unsigned int flashTag);
void CG_HoldBreathInit(cg_t *cgameGlob);
void HoldBreathUpdate(LocalClientNum_t localClientNum);
void ChargeShotUpdate(LocalClientNum_t localClientNum, const WeaponVariantDef *weapVariantDef, int chargeShotLevel);
void CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum);
void CG_UpdateMinigunTurretSounds(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent, const WeaponDef *weaponDef, float lastWeaponSpinSpeed, float minigunRotationSpeed);
void CG_UpdateJetgunSounds(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent, Weapon weapon, const WeaponDef *weaponDef);
void CG_UpdateMinigunSounds(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent, Weapon weapon, const WeaponDef *weaponDef);
void UpdateMinigunTag(cg_t *cgameGlob, centity_t *cent, const DObj *obj, unsigned __int16 name, int axis, int *partBits);
void UpdateJetgunDialTags(cg_t *cgameGlob, const playerState_s *ps, centity_t *cent, const DObj *obj, unsigned __int16 lname, unsigned __int16 rname, int axis, int *partBits);
void UpdateParalyzerDialTags(cg_t *cgameGlob, const playerState_s *ps, centity_t *cent, const DObj *obj, unsigned __int16 name1, unsigned __int16 name2, unsigned __int16 name3, int *partBits);
;
;
void CG_UpdateViewModelMinigun(cg_t *cgameGlob, const playerState_s *ps, DObj *obj, const Weapon weapon, centity_t *cent);
void CG_UpdateViewModelStackCounter(cg_t *cgameGlob, const playerState_s *ps, const DObj *obj, const Weapon weapon);
bool BulletTrace(LocalClientNum_t localClientNum, const BulletFireParams *bp, const WeaponDef *weapDef, const centity_t *attacker, BulletTraceResults *br, int lastSurfaceType, bool simulated);
bool IsEntityNotDoingClientSideBullets(LocalClientNum_t localClientNum, int entityNum);
bool CG_ShouldSimulateBulletFire(LocalClientNum_t localClientNum, BulletFireParams *bp);
bool CG_IsPlayerCrouching(clientInfo_t *ci, const centity_t *cent);
bool CG_IsPlayerADS(clientInfo_t *ci, const centity_t *cent);
void CG_GuessSpreadForWeapon(LocalClientNum_t localClientNum, const centity_t *cent, const WeaponDef *weapDef, float *minSpread, float *maxSpread);
void RandomBulletDir(unsigned int *randSeed, float *x, float *y);
void CG_BulletEndpos(unsigned int *randSeed, const float spread, const vec3_t *start, vec3_t *end, vec3_t *dir, const vec3_t *forwardDir, const vec3_t *rightDir, const vec3_t *upDir, const float maxRange, Weapon weapon, int shotIndex, int maxShotIndex);
char CG_GetPlayerVehicleViewOrigin_Internal(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
void CG_GetPlayer3rdPersonVehicleViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
char CG_GetPlayerVehicleViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
void CG_GetPlayerViewDirection(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *forward, vec3_t *right, vec3_t *up);
bool CG_ShowWeaponFx(const cg_t *cgameGlob, centity_t *cent, int bViewModel);
void CG_Hack_TouchPlayerWeaponBones(LocalClientNum_t localClientNum, const cg_t *cgameGlob, centity_t *cent);
void CG_SetSonarAttachmentShaderConstants(LocalClientNum_t localClientNum, ShaderConstantSet *constantSet);
void Weapon_DrawAxisOrigin(orientation_t orient, float colorScale);
void Weapon_DrawTagAxis(LocalClientNum_t localClientNum, int entityNum, Weapon weapon, int bViewModel);
void Anim_DrawTags(LocalClientNum_t localClientNum, int entityNum, Weapon weapon, cpose_t *pose, int flags);
bool UpdateViewmodelAttachments(LocalClientNum_t localClientNum, Weapon weapon, unsigned __int8 weaponModel, ClientPlayerWeaponInfo *weapInfo);
;
void CG_CalculateWeaponMovement_Landing(const cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_SaveOrigin(cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_Debug(const cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_SaveAngles(cg_t *cgameGlob, vec3_t *angles, GfxScaledPlacement *placement);
void CG_CalculateWeaponMovement_ClientSpecific(cg_t *cgameGlob, GfxScaledPlacement *placement, vec3_t *angles);
void CG_BuildWeaponState(cg_t *cgameGlob, weaponState_t *ws);
void CG_SaveWeaponState(const weaponState_t *ws, cg_t *cgameGlob);
Weapon NextWeapInCycle(LocalClientNum_t localClientNum, const playerState_s *ps, weapInventoryType_t type, Weapon startWeapon, bool cycleForward, bool skipEmpties);
Weapon CG_GetLastWeaponForAlt(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
Weapon CG_GetAltWeapon(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
Weapon CG_AltWeaponToggleIndex(LocalClientNum_t localClientNum, const cg_t *cgameGlob, Weapon *primaryWeapon);
bool ShouldToggleWeaponAltMode(LocalClientNum_t localClientNum, const playerState_s *ps);
int CG_GetBrassTagForEvent(int event);
void CG_EjectWeaponBrass(LocalClientNum_t localClientNum, const entityState_s *ent, Weapon weapon, int tagName, bool leftHand, bool lastShot);
void CG_VehicleJolt(centity_t *cent, vec3_t *origin, vec3_t *dir);
void CG_VehicleFire(centity_t *cent, const unsigned __int16 tagName);
bool CG_FireWeapon_LocalPlayerUsingVehicleWeapon(centity_t *cent, const playerState_s *ps, int event);
void CG_FireWeapon_VehicleFire(LocalClientNum_t localClientNum, centity_t *cent, const playerState_s *ps, const Weapon weapon, int event);
void CG_FireWeapon_OriginAndDirection(LocalClientNum_t localClientNum, centity_t *cent, const unsigned __int16 tagName, bool useViewModelDObj, vec3_t *origin, vec3_t *direction);
void SetWeaponFxFlags(centity_t *cent, bool leftGun, bool shellEject, bool lastShot);
void CG_FireWeapon_Rumble(LocalClientNum_t localClientNum, const entityState_s *ent, const Weapon weapon, bool isPlayerView, bool playerUsingVehicleWeapon);
void CG_HideVisibleAmmo(LocalClientNum_t localClientNum, centity_t *cent, const Weapon weapon);
void CG_SndWeaponFakeFire(snd_weapon_shot *shot, const WeaponDef *weaponDef);
void CG_SndWeaponFire(snd_weapon_shot *shot);
void CG_SndAutoSimReset();
void CG_SndPingAutoSim(snd_weapon_shot *shot);
void CG_SndKillAutoSimEnt(SndEntHandle ent);
void CG_SndUpdateAutoSim(float a1);
void CG_WeaponFireSingle(LocalClientNum_t localClientNum, SndEntHandle shooter, Weapon weapon, bool shooterIsPlayer, bool shooterIsLocalPlayer, bool leftGun, bool isLastShotInClip, const vec3_t *origin, const vec3_t *direction, unsigned int tagName, bool doubleTap, bool scriptedWeaponFire, bool firstShotOfBurst);
void CG_WeaponFireFake(LocalClientNum_t localClientNum, SndEntHandle shooter, Weapon weapon, const vec3_t *origin, const vec3_t *direction, int count);
void CG_PullBackWeapon(LocalClientNum_t localClientNum, const centity_t *cent, Weapon weapon, bool isPlayerView);
cg_t *CG_GetLocalClientGlobalsForEnt(LocalClientNum_t localClientNum, int entityNum);
void CG_GetViewDirection(LocalClientNum_t localClientNum, int entityNum, vec3_t *forward, vec3_t *right, vec3_t *up);
void CG_CalcEyePoint(LocalClientNum_t localClientNum, int entityNum, vec3_t *eyePos);
void CalcMuzzlePoint(LocalClientNum_t localClientNum, int entityNum, vec3_t *muzzle, unsigned int flashTag);
void CG_RandomEffectAxis(const vec3_t *forward, vec3_t *left, vec3_t *up);
void CG_ImpactEffectForWeapon(Weapon weapon, int surfType, int impactFlags, const FxEffectDef **outFx, unsigned int *outSnd);
centity_t *CG_BulletHitEvent_FindPlayerCorpse(LocalClientNum_t localClientNum, centity_t *player);
bool CG_BulletHitDeployedDeployedRiotshield(LocalClientNum_t localClientNum, int targetEntityNum, const vec3_t *position, int surfType);
void CG_DogBloodEvent(LocalClientNum_t localClientNum, int entnum, vec3_t *position, int boneIndex);
// void CG_DeployRiotshieldEvent(char *a1@<edi>, LocalClientNum_t localClientNum);
bool CalcViewmodelHitPos(LocalClientNum_t localClientNum, unsigned int eventParm, vec3_t *resultPos, vec3_t *resultNormal);
void CG_ViewmodelShieldHitStore(LocalClientNum_t localClientNum, unsigned int eventParm, bool damaged);
void CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum);
// void CG_BulletHitClientShieldEvent(char *a1@<edi>, LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon weapon, int surfType, int event, unsigned int eventParm);
// void CG_ExplosiveImpactOnShieldEvent(char *a1@<edi>, LocalClientNum_t localClientNum);
void CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage);
void CG_MeleeBloodEvent(LocalClientNum_t localClientNum, const centity_t *cent, int eventParm);
void CG_MeleeSwipeEvent(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_SetBaseWeaponForStats(const WeaponVariantDef *weapVariantDef);
void CG_SetupWeaponDef();
Weapon ValidLatestPrimaryWeapon(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
char CG_ClearLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
bool CG_SetLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon altWeapon, Weapon weapon);
bool CG_UpdateLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon oldweapon, Weapon weapon);
void CG_SelectWeaponIndex(LocalClientNum_t localClientNum, const playerState_s *ps, Weapon weapon);
void CG_SelectWeaponIndex(LocalClientNum_t localClientNum, Weapon weapon);
void CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum);
Weapon CG_GetPlayerTurretWeapon(LocalClientNum_t localClientNum);
Weapon CG_GetPlayerVehicleWeapon(const playerState_s *ps, const LocalClientNum_t localClientNum);
Weapon CG_GetPlayerMeleeWeapon(const playerState_s *ps);
Weapon CG_GetPlayerWeapon(const playerState_s *ps, const LocalClientNum_t localClientNum);
Weapon CG_GetClientWeapon(ClientNum_t clientNum, const LocalClientNum_t localClientNum);
bool CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum);
bool CG_PlayerUsingMouseToControlVehicle(LocalClientNum_t localClientNum);
bool CG_PlayerUsingHandbrakeInVehicle(LocalClientNum_t localClientNum);
float CG_GetPlayerVehicleHandbrakeTurnSpeedValue(LocalClientNum_t localClientNum);
void CG_ApplyWeaponTurnRateCap(LocalClientNum_t localClientNum);
void CG_MolotovFloat(LocalClientNum_t localClientNum, const centity_t *cent, const entityState_s *es);
Material *CG_GetWeaponOverlay(LocalClientNum_t localClientNum, Weapon weapon);
BOOL CG_IsInGuidedMissile(const playerState_s *ps);
int CG_IsInRemoteKillstreakStatic(const playerState_s *ps);
int CG_AirburstLazeCancelledByMovement(float forwardMove, float rightMove, float pitchMove, float yawMove, float moveScale);
void CG_CheckForAirburstReset(cg_t *cgameGlob, const playerState_s *ps);
BOOL CG_IsClientControlledMissile(LocalClientNum_t localClientNum);
BOOL CG_IsAirborneKillstreak(LocalClientNum_t localClientNum);
Weapon CG_GetWeaponForName_Internal(const char *name);
Weapon CG_GetWeaponForName(const char *name);
DroppedWeaponDobjInfo *CG_AllocDroppedWeaponDobjInfo(LocalClientNum_t localClientNum, centity_t *cent);
void CG_FreeDroppedWeaponDobjInfo(LocalClientNum_t localClientNum, centity_t *cent);
int AddViewmodelWeaponAttachments(const playerState_s *ps, Weapon weapon, const WeaponVariantDef *currentWeapVariantDef, DObjModel_s *dobjModels, int mdlIdx, const unsigned __int16 boneIndex, bool inADS, WeaponDobjInfo *weaponDobjInfo);
void ChangeViewmodelDobj(LocalClientNum_t localClientNum, const playerState_s *ps, Weapon weapon, unsigned __int8 weaponModel, XModel *newHands, XModel *newGoggles, XModel *newRocket, bool updateClientInfo, bool forceRebuildTree, bool inADS);
;
void CG_UpdateWeaponAndHandViewmodels(LocalClientNum_t localClientNum);
void CG_UpdateMinigunSpin(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
char CG_GetPlayerViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
char CG_PrepFireParams(LocalClientNum_t localClientNum, centity_t *ent, const unsigned __int16 boneName, const playerState_s *ps, Weapon weapon, int event, bool isPlayer, BulletFireParams *bp, vec3_t *tracerStart, int *shotCount, float *range, orientation_t *orient, vec3_t *origin, float *aimSpreadAmount, int *ignoreEntity);
Weapon CG_GetWeaponDefBasedOnNumberOfBullets(const cg_t *cgameGlob, int numBulletsQueued, Weapon weapon);
void CG_AddPlayerWeaponFx(centity_t *a1, LocalClientNum_t localClientNum, const playerState_s *ps, centity_t *cent, Weapon weapon, int bViewModel, int bDrawGun);
void CG_AddPlayerWeapon(LocalClientNum_t localClientNum, const GfxScaledPlacement *placement, const playerState_s *ps, centity_t *cent, int bDrawGun);
void CG_AddViewWeapon(LocalClientNum_t localClientNum);
bool CG_CancelOffhand(cg_t *cgameGlob);
bool WeaponCycleAllowed(cg_t *cgameGlob);
char VerifyPlayerAltModeWeapon(LocalClientNum_t localClientNum, Weapon weapon);
void CG_SwitchToLastValidPrimary(LocalClientNum_t localClientNum);
char CycleWeapPrimary(LocalClientNum_t localClientNum, int cycleForward, int bIgnoreEmpty);
void CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleForward);
char ToggleWeaponAltMode(LocalClientNum_t localClientNum, bool adsOnly);
void CG_AdsAltWeaponDown(LocalClientNum_t localClientNum);
char CG_ActionSlot_SelectWeapon(const LocalClientNum_t localClientNum, Weapon weapon, bool checkMomentumCost);
void CG_FakeFireWeapon(LocalClientNum_t localClientNum, centity_t *cent, Weapon weapon, vec3_t *origin, int count);
void CG_BulletHitEvent_Internal(LocalClientNum_t localClientNum, int sourceEntityNum, int targetEntityNum, Weapon weapon, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, const vec3_t *seeThruDecalNormal, int surfType, int event, unsigned __int8 eventParam, int hitContents, unsigned __int8 boneIndex);
;
void CG_BulletHitClientEvent(LocalClientNum_t localClientNum, int sourceEntityNum, Weapon weapon, int hitEntityNum, const vec3_t *startPos, const vec3_t *position, int surfType, int event);
char CG_ScopeIsOverlayed(LocalClientNum_t localClientNum);
// int CG_GetAirburstMarkDistance(LocalClientNum_t localClientNum, playerState_s *ps, bitarray<64> *buttons, unsigned int *outDistance, int lazeCancelled);
void CG_WeaponMyChanges();
void CG_SimulateBulletFire_Effect(LocalClientNum_t localClientNum, int sourceEntityNum, int targetEntityNum, Weapon weapon, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, const vec3_t *seeThruDecalNormal, int surfType, int event, unsigned __int8 eventParam, int hitContents, unsigned __int8 boneIndex);
void CG_WeaponBounceShot(LocalClientNum_t localClientNum, Weapon weapon, BulletFireParams *incomingbp, BulletTraceResults *br, centity_t *attacker, bool drawTracer);
;
;
void CG_SimulateBullet(bullet_hit_info_t *results, const int max_results, int *num_results);
;
void __thiscall CG_NextWeapon_f(cg_t *this);
void __thiscall CG_PrevWeapon_f(cg_t *this);
void CG_OutOfAmmoChange(LocalClientNum_t localClientNum);
bool ActionSlotUsageAllowed(const cg_t *cgameGlob);
void CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot);
void CG_ActionSlotUp(LocalClientNum_t localClientNum);
char CG_SelectInventoryWeapon(const LocalClientNum_t localClientNum);
void TakeClipOnlyWeaponIfEmpty(LocalClientNum_t localClientNum, playerState_s *ps);
void CG_FireWeapon(LocalClientNum_t localClientNum, centity_t *cent, int event, int eventParm, const unsigned __int16 tagName, Weapon weapon, const playerState_s *ps, centity_t *leftGun);
;
void CG_FireVehicleWeapon(LocalClientNum_t localClientNum, centity_t *cent, int event, int eventParm, const unsigned __int16 tagName, Weapon weapon, const playerState_s *ps);

//t6/code/src_noserver/cgame/cg_weapon_attachments.cpp
bool CG_RangeFinderEnabled(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
bool CG_RangeFinderChangeColor(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_InitRangeFinderParameters(LocalClientNum_t localClientNum);
;
unsigned int CG_DrawRangefinderHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawBallisticCpuHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawTacticalInsertionHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawBriefcaseBombHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawPDAHackerHUD(LocalClientNum_t localClientNum);
void CG_DrawWeaponDynamicTextures(LocalClientNum_t localClientNum);
;

//t6/code/src_noserver/cgame/cg_weapon_utils.cpp
unsigned __int16 G_GetWeaponAttachBone(clientInfo_t *ci, weapType_t weapType, weapInventoryType_t invType);
unsigned __int16 CG_AttachWeaponWorldModel(DObjModel_s *dobjModels, unsigned __int16 numModels, clientInfo_t *ci, bool hideClip);

//t6/code/src_noserver/cgame/cg_world.cpp
int CG_GetEntityBModelContents(const centity_t *cent);
void CG_GetEntityDobjBounds(const centity_t *cent, const DObj *dobj, vec3_t *mins, vec3_t *maxs, vec3_t *absMins, vec3_t *absMaxs);
int CG_GetEntityDObjContents(const centity_t *cent, const DObj *dobj);
bool CG_EntityHasCollision(const centity_t *cent, DObj *dobj);
bool CG_EntityNeedsLinked(LocalClientNum_t localClientNum, int entIndex);
void CG_UnlinkEntity(LocalClientNum_t localClientNum, int entIndex);
;
bool CG_EntityInArea(int entIndex, const vec3_t *mins, const vec3_t *maxs, int contentMask);
void CG_AreaEntities_r(unsigned __int16 sectorIndex, CEntityAreaParms *areaParms);
int CG_AreaEntities(const vec3_t *mins, const vec3_t *maxs, int *entityList, const int maxEntities, const int contentMask);
int cmpr(const void *e0, const void *e1);
int CG_GetEntityBoneInfo(int entID, int boneIndex, vec3_t *bonePos, vec3_t *boneAxis, const char **boneName);
void CG_GetEntityBModelBounds(int a1, const centity_t *cent, vec3_t *mins, vec3_t *maxs, vec3_t *absMins, vec3_t *absMaxs);
void CG_LinkEntity(LocalClientNum_t localClientNum, int entIndex);
void CG_ClipMoveToEntity(const moveclip_t *clip, int entIndex, trace_t *results);
void CG_ClipMoveToEntities_r(const moveclip_t *clip, unsigned __int16 sectorIndex, const vec4_t *p1, const vec4_t *p2, trace_t *results);
void CG_ClipMoveToEntities(const moveclip_t *clip, trace_t *results);
void CG_PointTraceToEntity(const pointtrace_t *clip, int entIndex, trace_t *results);
void CG_PointTraceToEntities_r(const pointtrace_t *clip, unsigned __int16 sectorIndex, const vec4_t *p1, const vec4_t *p2, trace_t *results, col_context_t *context);
void CG_PointTraceToEntities(const pointtrace_t *clip, trace_t *results, col_context_t *context);
;
void CG_LocationalTrace(trace_t *results, const vec3_t *start, const vec3_t *end, int passEntityNum, int contentMask, bool checkRopes, col_context_t *context);
;
;
void CG_TraceCapsule(int a1, trace_t *results, const vec3_t *start, const vec3_t *mins, const vec3_t *maxs, const vec3_t *end, int passEntityNum, int contentMask, col_context_t *context);

//t6/code/src_noserver/cgame/offhandweapons.cpp
bool IsOffHandDisplayVisible(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
int CalcOffHandAmmo(const playerState_s *predictedPlayerState, int weaponType);
void OffHandFlash(const cg_t *cgameGlob, const vec4_t *base_color, vec4_t *out_color);
void CG_DrawOffHandHighlight(char *a1, LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color, Material *material, OffhandSlot weaponType);
void CG_DrawOffHandAmmo(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, const vec4_t *color, int textStyle, OffhandSlot weaponType);
void CG_DrawOffHandName(LocalClientNum_t localClientNum, const rectDef_s *rect, Font_s *font, float scale, const vec4_t *color, int textStyle, OffhandSlot weaponType);
void CG_PrepOffHand(LocalClientNum_t localClientNum, const entityState_s *ent, Weapon weapon, bool isPlayerView);
void CG_UseOffHand(LocalClientNum_t localClientNum, const centity_t *cent, Weapon weapon, bool isPlayerView);
void CG_SetEquippedOffHand(LocalClientNum_t localClientNum, Weapon offHandWeapon);
void CG_DrawOffHandIcon(LocalClientNum_t localClientNum, const rectDef_s *rect, const vec4_t *color, Material *material, OffhandSlot weaponType);
void CG_SwitchOffHandCmd(LocalClientNum_t localClientNum);

