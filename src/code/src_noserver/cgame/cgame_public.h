#pragma once

#include "types.h"

//t6/code/src_noserver/cgame/cg_ammocounter.cpp
void CG_AmmoCounterRegisterDvars();
void GetBaseRectPos(LocalClientNum_t localClientNum, const rectDef_s *rect, vec2_t *base);
Weapon GetWeaponAltIndex(const cg_t *cgameGlob, Weapon weapon);
void AmmoColor(cg_t *cgameGlob, vec3_t *color, Weapon weapon);
float AmmoCounterFadeAlpha(LocalClientNum_t localClientNum, cg_t *cgameGlob);
void DrawClipAmmoMagazine(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoShortMagazine(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoShotgunShells(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoRockets(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmoBeltfed(cg_t *cgameGlob, const vec2_t *base, Weapon weapon, vec4_t *color);
void DrawClipAmmo(;
void CG_DrawAmmoCounterSingle(LocalClientNum_t localClientNum, rectDef_s *rect, vec4_t *color, bool last);
void CG_DrawPlayerWeaponAmmoStock(;
void CG_DrawFuelTankPercentage(;
void CG_DrawPlayerWeaponAmmoClip(;
void CG_DrawPlayerWeaponAmmoClipDualWield(;
void DpadIconDims(;
void DpadTextPos(;
bool ActionSlotIsActive(LocalClientNum_t localClientNum, unsigned int slotIdx);
float DpadFadeAlpha(LocalClientNum_t localClientNum, cg_t *cgameGlob);
// double CG_GetHudAlphaDPad@<st0>(cg_t *a1@<edx>, LocalClientNum_t a2@<ecx>, LocalClientNum_t localClientNum);
// double CG_GetHudAlphaAmmoCounter@<st0>(;
char CG_ActionSlotIsUsable(const LocalClientNum_t localClientNum, unsigned int slotIdx);
void CG_DrawPlayerActionSlotDpad(;
void CG_DrawPlayerActionSlotCarousel(;
void CG_DrawPlayerActionSlotBack(;
void CG_DrawPlayerActionSlotArrow(;
void CG_DrawPlayerActionSlot(;
void CG_DrawPlayerWeaponBackground(;
void CG_DrawPlayerWeaponAmmoClipGraphic(;
void CG_DrawPlayerWeaponAmmoClipGraphicDualWield(;
void DrawStretchPicGun(;
void CG_DrawPlayerWeaponIcon(;
void CG_DrawPlayerWeaponLowAmmoWarning(;

//t6/code/src_noserver/cgame/cg_bolt.cpp
void CG_InitBolt(LocalClientNum_t localClientNum);
void CG_UpdateBolt(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_camera.cpp
void InterpolateAnglesSmooth(;
void CG_StartCameraTween(LocalClientNum_t localClientNum, float tweenTime);
float CG_UpdateCameraTweenFOV(LocalClientNum_t localClientNum, float currentFov);
void CG_UpdateCameraTween(LocalClientNum_t localClientNum);
void CG_UpdateVehicleInitView(LocalClientNum_t localClientNum, CameraMode newMode);
void CG_SetSoundFutz(LocalClientNum_t localClientNum);
void CG_UpdateSoundFutz(LocalClientNum_t localClientNum, CameraMode newMode);
void CG_UpdateCameraTransition(;
int CG_RemapVehicleButton(LocalClientNum_t localClientNum, int *twokeys, int button, Bind_t vehicleBinding);
void CG_UpdateVehicleBindings(LocalClientNum_t localClientNum);
bool CG_RenderPlayerFromMissilePOV(LocalClientNum_t localClientNum);
bool CG_SpikeCameraViewActive(LocalClientNum_t localClientNum);
bool CG_ScriptedExtraCamActive(LocalClientNum_t localClientNum);
float CG_ScriptedExtraCamFov(LocalClientNum_t localClientNum);
char ShouldDoCameraTransition(cg_t *cgameGlob, CameraMode prevMode, CameraMode newMode, bool useTagCamera);
char ShouldDoThirdPersonVehicle(;
CameraMode CG_UpdateCameraMode(LocalClientNum_t localClientNum);
CameraMode CG_GetExtraCamMode(LocalClientNum_t localClientNum);
void CG_ApplyViewAnimation(LocalClientNum_t localClientNum);
bool CG_ShouldDefaultViewFov(LocalClientNum_t localClientNum);
float CG_GetWeaponViewFov(;
double CG_GetTurretViewFov(LocalClientNum_t localClientNum, const playerState_s *ps);
float CG_GetViewFov(LocalClientNum_t localClientNum, const playerState_s *forWeapon);
void CG_CalcFovInternal(;
void CG_CalcFov(LocalClientNum_t localClientNum, float fov_x);
void CG_CalculateGunnerOffset_Sway(;
;
void CG_GetExtraCamOrigin(LocalClientNum_t localClientNum, vec3_t *out);
void CG_CalcExtraCamViewValues(LocalClientNum_t localClientNum);
void RemoteEyesShake(cg_t *cgameGlob, centity_t *possessedEnt);
bool GetWeaponviewEyeValues(LocalClientNum_t localClientNum);
void CG_GetMissileViewOrigin(LocalClientNum_t localClientNum, vec3_t *out);
void CG_CalcScriptedExtraCamViewValues(LocalClientNum_t localClientNum);
// void CG_CalcMissileAngleValues(float a1@<esi>, LocalClientNum_t localClientNum);
long double CG_Player3rdPersonVehicle_GetPitchOffsetRelativeToADirection(;
bool CG_Player3rdPersonVehicle_GetViewAngles(;
void CG_Player3rdPersonVehicle_GetLookAtPosition(;
float CG_Player3rdPersonVehicle_GetDampedSpringDistance(;
int CG_Get3rdPersonVehicleMask(int vehicleType);
void CG_OffsetVehicleView(LocalClientNum_t localClientNum, CameraMode camMode);
int CG_ScrCamActive(LocalClientNum_t localClientNum);
void CG_ScrCamCalcView(LocalClientNum_t localClientNum);
void CG_ExtraCamDebug_SetView(LocalClientNum_t localClientNum);
void CG_ExtraCamDebug_SaveView(LocalClientNum_t localClientNum);
// void CG_CalcFov_ExtraCam(float a1@<xmm0>, LocalClientNum_t localClientNum);
BOOL InScriptExtraCamDebugMode3();
void CG_ExtraCam_GetViewOrigin(LocalClientNum_t localClientNum, ExtraCamLodInfo *extraCamLodInfo);
void CG_UpdateScriptExtraCams(LocalClientNum_t localClientNum);
void CG_ResetScriptExtraCam(ScriptExtraCam *scriptExtraCam);
bool CG_ExtraCamIsActive(LocalClientNum_t localClientNum);
BOOL CG_IsUsingMultiExtraCam(LocalClientNum_t localClientNum);
// void __thiscall ExtraCamClientStateRestore::ExtraCamClientStateRestore(;
// void __thiscall ExtraCamClientStateRestore::~ExtraCamClientStateRestore(ExtraCamClientStateRestore *this);
void CG_GetClientExtraCamParms(LocalClientNum_t localClientNum, GfxExtraCamParms *extraCamParms);
void CG_CaptureCameraOffset(LocalClientNum_t localClientNum);
;
void CG_CalcMissileViewValues(LocalClientNum_t localClientNum);
bool CG_ShouldVehicleCamAutoRecenter(LocalClientNum_t localClientNum, const VehicleDef *info);
void CG_CalcVehicleViewValues(LocalClientNum_t localClientNum);
void CG_Calc3rdPersonVehicleViewValues(LocalClientNum_t localClientNum);
void CG_RadiantCamCalcView(LocalClientNum_t localClientNum);
char GetRemoteEyeValues(LocalClientNum_t localClientNum);
bool CG_CalcRemoteEyesViewValues(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_camerashake.cpp
void TRACK_cg_camerashake();
int CG_UpdateCameraShake(const cg_t *cgameGlob, CameraShake *shake);
void CG_StartShakeCamera(;
// void CG_ShakeCamera(CameraShake *a1@<edx>, const cg_t *a2@<ecx>, LocalClientNum_t localClientNum);
void CG_ClearCameraShakes(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_colltree.cpp
void TRACK_CG_CollWorld();
void CG_ClearEntityCollWorld(LocalClientNum_t localClientNum);
void CG_AddEntityToCollSector(LocalClientNum_t localClientNum, int entIndex, unsigned __int16 sectorIndex);
unsigned __int16 CG_AllocEntityCollSector(;
void CG_SortEntityCollSector(;
void CG_UnlinkEntityColl(LocalClientNum_t localClientNum, int entIndex);
void CG_LinkEntityColl(;

//t6/code/src_noserver/cgame/cg_compass.cpp
void CG_CompassRegisterDvars();
bool CG_IsSelectingLocation(LocalClientNum_t localClientNum);
void CG_ApplySplitScreenCompassScale(CompassType compassType, float *x, float *y, float *w, float *h);
bool CG_WorldPosToCompass(;
void CG_CompassCalcDimensions(;
double CG_FadeCompass(LocalClientNum_t localClientNum, int displayStartTime, CompassType compassType);
void CG_DrawPlayerPopUps(;
void CG_DrawPlayerCOD7TypeWriter(;
void CG_DrawPlayerRedationText(;
void CG_DrawPlayerPopInText(;
void CG_CompassDrawPlayerNorthCoord(;
void CG_CompassDrawPlayerEastCoord(;
void CG_CompassDrawPlayerNCoordScroll(;
void CG_CompassDrawPlayerECoordScroll(;
void CG_UpdateEnemyScramblerAlpha(LocalClientNum_t localClientNum);
void CG_CompassDrawRound(;
void CalcCompassPointerSize(CompassType compassType, float *w, float *h);
void DrawIconDistanceText(;
void CG_CompassDrawTickertape(;
void CG_SetGridTable();
void CG_GetGridFromPos(LocalClientNum_t localClientNum, vec3_t *pos, char *gridName);
double CG_GetHudAlphaCompass(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_drawtools.cpp
double CG_GetPicWidth(Material *mat);
void CG_DrawRotatedPicPhysicalW(;
void CG_DrawRotatedPicPhysical(;
void CG_DrawRotatedPicW(;
void CG_DrawRotatedPic(;
void CG_DrawRotatedQuadPic(;
void CG_DrawStringExt(;
int CG_DrawDevString(;
int CG_DrawSmallDevStringColor(;
double CG_FadeAlpha(int timeNow, int startMsec, int totalMsec, int fadeMsec);
vec4_t *CG_FadeColor(int timeNow, int startMsec, int totalMsec, int fadeMsec);
void CG_MiniMapChanged(LocalClientNum_t localClientNum);
void CG_NorthDirectionChanged(LocalClientNum_t localClientNum);
void CG_RelativeTeamColor(ClientNum_t clientNum, vec4_t *color, LocalClientNum_t localClientNum);
int CG_DrawBigDevString(;

//t6/code/src_noserver/cgame/cg_draw_debug.cpp
void CG_DrawScriptUsage(const ScreenPlacement *scrPlace);
int CG_CompareSndInfoChannel(const void *va, const void *vb);
int CG_CompareSndInfoPriority(const void *va, const void *vb);
int CG_CompareSndInfoAlias(const void *va, const void *vb);
int CG_CompareSndInfoDryLevel(const void *va, const void *vb);
int CG_CompareSndInfoDistance(const void *va, const void *vb);
int CG_CompareSndInfoEntity(const void *va, const void *vb);
void CG_DrawSoundOverlay(const ScreenPlacement *scrPlace);
void CG_DrawPerformanceWarnings(LocalClientNum_t localClientNum);
void CG_DrawModelBoneAxis(LocalClientNum_t localClientNum);
void CG_DrawFxText(const char *text, vec2_t *profilePos);
void CG_DrawFxPriorityText(const char *text, vec2_t *profilePos);
void CG_DrawDebugPlayerHealth(LocalClientNum_t localClientNum);
void CG_DrawDebugPlayerSprint(LocalClientNum_t localClientNum);
void CG_DrawEntDObjBoneDebug(LocalClientNum_t localClientNum, int entNum);
void CG_DrawDebugOverlays(LocalClientNum_t localClientNum);
void CG_DrawFullScreenDebugOverlays(LocalClientNum_t localClientNum);
void CG_DrawGfxStatsLine(;
void CG_DrawGfxStatsMatrix(const ScreenPlacement *scrPlace, GfxPrimStatsCounters counter);
// void CG_DrawGfxStats(int a1@<ebx>, LocalClientNum_t localClientNum);
void CG_DrawVersion(LocalClientNum_t localClientNum);
void CG_QuickPrintFlush();
double CG_GetCornerDebugPrintScale_X();
double CG_GetCornerDebugPrintScale_Y();
double CG_CornerDebugPrint(;
char *DebugSessionInfo();
void CG_DrawTaskErrorDebugInfo(LocalClientNum_t localClientNum);
void CG_DrawHostDebugInfo(LocalClientNum_t localClientNum);
void CG_DrawChangelistMismatch(LocalClientNum_t localClientNum);
void CG_DebugLineVertical(const vec3_t *p, const vec4_t *color, int depthTest, int duration);
void CG_DebugStarWithText(;
void CG_DebugBox(;
void CG_DebugBoxOriented(;
float CG_CornerDebugPrintCaption(;
float CG_DrawSnapshot(LocalClientNum_t localClientNum, float posY);
float CG_DrawViewpos(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float CG_DrawCullDistDebugText(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float CG_DrawShadowMapDebugText(const ScreenPlacement *scrPlace, float y, LocalClientNum_t localClientNum);
float DrawEntityCounts(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float posY);
double CG_DrawAnimTagInfo(LocalClientNum_t localClientNum, const ScreenPlacement *scrPlace, float posY);
double CG_DrawFPS(;
void CG_QuickPrint(const char *fmt, ...);
void CG_DrawUpperRightDebugInfo(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_indicators.cpp
void CG_GrenadeIndicator_GetPlayerPosition(const cg_t *cgameGlob, vec3_t *playerOrigin);
// void CG_DrawFriendlyIndicators(int a1@<edi>, int a2@<esi>, LocalClientNum_t localClientNum);
void CG_DrawFlashDamage(const cg_t *cgameGlob);
bool CG_ShouldDrawDamageDirectionIndicators(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_DrawDamageDirectionIndicators(LocalClientNum_t localClientNum);
void CG_DrawWarningPointer(;
void CG_DrawWarningIcon(;
void CG_ClearHudGrenades();
// double CG_AddHudGrenade_PositionCheck@<st0>(;
void CG_AddHudGrenade(const cg_t *cgameGlob, const centity_t *grenadeEnt);
// void CG_DrawGrenadeIndicators(float a1@<edi>, LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_names.cpp
void TRACK_cg_draw_names();
void CG_ClearOverheadFade();
OverheadFade *CG_GetOverheadFade(LocalClientNum_t localClientNum);
void CG_ClearPlayerDetails();
void CG_InitPlayerDetails(LocalClientNum_t localClientNum, int targetClientNum);
bool CG_CalcNamePosition(LocalClientNum_t localClientNum, const vec3_t *origin, float *xOut, float *yOut);
int CG_GetZombiePlayerColorIndex(LocalClientNum_t localClientNum, ClientNum_t currentClientNum);
void CG_DrawOverheadNames(LocalClientNum_t localClientNum, const centity_t *cent, float alpha, int mode);
bool CG_CanSeeFriendlyHeadInView(;
void CG_GetFriendlyHeadPos(LocalClientNum_t localClientNum, const centity_t *cent, vec3_t *end);
int CG_CheckIfDrivingRemoteControlVehicle(LocalClientNum_t localClientNum, unsigned __int16 EntId);
;
void CG_ScanForCrosshairEntity(LocalClientNum_t localClientNum);
int compareEntityDist(const void *v1, const void *v2);
void CG_AddDrawName(LocalClientNum_t localClientNum, int entnum, float alpha, team_indicator teamIndicator);
void CG_DrawNames(LocalClientNum_t localClientNum);
bool CG_IsValidCrosshairEntity(;
bool ShouldDrawCrosshairNames(LocalClientNum_t localClientNum);
// void CG_DrawCrosshairNames(LocalClientNum_t a1@<ecx>, int a2@<ebx>, LocalClientNum_t localClientNum);
bool activeKillstreakWithLineOfSightOverlay(LocalClientNum_t localClientNum, const cg_t *cgameGlob, int entnum);
bool PlayerCanSeeEnemyNames(LocalClientNum_t localClientNum, int entnum);
bool ShouldDrawPlayerName(LocalClientNum_t localClientNum, int entnum, int team);
bool ShouldDrawFriendlyName(LocalClientNum_t localClientNum, const centity_t *cent, int entnum, int team);
int GetVehicleDriverEntNum(const cg_t *cgameGlob, const centity_t *cent, int entnum);
;
// char CG_CanSeeFriendlyHead@<al>(vec3_t *a1@<edi>, LocalClientNum_t localClientNum, const centity_t *cent);
void CG_DrawActorName(LocalClientNum_t localClientNum, const centity_t *cent, bool flashed);
void CG_DrawFriendlyName(;
void CG_DrawFriendlyNames(LocalClientNum_t localClientNum);
void CG_DrawVisibleNames(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_draw_reticles.cpp
void CG_CalcCrosshairPosition(const cg_t *cgameGlob, float *x, float *y);
char CG_GetWeapReticleZoom(const cg_t *cgameGlob, float *zoom);
void CG_DrawFrameOverlay(;
void CG_DrawNightVisionOverlay(LocalClientNum_t localClientNum);
bool CG_UsingLowResViewPort(LocalClientNum_t localClientNum);
void CG_UpdateScissorViewport(refdef_t *refdef, vec2_t *drawPos, vec2_t *drawSize);
void CG_DrawAdsOverlay(;
void CG_DrawWeapReticle(LocalClientNum_t localClientNum);
void CG_CalcCrosshairColor(const LocalClientNum_t localClientNum, float alpha, vec4_t *color);
void CG_DrawTurretCrossHair(LocalClientNum_t localClientNum);
float CG_GetVehicleCrossHairAlpha(LocalClientNum_t localClientNum);
bool ShouldShowCrosshairOnVehicle(const cg_t *cgameGlob, const WeaponDef *weapDef);
bool CG_DrawVehicleCrossHair(LocalClientNum_t localClientNum);
bool AllowedToDrawCrosshair(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState);
void CG_DrawAdsAimIndicator(;
void CG_TransitionToAds(;
bool CG_DrawReticleCenter(;
void CG_CalcReticleSpread(;
void CG_CalcReticleColor(;
void CG_DrawReticleSides(;
bool ShouldDrawCrosshair(const cg_t *cgameGlob, const playerState_s *ps);
;

//#include "cgame/cg_effects_load_db.h"

//t6/code/src_noserver/cgame/cg_effects_load_obj.cpp
const char *CG_FleshTypeToName(int fleshTypeId);
int CG_AddImpactFileToList(const char *filePath, int index, char **fileList, int *fileCount, int maxFiles);
int CG_GetIncludesForFile(const char *file, char **list, int *count, int max);
// int CG_BuildFileList@<eax>(int a1@<edx>, const char *rootFilePath, char **list, int *count);
int CG_ProcessFileList(char **list, int count, EffectFile *effectFile);
void CG_RegisterImpactEffectsForFile(const char *filePath, EffectFile *effectFile, char *listbuf);
FxImpactTable *CG_RegisterImpactEffects_FastFile();
int CG_RegisterImpactEffects_NonFlesh(;
FxImpactTable *CG_RegisterImpactEffects_LoadObj(const char *filePath);
FxImpactTable *CG_RegisterImpactEffects();

//t6/code/src_noserver/cgame/cg_event.cpp
void CG_Obituary(LocalClientNum_t localClientNum, const entityState_s *ent);
void RemoteMissileBoostEvent(LocalClientNum_t localClientNum, centity_t *cent, int eventParm);
void CG_ObituaryRevive(LocalClientNum_t localClientNum, const entityState_s *ent);
void CG_DirectionalHitIndicator(LocalClientNum_t localClientNum, const entityState_s *ent);
void CG_ItemPickup(LocalClientNum_t localClientNum, Weapon weapon);
void CG_SetWetness(LocalClientNum_t localClientNum, int entNum, float wetness, int invert);
void CG_ExplosionEvent(;
void CG_ProjectileExplosionEvent(;
const DObj *CG_GetBoneIndex(;
unsigned int CG_PlayBoltedEffect(;
unsigned int CG_PlayBoltedEffectRelative(;
void CG_PlayFx(LocalClientNum_t localClientNum, centity_t *cent, const vec3_t *angles);
void CG_PlayFxOnTag(LocalClientNum_t localClientNum, centity_t *cent, int eventParm);
void CG_SetInvalidCmdHint(cg_t *cgameGlob, InvalidCmdHintType hintType);
void CG_SetInvalidStanceHint(cg_t *cgameGlob, invalid_cmd_hint_t type);
void CG_StopWeaponSound(;
bool CG_IsSoundEventLouder(LocalClientNum_t localClientNum, centity_t *cent);
void CG_DoJumpEvent(;
void CG_DoLandEvent(;
void CG_GibEvent(LocalClientNum_t localClientNum, centity_t *cent, unsigned int eventParm);
void CG_GrabWeapon(;
void CG_PhysLaunch(LocalClientNum_t localClientNum, centity_t *cent, const entityState_s *es);
bool CG_CheckIfDualWieldEmpty(playerState_s *ps, Weapon weapon);
;
void CG_CheckEvents(LocalClientNum_t localClientNum, centity_t *cent);
void CG_CheckEntEvents(LocalClientNum_t localClientNum, centity_t *cent);

//#include "cgame/cg_footstepfxtable_load_db.h"

//#include "cgame/cg_footsteptable_load_db.h"

//t6/code/src_noserver/cgame/cg_hudelem.cpp
void CG_HudElemRegisterDvars();
void DirectiveFakeIntroSeconds(LocalClientNum_t localClientNum, const char *arg0, char *result);
void ParseDirective(const char *directive, char *resultName, char *resultArg0);
void GetHudelemDirective(;
char ReplaceDirective(;
void CG_TranslateHudElemMessage(;
void SafeTranslateHudElemString(LocalClientNum_t localClientNum, int index, char *hudElemString);
float HudElemStringWidth(;
int GetHudElemTime(const hudelem_s *elem, int timeNow);
const char *HudElemTimerString(const hudelem_s *elem, int timeNow);
const char *HudElemTenthsTimerString(const hudelem_s *elem, int timeNow);
float HudElemMaterialWidth(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
float HudElemMaterialHeight(;
float HudElemWidth(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
float HudElemHeight(const ScreenPlacement *scrPlace, const hudelem_s *elem, const cg_hudelem_t *cghe);
void GetHudElemOrg(;
void SetHudElemPos(const ScreenPlacement *scrPlace, const hudelem_s *elem, cg_hudelem_t *cghe);
float OffsetHudElemY(const hudelem_s *elem, const cg_hudelem_t *cghe, float offsetY);
void ConsolidateHudElemText(;
void CopyStringToHudElemString(const char *string, char *hudElemString);
void GetHudElemInfo(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe);
void HudElemColorToVec4(const hudelem_color_t *hudElemColor, vec4_t *resultColor);
void DrawHudElemString(;
void DrawHudElemClock(LocalClientNum_t localClientNum, const hudelem_s *elem, const cg_hudelem_t *cghe);
void DrawHudElemMaterial(LocalClientNum_t localClientNum, const hudelem_s *elem, cg_hudelem_t *cghe);
float HudElemWaypointHeight(LocalClientNum_t localClientNum, const hudelem_s *elem);
char WorldPosToScreenPos(LocalClientNum_t localClientNum, const vec3_t *worldPos, vec2_t *outScreenPos);
char WorldPosToExtraCamScreenPos(LocalClientNum_t localClientNum, const vec3_t *worldPos, vec2_t *outScreenPos);
BOOL ClampScreenPosToEdges(;
float GetScaleForDistance(LocalClientNum_t localClientNum, const vec3_t *worldPos);
float WaypointFadeGetTimeFrac(const cg_t *cgameGlob, int currentTime);
void WaypointTargetFade(;
void DrawOffscreenViewableWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem);
float DrawHudElemPerk(;
void DrawHudElemPerkName(;
void DrawHudElemPerks(;
void DrawSingleHudElem2d(LocalClientNum_t localClientNum, const hudelem_s *elem);
int compare_hudelems(const void *pe0, const void *pe1);
int GetSortedHudElems(LocalClientNum_t localClientNum, hudelem_s **elems);
int GetSortedDebugHudElems(hudelem_s **elems);
void CG_Draw2dHudElemList(;
void CG_Draw2dHudElems(LocalClientNum_t localClientNum, int foreground);
void AddDrawSurfForHudElemWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem);
bool RB_AddWaypoint(LocalClientNum_t localClientNum, const hudelem_s *elem, int slot);
void RB_AddWaypoints(LocalClientNum_t localClientNum);
void RB_ClearWaypoints(LocalClientNum_t localClientNum);
void CG_AddDrawSurfsFor3dHudElems(LocalClientNum_t localClientNum);
void CG_AddWaypoint(;
int RB_NumDrawWaypoints(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_info.cpp
void CG_LoadingString(LocalClientNum_t localClientNum, const char *s);
BOOL CG_IsShowingProgress_LoadObj();
BOOL CG_IsShowingProgress_FastFile();
void CG_DrawInformation(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_laser.cpp
laser_cache_t *get_laser_cache(int entnum);
void CG_LaserRegisterDvars();
bool CG_LaserForceOnEnabled();
void AddCore(;
void CG_AddCore(;
void CG_LaserDraw(;
void CG_LaserClearAll();
void CG_LaserAdd(LocalClientNum_t localClientNum, int entnum);
void CG_LaserDrawAll(LocalClientNum_t localClientNum);

//#include "cgame/cg_local.h"

//t6/code/src_noserver/cgame/cg_localents.cpp
void TRACK_cg_localents();
void CG_InitLocalEntities(const LocalClientNum_t localClientNum);
localEntity_s *CG_AllocLocalEntity(const LocalClientNum_t localClientNum);
void CG_AddMovingTracer(const cg_t *cgameGlob, localEntity_s *le);
// void CG_AddLocalEntityTracerBeams(localEntity_s *next@<edx>, const LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_main.cpp
void TRACK_cg_main();
int CG_irand(int min, int max);
double CG_flrand(float min, float max);
;
bool CG_HasClientSystemBeenInitialzed();
bool CG_HaveClientScriptsBeenRun();
void CG_ClientDoneWithInitialization();
void CG_ResetClientInitializationState();
void CG_ResetClientScriptsRunStatus();
void CG_SetClientScriptsRunStatus();
void CG_UpdateUIDeviceContexts(LocalClientNum_t localClientNum, int time);
void CG_UpdateFov(float value);
char CG_IsThirdPerson(LocalClientNum_t localClientNum);
BOOL CG_IsEntWalkable(LocalClientNum_t localClientNum, int entityNum);
BOOL CG_IsCreateFX();
int CScriptMover_UpdateMove(;
void CG_InitScreenDimensions(LocalClientNum_t localClientNum);
int CScr_LoadScriptAndLabel(const char *filename, const char *label);
void CG_AddFootstepEvent(;
void CG_AddPlayerFootstepEvent(;
void CG_ProcessFootstepEvents(LocalClientNum_t localClientNum, cg_t *cgameGlob);
bool CG_IsSonarAttachment(LocalClientNum_t localClientNum);
void CG_SetupSonar(LocalClientNum_t localClientNum);
void CG_UpdateVehicleBindings_f();
void CG_InitConsoleCommands();
void CG_ShutdownConsoleCommands();
float CG_GetDefaultFovForView(LocalClientNum_t localClientNum);
void CG_SetThirdPersonForAllLocalClients(bool value);
void CG_SetThirdPerson(LocalClientNum_t localClientNum, bool value);
void CG_UpdateFovCallBack();
void CG_RegisterDvars();

//t6/code/src_noserver/cgame/cg_mem_track.cpp
void CG_track_init();

//t6/code/src_noserver/cgame/cg_perf.cpp
void UpdateData(CG_PerfData *data, int value);
void CG_PerfInit();
void CG_PerfUpdate();

//t6/code/src_noserver/cgame/cg_playerstate.cpp
void CG_DamageFeedback(LocalClientNum_t localClientNum, int yawByte, int pitchByte, int damage);
void CG_Respawn(LocalClientNum_t localClientNum, int spectate);
void CG_ResetSpectatorViewAngles(LocalClientNum_t localClientNum);
void CG_CheckPlayerstateEvents(;
void CG_TransitionPlayerState(;
void CG_ClearTransPlayerState(transPlayerState_t *transPs);
void CG_ExtractTransPlayerState(const playerState_s *ps, transPlayerState_t *transPs);

//t6/code/src_noserver/cgame/cg_pose.cpp
void BG_Player_DoControllers(const CEntPlayerInfo *player, const DObj *obj, int *partBits);
void CG_Player_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Vehicle_DoControllersAir(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Destructible_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Turret_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_Actor_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_DoBaseOriginController(const cpose_t *pose, const DObj *obj, int *setPartBits);
void CG_Vehicle_PostDObjCalcSkel(const cpose_t *pose, const DObj *obj, int *partBits);
;
void CG_Vehicle_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
void CG_DoControllers(const cpose_t *pose, const DObj *obj, int *partBits);
DObjAnimMat *CG_DObjCalcPose(const cpose_t *remote_pose, const DObj *obj, int *partBits);

//#include "cgame/cg_pose.h"

//t6/code/src_noserver/cgame/cg_pose_utils.cpp
void CG_UsedDObjCalcPose(const cpose_t *pose);
void CG_CullIn(const cpose_t *pose);

//t6/code/src_noserver/cgame/cg_rumble.cpp
void Rumble_Strcpy(unsigned __int8 *member, const char *keyValue);
bool ParseRumbleGraph(RumbleGraph *graph, const char *buffer, const char *fileName);
bool ReadRumbleGraph(RumbleGraph *graph, const char *rumbleFileName);
// char LoadRumbleGraph@<al>(;
bool CG_LoadRumble(RumbleGraph *rumbleGraphArray, RumbleInfo *info, const char *name, int rumbleNameIndex);
void CG_RegisterRumbles(LocalClientNum_t localClientNum);
void DrawActiveRumbles(LocalClientNum_t localClientNum, const ActiveRumble *activeRumbleArray);
void RemoveInactiveRumbles(LocalClientNum_t localClientNum, ActiveRumble *activeRumbleArray);
void CalcActiveRumbles(;
int GetRumbleInfoIndexFromName(LocalClientNum_t localClientNum, const char *rumbleName);
bool DuplicateRumbleExists(;
ActiveRumble *NextAvailableRumble(const cg_t *cgameGlob, ActiveRumble *arArray);
void PlayRumbleInternal(;
void CG_PlayRumbleOnEntity(LocalClientNum_t localClientNum, const char *rumbleName, int entityNum);
void CG_PlayRumbleOnPosition(LocalClientNum_t localClientNum, const char *rumbleName, const vec3_t *pos);
void CG_PlayRumbleLoopOnEntity(LocalClientNum_t localClientNum, const char *rumbleName, int entityNum);
void CG_PlayRumbleLoopOnPosition(LocalClientNum_t localClientNum, const char *rumbleName, const vec3_t *pos);
void CG_PlayRumbleOnClient(LocalClientNum_t localClientNum, const char *rumbleName);
void CG_PlayLoopRumbleOnClient(LocalClientNum_t localClientNum, const char *rumbleName);
void CG_StopRumble(LocalClientNum_t localClientNum, int entityNum, const char *rumbleName);
void CG_StopAllRumbles(LocalClientNum_t localClientNum);
void CG_SetRumbleReceiver(LocalClientNum_t localClientNum, int entityNum, const vec3_t *position);
void CG_DrawRumbleDebug(LocalClientNum_t localClientNum);
void RumbleGraphEventCallback(const DevGraph *graph, DevEventType event, LocalClientNum_t localClientNum);
void RumbleGraphTextCallback(const DevGraph *graph, const float inputX, const float inputY, char *text);
void InitDevguiRumbleGraphInteral(const char *rumbleName, RumbleGraph *rumbleGraph, RumbleInfo *rumbleInfo);
void CG_InitDevguiRumbleGraph(LocalClientNum_t localClientNum);
void CG_UpdateRumble(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_scr_main.cpp
unsigned __int16 CScr_GetMeansOfDeathConstString(int mod);
void CScr_Notify(;
void CScr_ToLower();
void CScr_ReadOnly(centity_t *cent, const cent_field_s *pField);
void CScr_GetType(centity_t *cent, const cent_field_s *pField);
void CScr_GetWeaponName(centity_t *cent, const cent_field_s *pField);
void CScr_SetOrigin(centity_t *cent, const cent_field_s *pField);
void CScr_SetAngles(centity_t *cent, const cent_field_s *pField);
void CScr_GetModel(centity_t *cent, const cent_field_s *pField);
void VehicleCScr_GetVehicleDefField(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleClass(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleTreadFxArray(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleLightFXArray(centity_t *cent, const cent_field_s *pField);
void CScr_GetVehicleLightFXTagArray(centity_t *cent, const cent_field_s *pField);
void CScr_FreeFakeEntity(LocalClientNum_t localClientNum, int entNum);
void CScr_DeleteFakeEnt();
void CScr_IsString();
void CScr_IsArray();
void assertCmd();
void assertmsgCmd();
void debugBreakCmd();
void print();
void println();
void CScr_IPrintLnBold();
void CScr_Print3D();
void CScr_RandomInt();
void CScr_RandomFloat();
void CScr_RandomIntRange();
void CScr_RandomFloatRange();
void CScr_VectorFromLineToPoint();
void CScr_PointOnSegmentNearestToPoint();
char CScr_Distance();
void CScr_Distance2D();
void CScr_DistanceSquared();
void CScr_Length();
void CScr_LengthSquared();
void CScr_Closer();
void CScr_VectorDot();
void CScr_VectorCross();
void CScr_VectorNormalize();
void CScr_VectorLerp();
void CScr_LerpFloat();
void CScr_LerpVector();
void CScr_GetMinBitCountForNum();
void CScr_CombineAngles();
void CScr_AbsAngleClamp180();
int Effect_Index(LocalClientNum_t clientNum, const char *name);
void CScr_LoadedFX();
void CScr_BulletTracer();
void CScr_AnimateUI();
void CScr_GetAnimLength();
void CScr_ShowUI();
void CScr_GetSystemTime();
void CScr_GetServerTime();
void CScr_ClientHasSnapShot();
void CScr_GetMapCenter();
char CScr_SetDvar();
void CScr_SetSavedDvar();
void CScr_IsStereoOn();
void CScr_IsMatureContentEnabled();
void CScr_GetDebugDvar();
void CScr_GetDebugDvarInt();
void CScr_GetDebugDvarFloat();
void CScr_SetDvarBool();
void CScr_SetDvarFloat();
void CScr_SetDvarInt();
void CScr_PlaySound();
void CScr_PlaySoundOnEntity(scr_entref_t entref);
void CScr_PlayLoopSoundOnEntity(scr_entref_t entref);
void CScr_StopLoopSoundOnEntity(scr_entref_t entref);
void CScr_IsPlayingLoopSound(scr_entref_t entref);
void CScr_SetSoundContext();
void CScr_SetSoundEntContext(scr_entref_t entref);
void CScr_SetLoopState(scr_entref_t entref);
void robot_mixer_behavior(_mixerLight_t *pMixer, const cg_t *cgameGlob);
void CG_MixerLightNotifyListener(unsigned int objectId, unsigned int notifyString);
void CScr_AllocateMixerLights();
void CScr_IsMixerLightBehaviorHardCoded();
void CScr_IsMixerBehaviorHardCoded();
void CG_FreeMixerLights();
void CG_TurnOffMixerExploder(_mixerLight_t *pMixer);
void CG_TurnOnMixerExploder(_mixerLight_t *pMixer);
void CG_SetMixerLightIntensity(;
void CG_DeleteLightModels(_lightModel_t *lightModel);
void CG_CreateLightModelsAndFX(;
void CScr_AllocateSoundRandoms();
void CG_FreeSoundRandoms();
void CG_AddSoundRandomToActiveList(soundRandom_t *soundRandom);
void CG_RunSoundRandoms();
void CScr_CreateSoundRandom();
void CScr_SoundSetMusicState();
void CScr_SoundLoopEmitter();
void CScr_SoundStopLoopEmitter();
void CScr_SoundLineEmitter();
void CScr_SoundStopLineEmitter();
void CScr_GetAliasName();
void CScr_GetAliasCount();
void CScr_IsAliasLoop();
void CScr_StopLocalSound();
void CScr_SoundTimescale();
void CScr_SoundPlaying();
void CScr_SetSoundVolume();
void CScr_SetSoundPitch();
void CScr_SetSoundVolumeRate();
void CScr_SetSoundPitchRate();
void CScr_GetRealTime();
void CScr_GetPlaybackTime();
void CScr_GetKnownLength();
void CScr_SetGroupSnapshot();
void CScr_SetAmbientSnapshot();
void CScr_SetAmbientSideChainDuck();
void CScr_SetGlobalFutz();
void CScr_SetHealthSnapshot();
void CScr_SetLevelFadeSnapshot();
void CScr_StopSound();
void CScr_ScaleSpeed();
void CScr_DeactivateReverb();
void CScr_SetReverb();
void CScr_GetArrayKeys();
void CScr_GetFirstArrayKey();
void CScr_GetNextArrayKey();
void CScr_GetLastArrayKey();
void CScr_GetPrevArrayKey();
void CScr_GetLocalClientPos();
void CScr_AimingAtFriendly();
void CScr_SplitArgs();
void CScr_SetThirdPerson();
void CScr_sin();
void CScr_cos();
void CScr_tan();
void CScr_asin();
void CScr_acos();
void CScr_atan();
void CScr_min();
void CScr_max();
void CScr_floor();
void CScr_ceil();
void CScr_sqrt();
void CScr_CastInt();
void CScr_CastFloat();
void CScr_CastIString();
void CScr_GetLocalClientEyePos();
void CScr_GetLocalClientAngles();
char CScr_Spawn();
void CScr_IsAlive();
void CScr_GetWeaponAmmoClip();
void CScr_IsThrowingGrenade();
void CScr_IsMeleeing();
void CScr_IsSwitchingWeapons();
void CScr_IsOnTurret();
void CScr_IsSubStr();
void CScr_GetSubStr();
void CScr_StrTok();
void CScr_MakeLocalizedString();
void CScr_GetSpecies(centity_t *cent, const cent_field_s *pField);
void CScr_GetIsDog(centity_t *cent, const cent_field_s *pField);
void CScr_GetIsBigDog(centity_t *cent, const cent_field_s *pField);
void CScr_PlayerJumpEvent(;
void CScr_PlayerLandEvent(;
void CScr_PlayerFoliageEvent(LocalClientNum_t localClientNum, centity_t *cent, bool isPlayerView, bool quiet);
void CScrCmd_GetThrottle(scr_entref_t entref);
void CScrCmd_GetBrake(scr_entref_t entref);
void CScrCmd_GetMaxSpeed(scr_entref_t entref);
void CScrCmd_GetSteering(scr_entref_t entref);
void CScrCmd_GetMaxReverseSpeed(scr_entref_t entref);
void CScrCmd_IsDriving(scr_entref_t entref);
void CScrCmd_IsLocalPlayerWeaponViewOnlyLinked(scr_entref_t entref);
void CScrCmd_IsLocalPlayerViewLinked(scr_entref_t entref);
void CScrCmd_IsLocalClientDriver(scr_entref_t entref);
void CScrCmd_GetLocalClientDriver(scr_entref_t entref);
void CScrCmd_GetWheelSurface(scr_entref_t entref);
void CScrCmd_IsWheelSliding(scr_entref_t entref);
void CScrCmd_IsWheelColliding(scr_entref_t entref);
void CScrCmd_GetLocalGunnerAngles(scr_entref_t entref);
void CScrCmd_SetStunned(scr_entref_t entref);
void CScr_IsInVehicle();
void CScr_IsXenon();
void CScr_GetSurfaceStrings();
void CScr_FindStaticModelIndex();
void CScr_HideStaticModel();
void CScr_UnhideStaticModel();
void CScr_GetFootstepStrings();
void CScrCmd_IsVehiclePeelingOut(scr_entref_t entref);
void CScr_line();
void CScr_box();
void CScr_PixBeginEvent();
void CScr_debugstar();
void CScr_GetMaxLocalClients();
void CScr_GetActiveLocalClients();
void CScr_LocalClientActive();
void CScr_IsSplitScreenHost();
void CScr_IsSplitScreen();
void CScr_StopBink();
void CScr_GetBinkLength();
void CScr_IsBinkFinished();
void CScr_FxParamError(LocalClientNum_t localClientNum, int paramIndex, const char *errorString, int fxId);
void CScr_SetFxAngles(int givenAxisCount, vec3_t *axis, vec3_t *angles);
unsigned int CScr_PlayFXInternal(;
void CScr_PlayFX();
void CScr_StopFX();
void CScr_IsFXPlaying();
void CScr_DisableImpactMarks();
void CScr_EnableImpactMarks();
void CScr_GetGenericEnt(LocalClientNum_t localClientNum, int offset, const char *pName);
void CScr_GetEnt();
void CScrCmd_IsAlive(scr_entref_t entref);
void CScr_GetEntByNum();
void CScr_GetEntArray();
void CScr_GetLocalPlayers();
void CScr_GetLocalPlayer();
void CScr_GetNonPredictedLocalPlayer();
void CScr_PrecacheRumble();
void CScr_PlayRumbleOnPosition_Internal();
;
char CScr_TracePoint();
void CScr_OpenFile();
void CScr_CloseFile();
void CScr_FPrint_internal(bool commaBetweenFields);
void CScr_FPrintln();
void CScr_FPrintFields();
void __thiscall CScr_FReadLn(const char *this);
void CScr_FGetArg();
void CScr_SetUI3DTextureWindow();
void CScr_GetWeaponModel();
void CScr_CreateNewArray();
void CScr_ArrayRemoveValue();
void CScr_ArrayRemoveIndex();
void CScr_ArrayInsert();
void CScr_ArrayCombine();
void CScr_ArrayCopy();
void CScr_IsInArray();
void CScr_SessionModeIsOnlineGame();
void CScr_SessionModeIsPrivateOnlineGame();
void CScr_SessionModeIsPrivate();
void CScr_SessionModeIsSystemlink();
void CScr_SessionModeIsZombiesGame();
void CScr_GameModeIsMode();
void CScr_GameModeIsUsingXP();
void CScr_GameModeIsUsingStats();
void CScr_TriggerFX();
char CScr_VisionSetNaked();
bool CScr_VisionSetNakedLerp();
void CScr_GetVisionSetNaked();
void CScr_SetRippleWave();
// void CScr_Project2DTo3D(unsigned int a1@<ebp>);
void CScr_ForwardRotateAroundUpByAngle();
int CScr_ScriptCallbackOnFootstepEvent();
char *CScr_UseFootstepTable();
char *CScr_UseFootstepFXTable();
char CScr_FootstepDoNothing();
char CScr_FootstepDoEverything();
void CScr_FootstepDoSound();
void CScr_FootstepDoFootstepFX();
void CScr_SetDemoLockOnValues();
void CScr_TableLookupFindCoreAsset();
void CScr_TableLookupRowNum();
void CScr_TableLookupColumnForRow();
void CScr_TableLookup();
void CScr_TableLookupIString();
void BG_EvalVehicleName();
void CScr_CreateQRCode();
void CScr_DeleteQRCode();
void CScr_ForceAmbientRoom();
void CScr_ForceAmbientPackage();
void CScr_SetAmbientPackage();
void CScr_SetAmbientRoomContext();
void CScr_RopePulse();
void CScr_SetForceNotSimple(scr_entref_t entref);
void CScrCmd_GetCamPosByLocalClientNum();
void CScrCmd_GetCamAnglesByLocalClientNum();
void CScrCmd_DemoIsAnyFreeMoveCamera();
void CScrCmd_DemoIsMovieCamera();
void CScrCmd_DemoIsEditCamera();
void CScrCmd_DemoIsDollyCamera();
void CScrCmd_GetScreenWidth();
void CScrCmd_GetScreenHeight();
void (*CScr_GetFunction(const char **pName, int *type, int *min_args, int *max_args))();
;
void CScrCmd_SetModel(scr_entref_t entref);
void CScrCmd_SetScale(scr_entref_t entref);
void CScr_Attach(scr_entref_t entref);
void CScrCmd_GetSpeed(scr_entref_t entref);
void CScrCmd_GetStance();
void CScrCmd_GetWeaponPosFrac();
void CScrCmd_GetEntNum(scr_entref_t entref);
void CScrCmd_GetEntityNumber(scr_entref_t entref);
void CScrCmd_MakeLight(scr_entref_t entref);
void CScr_GetLightColor(scr_entref_t entref);
void CScr_SetLightColor(scr_entref_t entref);
void CScr_GetLightIntensity(scr_entref_t entref);
void CScr_SetLightIntensity(scr_entref_t entref);
void CScr_GetLightRadius(scr_entref_t entref);
void CScr_SetLightRadius(scr_entref_t entref);
void CScr_GetLightFovInner(scr_entref_t entref);
void CScr_GetLightFovOuter(scr_entref_t entref);
// void CScr_SetLightFovRange(float a1@<edi>, scr_entref_t entref);
void CScr_GetLightExponent(scr_entref_t entref);
void CScr_SetLightExponent(scr_entref_t entref);
void CScr_MakeLightSlave(scr_entref_t entref);
void CScrCmd_PlayRumbleOnEntity_Internal(scr_entref_t entref, int event);
void CScrCmd_PlayRumbleOnEntity(scr_entref_t entref);
void CScrCmd_PlayRumbleLoopOnEntity(scr_entref_t entref);
void CScrCmd_StopRumble(scr_entref_t entref);
void CScrCmdGetCommandTimes(float *pfTotalTime, float *pfAccelTime, float *pfDecelTime);
void CScriptMover_SetupMove(;
void CScriptMover_SetupMoveSpeed(;
void CScriptMover_MoveGravity(;
void CScrCmd_MoveGravity(scr_entref_t entref);
void CScrCmd_MoveTo(scr_entref_t entref);
void CScrEnt_MoveAxis(scr_entref_t entref, int iAxis);
void CScrEntCmd_MoveX(scr_entref_t entref);
void CScrEntCmd_MoveY(scr_entref_t entref);
void CScrEntCmd_MoveZ(scr_entref_t entref);
void CScriptEnt_RotateAxis(scr_entref_t entref, int iAxis);
void CScrCmd_RotatePitch(scr_entref_t entref);
void CScrCmd_RotateYaw(scr_entref_t entref);
void CScrCmd_RotateRoll(scr_entref_t entref);
void CScrCmd_RotateTo(scr_entref_t entref);
void CScrCmd_RotateVelocity(scr_entref_t entref);
void CScr_StartPoisoning(scr_entref_t entref);
void CScr_StopPoisoning(scr_entref_t entref);
void CScr_IsPoisoned(scr_entref_t entref);
void CScrCmd_GetCamPos(scr_entref_t entref);
void CScrCmd_GetCamAngles(scr_entref_t entref);
void CScr_UseAnimTree(scr_entref_t entref);
XAnimTree_s *CScr_GetEntAnimTree(centity_t *ent);
void CScr_HasAnimTree(scr_entref_t entref);
void CScr_ClearAnim(scr_entref_t entref);
void CScr_ClearAnimLimited(scr_entref_t entref);
void CScr_HandleAnimError(int error);
void CScr_SetAnimKnobInternal(scr_entref_t entref, unsigned int flags, bool bFlagged);
void CScr_SetAnimKnob(scr_entref_t entref);
void CScr_SetAnimKnobLimited(scr_entref_t entref);
void CScr_SetAnimKnobRestart(scr_entref_t entref);
void CScr_SetAnimKnobLimitedRestart(scr_entref_t entref);
void CScr_SetAnimKnobAllInternal(scr_entref_t entref, unsigned int flags, bool bFlagged);
void CScr_SetAnimKnobAll(scr_entref_t entref);
void CScr_SetAnimKnobAllLimited(scr_entref_t entref);
void CScr_SetAnimKnobAllRestart(scr_entref_t entref);
void CScr_SetAnimKnobAllLimitedRestart(scr_entref_t entref);
void CScr_SetAnimInternal(scr_entref_t entref, unsigned int flags, __int16 bFlagged, bool scripted);
void CScr_SetAnim(scr_entref_t entref);
void CScr_SetAnimLimited(scr_entref_t entref);
void CScr_SetAnimRestart(scr_entref_t entref);
void CScr_SetAnimLimitedRestart(scr_entref_t entref);
void CScr_SetFlaggedAnim(scr_entref_t entref);
void CScr_SetFlaggedAnimLimited(scr_entref_t entref);
void CScr_SetFlaggedAnimRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimLimitedRestart(scr_entref_t entref);
void CScr_AnimScripted(scr_entref_t entref);
void CScr_AnimFlaggedScripted(scr_entref_t entref);
void CScr_SetFlaggedAnimKnob(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobLimited(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobLimitedRestart(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobAll(scr_entref_t entref);
void CScr_SetFlaggedAnimKnobAllRestart(scr_entref_t entref);
void CScr_AnimGetChildAt(scr_entref_t entref);
void CScr_AnimGetNumChildren(scr_entref_t entref);
void CScr_GetAnimTime(scr_entref_t entref);
void CScr_GetAnimCurrFrameCount(scr_entref_t entref);
void CScr_SetAnimTime(scr_entref_t entref);
void CScr_SetEntityAnimRate(scr_entref_t entref);
void CScr_GetEntityAnimRate(scr_entref_t entref);
void CScrCmd_IsPlayer(scr_entref_t entref);
void CScrCmd_IsLocalPlayer(scr_entref_t entref);
void CScrCmd_IsAI(scr_entref_t entref);
void CScr_HasDObj(scr_entref_t entref);
void CScr_SetCompassIcon(scr_entref_t entref);
void CScrCmd_IsSplitScreenHost(scr_entref_t entref);
void CScrCmd_UnderWater(scr_entref_t entref);
void CScrCmd_LinkTo(scr_entref_t entref);
void CScrCmd_Unlink(scr_entref_t entref);
void CScr_Map_Material(scr_entref_t entref);
void CScr_Set_Filter_Pass_Material(scr_entref_t entref);
void CScr_Set_Filter_Pass_Enabled(scr_entref_t entref);
void CScr_Set_Filter_Pass_Quads(scr_entref_t entref);
void CScr_Set_Filter_Pass_Constant(scr_entref_t entref);
void CScr_Set_Filter_Bit_Flag(scr_entref_t entref);
void CScr_Set_Overlay_Material(scr_entref_t entref);
void CScr_Set_Overlay_Constant(scr_entref_t entref);
void CScr_SetInfraredVisionset(scr_entref_t entref);
void CScr_SetSonarEnabled(scr_entref_t entref);
void CScr_ForceInfraredMaterialsStreaming(scr_entref_t entref);
void CScr_Set_Overlay_Enabled(scr_entref_t entref);
void CScr_LaunchRagdoll(scr_entref_t entref);
void CScr_Show(scr_entref_t entref);
void CScr_Hide(scr_entref_t entref);
void CScrCmd_GetEye(scr_entref_t entref);
void CScrCmd_GetEyeApprox(scr_entref_t entref);
void CScrCmd_GetLocalClientNumber(scr_entref_t entref);
void CScr_MapShaderConstant(scr_entref_t entref);
void CScr_SetShaderConstant(scr_entref_t entref);
void CScr_MakeMixerLight(scr_entref_t entref);
void CScr_ActivateMixer(scr_entref_t entref);
int CG_GetMixerLightSide(int param);
void CScr_SetMixerLightModels(scr_entref_t entref);
void CScr_SetMixerSpinModels(scr_entref_t entref);
void CScr_SetMixerLightBehavior(scr_entref_t entref);
void CScr_SetMixerExploderId(scr_entref_t entref);
void CScr_SetMixerBehavior(scr_entref_t entref);
void CScr_SetMixerLightParam(scr_entref_t entref);
void CScr_SetMixerParam(scr_entref_t entref);
void CScr_SetMixerL2RRampSpeed(scr_entref_t entref);
void CScr_SetMixerR2LRampSpeed(scr_entref_t entref);
void CScr_SetMixerLightRotateTime(scr_entref_t entref);
void CScr_SetMixerLightIntensity(scr_entref_t entref);
void CScr_SetMixerLightColor(scr_entref_t entref);
void CScr_SetMixerLightExponent(scr_entref_t entref);
void CScr_SetMixerLightRadius(scr_entref_t entref);
void CScr_SetMixerLightFovRange(scr_entref_t entref);
team_t GetTeam(centity_t *cent);
void CScr_GetTeamName(centity_t *cent, const cent_field_s *pField);
void CScr_GetPlayerName(centity_t *cent, const cent_field_s *pField);
void CScrCmd_GetCharacterIndex(scr_entref_t entref);
void CScr_SetMaterialOverride(scr_entref_t entref);
void CScr_ClearMaterialOverride(scr_entref_t entref);
void CScr_SetStepTriggerSound(scr_entref_t entref);
void CScr_ClearStepTriggerSound(scr_entref_t entref);
void CScr_GetMovementType(scr_entref_t entref);
void CScr_IsInsideHeightLock(scr_entref_t entref);
void CScr_SetAmbientTrigger(scr_entref_t entref);
void CScr_SoundSetAmbientState(;
void CScr_SoundPlayUiDecodeLoop(const char *decodeString, const int playTimeMs);
void CScr_IsGrenadeDud(scr_entref_t entref);
void (*CScr_GetMethod(const char **pName, int *type, int *min_args, int *max_args))(scr_entref_t);
void CScr_LoadLevel(bool bPrecacheGameType);
void CScr_FreeScripts();
unsigned int CG_SetEntityScriptVariableInternal(const char *key, const char *value);
unsigned int CG_SpawnStruct(const SpawnVar *spawnVar);
void CG_SpawnNode();
void CScr_GlassSmash(const vec3_t *pos, const vec3_t *dir);
void CScr_BuildClientsideAITypeList(bool bRestarting);
void CScr_GetPlayerFootstepTables();
void *CScr_LoadEntityscriptAlloc(int size);
void CScr_LoadEntityScripts();
void *CScr_SetupClientZBarrierIndicesAlloc(int size);
void CScr_SetupClientZBarrierIndices();
int CScr_UpdateTagInternal(;
void CScr_LoadStructs();
unsigned __int16 CScr_ExecEntThread(centity_t *ent, int handle, unsigned int paramcount);
;
void CG_DoTouchTriggers(centity_t *ent, LocalClientNum_t localClientNum);
void CScr_GetField(centity_t *ent, cent_field_s *fieldarray, unsigned int offset);
void CScr_GetEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_SetField(centity_t *ent, cent_field_s *fieldarray, unsigned int offset);
int CScr_SetEntityField(int entnum, LocalClientNum_t clientNum, int offset);
void CScr_GetObjectField(unsigned int classnum, int entnum, LocalClientNum_t clientNum, int offset);
// int CScr_SetObjectField@<eax>(;
void CScr_PostLoadScripts();
unsigned int CScr_GetFakeEntity(LocalClientNum_t localClientNum);
void CScr_SpawnFakeEnt();
centity_t *CScr_SetFakeEntOrg();
int CScr_PlayLoopedFX();
void CScr_PlayLoopSound();
unsigned int CScr_StopLoopSound();
void firecaster_light_behavior(;
void fire_flicker_internal(;
void fire_flicker_light_behavior(;
void flickerthenstop_light_behavior(;
void explode_then_flicker_light_behavior(;
void electrical_flicker_light_behavior(;
void generic_strobe_light_behavior(;
void generic_double_strobe_light_behavior(;
void light_off_light_behavior(;
void generic_pulsing_light_behavior(;
void television_light_behavior(;
void generic_flickering_light_behavior(;
void CG_HandleSpinnerLights(;
// void CG_RunMixerLights(float a1@<edi>);
void CScr_SpawnPlane();
;
void CScrCmd_Delete(scr_entref_t entref);
void CScrCmd_SetViewModelRenderFlag(scr_entref_t entref);
void CScrCmd_ForceDelete(scr_entref_t entref);
void CScrCmd_GetVelocity(scr_entref_t entref);
void CScrCmd_IsTouching(scr_entref_t entref);
void CG_FreeEntityDelay(centity_t *ed);

//#include "cgame/cg_scr_main.h"

//t6/code/src_noserver/cgame/cg_shellshock.cpp
void CG_PerturbCamera(cg_t *cgameGlob);
void SaveScreenToBuffer(LocalClientNum_t localClientNum);
int CG_DrawShellShockSavedScreenBlendBlurred(;
int CG_DrawShellShockSavedScreenBlendFlashed(;
void EndShellShockSound(LocalClientNum_t localClientNum);
void EndShellShockLookControl(LocalClientNum_t localClientNum);
void EndShellShockCamera(LocalClientNum_t localClientNum);
void EndShellShockScreen(LocalClientNum_t localClientNum);
void EndShellShock(LocalClientNum_t localClientNum);
void UpdateShellShockSound(;
void UpdateShellShockLookControl(;
void UpdateShellShockCamera(;
void UpdateShellShockVisionSet(;
void CG_UpdateShellShock(;
void CG_StartShellShock(cg_t *cgameGlob, const shellshock_parms_t *parms, int start, int duration);
bool CG_Flashbanged(LocalClientNum_t localClientNum);
bool CG_Flared(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_sound.cpp
void CG_RegisterSoundDvars();
void CG_ClearSoundPlaybackTracking();
bool CG_ShouldPlaySoundOnLocalClient(;
SndEntHandle CG_SndEntHandle(LocalClientNum_t localClientNum, int entIndex);
void CG_PlaySound(;
void CG_PlaySound(;
void CG_PlaySound(;
int CG_PlaySoundWithHandle(;
int CG_PlaySoundWithHandle(;
void CG_FlushLoops();
void CG_PumpEntityLoopSound(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_PlayAnimScriptSoundAlias(ClientNum_t clientIndex, SndAliasList *aliasList);
void CG_SubtitlePrint(int msec, const char *subtitle);
void CG_SubtitleSndLengthNotify(int msec, const char *lengthNotifyData);
void CG_ScriptSndLengthNotify(int msec, int lengthNotifyData);
void CG_CopySoundEntityOrientation(;
unsigned int CG_SoundGetUseCount(const SndEntHandle sndEnt);
void CG_GetSoundEntityOrientation(;
void CG_StopSoundAlias(LocalClientNum_t localClientNum, int entityNum, unsigned int aliasName);
void CG_SndFireReset();
void CG_SndUpdateFire();
void CG_FlameSourceUpdate(;
void CG_SoundWhizby(;
void CG_SndUpdate();
void CG_SoundUpdateListeners(LocalClientNum_t localClientNum);
void CG_GetLoopingSoundPosition(LocalClientNum_t localClientNum, centity_t *cent, vec3_t *sndOrigin);
void CG_UpdateLoopingFireSounds(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_CheckADSRaiseAndLower(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
void CG_Turret_UpdateTurretRotationSound(LocalClientNum_t localClientNum, centity_t *cent);
void CG_SoundForceAmbientRoomChange(bool forceChange, bool defaultRoom, unsigned int roomHash);
void CG_SoundForceAmbientPackageChange(bool forceChange, bool defaultPackage, unsigned int packageHash);
void CG_SoundInitAmbientColliders();
void CG_SoundSetAmbientData(const snd_ambient_script_data *ambData);
void CG_SoundSetAmbientContext(;
void CG_GetHighestPriorityRoomIndices(cg_t *cgameGlob, snd_ambient_collider *currentCollider);
void CG_SoundAmbientCheckOverrides(cg_t *cgameGlob, snd_ambient_collider *collider);
void CG_SoundUpdateAmbient();
void CG_StopZombieVoxSounds(LocalClientNum_t localClientNum, int entityNum);
bool CG_SoundEntInUse(const SndEntHandle sndEnt);
void CG_SndGameReset();

//t6/code/src_noserver/cgame/cg_spawn.cpp
const char *CG_GetEntityTypeName(centity_t *cent);
int CG_GetModelIndex(const char *name, LocalClientNum_t localClientNum);
void CScr_FreeFields(const cent_field_t *fields, unsigned __int8 *base);
void CScr_FreeEntityFields(centity_t *cent);
void CG_ParseEntityFields(;
void CG_InitScriptMover(centity_t *cent);
bool CG_SetTriggerBrushModel(LocalClientNum_t localClientNum, centity_t *ent);
void CG_InitSentientTrigger(centity_t *self, int spawnflags);
bool CG_IsPositionInZeroGravity(const vec3_t *position);
void CG_PrintEntities(LocalClientNum_t localClientNum);
centity_t *CG_Spawn(LocalClientNum_t localClientNum);
void CG_Free(LocalClientNum_t localClientNum, int entNum);
void CG_ShutdownFakeEntities(LocalClientNum_t localClientNum);
bool CG_InitTrigger(LocalClientNum_t localClientNum, centity_t *self);
void CG_SP_trigger_multiple(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_once(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_radius(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_SP_trigger_box(LocalClientNum_t localClientNum, centity_t *ent, int spawnFlags);
void CG_CallSpawn(LocalClientNum_t localClientNum, SpawnVar *spawnVar);
void CG_SpawnEntitiesFromString(LocalClientNum_t localClientNum);
void CG_InitFakeEntities(LocalClientNum_t localClientNum, bool spawnEntsFromMap);

//t6/code/src_noserver/cgame/cg_vehicle.cpp
cgVehicleTurretLoopState_t CG_VehicleComputeTurretRotationState(float angularVel, cgVehicle_t *vehicle);
void CG_Vehicle_UpdateTurretRotateSounds(LocalClientNum_t localClientNum, centity_t *cent);
bool CG_ShouldLockTurretToPlayerView(const centity_t *cent, const VehicleDef *info, const playerState_s *ps);
void CG_UpdateVehicleSoundOrigins(centity_t *cent, const DObj *obj);
void CG_InitAntenna(centity_t *cent, const DObj *obj);
int GetSoundInfoForVehicle(LocalClientNum_t localClientNum, const centity_t *cent, float *slideRate);
void CG_CrossFadeVehicleMaterialEffects(;
void CG_UpdateWheeledSurfaceSounds(;
void CG_UpdateSurfaceSounds(;
void CG_UpdateVehicleNotifies(LocalClientNum_t localClientNum, centity_t *cent);
char CG_VehicleOccupiedByPlayer(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Vehicle_GetSoundOriginForGun(centity_t *cent, int gunIndex, vec3_t *sndOrigin);
bool CircleLineIntersect(vec3_t *p1, vec3_t *p2, vec3_t *center, float radius, float *t0, float *t1);
bool CG_Vehicle_GetWheelBone(;
void CG_Vehicle_GetBoneOrigin(;
int CG_Vehicle_GetVehicleDefIndex(const centity_t *cent);
const VehicleDef *CG_Vehicle_GetVehicleDef(const centity_t *cent);
bool CG_Vehicle_IsDefRemoteControl(int index);
bool CG_Vehicle_IsRemoteControl(const centity_t *cent);
BOOL CG_Vehicle_IsGunnerTurretFiring(const centity_t *cent, int gunnerIndex);
bool CG_Vehicle_IsGunFiring(const centity_t *cent, int gunIndex);
void CG_Vehicle_RegisterMaterials();
void CG_Vehicle_UpdateEngine(;
void CG_Vehicle_UpdateMaterialTime(centity_t *cent, int dt, float speed);
void CG_VehicleDebug(centity_t *cent, const DObj *obj);
void CG_Vehicle_UpdateAntennas(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_Vehicle_UpdateMinigun(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_AllocClientVehicle(LocalClientNum_t localClientNum, const DObj *obj, centity_t *cent);
void CG_UpdateVehicleEngineSounds(;
void CG_UpdateVehicleTags(centity_t *ent);
void CG_TriggerLoopingVehFire(;
void CG_UpdateLoopingVehicleFireSounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateDriveBySounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_UpdateVehicleSounds(LocalClientNum_t localClientNum, centity_t *cent);
void CG_Vehicle_Init();
void CG_Vehicle_SetupCollisionCache(cg_t *cgameGlob, centity_t *cent, bool uses_vehicle_cache);
void CG_Vehicle_PreControllersAir(;
;
;

//t6/code/src_noserver/cgame/cg_vehicle_hud.cpp
void CG_TargetsChanged(LocalClientNum_t localClientNum, int num);
void CG_ParseAllTargets(LocalClientNum_t localClientNum);

//t6/code/src_noserver/cgame/cg_visionsets.cpp
void CG_RegisterVisionSetsDvars();
const char *RawBufferOpen(const char *path, const char *backupPath);
bool ApplyTokenToField(int fieldNum, const char *token, visionSetVars_t *settings);
bool LoadVisionSettingsFromBuffer(const char *buffer, const char *filename, visionSetVars_t *settings);
bool LoadVisionFile(const char *name, visionSetVars_t *resultSettings);
bool GetVisionSet(LocalClientNum_t localClientNum, const char *name, visionSetVars_t *resultSettings);
bool LerpBool(bool from, bool to, float fraction, visionSetLerpStyle_t style);
int LerpInteger(int from, int to, const float fraction, visionSetLerpStyle_t style);
float LerpStepFloat(float from, float to, const float fraction, visionSetLerpStyle_t style);
float LerpFloat(float from, float to, float fraction, visionSetLerpStyle_t style);
void LerpVec4(;
bool VisionSetCurrent(LocalClientNum_t localClientNum, visionSetMode_t mode, const char *name);
bool CG_VisionSetStartLerp_To(;
// char CG_VisionSetLerp_To@<al>(;
void SetDefaultVision(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_Naked(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_Night(LocalClientNum_t localClientNum);
void CG_VisionSetConfigString_LastStand(LocalClientNum_t localClientNum);
void CG_VisionSetMyChanges();
bool CG_InLastStandVision(const LocalClientNum_t localClientNum);
bool CG_InFlareVision(const LocalClientNum_t localClientNum);
char CG_LookingThroughNightVision(const LocalClientNum_t localClientNum);
void DrawVisionSetDebug(LocalClientNum_t localClientNum, visionSetMode_t curChannel);
void CG_VisionSetApplyToRefdef(LocalClientNum_t localClientNum, bool isExtracam);
void UpdateVarsLerpCustom(;
void UpdateVarsLerp(;
void CG_InitVisionSets(LocalClientNum_t localClientNum);
void CG_VisionSetsUpdate(LocalClientNum_t localClientNum);
bool LoadVisionFileForTweaks(visionSetVars_t *setVars);
void CG_VisionSetUpdateTweaksFromFile_Film();
void CG_VisionSetUpdateTweaksFromFile_CharPrimary();
void CG_VisionSetUpdateTweaksFromFile_Bloom();

//t6/code/src_noserver/cgame/cg_weapons.cpp
void CG_RegisterWeaponDvars();
float GetWeaponAnimRate(LocalClientNum_t localClientNum, const Weapon weapon, XAnim_s *anims, int animIndex);
float GetWeaponAnimTimeFrac(;
void StartWeaponAnim(;
// double StartCameraAnim@<st0>(;
void StopCameraAnim(DObj *obj);
void PlayIdleAnim(;
void PlayLeftIdleAnim(;
void PlayADSAnim(;
bool CG_JavelinADS(LocalClientNum_t localClientNum);
bool CG_UICheckWeapLockBlink(LocalClientNum_t localClientNum, float blinkPerSec);
bool CG_UICheckWeapLockAttackTop(LocalClientNum_t localClientNum);
bool CG_UICheckWeapLockAttackDirect(LocalClientNum_t localClientNum);
int CheckForValidAnimIDDW(int animID);
void EnsureValidLeftAnim(;
void WeaponRunXModelAnims(;
void CG_ResetWeaponAnimTrees(LocalClientNum_t localClientNum, const playerState_s *ps, int newPlayerstate);
int CG_WeaponDObjHandle(LocalClientNum_t localClientNum);
void CG_CreateWeaponViewModelXAnim(const char **animArray, const char **dwAnimArray, XAnim_s *pAnims);
Weapon RemoveAltAttachmentFromWeapon(const Weapon weapon);
void CG_CreateWeaponViewModelXAnimDefs(;
void CG_SetWeaponHidePartBits(const Weapon weapon, ViewModelInfo *viewModelInfo, DObj *obj, int modelNum);
void CG_FreeWeapons(LocalClientNum_t localClientNum);
void CG_RegisterWeapon(LocalClientNum_t localClientNum, Weapon weapon);
bool ShouldRebuildTree(;
char ShouldRebuildAnims(LocalClientNum_t localClientNum, const ViewModelInfo *viewModelInfo, Weapon weapon);
void PlayViewmodelAdsAnim(ViewModelInfo *viewModelInfo, Weapon weapon, int animIndex);
void PlayChangedViewmodelAdsAnim(;
bool ViewmodelRocketShouldBeAttached(LocalClientNum_t localClientNum, Weapon weapon);
XModel *CG_GetHandViewmodel(cg_t *cgameGlob);
void PlayNoteMappedSoundAliases(;
void ProcessWeaponNoteTracks(;
void CG_RegisterItems(LocalClientNum_t localClientNum);
void CalculateWeaponPostion_PositionToADS(cg_t *cgameGlob, playerState_s *ps);
void PlayWeaponFx(;
void WeaponFlash(;
void PlayWeaponContinuousFireFx(;
void CG_HoldBreathInit(cg_t *cgameGlob);
void HoldBreathUpdate(LocalClientNum_t localClientNum);
void ChargeShotUpdate(;
void CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum);
void CG_UpdateMinigunTurretSounds(;
void CG_UpdateJetgunSounds(;
void CG_UpdateMinigunSounds(;
void UpdateMinigunTag(;
void UpdateJetgunDialTags(;
void UpdateParalyzerDialTags(;
void CG_UpdateMinigunTags(cg_t *cgameGlob, centity_t *cent, const DObj *obj, int *partBits);
void CG_UpdateJetgunTags(;
void CG_UpdateViewModelMinigun(;
void CG_UpdateViewModelStackCounter(;
bool BulletTrace(;
bool IsEntityNotDoingClientSideBullets(LocalClientNum_t localClientNum, int entityNum);
bool CG_ShouldSimulateBulletFire(LocalClientNum_t localClientNum, BulletFireParams *bp);
bool CG_IsPlayerCrouching(clientInfo_t *ci, const centity_t *cent);
bool CG_IsPlayerADS(clientInfo_t *ci, const centity_t *cent);
void CG_GuessSpreadForWeapon(;
void RandomBulletDir(unsigned int *randSeed, float *x, float *y);
void CG_BulletEndpos(;
char CG_GetPlayerVehicleViewOrigin_Internal(;
void CG_GetPlayer3rdPersonVehicleViewOrigin(;
char CG_GetPlayerVehicleViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
void CG_GetPlayerViewDirection(;
bool CG_ShowWeaponFx(const cg_t *cgameGlob, centity_t *cent, int bViewModel);
void CG_Hack_TouchPlayerWeaponBones(LocalClientNum_t localClientNum, const cg_t *cgameGlob, centity_t *cent);
void CG_SetSonarAttachmentShaderConstants(LocalClientNum_t localClientNum, ShaderConstantSet *constantSet);
void Weapon_DrawAxisOrigin(orientation_t orient, float colorScale);
void Weapon_DrawTagAxis(LocalClientNum_t localClientNum, int entityNum, Weapon weapon, int bViewModel);
void Anim_DrawTags(LocalClientNum_t localClientNum, int entityNum, Weapon weapon, cpose_t *pose, int flags);
bool UpdateViewmodelAttachments(;
bool NeedToRebuildViewmodel(;
void CG_CalculateWeaponMovement_Landing(const cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_SaveOrigin(cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_Debug(const cg_t *cgameGlob, vec3_t *origin);
void CG_CalculateWeaponMovement_SaveAngles(cg_t *cgameGlob, vec3_t *angles, GfxScaledPlacement *placement);
void CG_CalculateWeaponMovement_ClientSpecific(;
void CG_BuildWeaponState(cg_t *cgameGlob, weaponState_t *ws);
void CG_SaveWeaponState(const weaponState_t *ws, cg_t *cgameGlob);
Weapon NextWeapInCycle(;
Weapon CG_GetLastWeaponForAlt(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
Weapon CG_GetAltWeapon(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
Weapon CG_AltWeaponToggleIndex(LocalClientNum_t localClientNum, const cg_t *cgameGlob, Weapon *primaryWeapon);
bool ShouldToggleWeaponAltMode(LocalClientNum_t localClientNum, const playerState_s *ps);
int CG_GetBrassTagForEvent(int event);
void CG_EjectWeaponBrass(;
void CG_VehicleJolt(centity_t *cent, vec3_t *origin, vec3_t *dir);
void CG_VehicleFire(centity_t *cent, const unsigned __int16 tagName);
bool CG_FireWeapon_LocalPlayerUsingVehicleWeapon(centity_t *cent, const playerState_s *ps, int event);
void CG_FireWeapon_VehicleFire(;
void CG_FireWeapon_OriginAndDirection(;
void SetWeaponFxFlags(centity_t *cent, bool leftGun, bool shellEject, bool lastShot);
void CG_FireWeapon_Rumble(;
void CG_HideVisibleAmmo(LocalClientNum_t localClientNum, centity_t *cent, const Weapon weapon);
void CG_SndWeaponFakeFire(snd_weapon_shot *shot, const WeaponDef *weaponDef);
void CG_SndWeaponFire(snd_weapon_shot *shot);
void CG_SndAutoSimReset();
void CG_SndPingAutoSim(snd_weapon_shot *shot);
void CG_SndKillAutoSimEnt(SndEntHandle ent);
// void CG_SndUpdateAutoSim(float a1@<ebx>);
void CG_WeaponFireSingle(;
void CG_WeaponFireFake(;
void CG_PullBackWeapon(;
cg_t *CG_GetLocalClientGlobalsForEnt(LocalClientNum_t localClientNum, int entityNum);
void CG_GetViewDirection(;
void CG_CalcEyePoint(LocalClientNum_t localClientNum, int entityNum, vec3_t *eyePos);
void CalcMuzzlePoint(LocalClientNum_t localClientNum, int entityNum, vec3_t *muzzle, unsigned int flashTag);
void CG_RandomEffectAxis(const vec3_t *forward, vec3_t *left, vec3_t *up);
void CG_ImpactEffectForWeapon(;
centity_t *CG_BulletHitEvent_FindPlayerCorpse(LocalClientNum_t localClientNum, centity_t *player);
bool CG_BulletHitDeployedDeployedRiotshield(;
void CG_DogBloodEvent(LocalClientNum_t localClientNum, int entnum, vec3_t *position, int boneIndex);
void CG_DeployRiotshieldEvent(LocalClientNum_t localClientNum);
bool CalcViewmodelHitPos(;
void CG_ViewmodelShieldHitStore(LocalClientNum_t localClientNum, unsigned int eventParm, bool damaged);
void CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum);
void CG_BulletHitClientShieldEvent(;
void CG_ExplosiveImpactOnShieldEvent(LocalClientNum_t localClientNum);
void CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage);
void CG_MeleeBloodEvent(LocalClientNum_t localClientNum, const centity_t *cent, int eventParm);
void CG_MeleeSwipeEvent(LocalClientNum_t localClientNum, const centity_t *cent);
void CG_SetBaseWeaponForStats(const WeaponVariantDef *weapVariantDef);
void CG_SetupWeaponDef();
Weapon ValidLatestPrimaryWeapon(const cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
char CG_ClearLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon weapon);
bool CG_SetLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon altWeapon, Weapon weapon);
bool CG_UpdateLastWeaponForAlt(cg_t *cgameGlob, const playerState_s *ps, Weapon oldweapon, Weapon weapon);
void CG_SelectWeaponIndex(LocalClientNum_t localClientNum, const playerState_s *ps, Weapon weapon);
void CG_SelectWeaponIndex(LocalClientNum_t localClientNum, Weapon weapon);
void CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum);
Weapon CG_GetPlayerTurretWeapon(LocalClientNum_t localClientNum);
Weapon CG_GetPlayerVehicleWeapon(const playerState_s *ps, const LocalClientNum_t localClientNum);
Weapon CG_GetPlayerMeleeWeapon(const playerState_s *ps);
Weapon CG_GetPlayerWeapon(const playerState_s *ps, const LocalClientNum_t localClientNum);
Weapon CG_GetClientWeapon(ClientNum_t clientNum, const LocalClientNum_t localClientNum);
bool CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum);
bool CG_PlayerUsingMouseToControlVehicle(LocalClientNum_t localClientNum);
bool CG_PlayerUsingHandbrakeInVehicle(LocalClientNum_t localClientNum);
float CG_GetPlayerVehicleHandbrakeTurnSpeedValue(LocalClientNum_t localClientNum);
void CG_ApplyWeaponTurnRateCap(LocalClientNum_t localClientNum);
void CG_MolotovFloat(LocalClientNum_t localClientNum, const centity_t *cent, const entityState_s *es);
Material *CG_GetWeaponOverlay(LocalClientNum_t localClientNum, Weapon weapon);
BOOL CG_IsInGuidedMissile(const playerState_s *ps);
int CG_IsInRemoteKillstreakStatic(const playerState_s *ps);
int CG_AirburstLazeCancelledByMovement(;
void CG_CheckForAirburstReset(cg_t *cgameGlob, const playerState_s *ps);
BOOL CG_IsClientControlledMissile(LocalClientNum_t localClientNum);
BOOL CG_IsAirborneKillstreak(LocalClientNum_t localClientNum);
Weapon CG_GetWeaponForName_Internal(const char *name);
Weapon CG_GetWeaponForName(const char *name);
DroppedWeaponDobjInfo *CG_AllocDroppedWeaponDobjInfo(LocalClientNum_t localClientNum, centity_t *cent);
void CG_FreeDroppedWeaponDobjInfo(LocalClientNum_t localClientNum, centity_t *cent);
int AddViewmodelWeaponAttachments(;
void ChangeViewmodelDobj(;
void CG_UpdateHandViewmodel_Internal(LocalClientNum_t localClientNum, Weapon weapon, XModel *handModel);
void CG_UpdateWeaponAndHandViewmodels(LocalClientNum_t localClientNum);
void CG_UpdateMinigunSpin(LocalClientNum_t localClientNum, cg_t *cgameGlob, centity_t *cent);
char CG_GetPlayerViewOrigin(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *origin);
char CG_PrepFireParams(;
Weapon CG_GetWeaponDefBasedOnNumberOfBullets(const cg_t *cgameGlob, int numBulletsQueued, Weapon weapon);
void CG_AddPlayerWeaponFx(;
void CG_AddPlayerWeapon(;
void CG_AddViewWeapon(LocalClientNum_t localClientNum);
bool CG_CancelOffhand(cg_t *cgameGlob);
bool WeaponCycleAllowed(cg_t *cgameGlob);
char VerifyPlayerAltModeWeapon(LocalClientNum_t localClientNum, Weapon weapon);
void CG_SwitchToLastValidPrimary(LocalClientNum_t localClientNum);
char CycleWeapPrimary(LocalClientNum_t localClientNum, int cycleForward, int bIgnoreEmpty);
void CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleForward);
bool ToggleWeaponAltMode(LocalClientNum_t localClientNum, bool adsOnly);
void CG_AdsAltWeaponDown(LocalClientNum_t localClientNum);
char CG_ActionSlot_SelectWeapon(const LocalClientNum_t localClientNum, Weapon weapon, bool checkMomentumCost);
void CG_FakeFireWeapon(;
void CG_BulletHitEvent_Internal(;
void CG_BulletHitEvent(;
void CG_BulletHitClientEvent(;
char CG_ScopeIsOverlayed(LocalClientNum_t localClientNum);
int CG_GetAirburstMarkDistance(;
void CG_WeaponMyChanges();
void CG_SimulateBulletFire_Effect(;
void CG_WeaponBounceShot(;
;
;
void CG_SimulateBullet(bullet_hit_info_t *results, const int max_results, int *num_results);
;
void __thiscall CG_NextWeapon_f(cg_t *this);
void __thiscall CG_PrevWeapon_f(cg_t *this);
void CG_OutOfAmmoChange(LocalClientNum_t localClientNum);
bool ActionSlotUsageAllowed(const cg_t *cgameGlob);
void CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot);
void CG_ActionSlotUp(LocalClientNum_t localClientNum);
char CG_SelectInventoryWeapon(const LocalClientNum_t localClientNum);
void TakeClipOnlyWeaponIfEmpty(LocalClientNum_t localClientNum, playerState_s *ps);
void CG_FireWeapon(;
void CG_UpdateViewWeaponAnim(LocalClientNum_t localClientNum, int newPlayerstate);
void CG_FireVehicleWeapon(;

//t6/code/src_noserver/cgame/cg_weapon_attachments.cpp
bool CG_RangeFinderEnabled(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
bool CG_RangeFinderChangeColor(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
void CG_InitRangeFinderParameters(LocalClientNum_t localClientNum);
;
unsigned int CG_DrawRangefinderHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawBallisticCpuHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawTacticalInsertionHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawBriefcaseBombHUD(LocalClientNum_t localClientNum);
unsigned int CG_DrawPDAHackerHUD(LocalClientNum_t localClientNum);
void CG_DrawWeaponDynamicTextures(LocalClientNum_t localClientNum);
;

//t6/code/src_noserver/cgame/cg_weapon_utils.cpp
unsigned __int16 G_GetWeaponAttachBone(clientInfo_t *ci, weapType_t weapType, weapInventoryType_t invType);
unsigned __int16 CG_AttachWeaponWorldModel(;

//t6/code/src_noserver/cgame/cg_world.cpp
int CG_GetEntityBModelContents(const centity_t *cent);
void CG_GetEntityDobjBounds(;
int CG_GetEntityDObjContents(const centity_t *cent, const DObj *dobj);
bool CG_EntityHasCollision(const centity_t *cent, DObj *dobj);
bool CG_EntityNeedsLinked(LocalClientNum_t localClientNum, int entIndex);
void CG_UnlinkEntity(LocalClientNum_t localClientNum, int entIndex);
;
bool CG_EntityInArea(int entIndex, const vec3_t *mins, const vec3_t *maxs, int contentMask);
void CG_AreaEntities_r(unsigned __int16 sectorIndex, CEntityAreaParms *areaParms);
int CG_AreaEntities(;
int cmpr(const void *e0, const void *e1);
int CG_GetEntityBoneInfo(int entID, int boneIndex, vec3_t *bonePos, vec3_t *boneAxis, const char **boneName);
void CG_GetEntityBModelBounds(;
void CG_LinkEntity(LocalClientNum_t localClientNum, int entIndex);
void CG_ClipMoveToEntity(const moveclip_t *clip, int entIndex, trace_t *results);
void CG_ClipMoveToEntities_r(;
void CG_ClipMoveToEntities(const moveclip_t *clip, trace_t *results);
void CG_PointTraceToEntity(const pointtrace_t *clip, int entIndex, trace_t *results);
void CG_PointTraceToEntities_r(;
void CG_PointTraceToEntities(const pointtrace_t *clip, trace_t *results, col_context_t *context);
;
void CG_LocationalTrace(;
;
;
void CG_TraceCapsule(;

//t6/code/src_noserver/cgame/offhandweapons.cpp
bool IsOffHandDisplayVisible(LocalClientNum_t localClientNum, const cg_t *cgameGlob);
int CalcOffHandAmmo(const playerState_s *predictedPlayerState, int weaponType);
void OffHandFlash(const cg_t *cgameGlob, const vec4_t *base_color, vec4_t *out_color);
void CG_DrawOffHandHighlight(;
void CG_DrawOffHandAmmo(;
void CG_DrawOffHandName(;
void CG_PrepOffHand(;
void CG_UseOffHand(LocalClientNum_t localClientNum, const centity_t *cent, Weapon weapon, bool isPlayerView);
void CG_SetEquippedOffHand(LocalClientNum_t localClientNum, Weapon offHandWeapon);
void CG_DrawOffHandIcon(;
void CG_SwitchOffHandCmd(LocalClientNum_t localClientNum);

