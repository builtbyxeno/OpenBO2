#pragma once

#include "types.h"

//t6/code/src_noserver/bgame/bg_actor.cpp
int BG_Actor_GetAnimStateIndex(unsigned __int16 animStateName);
char *BG_Actor_GetAnimStateName(int animStateIndex);
char *BG_Actor_GetAnimStateCategoryName(int animStateIndex);
void BG_Actor_FastForwardAnimState(;
void BG_Actor_GetAnimState(entityState_s *es, int *animState, int *animSubState);
void BG_Actor_SetAnimState(entityState_s *es, int animState, int animSubState);
bool BG_Actor_ApplyNewAnimState(XAnimTree_s *pAnimTree, actorLerpFrame_t *lf, int newAnimationState);
void BG_Actor_UpdateAnimationState(;
XAnim_s *BG_Actor_GetAnims();
void BG_Actor_CreateAnims(void *(*xanimAlloc)(int));
void BG_Actor_ShutdownAnims();

//t6/code/src_noserver/bgame/bg_actor_dog.cpp
void BG_Dog_SetNewAnimationState(;
void BG_Dog_UpdateAnimationState(;

//t6/code/src_noserver/bgame/bg_actor_dog_animations_mp.cpp
XAnim_s *Dog_GetAnims();
void Dog_CreateAnims(void *(*xanimAlloc)(int));
void Dog_ShutdownAnims();
void BG_Dog_GetRunAnimWeights(float leanAmount, float *center, float *left, float *right);
void BG_Dog_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Clear_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Init_Normal_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Init_Attack_Look_At(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Start(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Stop(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Think(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Walk_Think(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Clear_All_Turns(DObj *obj);
void BG_Dog_Move_Turn_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Turn_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Turn_Around_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Turn_Around_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Around_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run_Turn_Around_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Stop_Init(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Stop_Idle(LocalClientNum_t localClientNum, const entityState_s *es, ActorAnimStates prevState);
void BG_Dog_Stop_AttackIdle(;
void BG_Dog_Stop_AttackIdle_Bark(;
void BG_Dog_Stop_AttackIdle_Growl(;
void BG_Dog_Pain_Main(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Front(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Back(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Pain_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Front(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Back(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Run_Pain_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Front(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Back(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Death_Fast_Forward_Front(;
void BG_Dog_Death_Fast_Forward_Back(;
void BG_Dog_Death_Fast_Forward_Left(;
void BG_Dog_Death_Fast_Forward_Right(;
void BG_Dog_Flashed(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_AttackIdle(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_AttackIdle_Bark(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_AttackIdle_Growl(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Run(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Player_Close_Range(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Miss(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Miss_Left(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Combat_Attack_Miss_Right(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Clear_Traverse_Anims(;
void BG_Dog_Traverse_Jump_Up_40(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Jump_Up_80(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Jump_Down_40(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Jump_Down_80(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Wallhop(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Window(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Traverse_Through_Hole_42(LocalClientNum_t localClientNum, const entityState_s *es);
void BG_Dog_Move_Run(LocalClientNum_t localClientNum, const entityState_s *es, ActorAnimStates prevState);
void BG_Dog_Move_Walk(LocalClientNum_t localClientNum, const entityState_s *es, ActorAnimStates prevState);

//t6/code/src_noserver/bgame/bg_actor_prone.cpp
int BG_ActorIsProne(actor_prone_info_s *pInfo, int iCurrentTime);
double BG_GetActorProneFraction(actor_prone_info_s *pInfo, int iCurrentTime);

//t6/code/src_noserver/bgame/bg_animation.cpp
const char *BG_GetPlayerAnimScriptFileName();
void TRACK_bg_animation_mp();
int BG_StringHashValue(const char *fname);
void BG_AnimParseError(const char *msg, ...);
unsigned int BG_AnimationIndexForString(const char *string);
int BG_IndexForString(const char *token, animStringItem_t *strings, int allowFail);
char *BG_CopyStringIntoBuffer(const char *string, char *buffer, unsigned int bufSize, unsigned int *offset);
void BG_InitWeaponString(int index, const char *name);
void BG_InitWeaponStrings();
void BG_AddVehicleName(const char *vehName, int vehType, int drivers, int gunners, int passengers);
unsigned int BG_AnimGetConditionValue(animScriptItem_t *scriptItem, int conditionIndex);
int BG_GetVehicleAnimSetIndex(unsigned __int16 animSetStr);
void BG_SetupAnimNoteTypes(animScriptData_t *scriptData);
void BG_SetAnimConditionFlags(int condIndex, unsigned int result);
void BG_ParseConditionBits(;
int BG_ParseConditions(const char **text_pp, animScriptItem_t *scriptItem);
void BG_ParseCommands(const char **input, animScriptItem_t *scriptItem, animScriptData_t *scriptData);
const char *GetWeaponTypeName(int type);
int GetValueForBitfield(unsigned int bitfield);
const char *BG_GetConditionString(int condition, int value);
int BG_EvaluateConditions(clientInfo_t *ci, animScriptItem_t *scriptItem);
animScriptItem_t *BG_FirstValidItem(int client, animScript_t *script);
animScriptCommand_t *BG_AnimScriptEventGetCommand(;
void BG_SetConditionBit(ClientNum_t client, int condition, int value);
unsigned int BG_GetConditionValue(const clientInfo_t *ci, const int condition);
int BG_GetConditionBit(const clientInfo_t *ci, const int condition);
Weapon BG_GetPlayerStateWeapon(const pmove_t *pm);
Weapon BG_GetNextPlayerStateWeapon(const pmove_t *pm);
void BG_AnimUpdatePlayerStateConditions(pmove_t *pmove);
int BG_IsCrouchingAnim(const clientInfo_t *ci, int animNum);
int BG_IsProneAnim(const clientInfo_t *ci, int animNum);
int BG_IsKnifeMeleeAnim(const clientInfo_t *ci, int animNum);
BOOL BG_IsSliding(const clientInfo_t *ci);
void BG_SetNewAnimation(;
void BG_RunLerpFrameRate(;
void BG_PlayerAnimation_VerifyAnim(XAnimTree_s *pAnimTree, lerpFrame_t *lf);
void BG_SwingAngles(;
void BG_PlayerAngles(LocalClientNum_t localClientNum, const entityState_s *es, clientInfo_t *ci);
void BG_Player_DoControllersInternal(;
void BG_Player_DoControllersSetup(const entityState_s *es, clientInfo_t *ci, int frametime);
void BG_PlayerAnimation(;
void BG_UpdatePlayerDObj(;
void BG_FindAnims();
scr_animtree_t BG_FindAnimTree(const char *filename, int bEnforceExists);
void BG_FindAnimTrees();
void BG_ResetAnimSpeeds();
void BG_SetSAnimSpeed(int handle, float rate);
double BG_GetSAnimSpeed(int handle);
void BG_SetCAnimSpeed(int handle, float rate);
double BG_GetCAnimSpeed(int handle);
void BG_AnimParseAnimScript(;
const char *BG_GetCurrentMoveStatus(playerState_s *ps);
int BG_PlayAnim(;
int BG_ExecuteCommand(;
int BG_AnimScriptAnimation(pmove_t *pm, aistateEnum_t state, scriptAnimMoveTypes_t movetype, int force);
int BG_AnimScriptEvent(;
void BG_SetConditionValue(ClientNum_t client, int condition, unsigned __int64 value);
unsigned __int16 BG_AddWorldModelWeaponAttachments(;
unsigned __int16 BG_AttachWeaponStowedModel(;
void BG_LoadAnim(const char *levelName, bool canModifyChecksum);
void BG_FinalizePlayerAnims(const char *levelName);
void BG_PostLoadAnim(const char *levelName);

//t6/code/src_noserver/bgame/bg_animconditions.cpp
void BG_LocalEvalPlayerAnimType(pmove_t *pm);
void BG_EvalPlayerAnimType(const entityState_s *es);
void BG_LocalEvalNextPlayerAnimType(pmove_t *pm);
void BG_LocalEvalWeaponClass(pmove_t *pm);
void BG_EvalWeaponClass(const entityState_s *es);
void BG_LocalEvalNextWeaponClass(pmove_t *pm);
void BG_LocalEvalMounted(pmove_t *pm);
void BG_EvalMounted(const entityState_s *es);
void BG_LocalEvalMoveStatus(pmove_t *pm);
void BG_EvalMoveStatus(const entityState_s *es);
void BG_LocalEvalPrevDirection(pmove_t *pm);
void BG_LocalEvalDirection(pmove_t *pm);
void BG_EvalDirection(const entityState_s *es);
void BG_LocalEvalDmgDirection(pmove_t *pm);
void BG_EvalDmgDirection(const entityState_s *es);
void BG_LocalEvalDmgType(pmove_t *pm);
void BG_LocalEvalStance(pmove_t *pm);
void BG_EvalStance(const entityState_s *es);
void BG_LocalEvalUnderhand(pmove_t *pm);
void BG_EvalUnderhand(const entityState_s *es, const clientInfo_t *ci);
void BG_EvalFiring(const entityState_s *es);
void BG_LocalEvalWeaponPosition(pmove_t *pm);
void BG_EvalWeaponPosition(const entityState_s *es);
void BG_LocalEvalSlope(pmove_t *pm);
void BG_EvalSlope(const entityState_s *es);
void BG_LocalEvalPerk(pmove_t *pm);
void BG_LocalEvalAttachment(pmove_t *pm);
void BG_LocalEvalRiotShieldNext(pmove_t *pm);
void BG_LocalEvalVehicleName(pmove_t *pm);
void BG_LocalEvalVehicleSeatTo(pmove_t *pm);
void BG_LocalEvalEvent(pmove_t *pm);
void BG_LocalEvalFiring(pmove_t *pm);

//t6/code/src_noserver/bgame/bg_animstatedef.cpp
;
void BG_AnimStateDef_Precache(int aiIndex, scr_animtree_t animtree, unsigned __int16 animStateDefName);
void BG_AnimStateDef_ParseError(const char *filename, const char *msg);
void BG_AnimStateDef_ValidateAgainstPropertyNames(;
void BG_AnimStateDef_SetFlag(AnimState *state, int flag);
void BG_AnimStateDef_TokenizeNotify(AnimState *state, const char **data_p, char *token, const char *filename);
void BG_AnimStateDef_Parse(AnimStateDef *def);
void BG_AnimStateDef_Load_Internal(AnimStateDef *def, void *(*animStateDefAlloc)(int));
// void BG_AnimStateDef_Load(void *(*a1)(int)@<edx>, void *(*animStateDefAlloc)(int));
AnimStateDef *BG_AnimStateDef_GetDefFromEntityState(const entityState_s *es);
unsigned __int16 BG_AnimStateDef_GetAnimIndex(const entityState_s *es);
bool BG_AnimStateDef_GetFlag(const entityState_s *es, int flag);
unsigned __int16 BG_AnimStateDef_GetNotify(const entityState_s *es);
void BG_AnimStateDef_SetNewAnimationState(;
void BG_AnimStateDef_Update(LocalClientNum_t localClientNum, const entityState_s *es, actorInfo_t *actorInfo);
unsigned __int16 BG_AnimStateDef_GetName(const entityState_s *es);
XAnim_s *BG_AnimStateDef_GetAnims(const entityState_s *es);
bool BG_AnimStateDef_IsMissingLegs(const entityState_s *a1, int a2);
unsigned __int16 BG_AnimStateDef_GetCurrentStateName(const entityState_s *es);
int BG_AnimStateDef_GetCurrentSubStateIndex(const entityState_s *es);
float BG_AnimStateDef_GetCurrentAnimTime(const entityState_s *es, XAnimTree_s *tree);
int BG_AnimStateDef_GetAnimIndex(;
int BG_AnimStateDef_GetAnimStateIndex(const entityState_s *es, unsigned __int16 stateName);
int BG_AnimStateDef_GetAnimSubStateCount(const entityState_s *es, unsigned __int16 stateName);
int BG_AnimStateDef_GetAnimSubStateIndex(;
void BG_AnimStateDef_GetCurrentStateInfo(;
void BG_AnimStateDef_Shutdown();

//t6/code/src_noserver/bgame/bg_attachments_load_obj.cpp
int Attachment_GetStringArrayIndex(const char *value, const char **stringArray, int arraySize);
// int BG_ParseAttachmentSpecificFieldType@<eax>(;
WeaponAttachment *BG_LoadDefaultWeaponAttachment_LoadObj();
WeaponAttachment *BG_LoadDefaultWeaponAttachment_FastFile();
WeaponAttachment *BG_LoadDefaultWeaponAttachment();
char BG_AttachmentUpdateField(const char *attachmentName, const char *keyValue);

//t6/code/src_noserver/bgame/bg_attachments_unique_load_obj.cpp
void SetConfigString(char **ppszConfigString, const char *pszKeyValue);
void SetConfigString2(char **a1, const char *a2);
// int BG_ParseAttachmentUniqueSpecificFieldType@<eax>(;
int WeaponAttachmentUnique_GetSoundOverrideFieldOffset(eAttachmentOverrideSounds overrideField);
int WeaponAttachmentUnique_GetEffectOverrideFieldOffset(eAttachmentOverrideEffects overrideField);
char BG_AttachmentUniqueUpdateField(const char *attachmentName, const char *keyValue);
void SetConfigString(char **ppszConfigString, const char *pszKeyValue);

//#include "bgame/bg_attachment_load_db.h"

//#include "bgame/bg_attachment_unique_load_db.h"

//t6/code/src_noserver/bgame/bg_clientfields.cpp
int BG_GetFieldOffset(const NetField *pFields, int numFields, const char *pName);
void BG_InitClientFields();
void BG_ShutdownClientFields();
int BG_SortClientFields(const void *arg0, const void *arg1);
int BG_GetClientFieldSetFromSetName(const char *pSetName);
const char *BG_GetClientFieldSetName(int system);
unsigned int BG_GetClientFieldTypeFromTypeName(unsigned __int16 typeName);
void BG_ReportClientFieldAllocation();
void BG_ReportClientFields(const char *pMsg);
unsigned int BG_GetClientFieldsHash();
unsigned int BG_GetClientFieldsHighestVersionUsed();
unsigned int BG_BuildHashFromClientFieldSystem(bgsClientFields_s *pSys);
void BG_RemoveObsoleteClientFields();
void BG_PerformClientFieldSort();
unsigned int BG_GetClientFieldVersion(const char *pSetName, const char *pFieldName);
void BG_AllocateBitSpaceToFields();
void BG_FinalizeClientFieldRegistration();
clientField_s *BG_GetClientField(int system, const char *pFieldName, bool bErrorIfNotFound);
void BG_AddClientfieldCodeCallback(;
void BG_AddClientfieldCodeCallback(;
clientField_s *BG_RegisterClientFieldInternal(;
void BG_RegisterClientField(;
void BG_RegisterClientField(;
unsigned int BG_GetClientFieldIntVal(int system, const char *pFieldName, void *pData);
void BG_SetClientFieldIntVal(int system, clientField_s *pField, void *pData, int val);
double BG_GetClientFieldFloatValInternal(clientField_s *pField, unsigned int val);
double BG_GetClientFieldFloatVal(int system, const char *pFieldName, void *pData);
void BG_SetClientFieldFloatVal(int system, clientField_s *pField, void *pData, float val);
void BG_ReportPendingClientfieldCallbackEvents(LocalClientNum_t localClientNum);
void BG_AddClientfieldCallbackEvent(;
void BG_AddClientfieldCallbackEvent(;
void BG_ExecuteClientFieldCallbacks(LocalClientNum_t localClientNum);
void BG_ProcessClientFieldSet(;

//#include "bgame/bg_common_load_db.h"

//t6/code/src_noserver/bgame/bg_dtp.cpp
void Dtp_RegisterDvars();
int Dtp_CalcSurfaceType(pmove_t *pm, pml_t *pml);
BOOL Dtp_IsSliding(const playerState_s *ps);
void Dtp_AdjustDamage(const playerState_s *ps, float fallHeight, int *damage);
void Dtp_Start(pmove_t *pm, pml_t *pml, float _height);
void Dtp_Interrupt(pmove_t *pm);
void Dtp_CheckForEnd(pmove_t *pm);
void Dtp_AirMove(playerState_s *ps, const pmove_t *pm);
BOOL Dtp_CanMove(pmove_t *pm);
;
int Dtp_IsDtp(const pmove_t *pm, const playerState_s *ps);
int Dtp_Update(pmove_t *pm, pml_t *pml);

//t6/code/src_noserver/bgame/bg_emblems.cpp
int BG_EmblemsGetUnlockedLayerCount(ControllerIndex_t controllerIndex);
EmblemLayer *BG_EmblemsGetLayerCost(int layer);
int BG_EmblemsGetLayerUnlockLevel(int layer);
int BG_EmblemsGetPurchasedLayerCount(ControllerIndex_t controllerIndex);
int ResultSort(const void *a, const void *b);
int BG_EmblemsGetIconCost(__int16 id);
int BG_EmblemsGetIconUnlockLevel(__int16 id);
int BG_EmblemsGetIconUnlockPLevel(__int16 id);
int BG_EmblemsGetIconUnclassifyAt(__int16 id);
const vec4_t *BG_EmblemsGetIconDefaultColor(const vec4_t *result, __int16 id);
double BG_EmblemsGetIconOutlineSize(__int16 id);
bool BG_EmblemsCheckDLCLocked(emblemChallengeLookup_t *challengeLookup);
char BG_EmblemsIsIconLocked(ControllerIndex_t controllerIndex, __int16 id);
bool BG_EmblemsIsIconPurchased(ControllerIndex_t controllerIndex, __int16 id);
void BG_EmblemsCheckEmblemAndBackingUnlocks(const ControllerIndex_t controllerIndex);
EmblemBGCategory *BG_EmblemsGetCategoryCount();
const GfxViewParms *BG_EmblemsGetCategoryDesc(int index);
EmblemIcon *BG_EmblemsGetBackgroundCount();
__int16 BG_EmblemsGetBackgroundID(int index);
int BG_EmblemsGetBackgroundIndex(__int16 id);
int BG_EmblemsGetBackgroundCost(__int16 id);
int BG_EmblemsGetBackgroundUnlockLevel(__int16 id);
int BG_EmblemsGetBackgroundUnlockPLevel(__int16 id);
int BG_EmblemsGetBackgroundUnclassifyAt(__int16 id);
EmblemIcon *BG_EmblemsGetBackgroundMaterial(__int16 id);
int BG_EmblemsGetBackgroundMTXIndex(__int16 id);
bool BG_EmblemsIsBackgroundMTX(__int16 id);
bool BG_EmblemsIsBackgroundPurchased(ControllerIndex_t controllerIndex, __int16 id);
GfxColor *BG_GetSwatchColorByIndex(int rowNumber, int columnNumber);
emblemChallengeLookup_t *BG_EmblemGetChallengeLookup(__int16 emblemIndex);
emblemChallengeLookup_t *BG_EmblemBackingGetChallengeLookup(__int16 backingIndex);
void BG_EmblemsClearDefaults();
void BG_EmblemsSetDefaultForLevel(int minlevel, int maxlevel, CompositeEmblemLayer *s_emblem, int layerCount);
void BG_EmblemsGenerateDefault(;
bool BG_EmblemsIsIconHidden(ControllerIndex_t controllerIndex, __int16 id);
int BG_EmblemsGetPurchasedBackgroundCount(ControllerIndex_t controllerIndex);
const char *BG_EmblemsGetBackgroundDesc(ControllerIndex_t controllerIndex, __int16 id);
const char *BG_EmblemsGetBackgroundUnlockDesc(ControllerIndex_t controllerIndex, __int16 id);
bool BG_EmblemsIsBackgroundClassified(ControllerIndex_t controllerIndex, __int16 id);
ResultCache *BG_EmblemsGetResults(;
int BG_EmblemsGetIconCount(;
__int16 BG_EmblemsGetIconID(;
const char *BG_EmblemsGetIconDesc(ControllerIndex_t controllerIndex, __int16 id);
const char *BG_EmblemsGetIconUnlockDesc(ControllerIndex_t controllerIndex, __int16 id);
bool BG_EmblemsIsIconClassified(ControllerIndex_t controllerIndex, __int16 id);
char BG_EmblemsIsBackgroundLocked(ControllerIndex_t controllerIndex, __int16 id);

//#include "bgame/bg_emblems_load_db.h"

//t6/code/src_noserver/bgame/bg_faction.cpp
void BG_FactionData_Clear();
void BG_FactionData_GetTeamColor(team_t team, vec4_t *out);
const char *BG_GetTeamName(const team_t team);
bool BG_IsTeamBased();
const char *BG_GetFactionForTeam(const team_t team, const char *mapName);
char BG_GetFactionColor(const char *factionName, vec4_t *out);
void BG_FactionData_Init(const char *mapName);

//t6/code/src_noserver/bgame/bg_helicopter.cpp
void BG_HeliCmdScale(bool scaleMovement, const char *move, vec4_t *outFracs);
void BG_HeliCalcAccelFromTilt(;
void BG_HelicopterHeightTrace(;
void BG_HelicopterGroundTrace(;
int BG_VehicleHeliLockHeight(VehicleState *vehicleState);
void BG_CalculateRotorArms(;
void BG_HeliCalcAccel(;
void BG_HeliMaintainHeight_UpdateHeight(pmove_t *pm, const pml_t *pml, VehicleState *vehicleState);
void BG_PlayerStateToVehicleStateHelicopter(;
;
char BG_VehicleHelicopterVerticalMove(pmove_t *pm, const pml_t *pml, VehicleState *vehicleState);
;

//t6/code/src_noserver/bgame/bg_jump.cpp
void Jump_RegisterDvars(int a1, dvarType_t a2);
double Jump_GetHeight();
void Jump_ClearState(playerState_s *ps);
char Jump_GetStepHeight(playerState_s *ps, const vec3_t *origin, float *stepSize);
BOOL Jump_IsPlayerAboveMax(playerState_s *ps);
void Jump_ActivateSlowdown(playerState_s *ps);
void Jump_ApplySlowdown(playerState_s *ps);
float Jump_GetSlowdownFriction(playerState_s *ps);
// float Jump_ReduceFriction@<st0>(playerState_s *a1@<ecx>, int a2@<xmm0>, playerState_s *ps);
void Jump_ClampVelocity(playerState_s *ps, const vec3_t *origin);
float Jump_GetLandFactor(playerState_s *ps);
void Jump_Start(pmove_t *pm, pml_t *pml, float height);
void Jump_PushOffLadder(playerState_s *ps, pml_t *pml, pmove_t *pm);
void Jump_AddSurfaceEvent(playerState_s *ps, pml_t *pml);
// char Jump_Check@<al>(pmove_t *a1@<edi>, pmove_t *pm, pml_t *pml);

//t6/code/src_noserver/bgame/bg_mantle.cpp
void Mantle_RegisterDvars();
void Mantle_DebugPrint(const char *msg);
int Mantle_GetUpLength(const MantleState *mstate);
int Mantle_GetOverLength(const MantleState *mstate);
int Mantle_GetAnim(MantleState *mstate);
void Mantle_GetAnimDelta(MantleState *mstate, int time, vec3_t *delta);
int Mantle_FindTransition(float curHeight, float goalHeight);
void Mantle_SetHaveWeapon(MantleState *mstate, const playerState_s *ps);
void Mantle_Start(pmove_t *pm, playerState_s *ps, MantleResults *mresults);
bool Hatch_FindHatchSurface(;
void Mantle_CreateAnims(void *(*xanimAlloc)(int));
void Mantle_ShutdownAnims();
bool Mantle_FindMantleSurface(pmove_t *pm, pml_t *pml, trace_t *trace, vec3_t *mantleDir);
void Mantle_Move(pmove_t *pm, playerState_s *ps, pml_t *pml);
void Mantle_CapView(playerState_s *ps);
void Mantle_ClearHint(playerState_s *ps);
bool Mantle_IsWeaponInactive(const playerState_s *ps);
BOOL Mantle_IsWeaponEquipped(const playerState_s *ps);
BOOL Mantle_DoAnim(const playerState_s *ps);
int __thiscall Mantle_GetDuration(const MantleState *this);
double Mantle_GetMantleFrac(const playerState_s *ps);
bool Mount_CanPlayerDeployTurret(playerState_s *ps);
;
;
;
;
char Hatch_CheckHatch(pmove_t *pm, pml_t *pml);
;
;

//t6/code/src_noserver/bgame/bg_misc.cpp
void BG_RegisterDvars(int a1, dvarType_t a2);
double BG_GetFallDamageMaxHeight();
double BG_GetFallDamageMinHeight();
double BG_GetSprintSpeedScale();
bool BG_GetSprintUnlimited();
double BG_GetSprintMinTime();
double BG_GetSprintStrafeSpeedScale();
double BG_GetFriction();
char *BG_GetEntityTypeName(const int eType);
Weapon G_FindItem(const char *pickupName);
char HaveRoomForAmmo(const playerState_s *ps, const Weapon weapon);
bool BG_PlayerCanPickUpWeaponType(const WeaponDef *weapDef, const playerState_s *ps);
bool WeaponEntCanBeGrabbed(;
BOOL BG_CanItemBeGrabbed(const entityState_s *ent, const playerState_s *ps, int touched);
BOOL BG_PlayerHasRoomForEntAllAmmoTypes(const entityState_s *ent, const playerState_s *ps);
// void BG_EvaluateTrajectoryInternal(float a1@<ebx>, const trajectory_t *tr, int atTime, vec3_t *result);
// void BG_EvaluateTrajectoryDelta(float a1@<edi>, const trajectory_t *tr, int atTime, vec3_t *result);
bool BG_ValidateOrigin(const vec3_t *pos, unsigned int xyBits, unsigned int zBits, const vec3_t *mapCenter);
bool BG_ValidateOrigin(int a1, unsigned int a2);
bool BG_ValidateZOriginValue(const float val, const float mapCenterValue);
void BG_PlayerToEntitySetPitchAngles(playerState_s *ps, entityState_s *s);
void BG_PlayerToEntitySetTrajectory(playerState_s *ps, entityState_s *s, int snap);
void BG_GetPlayerViewDirection(const playerState_s *ps, vec3_t *forward, vec3_t *right, vec3_t *up);
void BG_GetPlayerGunDirection(;
void BG_ApplyLinkAngles(const vec3_t *linkAngles, vec3_t *viewangles);
void BG_LerpFontScale(const hudelem_s *elem, int time, float *toScale);
void BG_LerpHudColors(const hudelem_s *elem, int time, hudelem_color_t *toColor);
int BG_LoadShellShockDvars(const char *name);
void BG_SetShellShockParmsFromDvars(shellshock_parms_t *parms);
int BG_SaveShellShockDvars(const char *name);
shellshock_parms_t *BG_GetShellshockParms(const int index);
BOOL BG_IsShellshockAnim(const playerState_s *ps);
void BG_CreateXAnim(XAnim_s *anims, unsigned int animIndex, const char *name);
void BG_CheckThread();
int BG_GetMaxSprintTime(const playerState_s *ps);
bool BG_ClipMoveToDobj(const entityState_s *es);
int BG_GetFriendlyFireStatus();
const char *BG_DisplayName(const clientInfo_t *ci, int type);
void BG_UpdateClientControlledMissile(vec3_t *angles, const usercmd_s *cmd, int msec);
unsigned __int8 BG_ShieldHitEncode(const vec3_t *hitPos, bool fromTheFront);
void BG_ShieldHitDecode(unsigned int encoded, vec3_t *result, bool *resultHitFront);
void BG_ShieldHitDecode(unsigned int encoded, int *segY, int *segZ, bool *resultHitFront);
void BG_ClipCameraToHeliPatch(vec3_t *origin, vec3_t *oldpos, vec3_t *velocity, vec3_t *breachPos);
BOOL BG_PlayerTouchesItem(const playerState_s *ps, const entityState_s *item, int atTime);
void BG_AddPredictableEventToPlayerstate(int newEvent, unsigned int eventParm, playerState_s *ps);
void BG_AddUnpredictableEventToPlayerstate(int newEvent, unsigned int eventParm, playerState_s *ps);
void BG_AddEntityStateEvent(int newEvent, unsigned int eventParm, entityState_s *es, const int eventTime);
void BG_AddSentinelEventToEntityState(entityState_s *es, const int eventTime);
void BG_PlayerToEntityProcessEvents_Internal(;
void BG_PlayerToEntityProcessEvents(playerState_s *ps, entityState_s *s, unsigned __int8 handler);
void BG_PlayerToEntitySetMisc(playerState_s *ps, entityState_s *s);
void BG_PlayerStateToEntityState(;
;
void BG_GetPlayerViewOrigin(const playerState_s *ps, vec3_t *origin, int time);

//t6/code/src_noserver/bgame/bg_misctables.cpp
int VEH_ParseSpecificField(;
void TRACK_bg_misctables();

//t6/code/src_noserver/bgame/bg_mover.cpp
bool entity_is_a_mover(const int entnum, const int max_ents);
// void __thiscall mover_info_t::init(mover_info_t *this, const vec3_t *origin, const vec3_t *angles, int time);
// void __thiscall mover_info_t::add_record(mover_info_t *this, const vec3_t *origin, const vec3_t *angles, int time);
// void __thiscall mover_info_t::get_position(mover_info_t *this, int time, vec3_t *origin, vec3_t *angles);
// void sv_rewind_context_t::~sv_rewind_context_t(sv_rewind_context_t *this@<ecx>, int a2@<ebp>);
// void actors_rewind_context_t::restore(actors_rewind_context_t *this@<ecx>, int a2@<ebp>);
int get_entity_mover(gentity_t *ent);
void RestoreMovers(unsigned __int8 handler, LocalClientNum_t localClientNum, bool doLink);
mover_info_t *cl_get_mover_info(centity_t *ent);
mover_info_t *sv_get_mover_info(gentity_t *ent);
// void mover_info_t::apply_rotation(mover_info_t *this@<ecx>, int a2@<ebp>, vec3_t *v);
// void mover_info_t::apply_rotation_translation(mover_info_t *this@<ecx>, int a2@<ebp>, vec3_t *v);
void AdjustMovers(unsigned __int8 handler, LocalClientNum_t localClientNum, int time, bool doLink);
;
void cl_destroy_mover_info(void *mi_);
void cl_mover_info_level_init(LocalClientNum_t localClientNum);
mover_info_t *cl_create_mover_info(centity_t *ent);
void sv_destroy_mover_info(void *mi_);
void sv_mover_info_level_init();
void sv_destroy_mover_info(gentity_t *ent);
mover_info_t *sv_update_mover_info(gentity_t *ent, vec3_t origin, vec3_t angles, int time);
void mover_info_apply_rotation(const int gentnum, vec3_t *v);
void mover_info_apply_rotation_xy(const int gentnum, vec2_t *v);
void mover_info_apply_rotation_translation(const int gentnum, vec3_t *v);
// void __thiscall sv_rewind_context_t::sv_rewind_context_t(;
// void __thiscall actors_rewind_context_t::rewind(;

//#include "bgame/bg_mover.h"

//t6/code/src_noserver/bgame/bg_perks.cpp
void Perks_CalculateStringHashes();
unsigned int BG_GetPerkIndexForName(const char *perkName);
const char *BG_GetPerkNameForIndex(unsigned int perkIndex);
void Perks_RegisterDvars(int a1, dvarType_t a2);
char BG_WeaponHasPerk(Weapon weapon, unsigned int perkIndex);

//#include "bgame/bg_perks.h"

//t6/code/src_noserver/bgame/bg_pmove.cpp
float PM_GetMoveSpeedScale(pmove_t *pm, const WeaponDef *weapDef);
void PM_AddEvent(playerState_s *ps, int newEvent);
void PM_AddTouchEnt(pmove_t *pm, int entityNum);
void PM_AddTouchGlass(pmove_t *pm, int glassId);
void PM_ClipVelocity(const vec3_t *in, const vec3_t *normal, vec3_t *out);
void PM_ProjectVelocity(const vec3_t *velIn, const vec3_t *normal, vec3_t *velOut);
int PM_GetEffectiveStance(const playerState_s *ps);
int PM_GetSprintLeft(const playerState_s *ps, const int gametime);
bool PM_IsSprinting(const playerState_s *ps);
void PM_StartSprint(playerState_s *ps, pmove_t *pm, const pml_t *pml, int sprintLeft);
void PM_UpdateVisionAnims(pmove_t *pm, pml_t *pml);
void PM_UpdateScriptedAnim(pmove_t *pm, pml_t *pml);
int PM_GetEntityOrigin(;
BOOL PM_GetEntityVelocity(;
float PM_GetMeleeChargeFriction(pmove_t *pm, pml_t *pml);
void PM_Friction(playerState_s *ps, pml_t *pml, pmove_t *pm);
void PM_Accelerate(playerState_s *ps, const pml_t *pml, vec3_t *wishdir, float wishspeed, float accel);
void PM_DoSlideAdjustments(playerState_s *ps, const pml_t *pml);
float PM_MoveScale(playerState_s *ps, float fmove, float rmove, float umove);
float PM_CmdScale(playerState_s *ps, usercmd_s *cmd);
double PM_DamageScale_Walk(int damage_timer);
void PM_SetMovementDir(pmove_t *pm, pml_t *pml);
unsigned int PM_GroundSurfaceType(playerState_s *ps, pml_t *pml);
void PM_DeadMove(playerState_s *ps, pml_t *pml);
int PM_FootstepType(pmove_t *pm, pml_t *pml);
int PM_DamageLandingForSurface(playerState_s *ps, pml_t *pml);
void PM_CrashLand(pmove_t *pm, pml_t *pml);
int PM_GetWaterLevel(const playerState_s *ps, float waterHeight);
void PM_SetWaterLevel(pmove_t *pm);
int PM_GetViewHeightLerpTime(const playerState_s *ps, int iTarget, int bDown);
float PM_ViewHeightTableLerp(int iFrac, viewLerpWaypoint_s *pTable, int lowVal, int highVal);
void PM_ViewHeightAdjust(pmove_t *pm, pml_t *pml);
bool PlayerProneAllowed(pmove_t *pm);
bool PM_IsPlayerFrozenByWeapon(const playerState_s *ps);
bool PM_ShouldLeaveStanceAlone(const playerState_s *ps);
void PM_FootstepEvent(pmove_t *pm, pml_t *pml, int iOldBobCycle, int iNewBobCycle, int bFootStep);
BOOL PM_ShouldMakeFootsteps(pmove_t *pm);
int PM_Footsteps_TurnAnim(pmove_t *pm, clientInfo_t *ci);
int PM_ShouldFlinch(playerState_s *ps);
bool PM_Footstep_LadderMove(pmove_t *pm, pml_t *pml);
void PM_Footsteps_NotMoving(pmove_t *pm, pml_t *pml, int stance);
scriptAnimMoveTypes_t PM_GetMoveAnim(;
void PM_Footstep_NotTryingToMove(pmove_t *pm, pml_t *pml);
void PM_VehicleDrive(pmove_t *pm, pml_t *pml);
int BG_CalcBob(pmove_t *pm, pml_t *pml, int old, float bobmove);
void PM_ApplyMovementAnimations(;
void PM_ApplyLegAnimations(;
float PM_CalcPlayerPitch(playerState_s *ps, pml_t *pml);
bool PM_IsInAir(pmove_t *pm, pml_t *pml);
void PM_DropTimers(playerState_s *ps, pml_t *pml);
int BG_CheckProneTurned(playerState_s *ps, float newProneYaw, unsigned __int8 handler);
void PM_UpdateViewLockedEnt(;
void PM_UpdateViewAngles_Clamp(playerState_s *ps, usercmd_s *cmd, unsigned __int8 handler);
void PM_UpdateViewAngles_RangeLimited(playerState_s *ps);
void PM_UpdateViewAngles_LadderClamp(playerState_s *ps);
void PM_UpdateViewAngles_ProneYawClamp(;
void PM_UpdateViewAngles_PronePitchClamp(playerState_s *ps);
void PM_UpdateViewAngles_Prone(;
BOOL PM_ViewRangeLimited(const playerState_s *ps);
// void PM_UpdatePronePitch(unsigned int ebp0@<ebp>, pmove_t *pm, pml_t *pml);
void PM_SetProneMovementOverride(playerState_s *ps);
void PM_ClearLadderFlag(playerState_s *ps);
void PM_MeleeChargeClear(playerState_s *ps);
float PM_GetMeleeChargeYaw(pmove_t *pm);
bool PM_MeleeChargeIsValid(pmove_t *pm, pml_t *pml);
// void PM_MeleeChargeStart(pml_t *a1@<edx>, pmove_t *a2@<ecx>, pmove_t *pm, pml_t *pml);
bool PM_IsValidCharge(pmove_t *pm);
void PM_MeleeChargeCatchupVelocity(pmove_t *pm, pml_t *pml);
void PM_MeleeChargeUpdate(pmove_t *pm, pml_t *pml);
void PM_MeleeChargeCheck(pmove_t *pm);
bool PM_MeleeChargeMove_IsActive(pmove_t *pm);
void PM_MeleeChargeMove(pmove_t *pm, pml_t *pml);
void ClearPlayerVelocity(playerState_s *ps);
void PM_UpdatePush(pmove_t *pm, pml_t *pml);
void BG_seedRandWithGameTime(unsigned int *pHoldrand);
unsigned int BG_rand(unsigned int *pHoldrand);
int BG_irand(int min, int max, unsigned int *pHoldrand);
double BG_random(unsigned int *pHoldrand);
void PM_trace(;
int PM_GetSprintLeftLastTime(const playerState_s *ps);
void PM_EndSprint(playerState_s *ps, pmove_t *pm, const pml_t *pml);
char PM_SprintStartInterferingButtons(;
float PM_CmdScaleForStance(const pmove_t *pm);
bool PM_SprintEndingButtons(const pmove_t *pm);
float PM_CmdScale_Walk(pmove_t *pm, usercmd_s *cmd);
void PM_FlyMove(pmove_t *pm, pml_t *pml);
void PM_NoclipMove(pmove_t *pm, pml_t *pml);
void PM_UFOMove(pmove_t *pm, pml_t *pml);
float PM_GetMaxSpeed(pmove_t *pm, int walking, int sprinting);
// void PM_Footsteps(int a1@<esi>, pmove_t *pm, pml_t *pml);
;
void PM_UpdateViewAngles(;
void PM_UpdatePlayerWalkingFlag(pmove_t *pm);
void PM_WeaponThrustCheck(pmove_t *pm, pml_t *pml);
void TurretNVGTrigger(pmove_t *pm);
void BG_srand(unsigned int *pHoldrand);
void PM_playerTrace(;
;
bool PM_CanCrouch(playerState_s *ps, pmove_t *pm);
bool PM_CanStand(playerState_s *ps, pmove_t *pm);
void PM_UpdateSprint(pmove_t *pm, const pml_t *pml);
void PM_SwimMove(pmove_t *pm, pml_t *pml);
int PM_CorrectAllSolid(pmove_t *pm, pml_t *pml, trace_t *trace);
;
;
;
;
void PM_CheckLadderMove(pmove_t *pm, pml_t *pml);
void PM_AirMove(pmove_t *pm, pml_t *pml);
void PM_WalkMove(pmove_t *pm, pml_t *pml);
void PM_LadderMove(pmove_t *pm, pml_t *pml);
void PmoveSingle(pmove_t *pm);
void Pmove_1(pmove_t *pm);
void Pmove(pmove_t *pm);

//#include "bgame/bg_public.h"

//t6/code/src_noserver/bgame/bg_scriptmoveranim.cpp
void BG_ScriptMoverAnim_Shutdown();
void BG_ScriptMoverAnim_UseAnimTree(scr_animtree_t animtree);
int BG_ScriptMoverAnim_FindAnimTree(XAnimTree_s *tree);
void BG_ScriptMoverAnim_ClearServerEntity(gentity_t *ent);
void BG_ScriptMoverAnim_SetupServerEntity(;
void BG_ScriptMoverAnim_UpdateClientAnimation(LocalClientNum_t localClientNum, centity_t *cent);

//t6/code/src_noserver/bgame/bg_slidemove.cpp
gjk_polygon_cylinder_t *create_gjkcc_gjk_geom(;
// void gjkcc_info::update_cg(;
// bool __thiscall gjk_double_sphere_t::is_foot(gjk_double_sphere_t *this, const phys_vec3 *hit_point);
// bool __thiscall gjk_polygon_cylinder_t::is_foot(gjk_polygon_cylinder_t *this, const phys_vec3 *hit_point);
// bool __thiscall gjk_brush_t::is_walkable(gjk_brush_t *this, const phys_vec3 *hit_point, const phys_vec3 *up);
// bool __thiscall gjk_partition_t::is_walkable(gjk_partition_t *this, const phys_vec3 *hit_point, const phys_vec3 *up);
char gjk_collide(;
void init_pgi(phys_gjk_input *pgi, const gjk_trace_input_t *gti);
void sort_gi_list(gjk_geom_info_t **list, const int list_count);
char is_sentient(gjk_geom_info_t *gi);
char no_push_out(const gjk_trace_output_t *gto);
int PM_VerifyPronePosition(pmove_t *pm, vec3_t *vFallbackOrg, vec3_t *vFallbackVel);
double PM_PermuteRestrictiveClipPlanes(;
void setup_player_gjk_slide_move_input(;
// gjkcc_info *__thiscall gjkcc_info_database_t::gjkcc_info_find(;
// bool gjk_cylinder_t::is_foot@<al>(gjk_cylinder_t *this@<ecx>, float a2@<ebp>, const phys_vec3 *hit_point);
void setup_query_input(;
void setup_trace_info(;
// ;
void gjk_trace(const gjk_trace_input_t *gti, list_gjk_trace_output *list);
void add_hit_info(;
// bool gjk_push_out@<al>(;
// BOOL gjk_slide_move1@<eax>(;
BOOL gjk_slide_move(;
void gjk_sentient_push(;
;
// void render_gjkcc_collision(int a1@<esi>, pmove_t *pm);
void PM_gjk_ground_trace(;
;
;
void gjkcc_epilog(const gjkcc_input_t *gjkcc_in, const vec3_t *origin);
void gjk_player_trace(;
// gjkcc_info *__thiscall gjkcc_info_database_t::create_gjkcc_info(;
void destroy_gjkcc_info(void *gcci_);
// gjkcc_info *__thiscall gjkcc_info_database_t::gjkcc_info_find_or_create(;
// void __thiscall gjkcc_info_database_t::gjkcc_info_destroy(;
// void __thiscall gjkcc_info_database_t::gjkcc_info_destroy_all(gjkcc_info_database_t *this, const bool is_server_thread);
void destroy_client_gjkcc_info(LocalClientNum_t localClientNum);
void destroy_all_server_gjkcc_info();
void gjkcc_prolog(const gjkcc_input_t *gjkcc_in, const vec3_t *origin);

//t6/code/src_noserver/bgame/bg_unlockable_items.cpp
void BG_UnlockablesBuildUnlockMapping(const char *unlockMappingTableName);
int BG_UnlockablesGetUnlockIndexFromGroup(itemGroup_t group);
int BG_UnlockablesGetUnlockIndexFromName(const char *name);
const char *BG_UnlockablesGetUnlockLocString(int unlockIndex);
unsigned int BG_UnlockablesGetCurrentUnlocks(const ControllerIndex_t controllerIndex, int unlockIndex);
int BG_UnlockablesSpendUnlocks(const ControllerIndex_t controllerIndex, int unlockIndex, int cost);
void BG_UnlockablesSetItemIndex(;
void BG_UnlockablesSetGlobalItemIndex(const CACRoot *cacRoot, loadoutSlot_t loadoutSlot, int itemIndex);
void BG_UnlockablesSetLoadoutItem(const CACRoot *cacRoot, int customClass, int loadoutSlot, int itemIndex);
int BG_UnlockablesGetGlobalItemIndex(const CACRoot *cacRoot, loadoutSlot_t loadoutSlot);
int BG_UnlockablesGetItemIndex(;
// int BG_UnlockablesGetLoadoutItem@<eax>(;
void BG_UnlockablesEquipClassToSlot(;
const CACRoot *BG_UnlockablesGetLocalCACRoot(;

//t6/code/src_noserver/bgame/bg_unlockable_items_mp.cpp
const char *BG_UnlockablesGetLoadoutSlotName(loadoutSlot_t loadoutSlot);
int FindEntryInList(const char *stringEntry, const char **textArray, int numEntries);
int BG_UnlockablesCompareItemsBySortKey(const void *arg0, const void *arg1);
int BG_UnlockablesIsItemAttachmentValid(itemInfo_t *itemInfo, eAttachment attachment);
bool BG_UnlockablesIsGrenadeOrEquipment(itemInfo_t *itemInfo);
bool BG_UnlockablesIsPrimaryOrSecondary(itemInfo_t *itemInfo);
void BG_UnlockablesParseDefaultClassesForItem(;
void BG_UnlockablesParseAttachmentsForItem(itemInfo_t *itemInfo, const char *attachmentList);
itemInfo_t *BG_UnlockablesGetItemInfo(int itemIndex);
int BG_GetSpecialtyCollectionCount();
loadoutSlot_t BG_SpecialtyCollectionLoaoutSlot(int collectionIndex);
bool BG_HasSpecialtyCollection(int collectionIndex, unsigned int *perks);
// int BG_UnlockablesGetItemGroupFromName@<eax>(;
// int BG_UnlockablesGetClassIndexFromName@<eax>(;
int BG_UnlockablesGetBonusCardNameHashFromIndex(bonusCards_t bonusCard);
bonusCards_t BG_UnlockablesGetBonusCardIndexFromNameHash(int bonusCardNameHash);
void BG_UnlockablesBuildBonusCardNameHash();
const char *BG_UnlockablesGetNameForClass(loadoutClass_t customClass);
const char *BG_UnlockablesGetItemGroupName(itemGroup_t groupIndex);
int BG_UnlockablesCompareGunLevelRows(const void *a, const void *b);
gunLevelRow_t *BG_UnlockablesGetGunLevelRowForChallenge(int itemIndex, int currentXP);
void BG_UnlockablesHashItemGroupNames();
bool BG_UnlockablesAllItemsFree();
bool BG_UnlockablesAllItemsUnlocked();
char __thiscall BG_UnlockablesBuildClanTagFeatureRows(const StringTable *this);
unsigned int BG_UnlockablesGetEquippedClanTagFeatureIndex(const ControllerIndex_t controllerIndex);
const GfxViewParms *BG_UnlockablesGetClanTagFeature(unsigned int index, clanTagFeatureColumn_t column);
int BG_UnlockablesGetClanTagFeaturePLvlUnlock(unsigned int index);
bool BG_UnlockablesIsClanTagFeatureLocked(const ControllerIndex_t controllerIndex, unsigned int index);
bool BG_UnlockablesIsClanTagFeaturePurchased(const ControllerIndex_t controllerIndex, unsigned int index);
int BG_UnlockablesGetItemAttachmentNumWithAttachPoint(int itemIndex, int attachmentNum, int attachmentPoint);
int BG_UnlockablesIsItemAttachmentValid(int itemIndex, eAttachment attachment);
int BG_UnlockablesGetItemAttachmentIndexForAttachmentPoint(;
itemInfo_t *__thiscall BG_UnlockablesGetItemRefHash(void *this);
int __thiscall BG_UnlockablesGetItemCount(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemUnlockLevel(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemUnlockPLevel(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemMomentumCost(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetItemAllocationCost(void *this);
itemInfo_t *__thiscall BG_UnlockablesGetRealItemCost(void *this);
int __thiscall BG_UnlockablesGetItemCost(void *this);
int __thiscall BG_UnlockablesGetItemDualWieldCost(void *this);
int __thiscall BG_UnlockablesGetItemDualWieldIndex(void *this);
int __thiscall BG_UnlockablesGetItemDualWieldBaseIndex(void *this);
int BG_UnlockablesGetNumItemAttachmentsWithAttachPoint(int itemIndex, int attachPoint);
int __thiscall BG_UnlockablesGetNumItemAttachments(void *this);
int BG_UnlockablesGetNumItemAttachmentsAtPoint(int itemIndex, eAttachmentPoint point);
eAttachment BG_UnlockablesGetItemAttachmentAtPointByIndex(;
const char *__thiscall BG_UnlockablesGetItemGroup(void *this);
int __thiscall BG_UnlockablesGetItemGroupEnum(void *this);
// int BG_UnlockablesGetLoadoutSlotFromString@<eax>(;
int __thiscall BG_UnlockablesGetItemLoadoutSlot(void *this);
bool BG_UnlockablesIsItemLockedForRank(int pLevel, int rank);
bool BG_UnlockablesIsPrestigeTokenSpent(unsigned __int8 *buffer, int pLevel);
bool BG_UnlockablesSpendPrestigeToken(unsigned __int8 *buffer);
int BG_UnlockablesGetPrestigeTokenTypeFromBuffer(unsigned __int8 *buffer, int pLevel);
char BG_UnlockablesIsItemPermanentlyUnlockedFromBuffer(unsigned __int8 *buffer, int itemIndex);
bool BG_UnlockablesIsItemLockedFromBuffer(unsigned __int8 *buffer, int itemIndex);
unsigned __int8 __thiscall BG_UnlockablesGetItemDLCIndex(void *this);
char BG_UnlockablesIsItemDLCAvailable(const ControllerIndex_t controllerIndex);
bool __thiscall BG_UnlockablesItemHasDualWield(void *this);
bool __thiscall BG_UnlockablesItemIsDualWield(void *this);
bool BG_UnlockablesIsItemValidNotNull(int itemIndex);
bool BG_UnlockablesSetItemPurchased(;
int BG_UnlockablesGetCustomClassCountFromBuffer(unsigned __int8 *buffer);
bool BG_UnlockablesIsItemPublicPurchasedFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
bool BG_UnlockablesIsItemPurchasedFromBuffer();
void BG_UnlockablesSetPurchasedBits(unsigned __int8 *statsBuffer, unsigned __int8 *purchasedItems);
BOOL BG_UnlockablesGetItemAttachmentAllocationCost(int itemIndex, int attachmentNum);
int BG_UnlockablesGetItemAttachmentXPInternal(itemInfo_t *itemInfo, int attachmentNum);
int BG_UnlockablesGetItemAttachmentXP(int itemIndex, int attachmentNum);
unsigned int BG_UnlockablesGetGunXPFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
unsigned int BG_UnlockablesGetGunPLevelFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
void BG_UnlockablesSetGunXp(const ControllerIndex_t controllerIndex, const int itemIndex, const int gunXP);
void BG_UnlockablesSetGunXPCmd();
void BG_UnlockablesSetAllGunXPToMaxCmd();
bool BG_UnlockablesIsItemAttachmentLockedFromBuffer(;
bool BG_UnlockablesIsItemAttachmentLocked(;
int BG_SetBonusCardInUse(;
BOOL BG_GetBonusCardInUse(;
BOOL BG_AnyBonusCardInUse(;
int BG_UnlockablesGetStatPathForChallenge(;
bool ChallengeLockedByXPGroup(const ControllerIndex_t controllerIndex, challengeTableRow_t *challengeRow);
bool BG_UnlockablesItemOptionLockedByChallenge(;
bool BG_UnlockablesItemOptionLocked(const ControllerIndex_t controllerIndex, int itemIndex, int optionIndex);
bool BG_UnlockablesEmblemIsElite(int emblemIndex);
void BG_UnlockablesEquipClassSpecialPropertiesToSlot(;
const char *BG_UnlockablesGetWeaponOptionRef(;
int BG_UnlockablesGetLocalEquippedItemInSlot(;
int BG_UnlockablesGetDefaultItem(int loadoutSlot);
int BG_UnlockablesGetDefaultWeaponItem();
void BG_UnlockablesEquipDefaultClass(;
void BG_UnlockablesEquipDefaultCustomMatchClassCmd();
void BG_UnlockablesEquipDefaultLeagueClassCmd();
void BG_UnlockablesEquipDefaultClassCmdInternal(;
void BG_UnlockablesEquipDefaultClassCmd();
void BG_UnlockablesEquipDefaultClassToProfileCmd();
void BG_UnlockablesUIEquipDefaultClassCmd();
void BG_UnlockablesZeroClassSet(;
void BG_UnlockablesZeroClassSetCmdInternal(;
void BG_UnlockablesZeroPublicMatchClassSetCmd();
void BG_UnlockablesZeroCustomMatchClassSetCmd();
void BG_UnlockablesZeroLeagueMatchClassSetCmd();
void BG_UnlockablesCopyToClassSet(;
void BG_UnlockablesCopyToClassSetCmdInternal(;
void BG_UnlockablesCopyToPublicMatchClassSetCmd();
void BG_UnlockablesCopyToCustomMatchClassSetCmd();
void BG_UnlockablesCopyToLeagueMatchClassSetCmd();
void BG_UnlockablesSetClassSetNameFromLocStringCmdInternal(;
void BG_UnlockablesSetPublicMatchClassSetNameFromLocStringCmd();
void BG_UnlockablesSetCustomMatchClassSetNameFromLocStringCmd();
void BG_UnlockablesSetLeagueMatchClassSetNameFromLocStringCmd();
bool BG_UnlockablesGetClassSetsDDLState(ddlState_t *ddlState, int specificGameMode);
// int BG_UnlockablesGetDefaultClassSlotIndexFromName@<eax>(;
int BG_UnlockablesBuildItemListForGroup(itemGroup_t group);
void BG_UnlockablesBuildItemListForGroupCmd();
int BG_UnlockablesBuildItemListForGroupForWeaponTable(itemGroup_t group);
void BG_UnlockablesBuildItemListForGroupForWeaponTableCmd();
void BG_UnlockablesCopyClassSection(;
void BG_UnlockablesCopyClassCmd();
void BG_UnlockablesSetClanTagCmd();
void BG_UnlockablesClearWeaponInfo(;
int BG_UnlockablesGetBonusCardSet(const ControllerIndex_t controllerIndex, const loadoutClass_t customClass);
int BG_UnlockablesGetItemEquipCount(;
// int BG_UnlockablesGetAllocationCost@<eax>(;
// int BG_UnlockablesGetUsedAllocation@<eax>(;
void BG_UnlockablesGetBonusCardSetCmd();
void BG_UnlockablesGetUsedAllocationCmd();
int BG_UnlockablesGetItemsByGroup(itemGroup_t group, unsigned __int8 *buffer, unsigned int bufferSize);
void BG_PerformPushItem_ToCACMPShared(int numItemsInSlot, int itemNum, void *param);
// char validateCACStatus_s::ValidateClass_NoDuplicateCards(;
// char validateCACStatus_s::ValidateClass_NoDuplicates(;
// char validateCACStatus_s::ValidateClass_HasBonusCard(;
// char __thiscall validateCACStatus_s::verifyUnusedAttachmentSlotsCheck(;
// void __thiscall validateCACStatus_s::Print(validateCACStatus_s *this);
// void __thiscall validateCACStatus_s::Initialize(;
const char *BG_UnlockablesGetColStringForItemIndex(int itemIndex, statsTableColumns_t column);
loadoutSlot_t BG_UnlockablesGetCountSlot(itemInfo_t *itemInfo);
void BG_UnlockablesHandleDefaultGrenadeStatus(;
bool BG_UnlockablesIsPrimaryOrSecondaryFromIndex(int itemIndex);
void BG_UnlockablesParseDLCInfo(const char *dlcInfo, itemInfo_t *itemInfo);
char BG_UnlockablesIsMaxLevelFromBuffer(unsigned __int8 *statsBuffer, int itemIndex);
const char *BG_UnlockablesGetItemName(int a1, statsTableColumns_t a2);
const char *BG_UnlockablesGetItemRef(int a1, statsTableColumns_t a2);
const char *BG_UnlockablesGetItemImage(int a1, statsTableColumns_t a2);
bool __thiscall BG_UnlockablesDLCWeaponDisabled(void *this);
const char *BG_UnlockablesGetItemDesc(int a1, statsTableColumns_t a2);
bool BG_UnlockablesIsItemLocked(const ControllerIndex_t controllerIndex, int itemIndex);
bool BG_UnlockablesIsItemDualWieldLocked(const ControllerIndex_t controllerIndex);
// char BG_UnlockablesIsItemTrackedByMap@<al>(;
bool BG_UnlockablesIsItemNew(const ControllerIndex_t controllerIndex, int itemIndex);
char BG_UnlockablesIsItemGroupNew(;
bool BG_UnlockablesIsItemPurchased(const ControllerIndex_t controllerIndex, int itemIndex);
bool BG_UnlockablesIsItemDualWieldPurchased(const ControllerIndex_t controllerIndex);
void BG_UnlockablesSetBonusCardBits(;
bool BG_UnlockablesEmblemOrBackingLockedByChallenge(;
bool BG_UnlockablesEmblemLockedByChallenge(ControllerIndex_t controllerIndex, int emblemIndex);
bool BG_UnlockablesEmblemBackingLockedByChallenge(ControllerIndex_t controllerIndex, int backingIndex);
int BG_UnlockablesGetItemIndexFromName(const char *itemName);
// int BG_UnlockablesGetItemIndexFromRefHash@<eax>(;
int BG_UnlockablesGetItemIndexFromRef(const char *itemName);
int BG_UnlockablesGetItemIndexforWeapon(Weapon weapon);
void BG_UnlockablesClearItemNew(ControllerIndex_t controllerIndex, int itemIndex);
void BG_UnlockablesClearAllItemsNew(ControllerIndex_t controllerIndex);
void BG_UnlockablesEquipClass(ControllerIndex_t controllerIndex, loadoutClass_t customClass, int itemIndex);
bool BG_UnlockablesIsItemEquipped(ControllerIndex_t controllerIndex, loadoutClass_t customClass, int itemIndex);
void BG_UnlockablesEquipClassCmd();
void BG_UnlockablesEquipDefaultItemToSlotCmd();
// const char *BG_UnlockablesGetDefaultClassSlotFromName@<eax>(;
void BG_UnlockablesClearItemNewCmd();
void BG_UnlockablesClearAllItemsNewCmd();
int BG_UnlockablesGetNumPurchasedItemsInCurrentList(const ControllerIndex_t controllerIndex);
int BG_UnlockablesBuildItemListForSlotName(const ControllerIndex_t controllerIndex, const char *slotName);
void BG_UnlockablesBuildItemListForSlotNameCmd();
int BG_UnlockablesBuildItemListForGroupName(const ControllerIndex_t controllerIndex, const char *groupName);
void BG_UnlockablesBuildItemListForGroupNameCmd();
int BG_UnlockablesBuildItemListForSlotNameAndGroup(;
void BG_UnlockablesBuildItemListForSlotNameAndGroupCmd();
int BG_UnlockablesGetItemIndexInSlot(int itemNum);
bool BG_UnlockablesBonusCardEquipAction(;
bool BG_UnlockablesIsBonusCardInSet(const int cardSet, const char *cardName);
void BG_UnlockablesIsBonusCardInSetCmd();
void BG_UnlockablesEquipBonusCardCmd();
void BG_UnlockablesUnequipBonusCardCmd();
void BG_UnlockablesPushItemsByGroupName(;
// char validateCACStatus_s::ValidateClass_ByGroupSearch(;
// int __thiscall validateCACStatus_s::ValidateClass_GetNumItemAttachments(;
// bool __thiscall validateCACStatus_s::ValidateClass_BonusCard_PrerequisitesAndRules(;
// void validateCACStatus_s::ValidateClass_BonusCards(validateCACStatus_s *this, loadoutSlot_t a2);
// bool __thiscall validateCACStatus_s::ValidateClass_AdditionalGrenadeCheck(;
// void validateCACStatus_s::ValidateClass_Grenade(validateCACStatus_s *this, loadoutSlot_t a2, int slotIndex);
// void validateCACStatus_s::ValidateClass_Specialties(validateCACStatus_s *this, loadoutSlot_t a2);
// void validateCACStatus_s::ValidateClass_KillStreaks(validateCACStatus_s *this, loadoutSlot_t a2);
// void validateCACStatus_s::ValidateClass_BaseWeapon(;
// bool validateCACStatus_s::ValidateClass_Attachments_CheckMaxAllowed(;
// void validateCACStatus_s::ValidateClass_VerifyNoAttachments(;
// char validateCACStatus_s::Verify(;
bool BG_UnlockablesCheckItemsInClass(;
char BG_Unlockable_CheckLoadOutVsRank(unsigned __int8 *buffer);
void BG_UnlockablesBuildDefaultClasses(defaultClassInfo_t *defaultClassInfoTable);
void BG_UnlockablesParseDualWieldInfo(itemInfo_t *itemInfo);
void BG_UnlockablesParseSpecialtyInfo(itemInfo_t *itemInfo);
// const char *BG_GetSpecialtyCollectionImageName@<eax>(statsTableColumns_t a1@<edx>, int collectionIndex);
// const char *BG_GetSpecialtyCollectionName@<eax>(statsTableColumns_t a1@<edx>, int collectionIndex);
void BG_UnlockablesBuildGunLevels();
bool BG_UnlockablesIsItemInUnlockedByCAC(int itemIndex);
bool BG_UnlockablesBuildItemInfo(;
unsigned int BG_UnlockablesBuildActualDefaultItems();
unsigned int BG_UnlockablesBuildDefaultItems();
void BG_InitUnlockables();
eAttachment BG_UnlockablesGetItemAttachment(int itemIndex, int attachmentNum);
void BG_UnlockablesPurchaseItem(const ControllerIndex_t controllerIndex, int itemIndex, int cost);
const char *BG_UnlockablesGetItemAttachmentRef(int itemIndex, int attachmentNum);
void BG_UnlockablesPurchaseItemCmd();
void BG_UnlockablesSetUnlockedAttachmentBits(;
// const char *BG_UnlockablesGetAttachmentRef@<eax>(;
// const char *BG_UnlockablesGetItemReferenceInLoadoutSlot@<eax>(;
// void validateCACStatus_s::ValidateClass_WeaponOption(;
// char __thiscall validateCACStatus_s::ValidateClass_NoConflictingAttachments(;
// void validateCACStatus_s::ValidateClass_Attachments(;
// bool validateCACStatus_s::Validate(;
void BG_UnlockablesValidateClassCmd();
void BG_UnlockableItemsInit();

//t6/code/src_noserver/bgame/bg_vehicle.cpp
VehicleDef *BG_GetVehicleDef(int index);
BOOL BG_IsVehicleAircraftRemote(const VehicleDef *info);
bool BG_VehicleUsesCylinderGJK(const VehicleDef *vehDef);
bool BG_VehicleUsesGJK(const VehicleDef *vehDef);
PhysGeomList *G_VEH_GetCollmap(LocalClientNum_t localClientNum, const int entNum);
PhysGeomList *CG_VEH_GetCollmap(LocalClientNum_t localClientNum, const int entNum);
// colgeom_visitor_inlined_t<300> *G_GetVehicleProximityCache(;
// colgeom_visitor_inlined_t<300> *CG_GetVehicleProximityCache(;
VehicleDef *G_GetVehicleDef(LocalClientNum_t localClientNum, const playerState_s *ps);
VehicleDef *CG_GetVehicleDef(LocalClientNum_t localClientNum, const playerState_s *ps);
int CG_GetWheelOrigin(const pmove_t *pm, int wheelIndex, vec3_t *result);
int G_GetWheelOrigin(const pmove_t *pm, int wheelIndex, vec3_t *result);
const VehicleDef *BG_GetVehicleDef(const pmove_t *pm);
int BG_GetWheelOrigin(const pmove_t *pm, int wheelIndex, vec3_t *result);
void BG_GetVehicleBounds(const pmove_t *pm, vec3_t *mins, vec3_t *maxs);
void BG_VehicleClipVelocity(const vec3_t *velocity, const vec3_t *normal, vec3_t *clippedVelocity);
;
void BG_PlayerStateToVehicleState(;
;
void BG_VehicleGroundTrace(pmove_t *pm, VehicleState *vehicleState, GroundTrace *groundTrace);
;
;
void BG_VehicleGroundMove(;
;
;
void BG_VehicleMove(pmove_t *pm, const pml_t *pml);

//#include "bgame/bg_vehicleinfo_db.h"

//#include "bgame/bg_vehicleinfo_load_db.h"

//t6/code/src_noserver/bgame/bg_vehicleinfo_load_obj.cpp
void VEH_Strcpy(unsigned __int8 *pMember, const char *pKeyValue);
void InitVehicle(VehicleDef *vehicleDef);
// VehicleDef *VehicleDefLoadFile@<eax>(FsThread a1@<edi>, const char *name, void *(*Alloc)(int));
VehicleDef *VehicleDefPrecache(const char *name, void *(*Alloc)(int));
VehicleDef *VehicleDef_Register_FastFile(const char *name);
unsigned __int8 *Hunk_AllocVehicleDefPrecache(int size);
VehicleDef *VehicleDef_Register_LoadObj(const char *name);
VehicleDef *VehicleDef_Register();
void VehicleDef_PostLoadFixUp(VehicleDef *vehicleDef);

//t6/code/src_noserver/bgame/bg_vehicles_mp.cpp
unsigned __int16 BG_VehiclesGetSlotTagName(int seatIndex);

//t6/code/src_noserver/bgame/bg_vehicle_anim.cpp
void VehAnim_RegisterDvars();
void VehAnim_Init();
void VehAnim_GetAnimDelta(XAnimTree_s *tree, int animIndex, vec4_t *rot, vec3_t *trans);
void VehAnim_UpdatePosRot(;

//t6/code/src_noserver/bgame/bg_vehicle_csptable.cpp
void TRACK_bg_vehicle_csptable();

//t6/code/src_noserver/bgame/bg_weapons.cpp
void BG_ParsePenetrationDepthTable(const char *penetrateType, float *depthTable, const char *buffer);
void BG_LoadPenetrationDepthTable();
bool BG_AdvanceTrace(BulletFireParams *bp, BulletTraceResults *br, float dist);
double BG_GetSurfacePenetrationDepth(PenetrateType penetrateType, int surfaceType);
void PM_StartWeaponAnim(playerState_s *ps, int anim, int leftAnim);
void PM_ContinueWeaponAnim(playerState_s *ps, int anim, int leftAnim);
const char *BG_GetImpactTypeName(int impactTypeIndex);
Weapon BG_GetFirstEquippedOffhand(const playerState_s *ps, int offhandSlot);
int *BG_GetWeaponState(playerState_s *ps, bool leftGun);
BOOL BG_IsAimDownSightWeapon(const Weapon weapon);
BOOL BG_IsAdsOnlyWeaponChange(Weapon oldWeapon, Weapon newWeapon);
bool BG_CanPlayerHaveWeapon(const Weapon weapon);
BOOL BG_ValidateWeaponNumber(const Weapon weapon);
bool BG_IsWeaponValid(const playerState_s *ps, const Weapon weapon);
bool BG_WeaponBlocksProne(const Weapon weapon);
bool BG_IsOverheatingWeapon(const Weapon weapon);
bool BG_IsBayonetWeapon(const Weapon weapon);
char BG_IsUseAsMeleeWeapon(const Weapon weapon);
void BG_TakeHeldWeapon(playerState_s *ps, const Weapon weapon);
bool PM_IsAdsAllowed(pmove_t *pm, pml_t *pml);
void PM_ExitAimDownSight(playerState_s *ps);
int PM_Weapon_GetMaxChargeLevelForClipAmmo(playerState_s *ps, Weapon weapon);
double BG_GetChargeShotWeaponCenterSpeed(const playerState_s *ps, const Weapon weapon);
void PM_UpdateQuickScope(pmove_t *pm, pml_t *pml, float oldWeaponFrac);
BOOL BG_UsingSniperScope(const playerState_s *ps);
int BG_UsingTacticalInsertion(const playerState_s *ps);
BOOL BG_UsingVariableZoomWeapon(const playerState_s *ps);
BOOL BG_UsingVariableZoomScope(const playerState_s *ps);
bool BG_PlayerWeaponOverheating(const playerState_s *ps, const Weapon weapon);
double BG_PlayerWeaponOverheatPercent(const playerState_s *ps, const Weapon weapon);
void BG_PlayerWeaponOverheatUpdate(playerState_s *ps, const Weapon weapon, float amount);
int PM_IsWeaponMinFireTimeElapsed(playerState_s *ps, bool leftGun);
void BG_Weapon_PlayEjectBrass(playerState_s *ps);
void PM_Weapon_FinishRechamber(playerState_s *ps);
int PM_Weapon_CheckForRechamber(playerState_s *ps, int delayedAction);
Weapon PM_GetWeaponIndexForHand(playerState_s *ps);
int PM_GetWeaponOnVehicleReloadTime(playerState_s *ps);
bool BG_PlayDWThirdPersonReload(playerState_s *ps);
BOOL BG_IsAltSwitch(const playerState_s *ps, const Weapon lastWeapon, const Weapon weapon);
bool BG_CanFastSwitch(const WeaponDef *weapDef, int weaponState);
char BG_IsQuickSwitch(Weapon oldweapon, Weapon newweapon, int weaponState);
void PM_BeginWeaponChange(pmove_t *pm, pml_t *pml, Weapon newweapon, const bool quick);
void PM_Weapon_BeginWeaponRaise(;
bool BG_CheckIfDualWieldEmpty(playerState_s *ps);
void BG_SwitchWeaponsIfEmpty(playerState_s *ps);
Weapon BG_GetValidPrimaryWeaponForAltMode(;
int PM_GetWeaponFireButton(Weapon weapon, pmove_t *pm, bool runLeftGun);
void PM_Weapon_FinishWeaponRaise(playerState_s *ps);
void PM_Weapon_ReloadDelayedAction(playerState_s *ps);
void PM_Weapon_FinishReloadEnd(playerState_s *ps);
bool PM_CheckForReloadInterferingWeaponStates(pmove_t *pm, pml_t *pml, playerState_s *ps, int weaponState);
float PM_AddQuickScopeSpread(playerState_s *ps);
bool ShotLimitReached(playerState_s *ps, const Weapon weapon);
bool BurstFirePending(playerState_s *ps);
bool PM_Weapon_TriggerPullPending(const playerState_s *ps);
BOOL BG_CheckIfIntroShot(const playerState_s *ps, const Weapon weapon);
bool BG_CheckIfLastShot(playerState_s *ps, Weapon weapon);
void PM_Weapon_StartFiring(pmove_t *pm, pml_t *pml, int delayedAction);
int PM_Weapon_GetAmmoRequired(playerState_s *ps, Weapon weapon);
void PM_Weapon_Jam(playerState_s *ps);
void PM_Weapon_SetFPSFireAnim(playerState_s *ps);
void PM_Weapon_AddFiringAimSpreadScale(playerState_s *ps);
void DrawPlantDebug(vec3_t *start, vec3_t *end);
int PM_Weapon_CheckFriendlyFire(pmove_t *pm);
void PM_Weapon_MeleeFire(playerState_s *ps, int leftGun);
void PM_Weapon_MeleeInit(pmove_t *pm, pml_t *pml, bool right, bool left);
void PM_Weapon_Idle(playerState_s *ps);
void PM_Weapon_RiotshieldPrepare(pmove_t *pm, pml_t *pml);
void PM_Weapon_RiotshieldHold(playerState_s *ps);
void PM_Weapon_Riotshield(pmove_t *pm);
void PM_Weapon_OffHand_HoldUse(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHandInit(playerState_s *ps);
void PM_Weapon_OffHandEnd(playerState_s *ps);
void PM_SendEmtpyOffhandEvent(playerState_s *ps, OffhandSlot offhandSlot);
void PM_Detonate(playerState_s *ps, int delayedAction);
void PM_Weapon_FinishNightVisionWear(playerState_s *ps);
void PM_Weapon_FinishNightVisionRemove(playerState_s *ps);
void PM_WeaponSwimIn(playerState_s *ps);
void PM_WeaponSwimOut(playerState_s *ps);
void Sprint_State_Raise(playerState_s *ps);
void Sprint_State_Loop(playerState_s *ps);
void Crawl_State_In(playerState_s *ps);
void Crawl_State_Out(playerState_s *ps, int tryingToFiring);
void ContinuousFire_State_In(playerState_s *ps);
void ContinuousFire_State_Loop(playerState_s *ps);
void ContinuousFire_State_Out(playerState_s *ps);
void Dtp_State_In(playerState_s *ps);
void Slide_State_In(playerState_s *ps);
void Dtp_State_Out(playerState_s *ps);
void Dtp_State_Loop(playerState_s *ps);
void Deploy_State_Deploy(playerState_s *ps);
void Deploy_State_Breakdown(playerState_s *ps);
void PM_Weapon_CheckForDtp(pmove_t *pm);
void PM_Weapon_CheckForSlide(pmove_t *pm);
void PM_Weapon_CheckForDeploy(pmove_t *pm);
void PM_Weapon_CheckForMantle(pmove_t *pm);
void UpdateRiotShieldSwitchingFlag(playerState_s *ps);
void __thiscall PM_ResetWeaponState(playerState_s *this);
int BG_PlayerWeaponCountPrimaryTypes(const playerState_s *ps);
bool BG_PlayerWeaponsFull_Primaries(const playerState_s *ps);
char BG_PlayerHasCompatibleWeapon(const playerState_s *ps, const Weapon weapon);
BOOL BG_ThrowingBackGrenade(const playerState_s *ps);
void BG_CalcVehicleTurretWeaponPosOffset(;
WeaponVariantDef *BG_LoadWeaponVariantDef_LoadObj(const char *name);
WeaponVariantDef *BG_LoadWeaponVariantDef_FastFile(const char *name);
WeaponVariantDef *BG_LoadWeaponVariantDef();
PlayerHeldWeapon *BG_GetFuelTankTime(const playerState_s *ps, const Weapon weapon);
void BG_SetFuelTankTime(playerState_s *ps, const Weapon weapon, int time);
void BG_AddFuelTankTime(playerState_s *ps, const Weapon weapon, int time);
char *BG_GetWeaponName(const Weapon weapon, char *output, unsigned int maxStringLen);
void BG_GetWeaponFireBarrelInfo(const WeaponDef *weapDef, int currentBarrel, int *startBarrel, int *numBarrels);
BOOL BG_WeaponNotUsedOnVehicle(int eFlags);
BOOL BG_WeaponUsedOnVehicle(int eFlags);
Weapon BG_GetViewmodelWeaponIndex(const playerState_s *ps);
int BG_TakePlayerWeapon(playerState_s *ps, const Weapon weapon);
// void PM_UpdateAimDownSightFlag(pml_t *a1@<edx>, pmove_t *a2@<ecx>, pmove_t *pm);
void PM_UpdateScopeZoom(pmove_t *pm);
void PM_UpdateSpinLerp(pmove_t *pm, pml_t *pml);
void PM_UpdateChargeShot(pmove_t *pm, pml_t *pml);
bool ShouldFireChargeShotWeapon(playerState_s *ps, pmove_t *pm);
void PM_HoldBreathFire(playerState_s *ps);
void PM_UpdateAirburstLase(pmove_t *pm, pml_t *pml);
BOOL BG_UsingVehicleWeapon(const playerState_s *ps);
int PM_InteruptWeaponWithProneMove(playerState_s *ps);
void PM_SetWeaponReloadAddAmmoDelay(playerState_s *ps);
void PM_SetReloadingState(playerState_s *ps);
void PM_BeginWeaponReload(pmove_t *pm, pml_t *pml);
void BG_TakeClipOnlyWeaponIfEmpty(playerState_s *ps, Weapon weapon);
void PM_Weapon_FinishWeaponChange(pmove_t *pm, pml_t *pml, int previousWeaponState);
int PM_Weapon_AllowReload(playerState_s *ps);
void PM_Weapon_FinishReloadStart(pmove_t *pm, int delayedAction);
void PM_Weapon_FinishReload(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckFuelTime(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForReload(pmove_t *pm, pml_t *pml);
void PM_AdjustAimSpreadScale(pmove_t *pm, pml_t *pml);
void UpdatePendingTriggerPull(pmove_t *pm);
bool PM_Weapon_BurstFireWaitingForTriggerRelease(;
int PM_Weapon_WeaponTimeAdjust(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForChangeWeapon(pmove_t *pm, pml_t *pml);
int PM_Weapon_ShouldBeFiring(pmove_t *pm, int delayedAction, bool testOnly, bool runLeftGun);
int PM_Weapon_CheckFiringAmmo(pmove_t *pm, pml_t *pml);
bool PM_Weapon_IsHoldingGrenade(pmove_t *pm);
;
;
void PM_Weapon_FireWeapon(pmove_t *pm, pml_t *pml, int delayedAction);
void PM_Weapon_MeleeEnd(playerState_s *ps, int leftGun);
void PM_Weapon_CheckForMelee(pmove_t *pm, pml_t *pml, int delayedAction);
void PM_Weapon_RiotshieldStart(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForDeployRiotshield(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHandPrepare(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHandHold(playerState_s *ps);
void PM_Weapon_OffHandStart(pmove_t *pm, pml_t *pml);
void PM_Weapon_OffHand(pmove_t *pm);
bool PM_UpdateGrenadeThrow(playerState_s *ps, pml_t *pml);
bool PM_Weapon_CheckGrenadeHold(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckForDetonation(pmove_t *pm);
void PM_Weapon_CheckForGrenadeThrowCancel(pmove_t *pm);
void PM_Weapon_CheckForNightVision(pmove_t *pm);
char Crawl_Set_Direction(pmove_t *pm, int delayedAction);
void Crawl_State_Continue_Loop(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckForContinuousFire(pmove_t *pm, int delayedAction);
void PM_Weapon_CheckForProne(pmove_t *pm);
void PM_Weapon_CheckForAirburstMark(pmove_t *pm);
void BG_IncrementViewMovementIdleTime(playerState_s *ps, float frametime);
void BG_IncrementWeaponMovementIdleTime(const playerState_s *ps, float frametime, int *weaponIdleTime);
void PM_UpdateSwayPrediction(playerState_s *ps, float frametime);
void PM_Weapon_Turret(pmove_t *pm, pml_t *pml);
void BG_WeaponFireRecoil(;
void BG_AssertOffhandIndexOrNone(const Weapon offHandWeapon);
char BG_HoldWeapon(playerState_s *ps, const Weapon weapon);
Weapon BG_GetFirstAvailableOffhand(const playerState_s *ps, int offhandSlot);
void BG_GetSpreadForWeapon(const playerState_s *ps, const Weapon weapon, float *minSpread, float *maxSpread);
void PM_UpdateAimDownSightLerp(pmove_t *pm, pml_t *pml);
void PM_UpdateHoldBreath(pmove_t *pm, pml_t *pml);
void PM_Weapon_CheckForOffHand(pmove_t *pm, pml_t *pml);
void Sprint_State_Drop(playerState_s *ps);
void PM_Weapon_CheckForSprint(pmove_t *pm);
int BG_CheckForUniversalActionDW(playerState_s *ps);
void PM_Weapon(pmove_t *pm, pml_t *pml);

//#include "bgame/bg_weapons.h"

//t6/code/src_noserver/bgame/bg_weapons_ammo.cpp
void TRACK_bg_weapons_ammo();
Weapon BG_GetWeaponForAmmoClip(const Weapon weapon);
Weapon BG_GetWeaponForAmmoPool(const Weapon weapon);
void BG_SetupWeaponDefAmmoIndexes(const Weapon weapon, WeaponDef *weapDef, WeaponVariantDef *weapVarDef);
void BG_SetupWeaponAttachmentsAmmoIndexes(;
void BG_SetupWeaponDefSharedAmmoIndexes(const Weapon weapon, WeaponDef *weapDef);
void BG_SetupWeaponDefClipIndexes(const Weapon weapon, WeaponDef *weapDef, WeaponVariantDef *weapVarDef);
void BG_SetupWeaponAttachmentsClipIndexes(;
void BG_ClearWeaponDefAmmo();
int BG_GetSharedAmmoCapSize(int capIndex);
AmmoClip *BG_GetAmmoClip(playerState_s *ps, const Weapon weapon);
int BG_AddAmmoToClip(playerState_s *ps, const Weapon weapon, int amount);
void BG_SetAmmoInClip(playerState_s *ps, const Weapon weapon, int amount);
AmmoPool *BG_GetAmmoPool(playerState_s *ps, const Weapon weapon);
void BG_AddAmmoToPool(playerState_s *ps, const Weapon weapon, int amount);
void BG_SetAmmoInPool(playerState_s *ps, const Weapon weapon, int amount);
void AddValueToArray(int *weaponArray, int value);
BOOL BG_WeaponIsClipOnly(Weapon weapon);
int BG_GetClipSize(const Weapon weapon);
int BG_GetAmmoInClip(const playerState_s *ps, const Weapon weapon);
int BG_GetAmmoNotInClip(const playerState_s *ps, const Weapon weapon);
int BG_GetAmmoPlayerMax(const playerState_s *ps, const Weapon weapon, const Weapon weaponToSkip);
int BG_GetMaxPickupableAmmo(const playerState_s *ps, const Weapon weapon);
int BG_GetTotalAmmoReserve(const playerState_s *ps, const Weapon weapon);
int BG_WeaponAmmo(const playerState_s *ps, Weapon weapon);
void PM_ReloadClip(playerState_s *ps);
int PM_WeaponUseAmmo(playerState_s *ps, Weapon weapon, int amount);
int PM_WeaponAmmoAvailable(playerState_s *ps);
BOOL PM_WeaponClipEmpty(playerState_s *ps);

//#include "bgame/bg_weapons_ammo.h"

//t6/code/src_noserver/bgame/bg_weapons_attachment.cpp
const char **BG_GetAttachmentNames();
const char *BG_GetAttachmentName(eAttachment index);
eAttachment BG_GetAttachmentIndex(const char *name);
int BG_GetAttachmentPointIndex(const char *name);
int BG_GetWeaponAttachmentCount();
const char *BG_GetAttachmentDisplayName(eAttachment attachment);
const char *BG_GetAttachmentReference(eAttachment attachment);
const char *BG_GetAttachmentImage(eAttachment attachment);
const char *BG_GetAttachmentDesc(eAttachment attachment);
int BG_GetAttachmentAllocationCost(eAttachment attachment);
int BG_GetAttachmentCompatibleAttachmentsBitMask(eAttachment attachment);
eAttachmentPoint BG_GetAttachmentPointIndexFromAttachment(eAttachment attachment);
bool BG_IsAttachmentCompatible(unsigned __int64 bitMask, eAttachment attachment);
bool BG_AreAttachmentsCompatible(eAttachment attachment1, eAttachment attachment2);
const AttachmentTableEntry *BG_GetAttachmentTableEntry(int index);
const char *BG_GetWeaponOptionDisplayName(int weaponOption);
const char *BG_GetWeaponOptionReference(int weaponOption);
const char *BG_GetWeaponOptionImage(int weaponOption);
eWeaponOptionGroup BG_GetWeaponOptionGroup(int weaponOption);
int BG_GetWeaponOptionUnlockLvl(int weaponOption);
int BG_GetWeaponOptionSubIndex(int weaponOption);
int BG_GetWeaponOptionUnlockPLevel(int weaponOption);
bool BG_GetWeaponOptionIsElite(int weaponOption);
int BG_GetWeaponOptionNumFromIndexAndGroup(int index, eWeaponOptionGroup weaponOptionGroup);
int BG_GetWeaponOptionFromName(const char *optionName);
void BG_LoadWeaponAttachmentTableRow(;
void BG_LoadAttachmentRow(;
void BG_LoadWeaponOptionRow(;
void BG_LoadWeaponOptions(const StringTable *attachmentTable);
void BG_LoadWeaponAttachmentTable();
int BG_GetWeaponOptionMTXIndex(int weaponOption);
int BG_GetWeaponAttachmentCount(const Weapon weapon);

//t6/code/src_noserver/bgame/bg_weapons_def.cpp
// void __thiscall WeaponVariantDefHash::Set(WeaponVariantDefHash *this, int wi);
unsigned int BG_GetNumWeapons();
WeaponVariantDef *BG_GetWeaponVariantDef(const Weapon weapon);
WeaponDef *BG_GetWeaponDef(const Weapon weapon);
unsigned int BG_FreeWeaponDefStrings();
void BG_ShutdownWeaponDefFiles();
void BG_SetupAttachmentAlts(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupAttachmentDualWield(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupWeaponAlts(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupDualWieldAlts(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_SetupWeaponMountedVersions(const Weapon weapon, void (*regWeap)(unsigned int));
void BG_InitDefaultWeaponDef();
void BG_ClearWeaponDef();
void BG_WeaponMyChanges();
void BG_SetUpAmmoForWeapon(Weapon weapon);
int BG_WeaponVariantNameHashCompare(const void *a, const void *b);
Weapon BG_FindWeaponForName(const char *name);
bool BG_IsDefaultWeapon(const char *name);
Weapon BG_SortWeaponAttachments(const Weapon weapon);
Weapon BG_GetWeaponForFullName(const char *name, Weapon (*getWeaponForName)(const char *));
int GunPerkCount();
int GunPerkFromIndex(int index);
unsigned int BG_SetupWeaponVariantDef(WeaponVariantDef *weapVariantDef, void (*regWeap)(unsigned int));
void BG_FillInAllWeaponItems();
Weapon BG_GetWeaponForName(const char *name, void (*regWeap)(unsigned int));
Weapon BG_GetWeaponForName(const char *name);
void BG_SetupAltWeaponIndex(;
void BG_WeaponVariantPrecache(;
void PrecacheGunPerk_r(;
void WeaponVariantPrecacheGunPerk(;
bool BG_WeaponVariantPrecache_r(;
// bool BG_LoadWeaponTableBaseAndVariants@<al>(;
int BG_GetWeaponTableItemIndex(Weapon weapon);
char BG_LoadWeaponTable(const char *weaponNamePostfix, void (*regWeap)(unsigned int));

//#include "bgame/bg_weapons_load_db.h"

//t6/code/src_noserver/bgame/bg_weapons_load_obj.cpp
char *BG_GetPlayerAnimTypeName(int index);
int BG_GetPlayerAnimTypeIndex(int typeEnum);
void TRACK_bg_weapons_load_obj();
const char *BG_GetWeaponTypeName(weapType_t type);
const char *BG_GetWeaponClassName(weapClass_t type);
const char *BG_GetWeaponInventoryTypeName(weapInventoryType_t type);
void BG_LoadWeaponStrings();
void BG_LoadPlayerAnimTypes();
int Weapon_GetStringArrayIndex(const char *value, const char **stringArray, int arraySize);
void BG_ClearWeaponDefInternal();
char **BG_RegisterSurfaceTypeSounds(const char *surfaceSoundBase);
// int BG_ParseWeaponDefSpecificFieldType@<eax>(;
void BG_SetupTransitionTimes(WeaponVariantDef *weapVariantDef);
void BG_CheckWeaponDamageRanges(WeaponVariantDef *weapVariantDef);
void BG_SetupAttachmentField(WeaponVariantDef *weapVariantDef);
void BG_SetupAttachmentField_OldStyle(WeaponVariantDef *weapVariantDef, const char *name);
void BG_CheckProjectileValues(WeaponFullDef *weaponFullDef);
void InitWeaponDef(WeaponFullDef *weapFullDef);
flameTable *BG_LoadFlameTableInternal(const char *folder, const char *name);
flameTable *BG_GetFlameTable(const char *folder, const char *name);
char BG_LoadWeaponFile(const char *szFileName, char *szBuffer, int iBufferSize);
void BG_LoadWeaponMergeSupport();
char BG_SplitWeaponDefNames(;
int BG_MergeWeaponDefClipName(char **value, char *mergedValue, int size);
int BG_MergeWeaponDefFloatValue(char **value, char *mergedValue);
int BG_MergeWeaponDefBitFieldValue(char **value, char *mergedValue, int size);
int BG_MergeWeaponDefHidetags(char **value, char *mergedValue, int size);
bool BG_IsAnimationField(const char *fieldName);
int BG_MergeWeaponDefAnimations(const char *fieldName, char **value, char *mergedValue, int size);
int BG_MergeWeaponDefSpecialCases(const char *fieldName, char **value, char *mergedValue, int size);
bool BG_LoadWeaponVariantDefFile(;
WeaponVariantDef *BG_LoadWeaponVariantDefInternal(const char *folder, const char *name, const char *postfix);
char BG_WeaponUpdateField(const char *weaponName, const char *keyValue);
// bool BG_FlameTableUpdateField@<al>(;
void BG_CamoParseMaterialIndex(const char *key, unsigned int *set, unsigned int *mat);
char BG_CamoSetReplaceFlags(WeaponCamo *camo, const char *key, WeaponCamoMaterialFlags flag, int value);
char BG_WeaponCamoUpdateField(const char *camoName, const char *keyValue);
WeaponFullDef *__thiscall BG_LoadDefaultWeaponVariantDef_LoadObj(WeaponFullDef *this);
WeaponVariantDef *BG_LoadDefaultWeaponVariantDef_FastFile();
WeaponVariantDef *BG_LoadDefaultWeaponVariantDef();

//t6/code/src_noserver/bgame/bg_weapons_util.cpp
void BG_WeaponNameToComponentList(const char *name, WeaponComponentList *componentList);
void BG_WeaponNameToIdentifiedComponentList(const char *name, WeaponComponentList *componentList);
void BG_WeaponComponentListIdentify(WeaponComponentList *componentList);
int BG_WeaponComponentListCountAttachments(const WeaponComponentList *componentList);
void BG_WeaponComponentListRemove(;
void BG_WeaponComponentListRemoveAllAttachments(;
void BG_WeaponComponentListNthAttachment(;
void BG_WeaponComponentListToName(const WeaponComponentList *componentList, char *name, int size);
void BG_WeaponComponentListToBaseName(const WeaponComponentList *componentList, char *name, int size);
bool BG_WeaponUsesBurstFire(weapFireType_t fireType);
BOOL BG_WeaponUsesAttachments(const WeaponVariantDef *weapVariantDef);
bool BG_WeaponHasAttachment(const Weapon weapon, eAttachment attachment);
void BG_GetWeaponAttachments(const Weapon weapon, WeaponAttachment *(*attachmentList)[3]);
void BG_GetWeaponAttachmentUniques(const Weapon weapon, WeaponAttachmentUnique *(*attachmentUniqueList)[3]);
WeaponAttachmentUnique *BG_GetAttachmentUnique(const Weapon weapon, eAttachment attachment);
TracerDef *BG_TracerType(const Weapon weapon, bool friendly);
bool BG_WeaponBulletFire_ExplodeOnImpact(const Weapon weapon);
Weapon BG_PlayerPrimaryMeleeWeapon(const playerState_s *ps);
bool BG_ShouldWeaponIgnoreAttachments(const Weapon weapon);
void BG_GetAttachmentAnimationOverrideMask(const Weapon weapon, int (*overrideMask)[3]);
unsigned int BG_GetAttachmentAnimationOverrideADSIndex(const Weapon weapon);
BOOL BG_IsAttachmentUniqueOverridingAnimation(WeaponAttachmentUnique *attachment, int animType);
int BG_GetAttachmentOverrideChildIndex(;
const char *BG_GetAttachmentAnimationOverride_Internal(;
const char *BG_GetAttachmentAnimationFirstRaiseOverride(;
void BG_EnsureUniqueAttachments(Weapon *weapon);
char BG_IsDualWield(const Weapon weapon);
char BG_IsSilenced(const Weapon weapon);
char BG_IsDualMag(const Weapon weapon);
char BG_IsLaserSight(const Weapon weapon);
char BG_IsInfraRed(const Weapon weapon);
bool BG_IsTVGuided(const Weapon weapon);
char BG_IsSharedAmmo(const Weapon weapon);
char BG_IsSegmentedReload(const Weapon weapon);
char BG_IsMMS(const Weapon weapon);
double BG_GetMMSMaxDist(const Weapon weapon);
void BG_GetADSDofStartEnd(const Weapon weapon, float *start, float *end);
unsigned int BG_GetOverriddenSound(;
unsigned int BG_FireSound(const Weapon weapon);
unsigned int BG_FireSoundPlayer(const Weapon weapon);
unsigned int BG_FireFinalKillcamSound(const Weapon weapon);
unsigned int BG_FireFinalKillcamSoundPlayer(const Weapon weapon);
unsigned int BG_FireSoundStart(const Weapon weapon, bool isPlayer);
const FxEffectDef *BG_GetOverriddenEffect(;
const FxEffectDef *BG_ViewFlashEffect(const Weapon weapon);
const FxEffectDef *BG_WorldFlashEffect(const Weapon weapon);
void BG_GetHideTags(const Weapon weapon, unsigned __int16 *hideTags);
void BG_GetADSZoomFOV(const Weapon weapon, float *adsZoomFov1, float *adsZoomFov2, float *adsZoomFov3);
double BG_GetADSZoomInFrac(const Weapon weapon);
double BG_GetADSZoomOutFrac(const Weapon weapon);
void BG_GetSwaySettings(;
void BG_GetADSSwaySettings(;
int BG_GetFireTime(const Weapon weapon);
int BG_GetReloadTime(const Weapon weapon);
int BG_GetReloadEmptyTime(const Weapon weapon);
int BG_GetReloadAddTime(const Weapon weapon);
int BG_GetReloadQuickTime(const Weapon weapon);
int BG_GetReloadQuickEmptyTime(const Weapon weapon);
int BG_GetReloadQuickAddTime(const Weapon weapon);
Weapon BG_GetAltWeapon(const Weapon weapon);
Weapon BG_GetDualWieldWeapon(const Weapon weapon);
char BG_IsAltWeaponAdsOnly(const Weapon weapon);
char BG_IsAltWeaponDisableSwitching(const Weapon weapon);
double BG_GetAltScopeADSTransInTime(const Weapon weapon);
double BG_GetAltScopeADSTransOutTime(const Weapon weapon);
void BG_GetADSTransTimeScales(const Weapon weapon, float *adsTransInTimeScale, float *adsTransOutTimeScale);
void BG_GetADSRecoilReduction(const Weapon weapon, float *rate, float *limit);
weapFireType_t BG_GetFireType(const Weapon weapon);
bool BG_GetForceBounce(const Weapon weapon);
double BG_GetStackFireAccuracyDecay(const Weapon weapon);
double BG_GetStackFireSpread(const Weapon weapon);
PenetrateType BG_GetPenetrateType(const Weapon weapon);
void BG_GetPerks(const Weapon weapon, unsigned int *perks);
double BG_GetADSViewKickCenterSpeed(const Weapon weapon);
double BG_GetADSIdleAmount(const Weapon weapon);
double BG_GetDamageRangeScale(const Weapon weapon);
double BG_GetADSMoveSpeedScale(const Weapon weapon);
int BG_GetFirstRaiseTime(const Weapon weapon);
int BG_GetAltRaiseTime(const Weapon weapon);
int BG_GetAltDropTime(const Weapon weapon);
int BG_GetReloadAmmoAdd(const Weapon weapon);
int BG_GetReloadStartAdd(const Weapon weapon);
void BG_GetHipSpreadScale(const Weapon weapon, float *min, float *max);
double BG_GetHipIdleAmount(const Weapon weapon);
void BG_GetStandMoveAndRotation(const Weapon weapon, vec3_t *move, vec3_t *rot);
void BG_GetStrafeRotation(const Weapon weapon, vec3_t *rot);
Material *BG_GetOverlayMaterial(const Weapon weapon);
Material *BG_GetOverlayMaterialLowRes(const Weapon weapon);
weapOverlayReticle_t BG_GetOverlayReticle(const Weapon weapon);
Material *BG_GetDpadIcon(const Weapon weapon, weaponIconRatioType_t *ratio);
double BG_GetWeaponHitLocationMultiplier(const Weapon weapon, hitLocation_t hitLoc);
bool BG_IsBaseWeaponAttachmentDisabled(const Weapon weapon);
bool BG_IsBaseWeaponClipAttachmentDisabled(const Weapon weapon);
XModel *BG_GetClipWorldModel(const Weapon weapon);
eAttachment BG_IsOverridingBaseWeaponAttachmentOffsets(const Weapon weapon);
void BG_GetViewAttachmentOffsetsOverride(const Weapon weapon, eAttachment attachment, vec3_t *offset);
void BG_GetWorldAttachmentOffsetsOverride(const Weapon weapon, eAttachment attachment, vec3_t *offset);
void BG_GetLeftHandIK(const Weapon weapon, const float **offset, const float **rotation);
void BG_GetLeftHandProneIK(const Weapon weapon, const float **offset, const float **rotation);
int BG_GetWeaponDamageForRange(const Weapon weapon, const vec3_t *start, const vec3_t *hitPos);
bool BG_ShotLimitReached(const Weapon weapon, int weaponShotCount);
const char *BG_GetAttachmentAnimationOverride(;
char BG_IsLeftHandWeapon(const Weapon weapon);
void BG_WeaponComponentListSort(const char *originalName, WeaponComponentList *componentList, char *outputName);

//#include "bgame/bg_weapons_util.h"

//t6/code/src_noserver/bgame/bg_weapons_view.cpp
double BG_GetBobCycle(const playerState_s *ps);
long double BG_CalculateWeaponMovement_VerticalBobFactor(const playerState_s *ps, float cycle, float speed);
long double BG_CalculateWeaponMovement_HorizontalBobFactor(const playerState_s *ps, float cycle, float speed);
void BG_ComputeAndApplyWeaponMovement_IdleAngles(weaponState_t *ws, vec3_t *angles);
void BG_ComputeAndApplyWeaponMovement_DamageKickAngles(weaponState_t *ws, vec3_t *angles);
void BG_ApplyWeaponMovement_LeanOrigin(weaponState_t *ws, vec3_t *origin);
float BG_CalculateWeaponMovement_GetSprintLerp(const weaponState_t *ws, const WeaponDef *weapDef);
float BG_CalculateWeaponMovement_GetDTPLerp(const weaponState_t *ws, const WeaponDef *weapDef);
void BG_CalculateWeaponMovement_Base_Internal_WeaponState(;
void BG_CalculateWeaponMovement_Base_Internal_Stance(;
void BG_CalculateWeaponMovement_Base_Internal_Movement(;
void BG_CalculateWeaponMovement_Base_Internal_Save(;
void BG_CalculateWeaponMovement_Base(weaponState_t *ws);
void BG_CalculateWeaponMovement_Sway(weaponState_t *ws);
void BG_CalculateWeaponMovement_Bob(weaponState_t *ws);
void BG_SetWeaponMovementAngles(weaponState_t *ws, vec3_t *angles);
void BG_CalculateWeaponMovement(weaponState_t *ws, vec3_t *origin, vec3_t *angles);
long double BG_CalculateViewMovement_VerticalBobFactor(const playerState_s *ps, float cycle, float speed);
long double BG_CalculateViewMovement_HorizontalBobFactor(const playerState_s *ps, float cycle, float speed);
void BG_CalculateViewMovement_DamageKick(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovement_IdleAngles(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovement_BobAngles(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovement_AdsBob(viewState_t *vs, vec3_t *angles);
void BG_CalculateViewMovementAngles(;

//t6/code/src_noserver/bgame/bg_wind.cpp
void BG_Wind_RegisterDvars();
// void DisplayWindDebug(clientDebugLineInfo_t *a1@<edi>);
void BG_SeedVarintWinds(int variant_seed, int start_time);
void BG_UpdateVariantWind(VariantWind *wind, int variantIndex, const vec3_t *seedWindVector, int cur_time);
void CG_UpdateWind(int cur_time);
void BG_GetVariantWindVector(int which, vec3_t *out);

